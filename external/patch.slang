diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./generated/AllSyntax.cpp ./generated/AllSyntax.cpp
--- ./generated/AllSyntax.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/AllSyntax.cpp	2021-03-02 17:51:09.141286189 -0800
@@ -0,0 +1,14662 @@
+//------------------------------------------------------------------------------
+// AllSyntax.cpp
+// All generated syntax node data structures
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#include "slang/syntax/AllSyntax.h"
+
+// This file contains all parse tree syntax node generated definitions.
+// It is auto-generated by the syntax_gen.py script under the scripts/ directory.
+
+namespace slang {
+
+size_t SyntaxNode::getChildCount() const {
+    switch (kind) {
+        case SyntaxKind::Unknown: return 0;
+        case SyntaxKind::SyntaxList:
+        case SyntaxKind::TokenList:
+        case SyntaxKind::SeparatedList:
+            return ((const SyntaxListBase*)this)->getChildCount();
+        case SyntaxKind::AcceptOnPropertyExpression: return 3;
+        case SyntaxKind::ActionBlock: return 2;
+        case SyntaxKind::AddAssignmentExpression: return 4;
+        case SyntaxKind::AddExpression: return 4;
+        case SyntaxKind::AlwaysBlock: return 3;
+        case SyntaxKind::AlwaysCombBlock: return 3;
+        case SyntaxKind::AlwaysFFBlock: return 3;
+        case SyntaxKind::AlwaysLatchBlock: return 3;
+        case SyntaxKind::AlwaysPropertyExpression: return 3;
+        case SyntaxKind::AndAssignmentExpression: return 4;
+        case SyntaxKind::AndSequenceExpression: return 4;
+        case SyntaxKind::AnsiPortList: return 3;
+        case SyntaxKind::AnsiUdpPortList: return 4;
+        case SyntaxKind::ArgumentList: return 3;
+        case SyntaxKind::ArithmeticLeftShiftAssignmentExpression: return 4;
+        case SyntaxKind::ArithmeticRightShiftAssignmentExpression: return 4;
+        case SyntaxKind::ArithmeticShiftLeftExpression: return 4;
+        case SyntaxKind::ArithmeticShiftRightExpression: return 4;
+        case SyntaxKind::ArrayAndMethod: return 1;
+        case SyntaxKind::ArrayOrMethod: return 1;
+        case SyntaxKind::ArrayOrRandomizeMethodExpression: return 4;
+        case SyntaxKind::ArrayUniqueMethod: return 1;
+        case SyntaxKind::ArrayXorMethod: return 1;
+        case SyntaxKind::AscendingRangeSelect: return 3;
+        case SyntaxKind::AssertPropertyStatement: return 8;
+        case SyntaxKind::AssertionItemPort: return 5;
+        case SyntaxKind::AssertionItemPortList: return 3;
+        case SyntaxKind::AssignmentExpression: return 4;
+        case SyntaxKind::AssignmentPatternExpression: return 2;
+        case SyntaxKind::AssignmentPatternItem: return 3;
+        case SyntaxKind::AssumePropertyStatement: return 8;
+        case SyntaxKind::AttributeInstance: return 3;
+        case SyntaxKind::AttributeSpec: return 2;
+        case SyntaxKind::BadExpression: return 1;
+        case SyntaxKind::BeginKeywordsDirective: return 2;
+        case SyntaxKind::BinaryAndExpression: return 4;
+        case SyntaxKind::BinaryBlockEventExpression: return 3;
+        case SyntaxKind::BinaryEventExpression: return 3;
+        case SyntaxKind::BinaryOrExpression: return 4;
+        case SyntaxKind::BinarySequenceDelayExpression: return 4;
+        case SyntaxKind::BinaryXnorExpression: return 4;
+        case SyntaxKind::BinaryXorExpression: return 4;
+        case SyntaxKind::BindDirective: return 5;
+        case SyntaxKind::BindTargetList: return 2;
+        case SyntaxKind::BitSelect: return 1;
+        case SyntaxKind::BitType: return 3;
+        case SyntaxKind::BlockCoverageEvent: return 4;
+        case SyntaxKind::BlockingEventTriggerStatement: return 6;
+        case SyntaxKind::ByteType: return 3;
+        case SyntaxKind::CHandleType: return 1;
+        case SyntaxKind::CaseEqualityExpression: return 4;
+        case SyntaxKind::CaseGenerate: return 7;
+        case SyntaxKind::CaseInequalityExpression: return 4;
+        case SyntaxKind::CaseStatement: return 10;
+        case SyntaxKind::CastExpression: return 3;
+        case SyntaxKind::CellDefineDirective: return 1;
+        case SyntaxKind::ChargeStrength: return 3;
+        case SyntaxKind::ClassDeclaration: return 12;
+        case SyntaxKind::ClassMethodDeclaration: return 3;
+        case SyntaxKind::ClassMethodPrototype: return 4;
+        case SyntaxKind::ClassName: return 2;
+        case SyntaxKind::ClassPropertyDeclaration: return 3;
+        case SyntaxKind::ClockingDeclaration: return 10;
+        case SyntaxKind::ClockingDirection: return 4;
+        case SyntaxKind::ClockingItem: return 4;
+        case SyntaxKind::ClockingSkew: return 2;
+        case SyntaxKind::ColonExpressionClause: return 2;
+        case SyntaxKind::CompilationUnit: return 2;
+        case SyntaxKind::ConcatenationExpression: return 3;
+        case SyntaxKind::ConcurrentAssertionMember: return 2;
+        case SyntaxKind::ConditionalConstraint: return 6;
+        case SyntaxKind::ConditionalExpression: return 6;
+        case SyntaxKind::ConditionalPathDeclaration: return 6;
+        case SyntaxKind::ConditionalPattern: return 2;
+        case SyntaxKind::ConditionalPredicate: return 1;
+        case SyntaxKind::ConditionalStatement: return 9;
+        case SyntaxKind::ConstraintBlock: return 3;
+        case SyntaxKind::ConstraintDeclaration: return 5;
+        case SyntaxKind::ConstraintPrototype: return 5;
+        case SyntaxKind::ConstructorName: return 1;
+        case SyntaxKind::ContinuousAssign: return 6;
+        case SyntaxKind::CopyClassExpression: return 2;
+        case SyntaxKind::CoverPropertyStatement: return 8;
+        case SyntaxKind::CoverSequenceStatement: return 8;
+        case SyntaxKind::CoverageBins: return 9;
+        case SyntaxKind::CoverageIffClause: return 4;
+        case SyntaxKind::CoverageOption: return 7;
+        case SyntaxKind::CovergroupDeclaration: return 9;
+        case SyntaxKind::Coverpoint: return 9;
+        case SyntaxKind::CycleDelay: return 2;
+        case SyntaxKind::DPIExport: return 8;
+        case SyntaxKind::DPIImport: return 8;
+        case SyntaxKind::DataDeclaration: return 5;
+        case SyntaxKind::Declarator: return 3;
+        case SyntaxKind::DefParam: return 4;
+        case SyntaxKind::DefParamAssignment: return 2;
+        case SyntaxKind::DefaultCaseItem: return 3;
+        case SyntaxKind::DefaultClockingReference: return 5;
+        case SyntaxKind::DefaultCoverageBinInitializer: return 2;
+        case SyntaxKind::DefaultNetTypeDirective: return 2;
+        case SyntaxKind::DefaultPatternKeyExpression: return 1;
+        case SyntaxKind::DefaultSkewItem: return 4;
+        case SyntaxKind::DeferredAssertion: return 3;
+        case SyntaxKind::DefineDirective: return 4;
+        case SyntaxKind::Delay3: return 8;
+        case SyntaxKind::DelayControl: return 2;
+        case SyntaxKind::DelayedTerminalArg: return 4;
+        case SyntaxKind::DescendingRangeSelect: return 3;
+        case SyntaxKind::DisableConstraint: return 4;
+        case SyntaxKind::DisableForkStatement: return 5;
+        case SyntaxKind::DisableIff: return 5;
+        case SyntaxKind::DisableStatement: return 5;
+        case SyntaxKind::DistConstraintList: return 4;
+        case SyntaxKind::DistItem: return 2;
+        case SyntaxKind::DistWeight: return 2;
+        case SyntaxKind::DivideAssignmentExpression: return 4;
+        case SyntaxKind::DivideExpression: return 4;
+        case SyntaxKind::DividerClause: return 2;
+        case SyntaxKind::DoWhileStatement: return 9;
+        case SyntaxKind::DotMemberClause: return 2;
+        case SyntaxKind::DriveStrength: return 5;
+        case SyntaxKind::EdgeControlSpecifier: return 3;
+        case SyntaxKind::EdgeDescriptor: return 2;
+        case SyntaxKind::EdgeSensitivePathSuffix: return 6;
+        case SyntaxKind::ElabSystemTask: return 4;
+        case SyntaxKind::ElementSelect: return 3;
+        case SyntaxKind::ElementSelectExpression: return 2;
+        case SyntaxKind::ElsIfDirective: return 3;
+        case SyntaxKind::ElseClause: return 2;
+        case SyntaxKind::ElseConstraintClause: return 2;
+        case SyntaxKind::ElseDirective: return 2;
+        case SyntaxKind::EmptyArgument: return 1;
+        case SyntaxKind::EmptyIdentifierName: return 1;
+        case SyntaxKind::EmptyMember: return 3;
+        case SyntaxKind::EmptyPortConnection: return 2;
+        case SyntaxKind::EmptyQueueExpression: return 2;
+        case SyntaxKind::EmptyStatement: return 3;
+        case SyntaxKind::EmptyTimingCheckArg: return 1;
+        case SyntaxKind::EndCellDefineDirective: return 1;
+        case SyntaxKind::EndIfDirective: return 2;
+        case SyntaxKind::EndKeywordsDirective: return 1;
+        case SyntaxKind::EnumType: return 6;
+        case SyntaxKind::EqualityExpression: return 4;
+        case SyntaxKind::EqualsTypeClause: return 2;
+        case SyntaxKind::EqualsValueClause: return 2;
+        case SyntaxKind::EventControl: return 2;
+        case SyntaxKind::EventControlWithExpression: return 2;
+        case SyntaxKind::EventType: return 1;
+        case SyntaxKind::EventuallyPropertyExpression: return 3;
+        case SyntaxKind::ExpectPropertyStatement: return 8;
+        case SyntaxKind::ExplicitAnsiPort: return 7;
+        case SyntaxKind::ExplicitNonAnsiPort: return 5;
+        case SyntaxKind::ExpressionConstraint: return 3;
+        case SyntaxKind::ExpressionCoverageBinInitializer: return 2;
+        case SyntaxKind::ExpressionOrDist: return 2;
+        case SyntaxKind::ExpressionPattern: return 1;
+        case SyntaxKind::ExpressionStatement: return 4;
+        case SyntaxKind::ExpressionTimingCheckArg: return 2;
+        case SyntaxKind::ExtendsClause: return 3;
+        case SyntaxKind::ExternModule: return 2;
+        case SyntaxKind::FinalBlock: return 3;
+        case SyntaxKind::ForLoopStatement: return 11;
+        case SyntaxKind::ForVariableDeclaration: return 3;
+        case SyntaxKind::ForeachLoopList: return 6;
+        case SyntaxKind::ForeachLoopStatement: return 5;
+        case SyntaxKind::ForeverStatement: return 4;
+        case SyntaxKind::ForwardInterfaceClassTypedefDeclaration: return 6;
+        case SyntaxKind::ForwardTypedefDeclaration: return 5;
+        case SyntaxKind::FunctionDeclaration: return 6;
+        case SyntaxKind::FunctionPort: return 6;
+        case SyntaxKind::FunctionPortList: return 3;
+        case SyntaxKind::FunctionPrototype: return 5;
+        case SyntaxKind::GateInstance: return 4;
+        case SyntaxKind::GateInstanceName: return 2;
+        case SyntaxKind::GateInstantiation: return 6;
+        case SyntaxKind::GenerateBlock: return 7;
+        case SyntaxKind::GenerateRegion: return 4;
+        case SyntaxKind::GenvarDeclaration: return 4;
+        case SyntaxKind::GreaterThanEqualExpression: return 4;
+        case SyntaxKind::GreaterThanExpression: return 4;
+        case SyntaxKind::HierarchicalInstance: return 5;
+        case SyntaxKind::HierarchyInstantiation: return 5;
+        case SyntaxKind::IdentifierName: return 1;
+        case SyntaxKind::IdentifierSelectName: return 2;
+        case SyntaxKind::IfDefDirective: return 3;
+        case SyntaxKind::IfGenerate: return 7;
+        case SyntaxKind::IfNDefDirective: return 3;
+        case SyntaxKind::IfNonePathDeclaration: return 3;
+        case SyntaxKind::IffEventClause: return 2;
+        case SyntaxKind::IffPropertyExpression: return 4;
+        case SyntaxKind::ImmediateAssertStatement: return 6;
+        case SyntaxKind::ImmediateAssertionMember: return 2;
+        case SyntaxKind::ImmediateAssumeStatement: return 6;
+        case SyntaxKind::ImmediateCoverStatement: return 6;
+        case SyntaxKind::ImplementsClause: return 2;
+        case SyntaxKind::ImplicationConstraint: return 3;
+        case SyntaxKind::ImplicitAnsiPort: return 3;
+        case SyntaxKind::ImplicitEventControl: return 4;
+        case SyntaxKind::ImplicitNonAnsiPort: return 1;
+        case SyntaxKind::ImplicitType: return 2;
+        case SyntaxKind::ImpliesPropertyExpression: return 4;
+        case SyntaxKind::IncludeDirective: return 2;
+        case SyntaxKind::InequalityExpression: return 4;
+        case SyntaxKind::InitialBlock: return 3;
+        case SyntaxKind::InsideExpression: return 3;
+        case SyntaxKind::IntType: return 3;
+        case SyntaxKind::IntegerLiteralExpression: return 1;
+        case SyntaxKind::IntegerType: return 3;
+        case SyntaxKind::IntegerVectorExpression: return 3;
+        case SyntaxKind::InterconnectPortHeader: return 3;
+        case SyntaxKind::InterfaceDeclaration: return 5;
+        case SyntaxKind::InterfaceHeader: return 7;
+        case SyntaxKind::InterfacePortHeader: return 2;
+        case SyntaxKind::IntersectSequenceExpression: return 4;
+        case SyntaxKind::InvocationExpression: return 3;
+        case SyntaxKind::JumpStatement: return 4;
+        case SyntaxKind::LessThanEqualExpression: return 4;
+        case SyntaxKind::LessThanExpression: return 4;
+        case SyntaxKind::LetDeclaration: return 6;
+        case SyntaxKind::LineDirective: return 4;
+        case SyntaxKind::LocalScope: return 1;
+        case SyntaxKind::LogicType: return 3;
+        case SyntaxKind::LogicalAndExpression: return 4;
+        case SyntaxKind::LogicalEquivalenceExpression: return 4;
+        case SyntaxKind::LogicalImplicationExpression: return 4;
+        case SyntaxKind::LogicalLeftShiftAssignmentExpression: return 4;
+        case SyntaxKind::LogicalOrExpression: return 4;
+        case SyntaxKind::LogicalRightShiftAssignmentExpression: return 4;
+        case SyntaxKind::LogicalShiftLeftExpression: return 4;
+        case SyntaxKind::LogicalShiftRightExpression: return 4;
+        case SyntaxKind::LongIntType: return 3;
+        case SyntaxKind::LoopConstraint: return 3;
+        case SyntaxKind::LoopGenerate: return 13;
+        case SyntaxKind::LoopStatement: return 7;
+        case SyntaxKind::MacroActualArgument: return 1;
+        case SyntaxKind::MacroActualArgumentList: return 3;
+        case SyntaxKind::MacroArgumentDefault: return 2;
+        case SyntaxKind::MacroFormalArgument: return 2;
+        case SyntaxKind::MacroFormalArgumentList: return 3;
+        case SyntaxKind::MacroUsage: return 2;
+        case SyntaxKind::MatchesClause: return 2;
+        case SyntaxKind::MemberAccessExpression: return 3;
+        case SyntaxKind::MinTypMaxExpression: return 5;
+        case SyntaxKind::ModAssignmentExpression: return 4;
+        case SyntaxKind::ModExpression: return 4;
+        case SyntaxKind::ModportClockingPort: return 3;
+        case SyntaxKind::ModportDeclaration: return 4;
+        case SyntaxKind::ModportExplicitPort: return 5;
+        case SyntaxKind::ModportItem: return 2;
+        case SyntaxKind::ModportNamedPort: return 1;
+        case SyntaxKind::ModportSimplePortList: return 3;
+        case SyntaxKind::ModportSubroutinePort: return 1;
+        case SyntaxKind::ModportSubroutinePortList: return 3;
+        case SyntaxKind::ModuleDeclaration: return 5;
+        case SyntaxKind::ModuleHeader: return 7;
+        case SyntaxKind::MultipleConcatenationExpression: return 4;
+        case SyntaxKind::MultiplyAssignmentExpression: return 4;
+        case SyntaxKind::MultiplyExpression: return 4;
+        case SyntaxKind::NameValuePragmaExpression: return 3;
+        case SyntaxKind::NamedArgument: return 5;
+        case SyntaxKind::NamedBlockClause: return 2;
+        case SyntaxKind::NamedLabel: return 2;
+        case SyntaxKind::NamedPortConnection: return 6;
+        case SyntaxKind::NamedStructurePatternMember: return 3;
+        case SyntaxKind::NamedType: return 1;
+        case SyntaxKind::NetDeclaration: return 8;
+        case SyntaxKind::NetPortHeader: return 3;
+        case SyntaxKind::NetTypeDeclaration: return 6;
+        case SyntaxKind::NewArrayExpression: return 5;
+        case SyntaxKind::NewClassExpression: return 2;
+        case SyntaxKind::NextTimePropertyExpression: return 3;
+        case SyntaxKind::NoUnconnectedDriveDirective: return 1;
+        case SyntaxKind::NonAnsiPortList: return 3;
+        case SyntaxKind::NonAnsiUdpPortList: return 4;
+        case SyntaxKind::NonOverlappedFollowedByPropertyExpression: return 4;
+        case SyntaxKind::NonOverlappedImplicationPropertyExpression: return 4;
+        case SyntaxKind::NonblockingAssignmentExpression: return 4;
+        case SyntaxKind::NonblockingEventTriggerStatement: return 6;
+        case SyntaxKind::NullLiteralExpression: return 1;
+        case SyntaxKind::NumberPragmaExpression: return 3;
+        case SyntaxKind::OneStepLiteralExpression: return 1;
+        case SyntaxKind::OpenRangeExpression: return 5;
+        case SyntaxKind::OpenRangeList: return 3;
+        case SyntaxKind::OrAssignmentExpression: return 4;
+        case SyntaxKind::OrSequenceExpression: return 4;
+        case SyntaxKind::OrderedArgument: return 1;
+        case SyntaxKind::OrderedPortConnection: return 2;
+        case SyntaxKind::OrderedStructurePatternMember: return 1;
+        case SyntaxKind::OverlappedFollowedByPropertyExpression: return 4;
+        case SyntaxKind::OverlappedImplicationPropertyExpression: return 4;
+        case SyntaxKind::PackageDeclaration: return 5;
+        case SyntaxKind::PackageHeader: return 7;
+        case SyntaxKind::PackageImportDeclaration: return 4;
+        case SyntaxKind::PackageImportItem: return 3;
+        case SyntaxKind::ParallelBlockStatement: return 7;
+        case SyntaxKind::ParameterDeclaration: return 3;
+        case SyntaxKind::ParameterDeclarationStatement: return 3;
+        case SyntaxKind::ParameterPortList: return 4;
+        case SyntaxKind::ParameterValueAssignment: return 2;
+        case SyntaxKind::ParenExpressionList: return 3;
+        case SyntaxKind::ParenPragmaExpression: return 3;
+        case SyntaxKind::ParenthesizedEventExpression: return 3;
+        case SyntaxKind::ParenthesizedExpression: return 3;
+        case SyntaxKind::PathDeclaration: return 7;
+        case SyntaxKind::PathDescription: return 7;
+        case SyntaxKind::PatternCaseItem: return 5;
+        case SyntaxKind::PortConcatenation: return 3;
+        case SyntaxKind::PortDeclaration: return 4;
+        case SyntaxKind::PortReference: return 2;
+        case SyntaxKind::PostdecrementExpression: return 3;
+        case SyntaxKind::PostincrementExpression: return 3;
+        case SyntaxKind::PowerExpression: return 4;
+        case SyntaxKind::PragmaDirective: return 3;
+        case SyntaxKind::PrimaryBlockEventExpression: return 2;
+        case SyntaxKind::ProceduralAssignStatement: return 5;
+        case SyntaxKind::ProceduralDeassignStatement: return 5;
+        case SyntaxKind::ProceduralForceStatement: return 5;
+        case SyntaxKind::ProceduralReleaseStatement: return 5;
+        case SyntaxKind::ProgramDeclaration: return 5;
+        case SyntaxKind::ProgramHeader: return 7;
+        case SyntaxKind::PropertyDeclaration: return 10;
+        case SyntaxKind::PropertySpec: return 3;
+        case SyntaxKind::PropertyType: return 1;
+        case SyntaxKind::PulseStyleDeclaration: return 4;
+        case SyntaxKind::QueueDimensionSpecifier: return 2;
+        case SyntaxKind::RandCaseItem: return 3;
+        case SyntaxKind::RandCaseStatement: return 5;
+        case SyntaxKind::RangeCoverageBinInitializer: return 2;
+        case SyntaxKind::RangeDimensionSpecifier: return 1;
+        case SyntaxKind::RealLiteralExpression: return 1;
+        case SyntaxKind::RealTimeType: return 1;
+        case SyntaxKind::RealType: return 1;
+        case SyntaxKind::RegType: return 3;
+        case SyntaxKind::RejectOnPropertyExpression: return 3;
+        case SyntaxKind::RepeatedEventControl: return 5;
+        case SyntaxKind::ReplicatedAssignmentPattern: return 6;
+        case SyntaxKind::ResetAllDirective: return 1;
+        case SyntaxKind::RestrictPropertyStatement: return 8;
+        case SyntaxKind::ReturnStatement: return 5;
+        case SyntaxKind::RootScope: return 1;
+        case SyntaxKind::SAlwaysPropertyExpression: return 3;
+        case SyntaxKind::SEventuallyPropertyExpression: return 3;
+        case SyntaxKind::SNextTimePropertyExpression: return 3;
+        case SyntaxKind::SUntilPropertyExpression: return 4;
+        case SyntaxKind::SUntilWithPropertyExpression: return 4;
+        case SyntaxKind::ScopedName: return 3;
+        case SyntaxKind::SequenceDeclaration: return 10;
+        case SyntaxKind::SequenceType: return 1;
+        case SyntaxKind::SequentialBlockStatement: return 7;
+        case SyntaxKind::ShortIntType: return 3;
+        case SyntaxKind::ShortRealType: return 1;
+        case SyntaxKind::ShortcutCycleDelayRange: return 4;
+        case SyntaxKind::SignalEventExpression: return 3;
+        case SyntaxKind::SignedCastExpression: return 3;
+        case SyntaxKind::SimpleAssignmentPattern: return 3;
+        case SyntaxKind::SimplePathSuffix: return 1;
+        case SyntaxKind::SimplePragmaExpression: return 1;
+        case SyntaxKind::SimpleRangeSelect: return 3;
+        case SyntaxKind::SolveBeforeConstraint: return 5;
+        case SyntaxKind::SpecifyBlock: return 4;
+        case SyntaxKind::SpecparamDeclaration: return 5;
+        case SyntaxKind::SpecparamDeclarator: return 3;
+        case SyntaxKind::StandardCaseItem: return 3;
+        case SyntaxKind::StreamExpression: return 2;
+        case SyntaxKind::StreamExpressionWithRange: return 2;
+        case SyntaxKind::StreamingConcatenationExpression: return 7;
+        case SyntaxKind::StringLiteralExpression: return 1;
+        case SyntaxKind::StringType: return 1;
+        case SyntaxKind::StructType: return 8;
+        case SyntaxKind::StructUnionMember: return 5;
+        case SyntaxKind::StructurePattern: return 3;
+        case SyntaxKind::StructuredAssignmentPattern: return 3;
+        case SyntaxKind::SubtractAssignmentExpression: return 4;
+        case SyntaxKind::SubtractExpression: return 4;
+        case SyntaxKind::SuperHandle: return 1;
+        case SyntaxKind::SyncAcceptOnPropertyExpression: return 3;
+        case SyntaxKind::SyncRejectOnPropertyExpression: return 3;
+        case SyntaxKind::SystemName: return 1;
+        case SyntaxKind::SystemTimingCheck: return 6;
+        case SyntaxKind::TaggedPattern: return 3;
+        case SyntaxKind::TaggedUnionExpression: return 3;
+        case SyntaxKind::TaskDeclaration: return 6;
+        case SyntaxKind::ThisHandle: return 1;
+        case SyntaxKind::ThroughoutSequenceExpression: return 4;
+        case SyntaxKind::TimeLiteralExpression: return 1;
+        case SyntaxKind::TimeScaleDirective: return 4;
+        case SyntaxKind::TimeType: return 3;
+        case SyntaxKind::TimeUnitsDeclaration: return 5;
+        case SyntaxKind::TimingCheckCondition: return 2;
+        case SyntaxKind::TimingCheckEvent: return 4;
+        case SyntaxKind::TimingControlExpression: return 2;
+        case SyntaxKind::TimingControlExpressionConcatenation: return 3;
+        case SyntaxKind::TimingControlStatement: return 4;
+        case SyntaxKind::TransListCoverageBinInitializer: return 2;
+        case SyntaxKind::TransRange: return 2;
+        case SyntaxKind::TransRepeatRange: return 4;
+        case SyntaxKind::TransSet: return 3;
+        case SyntaxKind::TypeAssignment: return 2;
+        case SyntaxKind::TypeParameterDeclaration: return 3;
+        case SyntaxKind::TypeReference: return 4;
+        case SyntaxKind::TypedefDeclaration: return 6;
+        case SyntaxKind::UdpBody: return 5;
+        case SyntaxKind::UdpDeclaration: return 7;
+        case SyntaxKind::UdpEdgeIndicator: return 4;
+        case SyntaxKind::UdpEntry: return 8;
+        case SyntaxKind::UdpInitialStmt: return 5;
+        case SyntaxKind::UdpInputPortDecl: return 3;
+        case SyntaxKind::UdpOutputPortDecl: return 5;
+        case SyntaxKind::UnaryBitwiseAndExpression: return 3;
+        case SyntaxKind::UnaryBitwiseNandExpression: return 3;
+        case SyntaxKind::UnaryBitwiseNorExpression: return 3;
+        case SyntaxKind::UnaryBitwiseNotExpression: return 3;
+        case SyntaxKind::UnaryBitwiseOrExpression: return 3;
+        case SyntaxKind::UnaryBitwiseXnorExpression: return 3;
+        case SyntaxKind::UnaryBitwiseXorExpression: return 3;
+        case SyntaxKind::UnaryLogicalNotExpression: return 3;
+        case SyntaxKind::UnaryMinusExpression: return 3;
+        case SyntaxKind::UnaryNotPropertyExpression: return 3;
+        case SyntaxKind::UnaryPlusExpression: return 3;
+        case SyntaxKind::UnaryPredecrementExpression: return 3;
+        case SyntaxKind::UnaryPreincrementExpression: return 3;
+        case SyntaxKind::UnarySequenceDelayExpression: return 3;
+        case SyntaxKind::UnarySequenceEventExpression: return 3;
+        case SyntaxKind::UnbasedUnsizedLiteralExpression: return 1;
+        case SyntaxKind::UnconnectedDriveDirective: return 2;
+        case SyntaxKind::UndefDirective: return 2;
+        case SyntaxKind::UndefineAllDirective: return 1;
+        case SyntaxKind::UnionType: return 8;
+        case SyntaxKind::UniquenessConstraint: return 3;
+        case SyntaxKind::UnitScope: return 1;
+        case SyntaxKind::UntilPropertyExpression: return 4;
+        case SyntaxKind::UntilWithPropertyExpression: return 4;
+        case SyntaxKind::Untyped: return 1;
+        case SyntaxKind::UserDefinedNetDeclaration: return 5;
+        case SyntaxKind::VariableDimension: return 3;
+        case SyntaxKind::VariablePattern: return 2;
+        case SyntaxKind::VariablePortHeader: return 4;
+        case SyntaxKind::VirtualInterfaceType: return 5;
+        case SyntaxKind::VoidCastedCallStatement: return 8;
+        case SyntaxKind::VoidType: return 1;
+        case SyntaxKind::WaitForkStatement: return 5;
+        case SyntaxKind::WaitOrderStatement: return 7;
+        case SyntaxKind::WaitStatement: return 7;
+        case SyntaxKind::WildcardDimensionSpecifier: return 1;
+        case SyntaxKind::WildcardEqualityExpression: return 4;
+        case SyntaxKind::WildcardInequalityExpression: return 4;
+        case SyntaxKind::WildcardLiteralExpression: return 1;
+        case SyntaxKind::WildcardPattern: return 1;
+        case SyntaxKind::WildcardPortConnection: return 2;
+        case SyntaxKind::WildcardPortList: return 3;
+        case SyntaxKind::WildcardUdpPortList: return 4;
+        case SyntaxKind::WithClause: return 4;
+        case SyntaxKind::WithFunctionClause: return 2;
+        case SyntaxKind::WithFunctionSample: return 4;
+        case SyntaxKind::WithinSequenceExpression: return 4;
+        case SyntaxKind::XorAssignmentExpression: return 4;
+    }
+    THROW_UNREACHABLE;
+}
+
+bool ActionBlockSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ActionBlock;
+}
+
+TokenOrSyntax ActionBlockSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return statement;
+        case 1: return elseClause;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ActionBlockSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return statement;
+        case 1: return elseClause;
+        default: return nullptr;
+    }
+}
+
+void ActionBlockSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: statement = &child.node()->as<StatementSyntax>(); return;
+        case 1: elseClause = &child.node()->as<ElseClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ActionBlockSyntax* ActionBlockSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ActionBlockSyntax>(*this);
+}
+
+bool AnsiPortListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::AnsiPortList;
+}
+
+TokenOrSyntax AnsiPortListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ports;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax AnsiPortListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ports;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void AnsiPortListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: ports = child.node()->as<SeparatedSyntaxList<MemberSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+AnsiPortListSyntax* AnsiPortListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<AnsiPortListSyntax>(*this);
+}
+
+bool AnsiUdpPortListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::AnsiUdpPortList;
+}
+
+TokenOrSyntax AnsiUdpPortListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ports;
+        case 2: return closeParen;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax AnsiUdpPortListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ports;
+        case 2: return closeParen;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void AnsiUdpPortListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: ports = child.node()->as<SeparatedSyntaxList<UdpPortDeclSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+AnsiUdpPortListSyntax* AnsiUdpPortListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<AnsiUdpPortListSyntax>(*this);
+}
+
+bool ArgumentListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ArgumentList;
+}
+
+TokenOrSyntax ArgumentListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &parameters;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ArgumentListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &parameters;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ArgumentListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: parameters = child.node()->as<SeparatedSyntaxList<ArgumentSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ArgumentListSyntax* ArgumentListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ArgumentListSyntax>(*this);
+}
+
+bool ArgumentSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::EmptyArgument:
+        case SyntaxKind::NamedArgument:
+        case SyntaxKind::OrderedArgument:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool ArrayOrRandomizeMethodExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ArrayOrRandomizeMethodExpression;
+}
+
+TokenOrSyntax ArrayOrRandomizeMethodExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return method.get();
+        case 1: return with;
+        case 2: return args;
+        case 3: return constraints;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ArrayOrRandomizeMethodExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return method.get();
+        case 1: return with;
+        case 2: return args;
+        case 3: return constraints;
+        default: return nullptr;
+    }
+}
+
+void ArrayOrRandomizeMethodExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: method = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: with = child.token(); return;
+        case 2: args = &child.node()->as<ParenExpressionListSyntax>(); return;
+        case 3: constraints = &child.node()->as<ConstraintBlockSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ArrayOrRandomizeMethodExpressionSyntax* ArrayOrRandomizeMethodExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ArrayOrRandomizeMethodExpressionSyntax>(*this);
+}
+
+bool AssertionItemPortListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::AssertionItemPortList;
+}
+
+TokenOrSyntax AssertionItemPortListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ports;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax AssertionItemPortListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ports;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void AssertionItemPortListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: ports = child.node()->as<SeparatedSyntaxList<AssertionItemPortSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+AssertionItemPortListSyntax* AssertionItemPortListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<AssertionItemPortListSyntax>(*this);
+}
+
+bool AssertionItemPortSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::AssertionItemPort;
+}
+
+TokenOrSyntax AssertionItemPortSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return local;
+        case 2: return direction;
+        case 3: return type.get();
+        case 4: return declarator.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax AssertionItemPortSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return local;
+        case 2: return direction;
+        case 3: return type.get();
+        case 4: return declarator.get();
+        default: return nullptr;
+    }
+}
+
+void AssertionItemPortSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: local = child.token(); return;
+        case 2: direction = child.token(); return;
+        case 3: type = &child.node()->as<DataTypeSyntax>(); return;
+        case 4: declarator = &child.node()->as<DeclaratorSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+AssertionItemPortSyntax* AssertionItemPortSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<AssertionItemPortSyntax>(*this);
+}
+
+bool AssignmentPatternExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::AssignmentPatternExpression;
+}
+
+TokenOrSyntax AssignmentPatternExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return type;
+        case 1: return pattern.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax AssignmentPatternExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return type;
+        case 1: return pattern.get();
+        default: return nullptr;
+    }
+}
+
+void AssignmentPatternExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: type = &child.node()->as<DataTypeSyntax>(); return;
+        case 1: pattern = &child.node()->as<AssignmentPatternSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+AssignmentPatternExpressionSyntax* AssignmentPatternExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<AssignmentPatternExpressionSyntax>(*this);
+}
+
+bool AssignmentPatternItemSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::AssignmentPatternItem;
+}
+
+TokenOrSyntax AssignmentPatternItemSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return key.get();
+        case 1: return colon;
+        case 2: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax AssignmentPatternItemSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return key.get();
+        case 1: return colon;
+        case 2: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void AssignmentPatternItemSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: key = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: colon = child.token(); return;
+        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+AssignmentPatternItemSyntax* AssignmentPatternItemSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<AssignmentPatternItemSyntax>(*this);
+}
+
+bool AssignmentPatternSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ReplicatedAssignmentPattern:
+        case SyntaxKind::SimpleAssignmentPattern:
+        case SyntaxKind::StructuredAssignmentPattern:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool AttributeInstanceSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::AttributeInstance;
+}
+
+TokenOrSyntax AttributeInstanceSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &specs;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax AttributeInstanceSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &specs;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void AttributeInstanceSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: specs = child.node()->as<SeparatedSyntaxList<AttributeSpecSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+AttributeInstanceSyntax* AttributeInstanceSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<AttributeInstanceSyntax>(*this);
+}
+
+bool AttributeSpecSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::AttributeSpec;
+}
+
+TokenOrSyntax AttributeSpecSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return value;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax AttributeSpecSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return value;
+        default: return nullptr;
+    }
+}
+
+void AttributeSpecSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: value = &child.node()->as<EqualsValueClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+AttributeSpecSyntax* AttributeSpecSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<AttributeSpecSyntax>(*this);
+}
+
+bool BadExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::BadExpression;
+}
+
+TokenOrSyntax BadExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax BadExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void BadExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+BadExpressionSyntax* BadExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<BadExpressionSyntax>(*this);
+}
+
+bool BeginKeywordsDirectiveSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::BeginKeywordsDirective;
+}
+
+TokenOrSyntax BeginKeywordsDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return versionSpecifier;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax BeginKeywordsDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return versionSpecifier;
+        default: return nullptr;
+    }
+}
+
+void BeginKeywordsDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: versionSpecifier = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+BeginKeywordsDirectiveSyntax* BeginKeywordsDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<BeginKeywordsDirectiveSyntax>(*this);
+}
+
+bool BinaryBlockEventExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::BinaryBlockEventExpression;
+}
+
+TokenOrSyntax BinaryBlockEventExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return orKeyword;
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax BinaryBlockEventExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return orKeyword;
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+void BinaryBlockEventExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<BlockEventExpressionSyntax>(); return;
+        case 1: orKeyword = child.token(); return;
+        case 2: right = &child.node()->as<BlockEventExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+BinaryBlockEventExpressionSyntax* BinaryBlockEventExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<BinaryBlockEventExpressionSyntax>(*this);
+}
+
+bool BinaryEventExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::BinaryEventExpression;
+}
+
+TokenOrSyntax BinaryEventExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return operatorToken;
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax BinaryEventExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return operatorToken;
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+void BinaryEventExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<EventExpressionSyntax>(); return;
+        case 1: operatorToken = child.token(); return;
+        case 2: right = &child.node()->as<EventExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+BinaryEventExpressionSyntax* BinaryEventExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<BinaryEventExpressionSyntax>(*this);
+}
+
+bool BinaryExpressionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AddAssignmentExpression:
+        case SyntaxKind::AddExpression:
+        case SyntaxKind::AndAssignmentExpression:
+        case SyntaxKind::AndSequenceExpression:
+        case SyntaxKind::ArithmeticLeftShiftAssignmentExpression:
+        case SyntaxKind::ArithmeticRightShiftAssignmentExpression:
+        case SyntaxKind::ArithmeticShiftLeftExpression:
+        case SyntaxKind::ArithmeticShiftRightExpression:
+        case SyntaxKind::AssignmentExpression:
+        case SyntaxKind::BinaryAndExpression:
+        case SyntaxKind::BinaryOrExpression:
+        case SyntaxKind::BinarySequenceDelayExpression:
+        case SyntaxKind::BinaryXnorExpression:
+        case SyntaxKind::BinaryXorExpression:
+        case SyntaxKind::CaseEqualityExpression:
+        case SyntaxKind::CaseInequalityExpression:
+        case SyntaxKind::DivideAssignmentExpression:
+        case SyntaxKind::DivideExpression:
+        case SyntaxKind::EqualityExpression:
+        case SyntaxKind::GreaterThanEqualExpression:
+        case SyntaxKind::GreaterThanExpression:
+        case SyntaxKind::IffPropertyExpression:
+        case SyntaxKind::ImpliesPropertyExpression:
+        case SyntaxKind::InequalityExpression:
+        case SyntaxKind::IntersectSequenceExpression:
+        case SyntaxKind::LessThanEqualExpression:
+        case SyntaxKind::LessThanExpression:
+        case SyntaxKind::LogicalAndExpression:
+        case SyntaxKind::LogicalEquivalenceExpression:
+        case SyntaxKind::LogicalImplicationExpression:
+        case SyntaxKind::LogicalLeftShiftAssignmentExpression:
+        case SyntaxKind::LogicalOrExpression:
+        case SyntaxKind::LogicalRightShiftAssignmentExpression:
+        case SyntaxKind::LogicalShiftLeftExpression:
+        case SyntaxKind::LogicalShiftRightExpression:
+        case SyntaxKind::ModAssignmentExpression:
+        case SyntaxKind::ModExpression:
+        case SyntaxKind::MultiplyAssignmentExpression:
+        case SyntaxKind::MultiplyExpression:
+        case SyntaxKind::NonOverlappedFollowedByPropertyExpression:
+        case SyntaxKind::NonOverlappedImplicationPropertyExpression:
+        case SyntaxKind::NonblockingAssignmentExpression:
+        case SyntaxKind::OrAssignmentExpression:
+        case SyntaxKind::OrSequenceExpression:
+        case SyntaxKind::OverlappedFollowedByPropertyExpression:
+        case SyntaxKind::OverlappedImplicationPropertyExpression:
+        case SyntaxKind::PowerExpression:
+        case SyntaxKind::SUntilPropertyExpression:
+        case SyntaxKind::SUntilWithPropertyExpression:
+        case SyntaxKind::SubtractAssignmentExpression:
+        case SyntaxKind::SubtractExpression:
+        case SyntaxKind::ThroughoutSequenceExpression:
+        case SyntaxKind::UntilPropertyExpression:
+        case SyntaxKind::UntilWithPropertyExpression:
+        case SyntaxKind::WildcardEqualityExpression:
+        case SyntaxKind::WildcardInequalityExpression:
+        case SyntaxKind::WithinSequenceExpression:
+        case SyntaxKind::XorAssignmentExpression:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax BinaryExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return operatorToken;
+        case 2: return &attributes;
+        case 3: return right.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax BinaryExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return operatorToken;
+        case 2: return &attributes;
+        case 3: return right.get();
+        default: return nullptr;
+    }
+}
+
+void BinaryExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: operatorToken = child.token(); return;
+        case 2: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 3: right = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+BinaryExpressionSyntax* BinaryExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<BinaryExpressionSyntax>(*this);
+}
+
+bool BindDirectiveSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::BindDirective;
+}
+
+TokenOrSyntax BindDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return bind;
+        case 2: return target.get();
+        case 3: return targetInstances;
+        case 4: return instantiation.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax BindDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return bind;
+        case 2: return target.get();
+        case 3: return targetInstances;
+        case 4: return instantiation.get();
+        default: return nullptr;
+    }
+}
+
+void BindDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: bind = child.token(); return;
+        case 2: target = &child.node()->as<NameSyntax>(); return;
+        case 3: targetInstances = &child.node()->as<BindTargetListSyntax>(); return;
+        case 4: instantiation = &child.node()->as<HierarchyInstantiationSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+BindDirectiveSyntax* BindDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<BindDirectiveSyntax>(*this);
+}
+
+bool BindTargetListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::BindTargetList;
+}
+
+TokenOrSyntax BindTargetListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return colon;
+        case 1: return &targets;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax BindTargetListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return colon;
+        case 1: return &targets;
+        default: return nullptr;
+    }
+}
+
+void BindTargetListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: colon = child.token(); return;
+        case 1: targets = child.node()->as<SeparatedSyntaxList<NameSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+BindTargetListSyntax* BindTargetListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<BindTargetListSyntax>(*this);
+}
+
+bool BitSelectSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::BitSelect;
+}
+
+TokenOrSyntax BitSelectSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax BitSelectSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void BitSelectSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+BitSelectSyntax* BitSelectSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<BitSelectSyntax>(*this);
+}
+
+bool BlockCoverageEventSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::BlockCoverageEvent;
+}
+
+TokenOrSyntax BlockCoverageEventSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return atat;
+        case 1: return openParen;
+        case 2: return expr.get();
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax BlockCoverageEventSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return atat;
+        case 1: return openParen;
+        case 2: return expr.get();
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void BlockCoverageEventSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: atat = child.token(); return;
+        case 1: openParen = child.token(); return;
+        case 2: expr = &child.node()->as<BlockEventExpressionSyntax>(); return;
+        case 3: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+BlockCoverageEventSyntax* BlockCoverageEventSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<BlockCoverageEventSyntax>(*this);
+}
+
+bool BlockEventExpressionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::BinaryBlockEventExpression:
+        case SyntaxKind::PrimaryBlockEventExpression:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool BlockStatementSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ParallelBlockStatement:
+        case SyntaxKind::SequentialBlockStatement:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax BlockStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return begin;
+        case 3: return blockName;
+        case 4: return &items;
+        case 5: return end;
+        case 6: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax BlockStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return begin;
+        case 3: return blockName;
+        case 4: return &items;
+        case 5: return end;
+        case 6: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+void BlockStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: begin = child.token(); return;
+        case 3: blockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        case 4: items = child.node()->as<SyntaxList<SyntaxNode>>(); return;
+        case 5: end = child.token(); return;
+        case 6: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+BlockStatementSyntax* BlockStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<BlockStatementSyntax>(*this);
+}
+
+bool CaseGenerateSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::CaseGenerate;
+}
+
+TokenOrSyntax CaseGenerateSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return openParen;
+        case 3: return condition.get();
+        case 4: return closeParen;
+        case 5: return &items;
+        case 6: return endCase;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax CaseGenerateSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return openParen;
+        case 3: return condition.get();
+        case 4: return closeParen;
+        case 5: return &items;
+        case 6: return endCase;
+        default: return nullptr;
+    }
+}
+
+void CaseGenerateSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: openParen = child.token(); return;
+        case 3: condition = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: closeParen = child.token(); return;
+        case 5: items = child.node()->as<SyntaxList<CaseItemSyntax>>(); return;
+        case 6: endCase = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+CaseGenerateSyntax* CaseGenerateSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<CaseGenerateSyntax>(*this);
+}
+
+bool CaseItemSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::DefaultCaseItem:
+        case SyntaxKind::PatternCaseItem:
+        case SyntaxKind::StandardCaseItem:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool CaseStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::CaseStatement;
+}
+
+TokenOrSyntax CaseStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return uniqueOrPriority;
+        case 3: return caseKeyword;
+        case 4: return openParen;
+        case 5: return expr.get();
+        case 6: return closeParen;
+        case 7: return matchesOrInside;
+        case 8: return &items;
+        case 9: return endcase;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax CaseStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return uniqueOrPriority;
+        case 3: return caseKeyword;
+        case 4: return openParen;
+        case 5: return expr.get();
+        case 6: return closeParen;
+        case 7: return matchesOrInside;
+        case 8: return &items;
+        case 9: return endcase;
+        default: return nullptr;
+    }
+}
+
+void CaseStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: uniqueOrPriority = child.token(); return;
+        case 3: caseKeyword = child.token(); return;
+        case 4: openParen = child.token(); return;
+        case 5: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 6: closeParen = child.token(); return;
+        case 7: matchesOrInside = child.token(); return;
+        case 8: items = child.node()->as<SyntaxList<CaseItemSyntax>>(); return;
+        case 9: endcase = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+CaseStatementSyntax* CaseStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<CaseStatementSyntax>(*this);
+}
+
+bool CastExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::CastExpression;
+}
+
+TokenOrSyntax CastExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return apostrophe;
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax CastExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return apostrophe;
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+void CastExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: apostrophe = child.token(); return;
+        case 2: right = &child.node()->as<ParenthesizedExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+CastExpressionSyntax* CastExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<CastExpressionSyntax>(*this);
+}
+
+bool ChargeStrengthSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ChargeStrength;
+}
+
+TokenOrSyntax ChargeStrengthSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return strength;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ChargeStrengthSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return strength;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ChargeStrengthSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: strength = child.token(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ChargeStrengthSyntax* ChargeStrengthSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ChargeStrengthSyntax>(*this);
+}
+
+bool ClassDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ClassDeclaration;
+}
+
+TokenOrSyntax ClassDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return virtualOrInterface;
+        case 2: return classKeyword;
+        case 3: return lifetime;
+        case 4: return name;
+        case 5: return parameters;
+        case 6: return extendsClause;
+        case 7: return implementsClause;
+        case 8: return semi;
+        case 9: return &items;
+        case 10: return endClass;
+        case 11: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ClassDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return virtualOrInterface;
+        case 2: return classKeyword;
+        case 3: return lifetime;
+        case 4: return name;
+        case 5: return parameters;
+        case 6: return extendsClause;
+        case 7: return implementsClause;
+        case 8: return semi;
+        case 9: return &items;
+        case 10: return endClass;
+        case 11: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+void ClassDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: virtualOrInterface = child.token(); return;
+        case 2: classKeyword = child.token(); return;
+        case 3: lifetime = child.token(); return;
+        case 4: name = child.token(); return;
+        case 5: parameters = &child.node()->as<ParameterPortListSyntax>(); return;
+        case 6: extendsClause = &child.node()->as<ExtendsClauseSyntax>(); return;
+        case 7: implementsClause = &child.node()->as<ImplementsClauseSyntax>(); return;
+        case 8: semi = child.token(); return;
+        case 9: items = child.node()->as<SyntaxList<MemberSyntax>>(); return;
+        case 10: endClass = child.token(); return;
+        case 11: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ClassDeclarationSyntax* ClassDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ClassDeclarationSyntax>(*this);
+}
+
+bool ClassMethodDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ClassMethodDeclaration;
+}
+
+TokenOrSyntax ClassMethodDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return declaration.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ClassMethodDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return declaration.get();
+        default: return nullptr;
+    }
+}
+
+void ClassMethodDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: qualifiers = child.node()->as<TokenList>(); return;
+        case 2: declaration = &child.node()->as<FunctionDeclarationSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ClassMethodDeclarationSyntax* ClassMethodDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ClassMethodDeclarationSyntax>(*this);
+}
+
+bool ClassMethodPrototypeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ClassMethodPrototype;
+}
+
+TokenOrSyntax ClassMethodPrototypeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return prototype.get();
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ClassMethodPrototypeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return prototype.get();
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void ClassMethodPrototypeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: qualifiers = child.node()->as<TokenList>(); return;
+        case 2: prototype = &child.node()->as<FunctionPrototypeSyntax>(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ClassMethodPrototypeSyntax* ClassMethodPrototypeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ClassMethodPrototypeSyntax>(*this);
+}
+
+bool ClassNameSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ClassName;
+}
+
+TokenOrSyntax ClassNameSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return identifier;
+        case 1: return parameters.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ClassNameSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return identifier;
+        case 1: return parameters.get();
+        default: return nullptr;
+    }
+}
+
+void ClassNameSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: identifier = child.token(); return;
+        case 1: parameters = &child.node()->as<ParameterValueAssignmentSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ClassNameSyntax* ClassNameSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ClassNameSyntax>(*this);
+}
+
+bool ClassPropertyDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ClassPropertyDeclaration;
+}
+
+TokenOrSyntax ClassPropertyDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return declaration.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ClassPropertyDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return declaration.get();
+        default: return nullptr;
+    }
+}
+
+void ClassPropertyDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: qualifiers = child.node()->as<TokenList>(); return;
+        case 2: declaration = &child.node()->as<MemberSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ClassPropertyDeclarationSyntax* ClassPropertyDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ClassPropertyDeclarationSyntax>(*this);
+}
+
+bool ClockingDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ClockingDeclaration;
+}
+
+TokenOrSyntax ClockingDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return globalOrDefault;
+        case 2: return clocking;
+        case 3: return blockName;
+        case 4: return at;
+        case 5: return event.get();
+        case 6: return semi;
+        case 7: return &items;
+        case 8: return endClocking;
+        case 9: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ClockingDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return globalOrDefault;
+        case 2: return clocking;
+        case 3: return blockName;
+        case 4: return at;
+        case 5: return event.get();
+        case 6: return semi;
+        case 7: return &items;
+        case 8: return endClocking;
+        case 9: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+void ClockingDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: globalOrDefault = child.token(); return;
+        case 2: clocking = child.token(); return;
+        case 3: blockName = child.token(); return;
+        case 4: at = child.token(); return;
+        case 5: event = &child.node()->as<EventExpressionSyntax>(); return;
+        case 6: semi = child.token(); return;
+        case 7: items = child.node()->as<SyntaxList<MemberSyntax>>(); return;
+        case 8: endClocking = child.token(); return;
+        case 9: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ClockingDeclarationSyntax* ClockingDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ClockingDeclarationSyntax>(*this);
+}
+
+bool ClockingDirectionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ClockingDirection;
+}
+
+TokenOrSyntax ClockingDirectionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return input;
+        case 1: return inputSkew;
+        case 2: return output;
+        case 3: return ouputSkew;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ClockingDirectionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return input;
+        case 1: return inputSkew;
+        case 2: return output;
+        case 3: return ouputSkew;
+        default: return nullptr;
+    }
+}
+
+void ClockingDirectionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: input = child.token(); return;
+        case 1: inputSkew = &child.node()->as<ClockingSkewSyntax>(); return;
+        case 2: output = child.token(); return;
+        case 3: ouputSkew = &child.node()->as<ClockingSkewSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ClockingDirectionSyntax* ClockingDirectionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ClockingDirectionSyntax>(*this);
+}
+
+bool ClockingItemSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ClockingItem;
+}
+
+TokenOrSyntax ClockingItemSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return direction.get();
+        case 2: return &decls;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ClockingItemSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return direction.get();
+        case 2: return &decls;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void ClockingItemSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: direction = &child.node()->as<ClockingDirectionSyntax>(); return;
+        case 2: decls = child.node()->as<SeparatedSyntaxList<AttributeSpecSyntax>>(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ClockingItemSyntax* ClockingItemSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ClockingItemSyntax>(*this);
+}
+
+bool ClockingSkewSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ClockingSkew;
+}
+
+TokenOrSyntax ClockingSkewSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return edge;
+        case 1: return delay;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ClockingSkewSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return edge;
+        case 1: return delay;
+        default: return nullptr;
+    }
+}
+
+void ClockingSkewSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: edge = child.token(); return;
+        case 1: delay = &child.node()->as<DelaySyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ClockingSkewSyntax* ClockingSkewSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ClockingSkewSyntax>(*this);
+}
+
+bool ColonExpressionClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ColonExpressionClause;
+}
+
+TokenOrSyntax ColonExpressionClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return colon;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ColonExpressionClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return colon;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void ColonExpressionClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: colon = child.token(); return;
+        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ColonExpressionClauseSyntax* ColonExpressionClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ColonExpressionClauseSyntax>(*this);
+}
+
+bool CompilationUnitSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::CompilationUnit;
+}
+
+TokenOrSyntax CompilationUnitSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &members;
+        case 1: return endOfFile;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax CompilationUnitSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &members;
+        case 1: return endOfFile;
+        default: return nullptr;
+    }
+}
+
+void CompilationUnitSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: members = child.node()->as<SyntaxList<MemberSyntax>>(); return;
+        case 1: endOfFile = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+CompilationUnitSyntax* CompilationUnitSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<CompilationUnitSyntax>(*this);
+}
+
+bool ConcatenationExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConcatenationExpression;
+}
+
+TokenOrSyntax ConcatenationExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &expressions;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConcatenationExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &expressions;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void ConcatenationExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: expressions = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 2: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConcatenationExpressionSyntax* ConcatenationExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConcatenationExpressionSyntax>(*this);
+}
+
+bool ConcurrentAssertionMemberSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConcurrentAssertionMember;
+}
+
+TokenOrSyntax ConcurrentAssertionMemberSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConcurrentAssertionMemberSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void ConcurrentAssertionMemberSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: statement = &child.node()->as<ConcurrentAssertionStatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConcurrentAssertionMemberSyntax* ConcurrentAssertionMemberSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConcurrentAssertionMemberSyntax>(*this);
+}
+
+bool ConcurrentAssertionStatementSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AssertPropertyStatement:
+        case SyntaxKind::AssumePropertyStatement:
+        case SyntaxKind::CoverPropertyStatement:
+        case SyntaxKind::CoverSequenceStatement:
+        case SyntaxKind::ExpectPropertyStatement:
+        case SyntaxKind::RestrictPropertyStatement:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax ConcurrentAssertionStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return keyword;
+        case 3: return propertyOrSequence;
+        case 4: return openParen;
+        case 5: return propertySpec.get();
+        case 6: return closeParen;
+        case 7: return action.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConcurrentAssertionStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return keyword;
+        case 3: return propertyOrSequence;
+        case 4: return openParen;
+        case 5: return propertySpec.get();
+        case 6: return closeParen;
+        case 7: return action.get();
+        default: return nullptr;
+    }
+}
+
+void ConcurrentAssertionStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: keyword = child.token(); return;
+        case 3: propertyOrSequence = child.token(); return;
+        case 4: openParen = child.token(); return;
+        case 5: propertySpec = &child.node()->as<PropertySpecSyntax>(); return;
+        case 6: closeParen = child.token(); return;
+        case 7: action = &child.node()->as<ActionBlockSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConcurrentAssertionStatementSyntax* ConcurrentAssertionStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConcurrentAssertionStatementSyntax>(*this);
+}
+
+bool ConditionalBranchDirectiveSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ElsIfDirective:
+        case SyntaxKind::IfDefDirective:
+        case SyntaxKind::IfNDefDirective:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax ConditionalBranchDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return name;
+        case 2: return &disabledTokens;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConditionalBranchDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return name;
+        case 2: return &disabledTokens;
+        default: return nullptr;
+    }
+}
+
+void ConditionalBranchDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: name = child.token(); return;
+        case 2: disabledTokens = child.node()->as<TokenList>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConditionalBranchDirectiveSyntax* ConditionalBranchDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConditionalBranchDirectiveSyntax>(*this);
+}
+
+bool ConditionalConstraintSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConditionalConstraint;
+}
+
+TokenOrSyntax ConditionalConstraintSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return ifKeyword;
+        case 1: return openParen;
+        case 2: return condition.get();
+        case 3: return closeParen;
+        case 4: return constraints.get();
+        case 5: return elseClause;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConditionalConstraintSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return ifKeyword;
+        case 1: return openParen;
+        case 2: return condition.get();
+        case 3: return closeParen;
+        case 4: return constraints.get();
+        case 5: return elseClause;
+        default: return nullptr;
+    }
+}
+
+void ConditionalConstraintSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: ifKeyword = child.token(); return;
+        case 1: openParen = child.token(); return;
+        case 2: condition = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: closeParen = child.token(); return;
+        case 4: constraints = &child.node()->as<ConstraintItemSyntax>(); return;
+        case 5: elseClause = &child.node()->as<ElseConstraintClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConditionalConstraintSyntax* ConditionalConstraintSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConditionalConstraintSyntax>(*this);
+}
+
+bool ConditionalExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConditionalExpression;
+}
+
+TokenOrSyntax ConditionalExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return predicate.get();
+        case 1: return question;
+        case 2: return &attributes;
+        case 3: return left.get();
+        case 4: return colon;
+        case 5: return right.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConditionalExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return predicate.get();
+        case 1: return question;
+        case 2: return &attributes;
+        case 3: return left.get();
+        case 4: return colon;
+        case 5: return right.get();
+        default: return nullptr;
+    }
+}
+
+void ConditionalExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: predicate = &child.node()->as<ConditionalPredicateSyntax>(); return;
+        case 1: question = child.token(); return;
+        case 2: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 3: left = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: colon = child.token(); return;
+        case 5: right = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConditionalExpressionSyntax* ConditionalExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConditionalExpressionSyntax>(*this);
+}
+
+bool ConditionalPathDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConditionalPathDeclaration;
+}
+
+TokenOrSyntax ConditionalPathDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return openParen;
+        case 3: return predicate.get();
+        case 4: return closeParen;
+        case 5: return path.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConditionalPathDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return openParen;
+        case 3: return predicate.get();
+        case 4: return closeParen;
+        case 5: return path.get();
+        default: return nullptr;
+    }
+}
+
+void ConditionalPathDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: openParen = child.token(); return;
+        case 3: predicate = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: closeParen = child.token(); return;
+        case 5: path = &child.node()->as<PathDeclarationSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConditionalPathDeclarationSyntax* ConditionalPathDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConditionalPathDeclarationSyntax>(*this);
+}
+
+bool ConditionalPatternSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConditionalPattern;
+}
+
+TokenOrSyntax ConditionalPatternSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return matchesClause;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConditionalPatternSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return matchesClause;
+        default: return nullptr;
+    }
+}
+
+void ConditionalPatternSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: matchesClause = &child.node()->as<MatchesClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConditionalPatternSyntax* ConditionalPatternSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConditionalPatternSyntax>(*this);
+}
+
+bool ConditionalPredicateSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConditionalPredicate;
+}
+
+TokenOrSyntax ConditionalPredicateSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &conditions;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConditionalPredicateSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &conditions;
+        default: return nullptr;
+    }
+}
+
+void ConditionalPredicateSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: conditions = child.node()->as<SeparatedSyntaxList<ConditionalPatternSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConditionalPredicateSyntax* ConditionalPredicateSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConditionalPredicateSyntax>(*this);
+}
+
+bool ConditionalStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConditionalStatement;
+}
+
+TokenOrSyntax ConditionalStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return uniqueOrPriority;
+        case 3: return ifKeyword;
+        case 4: return openParen;
+        case 5: return predicate.get();
+        case 6: return closeParen;
+        case 7: return statement.get();
+        case 8: return elseClause;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConditionalStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return uniqueOrPriority;
+        case 3: return ifKeyword;
+        case 4: return openParen;
+        case 5: return predicate.get();
+        case 6: return closeParen;
+        case 7: return statement.get();
+        case 8: return elseClause;
+        default: return nullptr;
+    }
+}
+
+void ConditionalStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: uniqueOrPriority = child.token(); return;
+        case 3: ifKeyword = child.token(); return;
+        case 4: openParen = child.token(); return;
+        case 5: predicate = &child.node()->as<ConditionalPredicateSyntax>(); return;
+        case 6: closeParen = child.token(); return;
+        case 7: statement = &child.node()->as<StatementSyntax>(); return;
+        case 8: elseClause = &child.node()->as<ElseClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConditionalStatementSyntax* ConditionalStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConditionalStatementSyntax>(*this);
+}
+
+bool ConstraintBlockSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConstraintBlock;
+}
+
+TokenOrSyntax ConstraintBlockSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &items;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConstraintBlockSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &items;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void ConstraintBlockSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: items = child.node()->as<SyntaxList<ConstraintItemSyntax>>(); return;
+        case 2: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConstraintBlockSyntax* ConstraintBlockSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConstraintBlockSyntax>(*this);
+}
+
+bool ConstraintDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConstraintDeclaration;
+}
+
+TokenOrSyntax ConstraintDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return keyword;
+        case 3: return name.get();
+        case 4: return block.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConstraintDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return keyword;
+        case 3: return name.get();
+        case 4: return block.get();
+        default: return nullptr;
+    }
+}
+
+void ConstraintDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: qualifiers = child.node()->as<TokenList>(); return;
+        case 2: keyword = child.token(); return;
+        case 3: name = &child.node()->as<NameSyntax>(); return;
+        case 4: block = &child.node()->as<ConstraintBlockSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConstraintDeclarationSyntax* ConstraintDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConstraintDeclarationSyntax>(*this);
+}
+
+bool ConstraintItemSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ConditionalConstraint:
+        case SyntaxKind::ConstraintBlock:
+        case SyntaxKind::DisableConstraint:
+        case SyntaxKind::ExpressionConstraint:
+        case SyntaxKind::ImplicationConstraint:
+        case SyntaxKind::LoopConstraint:
+        case SyntaxKind::SolveBeforeConstraint:
+        case SyntaxKind::UniquenessConstraint:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool ConstraintPrototypeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConstraintPrototype;
+}
+
+TokenOrSyntax ConstraintPrototypeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return keyword;
+        case 3: return name.get();
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConstraintPrototypeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return keyword;
+        case 3: return name.get();
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void ConstraintPrototypeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: qualifiers = child.node()->as<TokenList>(); return;
+        case 2: keyword = child.token(); return;
+        case 3: name = &child.node()->as<NameSyntax>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConstraintPrototypeSyntax* ConstraintPrototypeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConstraintPrototypeSyntax>(*this);
+}
+
+bool ContinuousAssignSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ContinuousAssign;
+}
+
+TokenOrSyntax ContinuousAssignSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return assign;
+        case 2: return strength;
+        case 3: return delay;
+        case 4: return &assignments;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ContinuousAssignSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return assign;
+        case 2: return strength;
+        case 3: return delay;
+        case 4: return &assignments;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+void ContinuousAssignSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: assign = child.token(); return;
+        case 2: strength = &child.node()->as<DriveStrengthSyntax>(); return;
+        case 3: delay = &child.node()->as<TimingControlSyntax>(); return;
+        case 4: assignments = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 5: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ContinuousAssignSyntax* ContinuousAssignSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ContinuousAssignSyntax>(*this);
+}
+
+bool CopyClassExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::CopyClassExpression;
+}
+
+TokenOrSyntax CopyClassExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return scopedNew.get();
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax CopyClassExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return scopedNew.get();
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void CopyClassExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: scopedNew = &child.node()->as<NameSyntax>(); return;
+        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+CopyClassExpressionSyntax* CopyClassExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<CopyClassExpressionSyntax>(*this);
+}
+
+bool CoverageBinInitializerSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::DefaultCoverageBinInitializer:
+        case SyntaxKind::ExpressionCoverageBinInitializer:
+        case SyntaxKind::RangeCoverageBinInitializer:
+        case SyntaxKind::TransListCoverageBinInitializer:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool CoverageBinsSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::CoverageBins;
+}
+
+TokenOrSyntax CoverageBinsSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return wildcard;
+        case 2: return keyword;
+        case 3: return name;
+        case 4: return selector;
+        case 5: return equals;
+        case 6: return initializer.get();
+        case 7: return iff;
+        case 8: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax CoverageBinsSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return wildcard;
+        case 2: return keyword;
+        case 3: return name;
+        case 4: return selector;
+        case 5: return equals;
+        case 6: return initializer.get();
+        case 7: return iff;
+        case 8: return semi;
+        default: return nullptr;
+    }
+}
+
+void CoverageBinsSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: wildcard = child.token(); return;
+        case 2: keyword = child.token(); return;
+        case 3: name = child.token(); return;
+        case 4: selector = &child.node()->as<ElementSelectSyntax>(); return;
+        case 5: equals = child.token(); return;
+        case 6: initializer = &child.node()->as<CoverageBinInitializerSyntax>(); return;
+        case 7: iff = &child.node()->as<CoverageIffClauseSyntax>(); return;
+        case 8: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+CoverageBinsSyntax* CoverageBinsSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<CoverageBinsSyntax>(*this);
+}
+
+bool CoverageIffClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::CoverageIffClause;
+}
+
+TokenOrSyntax CoverageIffClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return iff;
+        case 1: return openParen;
+        case 2: return expr.get();
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax CoverageIffClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return iff;
+        case 1: return openParen;
+        case 2: return expr.get();
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void CoverageIffClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: iff = child.token(); return;
+        case 1: openParen = child.token(); return;
+        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+CoverageIffClauseSyntax* CoverageIffClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<CoverageIffClauseSyntax>(*this);
+}
+
+bool CoverageOptionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::CoverageOption;
+}
+
+TokenOrSyntax CoverageOptionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return option;
+        case 2: return dot;
+        case 3: return name;
+        case 4: return equals;
+        case 5: return expr.get();
+        case 6: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax CoverageOptionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return option;
+        case 2: return dot;
+        case 3: return name;
+        case 4: return equals;
+        case 5: return expr.get();
+        case 6: return semi;
+        default: return nullptr;
+    }
+}
+
+void CoverageOptionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: option = child.token(); return;
+        case 2: dot = child.token(); return;
+        case 3: name = child.token(); return;
+        case 4: equals = child.token(); return;
+        case 5: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 6: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+CoverageOptionSyntax* CoverageOptionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<CoverageOptionSyntax>(*this);
+}
+
+bool CovergroupDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::CovergroupDeclaration;
+}
+
+TokenOrSyntax CovergroupDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return covergroup;
+        case 2: return name;
+        case 3: return portList;
+        case 4: return event;
+        case 5: return semi;
+        case 6: return &members;
+        case 7: return endgroup;
+        case 8: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax CovergroupDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return covergroup;
+        case 2: return name;
+        case 3: return portList;
+        case 4: return event;
+        case 5: return semi;
+        case 6: return &members;
+        case 7: return endgroup;
+        case 8: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+void CovergroupDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: covergroup = child.token(); return;
+        case 2: name = child.token(); return;
+        case 3: portList = &child.node()->as<AnsiPortListSyntax>(); return;
+        case 4: event = &child.node()->as<SyntaxNode>(); return;
+        case 5: semi = child.token(); return;
+        case 6: members = child.node()->as<SyntaxList<MemberSyntax>>(); return;
+        case 7: endgroup = child.token(); return;
+        case 8: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+CovergroupDeclarationSyntax* CovergroupDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<CovergroupDeclarationSyntax>(*this);
+}
+
+bool CoverpointSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::Coverpoint;
+}
+
+TokenOrSyntax CoverpointSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return type;
+        case 2: return label;
+        case 3: return coverpoint;
+        case 4: return expr.get();
+        case 5: return openBrace;
+        case 6: return &members;
+        case 7: return closeBrace;
+        case 8: return emptySemi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax CoverpointSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return type;
+        case 2: return label;
+        case 3: return coverpoint;
+        case 4: return expr.get();
+        case 5: return openBrace;
+        case 6: return &members;
+        case 7: return closeBrace;
+        case 8: return emptySemi;
+        default: return nullptr;
+    }
+}
+
+void CoverpointSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: type = &child.node()->as<DataTypeSyntax>(); return;
+        case 2: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 3: coverpoint = child.token(); return;
+        case 4: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 5: openBrace = child.token(); return;
+        case 6: members = child.node()->as<SyntaxList<MemberSyntax>>(); return;
+        case 7: closeBrace = child.token(); return;
+        case 8: emptySemi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+CoverpointSyntax* CoverpointSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<CoverpointSyntax>(*this);
+}
+
+bool DPIExportSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DPIExport;
+}
+
+TokenOrSyntax DPIExportSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return specString;
+        case 3: return c_identifier;
+        case 4: return equals;
+        case 5: return functionOrTask;
+        case 6: return name;
+        case 7: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DPIExportSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return specString;
+        case 3: return c_identifier;
+        case 4: return equals;
+        case 5: return functionOrTask;
+        case 6: return name;
+        case 7: return semi;
+        default: return nullptr;
+    }
+}
+
+void DPIExportSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: specString = child.token(); return;
+        case 3: c_identifier = child.token(); return;
+        case 4: equals = child.token(); return;
+        case 5: functionOrTask = child.token(); return;
+        case 6: name = child.token(); return;
+        case 7: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DPIExportSyntax* DPIExportSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DPIExportSyntax>(*this);
+}
+
+bool DPIImportSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DPIImport;
+}
+
+TokenOrSyntax DPIImportSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return specString;
+        case 3: return property;
+        case 4: return c_identifier;
+        case 5: return equals;
+        case 6: return method.get();
+        case 7: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DPIImportSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return specString;
+        case 3: return property;
+        case 4: return c_identifier;
+        case 5: return equals;
+        case 6: return method.get();
+        case 7: return semi;
+        default: return nullptr;
+    }
+}
+
+void DPIImportSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: specString = child.token(); return;
+        case 3: property = child.token(); return;
+        case 4: c_identifier = child.token(); return;
+        case 5: equals = child.token(); return;
+        case 6: method = &child.node()->as<FunctionPrototypeSyntax>(); return;
+        case 7: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DPIImportSyntax* DPIImportSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DPIImportSyntax>(*this);
+}
+
+bool DataDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DataDeclaration;
+}
+
+TokenOrSyntax DataDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &modifiers;
+        case 2: return type.get();
+        case 3: return &declarators;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DataDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &modifiers;
+        case 2: return type.get();
+        case 3: return &declarators;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void DataDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: modifiers = child.node()->as<TokenList>(); return;
+        case 2: type = &child.node()->as<DataTypeSyntax>(); return;
+        case 3: declarators = child.node()->as<SeparatedSyntaxList<DeclaratorSyntax>>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DataDeclarationSyntax* DataDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DataDeclarationSyntax>(*this);
+}
+
+bool DataTypeSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::BitType:
+        case SyntaxKind::ByteType:
+        case SyntaxKind::CHandleType:
+        case SyntaxKind::EnumType:
+        case SyntaxKind::EventType:
+        case SyntaxKind::ImplicitType:
+        case SyntaxKind::IntType:
+        case SyntaxKind::IntegerType:
+        case SyntaxKind::LogicType:
+        case SyntaxKind::LongIntType:
+        case SyntaxKind::NamedType:
+        case SyntaxKind::PropertyType:
+        case SyntaxKind::RealTimeType:
+        case SyntaxKind::RealType:
+        case SyntaxKind::RegType:
+        case SyntaxKind::SequenceType:
+        case SyntaxKind::ShortIntType:
+        case SyntaxKind::ShortRealType:
+        case SyntaxKind::StringType:
+        case SyntaxKind::StructType:
+        case SyntaxKind::TimeType:
+        case SyntaxKind::TypeReference:
+        case SyntaxKind::UnionType:
+        case SyntaxKind::Untyped:
+        case SyntaxKind::VirtualInterfaceType:
+        case SyntaxKind::VoidType:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool DeclaratorSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::Declarator;
+}
+
+TokenOrSyntax DeclaratorSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return &dimensions;
+        case 2: return initializer;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DeclaratorSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return &dimensions;
+        case 2: return initializer;
+        default: return nullptr;
+    }
+}
+
+void DeclaratorSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
+        case 2: initializer = &child.node()->as<EqualsValueClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DeclaratorSyntax* DeclaratorSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DeclaratorSyntax>(*this);
+}
+
+bool DefParamAssignmentSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DefParamAssignment;
+}
+
+TokenOrSyntax DefParamAssignmentSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name.get();
+        case 1: return setter.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DefParamAssignmentSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name.get();
+        case 1: return setter.get();
+        default: return nullptr;
+    }
+}
+
+void DefParamAssignmentSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = &child.node()->as<NameSyntax>(); return;
+        case 1: setter = &child.node()->as<EqualsValueClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DefParamAssignmentSyntax* DefParamAssignmentSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DefParamAssignmentSyntax>(*this);
+}
+
+bool DefParamSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DefParam;
+}
+
+TokenOrSyntax DefParamSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return defparam;
+        case 2: return &assignments;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DefParamSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return defparam;
+        case 2: return &assignments;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void DefParamSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: defparam = child.token(); return;
+        case 2: assignments = child.node()->as<SeparatedSyntaxList<DefParamAssignmentSyntax>>(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DefParamSyntax* DefParamSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DefParamSyntax>(*this);
+}
+
+bool DefaultCaseItemSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DefaultCaseItem;
+}
+
+TokenOrSyntax DefaultCaseItemSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return defaultKeyword;
+        case 1: return colon;
+        case 2: return clause.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DefaultCaseItemSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return defaultKeyword;
+        case 1: return colon;
+        case 2: return clause.get();
+        default: return nullptr;
+    }
+}
+
+void DefaultCaseItemSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: defaultKeyword = child.token(); return;
+        case 1: colon = child.token(); return;
+        case 2: clause = &child.node()->as<SyntaxNode>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DefaultCaseItemSyntax* DefaultCaseItemSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DefaultCaseItemSyntax>(*this);
+}
+
+bool DefaultClockingReferenceSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DefaultClockingReference;
+}
+
+TokenOrSyntax DefaultClockingReferenceSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return defaultKeyword;
+        case 2: return clocking;
+        case 3: return name;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DefaultClockingReferenceSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return defaultKeyword;
+        case 2: return clocking;
+        case 3: return name;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void DefaultClockingReferenceSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: defaultKeyword = child.token(); return;
+        case 2: clocking = child.token(); return;
+        case 3: name = child.token(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DefaultClockingReferenceSyntax* DefaultClockingReferenceSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DefaultClockingReferenceSyntax>(*this);
+}
+
+bool DefaultCoverageBinInitializerSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DefaultCoverageBinInitializer;
+}
+
+TokenOrSyntax DefaultCoverageBinInitializerSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return defaultKeyword;
+        case 1: return sequenceKeyword;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DefaultCoverageBinInitializerSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return defaultKeyword;
+        case 1: return sequenceKeyword;
+        default: return nullptr;
+    }
+}
+
+void DefaultCoverageBinInitializerSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: defaultKeyword = child.token(); return;
+        case 1: sequenceKeyword = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DefaultCoverageBinInitializerSyntax* DefaultCoverageBinInitializerSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DefaultCoverageBinInitializerSyntax>(*this);
+}
+
+bool DefaultNetTypeDirectiveSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DefaultNetTypeDirective;
+}
+
+TokenOrSyntax DefaultNetTypeDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return netType;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DefaultNetTypeDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return netType;
+        default: return nullptr;
+    }
+}
+
+void DefaultNetTypeDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: netType = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DefaultNetTypeDirectiveSyntax* DefaultNetTypeDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DefaultNetTypeDirectiveSyntax>(*this);
+}
+
+bool DefaultSkewItemSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DefaultSkewItem;
+}
+
+TokenOrSyntax DefaultSkewItemSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return direction.get();
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DefaultSkewItemSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return direction.get();
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void DefaultSkewItemSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: direction = &child.node()->as<ClockingDirectionSyntax>(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DefaultSkewItemSyntax* DefaultSkewItemSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DefaultSkewItemSyntax>(*this);
+}
+
+bool DeferredAssertionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DeferredAssertion;
+}
+
+TokenOrSyntax DeferredAssertionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return hash;
+        case 1: return zero;
+        case 2: return finalKeyword;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DeferredAssertionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return hash;
+        case 1: return zero;
+        case 2: return finalKeyword;
+        default: return nullptr;
+    }
+}
+
+void DeferredAssertionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: hash = child.token(); return;
+        case 1: zero = child.token(); return;
+        case 2: finalKeyword = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DeferredAssertionSyntax* DeferredAssertionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DeferredAssertionSyntax>(*this);
+}
+
+bool DefineDirectiveSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DefineDirective;
+}
+
+TokenOrSyntax DefineDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return name;
+        case 2: return formalArguments;
+        case 3: return &body;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DefineDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return name;
+        case 2: return formalArguments;
+        case 3: return &body;
+        default: return nullptr;
+    }
+}
+
+void DefineDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: name = child.token(); return;
+        case 2: formalArguments = &child.node()->as<MacroFormalArgumentListSyntax>(); return;
+        case 3: body = child.node()->as<TokenList>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DefineDirectiveSyntax* DefineDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DefineDirectiveSyntax>(*this);
+}
+
+bool Delay3Syntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::Delay3;
+}
+
+TokenOrSyntax Delay3Syntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return hash;
+        case 1: return openParen;
+        case 2: return delay1.get();
+        case 3: return comma1;
+        case 4: return delay2;
+        case 5: return comma2;
+        case 6: return delay3;
+        case 7: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax Delay3Syntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return hash;
+        case 1: return openParen;
+        case 2: return delay1.get();
+        case 3: return comma1;
+        case 4: return delay2;
+        case 5: return comma2;
+        case 6: return delay3;
+        case 7: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void Delay3Syntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: hash = child.token(); return;
+        case 1: openParen = child.token(); return;
+        case 2: delay1 = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: comma1 = child.token(); return;
+        case 4: delay2 = &child.node()->as<ExpressionSyntax>(); return;
+        case 5: comma2 = child.token(); return;
+        case 6: delay3 = &child.node()->as<ExpressionSyntax>(); return;
+        case 7: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+Delay3Syntax* Delay3Syntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<Delay3Syntax>(*this);
+}
+
+bool DelaySyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::CycleDelay:
+        case SyntaxKind::DelayControl:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax DelaySyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return hash;
+        case 1: return delayValue.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DelaySyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return hash;
+        case 1: return delayValue.get();
+        default: return nullptr;
+    }
+}
+
+void DelaySyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: hash = child.token(); return;
+        case 1: delayValue = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DelaySyntax* DelaySyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DelaySyntax>(*this);
+}
+
+bool DelayedTerminalArgSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DelayedTerminalArg;
+}
+
+TokenOrSyntax DelayedTerminalArgSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return terminal;
+        case 1: return openBracket;
+        case 2: return expr.get();
+        case 3: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DelayedTerminalArgSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return terminal;
+        case 1: return openBracket;
+        case 2: return expr.get();
+        case 3: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+void DelayedTerminalArgSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: terminal = child.token(); return;
+        case 1: openBracket = child.token(); return;
+        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: closeBracket = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DelayedTerminalArgSyntax* DelayedTerminalArgSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DelayedTerminalArgSyntax>(*this);
+}
+
+bool DimensionSpecifierSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::QueueDimensionSpecifier:
+        case SyntaxKind::RangeDimensionSpecifier:
+        case SyntaxKind::WildcardDimensionSpecifier:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool DirectiveSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::BeginKeywordsDirective:
+        case SyntaxKind::CellDefineDirective:
+        case SyntaxKind::DefaultNetTypeDirective:
+        case SyntaxKind::DefineDirective:
+        case SyntaxKind::ElsIfDirective:
+        case SyntaxKind::ElseDirective:
+        case SyntaxKind::EndCellDefineDirective:
+        case SyntaxKind::EndIfDirective:
+        case SyntaxKind::EndKeywordsDirective:
+        case SyntaxKind::IfDefDirective:
+        case SyntaxKind::IfNDefDirective:
+        case SyntaxKind::IncludeDirective:
+        case SyntaxKind::LineDirective:
+        case SyntaxKind::MacroUsage:
+        case SyntaxKind::NoUnconnectedDriveDirective:
+        case SyntaxKind::PragmaDirective:
+        case SyntaxKind::ResetAllDirective:
+        case SyntaxKind::TimeScaleDirective:
+        case SyntaxKind::UnconnectedDriveDirective:
+        case SyntaxKind::UndefDirective:
+        case SyntaxKind::UndefineAllDirective:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax DirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        default: return nullptr;
+    }
+}
+
+void DirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DirectiveSyntax* DirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DirectiveSyntax>(*this);
+}
+
+bool DisableConstraintSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DisableConstraint;
+}
+
+TokenOrSyntax DisableConstraintSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return disable;
+        case 1: return soft;
+        case 2: return name.get();
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DisableConstraintSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return disable;
+        case 1: return soft;
+        case 2: return name.get();
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void DisableConstraintSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: disable = child.token(); return;
+        case 1: soft = child.token(); return;
+        case 2: name = &child.node()->as<NameSyntax>(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DisableConstraintSyntax* DisableConstraintSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DisableConstraintSyntax>(*this);
+}
+
+bool DisableForkStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DisableForkStatement;
+}
+
+TokenOrSyntax DisableForkStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return disable;
+        case 3: return fork;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DisableForkStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return disable;
+        case 3: return fork;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void DisableForkStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: disable = child.token(); return;
+        case 3: fork = child.token(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DisableForkStatementSyntax* DisableForkStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DisableForkStatementSyntax>(*this);
+}
+
+bool DisableIffSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DisableIff;
+}
+
+TokenOrSyntax DisableIffSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return disable;
+        case 1: return iff;
+        case 2: return openParen;
+        case 3: return expr.get();
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DisableIffSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return disable;
+        case 1: return iff;
+        case 2: return openParen;
+        case 3: return expr.get();
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void DisableIffSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: disable = child.token(); return;
+        case 1: iff = child.token(); return;
+        case 2: openParen = child.token(); return;
+        case 3: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DisableIffSyntax* DisableIffSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DisableIffSyntax>(*this);
+}
+
+bool DisableStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DisableStatement;
+}
+
+TokenOrSyntax DisableStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return disable;
+        case 3: return name.get();
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DisableStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return disable;
+        case 3: return name.get();
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void DisableStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: disable = child.token(); return;
+        case 3: name = &child.node()->as<NameSyntax>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DisableStatementSyntax* DisableStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DisableStatementSyntax>(*this);
+}
+
+bool DistConstraintListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DistConstraintList;
+}
+
+TokenOrSyntax DistConstraintListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return dist;
+        case 1: return openBrace;
+        case 2: return &items;
+        case 3: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DistConstraintListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return dist;
+        case 1: return openBrace;
+        case 2: return &items;
+        case 3: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void DistConstraintListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: dist = child.token(); return;
+        case 1: openBrace = child.token(); return;
+        case 2: items = child.node()->as<SeparatedSyntaxList<DistItemSyntax>>(); return;
+        case 3: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DistConstraintListSyntax* DistConstraintListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DistConstraintListSyntax>(*this);
+}
+
+bool DistItemSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DistItem;
+}
+
+TokenOrSyntax DistItemSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return range.get();
+        case 1: return weight;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DistItemSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return range.get();
+        case 1: return weight;
+        default: return nullptr;
+    }
+}
+
+void DistItemSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: range = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: weight = &child.node()->as<DistWeightSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DistItemSyntax* DistItemSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DistItemSyntax>(*this);
+}
+
+bool DistWeightSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DistWeight;
+}
+
+TokenOrSyntax DistWeightSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return op;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DistWeightSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return op;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void DistWeightSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: op = child.token(); return;
+        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DistWeightSyntax* DistWeightSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DistWeightSyntax>(*this);
+}
+
+bool DividerClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DividerClause;
+}
+
+TokenOrSyntax DividerClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return divide;
+        case 1: return value;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DividerClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return divide;
+        case 1: return value;
+        default: return nullptr;
+    }
+}
+
+void DividerClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: divide = child.token(); return;
+        case 1: value = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DividerClauseSyntax* DividerClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DividerClauseSyntax>(*this);
+}
+
+bool DoWhileStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DoWhileStatement;
+}
+
+TokenOrSyntax DoWhileStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return doKeyword;
+        case 3: return statement.get();
+        case 4: return whileKeyword;
+        case 5: return openParen;
+        case 6: return expr.get();
+        case 7: return closeParen;
+        case 8: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DoWhileStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return doKeyword;
+        case 3: return statement.get();
+        case 4: return whileKeyword;
+        case 5: return openParen;
+        case 6: return expr.get();
+        case 7: return closeParen;
+        case 8: return semi;
+        default: return nullptr;
+    }
+}
+
+void DoWhileStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: doKeyword = child.token(); return;
+        case 3: statement = &child.node()->as<StatementSyntax>(); return;
+        case 4: whileKeyword = child.token(); return;
+        case 5: openParen = child.token(); return;
+        case 6: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 7: closeParen = child.token(); return;
+        case 8: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DoWhileStatementSyntax* DoWhileStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DoWhileStatementSyntax>(*this);
+}
+
+bool DotMemberClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DotMemberClause;
+}
+
+TokenOrSyntax DotMemberClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return dot;
+        case 1: return member;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DotMemberClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return dot;
+        case 1: return member;
+        default: return nullptr;
+    }
+}
+
+void DotMemberClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: dot = child.token(); return;
+        case 1: member = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DotMemberClauseSyntax* DotMemberClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DotMemberClauseSyntax>(*this);
+}
+
+bool DriveStrengthSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DriveStrength;
+}
+
+TokenOrSyntax DriveStrengthSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return strength0;
+        case 2: return comma;
+        case 3: return strength1;
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DriveStrengthSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return strength0;
+        case 2: return comma;
+        case 3: return strength1;
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void DriveStrengthSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: strength0 = child.token(); return;
+        case 2: comma = child.token(); return;
+        case 3: strength1 = child.token(); return;
+        case 4: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DriveStrengthSyntax* DriveStrengthSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DriveStrengthSyntax>(*this);
+}
+
+bool EdgeControlSpecifierSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EdgeControlSpecifier;
+}
+
+TokenOrSyntax EdgeControlSpecifierSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBracket;
+        case 1: return &descriptors;
+        case 2: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EdgeControlSpecifierSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBracket;
+        case 1: return &descriptors;
+        case 2: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+void EdgeControlSpecifierSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBracket = child.token(); return;
+        case 1: descriptors = child.node()->as<SeparatedSyntaxList<EdgeDescriptorSyntax>>(); return;
+        case 2: closeBracket = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EdgeControlSpecifierSyntax* EdgeControlSpecifierSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EdgeControlSpecifierSyntax>(*this);
+}
+
+bool EdgeDescriptorSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EdgeDescriptor;
+}
+
+TokenOrSyntax EdgeDescriptorSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return t1;
+        case 1: return t2;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EdgeDescriptorSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return t1;
+        case 1: return t2;
+        default: return nullptr;
+    }
+}
+
+void EdgeDescriptorSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: t1 = child.token(); return;
+        case 1: t2 = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EdgeDescriptorSyntax* EdgeDescriptorSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EdgeDescriptorSyntax>(*this);
+}
+
+bool EdgeSensitivePathSuffixSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EdgeSensitivePathSuffix;
+}
+
+TokenOrSyntax EdgeSensitivePathSuffixSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &outputs;
+        case 2: return polarityOperator;
+        case 3: return colon;
+        case 4: return expr.get();
+        case 5: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EdgeSensitivePathSuffixSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &outputs;
+        case 2: return polarityOperator;
+        case 3: return colon;
+        case 4: return expr.get();
+        case 5: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void EdgeSensitivePathSuffixSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: outputs = child.node()->as<SeparatedSyntaxList<NameSyntax>>(); return;
+        case 2: polarityOperator = child.token(); return;
+        case 3: colon = child.token(); return;
+        case 4: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 5: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EdgeSensitivePathSuffixSyntax* EdgeSensitivePathSuffixSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EdgeSensitivePathSuffixSyntax>(*this);
+}
+
+bool ElabSystemTaskSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ElabSystemTask;
+}
+
+TokenOrSyntax ElabSystemTaskSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return name;
+        case 2: return arguments;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ElabSystemTaskSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return name;
+        case 2: return arguments;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void ElabSystemTaskSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: name = child.token(); return;
+        case 2: arguments = &child.node()->as<ArgumentListSyntax>(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ElabSystemTaskSyntax* ElabSystemTaskSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ElabSystemTaskSyntax>(*this);
+}
+
+bool ElementSelectExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ElementSelectExpression;
+}
+
+TokenOrSyntax ElementSelectExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return select.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ElementSelectExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return select.get();
+        default: return nullptr;
+    }
+}
+
+void ElementSelectExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: select = &child.node()->as<ElementSelectSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ElementSelectExpressionSyntax* ElementSelectExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ElementSelectExpressionSyntax>(*this);
+}
+
+bool ElementSelectSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ElementSelect;
+}
+
+TokenOrSyntax ElementSelectSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBracket;
+        case 1: return selector;
+        case 2: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ElementSelectSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBracket;
+        case 1: return selector;
+        case 2: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+void ElementSelectSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBracket = child.token(); return;
+        case 1: selector = &child.node()->as<SelectorSyntax>(); return;
+        case 2: closeBracket = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ElementSelectSyntax* ElementSelectSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ElementSelectSyntax>(*this);
+}
+
+bool ElseClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ElseClause;
+}
+
+TokenOrSyntax ElseClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return elseKeyword;
+        case 1: return clause.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ElseClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return elseKeyword;
+        case 1: return clause.get();
+        default: return nullptr;
+    }
+}
+
+void ElseClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: elseKeyword = child.token(); return;
+        case 1: clause = &child.node()->as<SyntaxNode>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ElseClauseSyntax* ElseClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ElseClauseSyntax>(*this);
+}
+
+bool ElseConstraintClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ElseConstraintClause;
+}
+
+TokenOrSyntax ElseConstraintClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return elseKeyword;
+        case 1: return constraints.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ElseConstraintClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return elseKeyword;
+        case 1: return constraints.get();
+        default: return nullptr;
+    }
+}
+
+void ElseConstraintClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: elseKeyword = child.token(); return;
+        case 1: constraints = &child.node()->as<ConstraintItemSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ElseConstraintClauseSyntax* ElseConstraintClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ElseConstraintClauseSyntax>(*this);
+}
+
+bool EmptyArgumentSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EmptyArgument;
+}
+
+TokenOrSyntax EmptyArgumentSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return placeholder;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EmptyArgumentSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return placeholder;
+        default: return nullptr;
+    }
+}
+
+void EmptyArgumentSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: placeholder = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EmptyArgumentSyntax* EmptyArgumentSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EmptyArgumentSyntax>(*this);
+}
+
+bool EmptyIdentifierNameSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EmptyIdentifierName;
+}
+
+TokenOrSyntax EmptyIdentifierNameSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return placeholder;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EmptyIdentifierNameSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return placeholder;
+        default: return nullptr;
+    }
+}
+
+void EmptyIdentifierNameSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: placeholder = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EmptyIdentifierNameSyntax* EmptyIdentifierNameSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EmptyIdentifierNameSyntax>(*this);
+}
+
+bool EmptyMemberSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EmptyMember;
+}
+
+TokenOrSyntax EmptyMemberSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EmptyMemberSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return semi;
+        default: return nullptr;
+    }
+}
+
+void EmptyMemberSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: qualifiers = child.node()->as<TokenList>(); return;
+        case 2: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EmptyMemberSyntax* EmptyMemberSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EmptyMemberSyntax>(*this);
+}
+
+bool EmptyPortConnectionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EmptyPortConnection;
+}
+
+TokenOrSyntax EmptyPortConnectionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return placeholder;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EmptyPortConnectionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return placeholder;
+        default: return nullptr;
+    }
+}
+
+void EmptyPortConnectionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: placeholder = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EmptyPortConnectionSyntax* EmptyPortConnectionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EmptyPortConnectionSyntax>(*this);
+}
+
+bool EmptyQueueExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EmptyQueueExpression;
+}
+
+TokenOrSyntax EmptyQueueExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EmptyQueueExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void EmptyQueueExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EmptyQueueExpressionSyntax* EmptyQueueExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EmptyQueueExpressionSyntax>(*this);
+}
+
+bool EmptyStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EmptyStatement;
+}
+
+TokenOrSyntax EmptyStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return semicolon;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EmptyStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return semicolon;
+        default: return nullptr;
+    }
+}
+
+void EmptyStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: semicolon = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EmptyStatementSyntax* EmptyStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EmptyStatementSyntax>(*this);
+}
+
+bool EmptyTimingCheckArgSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EmptyTimingCheckArg;
+}
+
+TokenOrSyntax EmptyTimingCheckArgSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return placeholder;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EmptyTimingCheckArgSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return placeholder;
+        default: return nullptr;
+    }
+}
+
+void EmptyTimingCheckArgSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: placeholder = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EmptyTimingCheckArgSyntax* EmptyTimingCheckArgSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EmptyTimingCheckArgSyntax>(*this);
+}
+
+bool EnumTypeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EnumType;
+}
+
+TokenOrSyntax EnumTypeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return baseType;
+        case 2: return openBrace;
+        case 3: return &members;
+        case 4: return closeBrace;
+        case 5: return &dimensions;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EnumTypeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return baseType;
+        case 2: return openBrace;
+        case 3: return &members;
+        case 4: return closeBrace;
+        case 5: return &dimensions;
+        default: return nullptr;
+    }
+}
+
+void EnumTypeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        case 1: baseType = &child.node()->as<DataTypeSyntax>(); return;
+        case 2: openBrace = child.token(); return;
+        case 3: members = child.node()->as<SeparatedSyntaxList<DeclaratorSyntax>>(); return;
+        case 4: closeBrace = child.token(); return;
+        case 5: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EnumTypeSyntax* EnumTypeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EnumTypeSyntax>(*this);
+}
+
+bool EqualsTypeClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EqualsTypeClause;
+}
+
+TokenOrSyntax EqualsTypeClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return equals;
+        case 1: return type.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EqualsTypeClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return equals;
+        case 1: return type.get();
+        default: return nullptr;
+    }
+}
+
+void EqualsTypeClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: equals = child.token(); return;
+        case 1: type = &child.node()->as<DataTypeSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EqualsTypeClauseSyntax* EqualsTypeClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EqualsTypeClauseSyntax>(*this);
+}
+
+bool EqualsValueClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EqualsValueClause;
+}
+
+TokenOrSyntax EqualsValueClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return equals;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EqualsValueClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return equals;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void EqualsValueClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: equals = child.token(); return;
+        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EqualsValueClauseSyntax* EqualsValueClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EqualsValueClauseSyntax>(*this);
+}
+
+bool EventControlSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EventControl;
+}
+
+TokenOrSyntax EventControlSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return at;
+        case 1: return eventName.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EventControlSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return at;
+        case 1: return eventName.get();
+        default: return nullptr;
+    }
+}
+
+void EventControlSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: at = child.token(); return;
+        case 1: eventName = &child.node()->as<NameSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EventControlSyntax* EventControlSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EventControlSyntax>(*this);
+}
+
+bool EventControlWithExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EventControlWithExpression;
+}
+
+TokenOrSyntax EventControlWithExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return at;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EventControlWithExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return at;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void EventControlWithExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: at = child.token(); return;
+        case 1: expr = &child.node()->as<EventExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EventControlWithExpressionSyntax* EventControlWithExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EventControlWithExpressionSyntax>(*this);
+}
+
+bool EventExpressionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::BinaryEventExpression:
+        case SyntaxKind::ParenthesizedEventExpression:
+        case SyntaxKind::SignalEventExpression:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool EventTriggerStatementSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::BlockingEventTriggerStatement:
+        case SyntaxKind::NonblockingEventTriggerStatement:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax EventTriggerStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return trigger;
+        case 3: return timing;
+        case 4: return name.get();
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EventTriggerStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return trigger;
+        case 3: return timing;
+        case 4: return name.get();
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+void EventTriggerStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: trigger = child.token(); return;
+        case 3: timing = &child.node()->as<TimingControlSyntax>(); return;
+        case 4: name = &child.node()->as<NameSyntax>(); return;
+        case 5: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EventTriggerStatementSyntax* EventTriggerStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EventTriggerStatementSyntax>(*this);
+}
+
+bool ExplicitAnsiPortSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ExplicitAnsiPort;
+}
+
+TokenOrSyntax ExplicitAnsiPortSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return direction;
+        case 2: return dot;
+        case 3: return name;
+        case 4: return openParen;
+        case 5: return expr;
+        case 6: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ExplicitAnsiPortSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return direction;
+        case 2: return dot;
+        case 3: return name;
+        case 4: return openParen;
+        case 5: return expr;
+        case 6: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ExplicitAnsiPortSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: direction = child.token(); return;
+        case 2: dot = child.token(); return;
+        case 3: name = child.token(); return;
+        case 4: openParen = child.token(); return;
+        case 5: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 6: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ExplicitAnsiPortSyntax* ExplicitAnsiPortSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ExplicitAnsiPortSyntax>(*this);
+}
+
+bool ExplicitNonAnsiPortSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ExplicitNonAnsiPort;
+}
+
+TokenOrSyntax ExplicitNonAnsiPortSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return dot;
+        case 1: return name;
+        case 2: return openParen;
+        case 3: return expr;
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ExplicitNonAnsiPortSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return dot;
+        case 1: return name;
+        case 2: return openParen;
+        case 3: return expr;
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ExplicitNonAnsiPortSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: dot = child.token(); return;
+        case 1: name = child.token(); return;
+        case 2: openParen = child.token(); return;
+        case 3: expr = &child.node()->as<PortExpressionSyntax>(); return;
+        case 4: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ExplicitNonAnsiPortSyntax* ExplicitNonAnsiPortSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ExplicitNonAnsiPortSyntax>(*this);
+}
+
+bool ExpressionConstraintSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ExpressionConstraint;
+}
+
+TokenOrSyntax ExpressionConstraintSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return soft;
+        case 1: return expr.get();
+        case 2: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ExpressionConstraintSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return soft;
+        case 1: return expr.get();
+        case 2: return semi;
+        default: return nullptr;
+    }
+}
+
+void ExpressionConstraintSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: soft = child.token(); return;
+        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 2: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ExpressionConstraintSyntax* ExpressionConstraintSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ExpressionConstraintSyntax>(*this);
+}
+
+bool ExpressionCoverageBinInitializerSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ExpressionCoverageBinInitializer;
+}
+
+TokenOrSyntax ExpressionCoverageBinInitializerSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return withClause;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ExpressionCoverageBinInitializerSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return withClause;
+        default: return nullptr;
+    }
+}
+
+void ExpressionCoverageBinInitializerSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: withClause = &child.node()->as<WithClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ExpressionCoverageBinInitializerSyntax* ExpressionCoverageBinInitializerSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ExpressionCoverageBinInitializerSyntax>(*this);
+}
+
+bool ExpressionOrDistSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ExpressionOrDist;
+}
+
+TokenOrSyntax ExpressionOrDistSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return distribution.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ExpressionOrDistSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return distribution.get();
+        default: return nullptr;
+    }
+}
+
+void ExpressionOrDistSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: distribution = &child.node()->as<DistConstraintListSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ExpressionOrDistSyntax* ExpressionOrDistSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ExpressionOrDistSyntax>(*this);
+}
+
+bool ExpressionPatternSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ExpressionPattern;
+}
+
+TokenOrSyntax ExpressionPatternSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ExpressionPatternSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void ExpressionPatternSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ExpressionPatternSyntax* ExpressionPatternSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ExpressionPatternSyntax>(*this);
+}
+
+bool ExpressionStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ExpressionStatement;
+}
+
+TokenOrSyntax ExpressionStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return expr.get();
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ExpressionStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return expr.get();
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void ExpressionStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ExpressionStatementSyntax* ExpressionStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ExpressionStatementSyntax>(*this);
+}
+
+bool ExpressionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AcceptOnPropertyExpression:
+        case SyntaxKind::AddAssignmentExpression:
+        case SyntaxKind::AddExpression:
+        case SyntaxKind::AlwaysPropertyExpression:
+        case SyntaxKind::AndAssignmentExpression:
+        case SyntaxKind::AndSequenceExpression:
+        case SyntaxKind::ArithmeticLeftShiftAssignmentExpression:
+        case SyntaxKind::ArithmeticRightShiftAssignmentExpression:
+        case SyntaxKind::ArithmeticShiftLeftExpression:
+        case SyntaxKind::ArithmeticShiftRightExpression:
+        case SyntaxKind::ArrayAndMethod:
+        case SyntaxKind::ArrayOrMethod:
+        case SyntaxKind::ArrayOrRandomizeMethodExpression:
+        case SyntaxKind::ArrayUniqueMethod:
+        case SyntaxKind::ArrayXorMethod:
+        case SyntaxKind::AssignmentExpression:
+        case SyntaxKind::AssignmentPatternExpression:
+        case SyntaxKind::BadExpression:
+        case SyntaxKind::BinaryAndExpression:
+        case SyntaxKind::BinaryOrExpression:
+        case SyntaxKind::BinarySequenceDelayExpression:
+        case SyntaxKind::BinaryXnorExpression:
+        case SyntaxKind::BinaryXorExpression:
+        case SyntaxKind::BitType:
+        case SyntaxKind::ByteType:
+        case SyntaxKind::CHandleType:
+        case SyntaxKind::CaseEqualityExpression:
+        case SyntaxKind::CaseInequalityExpression:
+        case SyntaxKind::CastExpression:
+        case SyntaxKind::ClassName:
+        case SyntaxKind::ConcatenationExpression:
+        case SyntaxKind::ConditionalExpression:
+        case SyntaxKind::ConstructorName:
+        case SyntaxKind::CopyClassExpression:
+        case SyntaxKind::DefaultPatternKeyExpression:
+        case SyntaxKind::DivideAssignmentExpression:
+        case SyntaxKind::DivideExpression:
+        case SyntaxKind::ElementSelectExpression:
+        case SyntaxKind::EmptyIdentifierName:
+        case SyntaxKind::EmptyQueueExpression:
+        case SyntaxKind::EnumType:
+        case SyntaxKind::EqualityExpression:
+        case SyntaxKind::EventType:
+        case SyntaxKind::EventuallyPropertyExpression:
+        case SyntaxKind::ExpressionOrDist:
+        case SyntaxKind::GreaterThanEqualExpression:
+        case SyntaxKind::GreaterThanExpression:
+        case SyntaxKind::IdentifierName:
+        case SyntaxKind::IdentifierSelectName:
+        case SyntaxKind::IffPropertyExpression:
+        case SyntaxKind::ImplicitType:
+        case SyntaxKind::ImpliesPropertyExpression:
+        case SyntaxKind::InequalityExpression:
+        case SyntaxKind::InsideExpression:
+        case SyntaxKind::IntType:
+        case SyntaxKind::IntegerLiteralExpression:
+        case SyntaxKind::IntegerType:
+        case SyntaxKind::IntegerVectorExpression:
+        case SyntaxKind::IntersectSequenceExpression:
+        case SyntaxKind::InvocationExpression:
+        case SyntaxKind::LessThanEqualExpression:
+        case SyntaxKind::LessThanExpression:
+        case SyntaxKind::LocalScope:
+        case SyntaxKind::LogicType:
+        case SyntaxKind::LogicalAndExpression:
+        case SyntaxKind::LogicalEquivalenceExpression:
+        case SyntaxKind::LogicalImplicationExpression:
+        case SyntaxKind::LogicalLeftShiftAssignmentExpression:
+        case SyntaxKind::LogicalOrExpression:
+        case SyntaxKind::LogicalRightShiftAssignmentExpression:
+        case SyntaxKind::LogicalShiftLeftExpression:
+        case SyntaxKind::LogicalShiftRightExpression:
+        case SyntaxKind::LongIntType:
+        case SyntaxKind::MemberAccessExpression:
+        case SyntaxKind::MinTypMaxExpression:
+        case SyntaxKind::ModAssignmentExpression:
+        case SyntaxKind::ModExpression:
+        case SyntaxKind::MultipleConcatenationExpression:
+        case SyntaxKind::MultiplyAssignmentExpression:
+        case SyntaxKind::MultiplyExpression:
+        case SyntaxKind::NamedType:
+        case SyntaxKind::NewArrayExpression:
+        case SyntaxKind::NewClassExpression:
+        case SyntaxKind::NextTimePropertyExpression:
+        case SyntaxKind::NonOverlappedFollowedByPropertyExpression:
+        case SyntaxKind::NonOverlappedImplicationPropertyExpression:
+        case SyntaxKind::NonblockingAssignmentExpression:
+        case SyntaxKind::NullLiteralExpression:
+        case SyntaxKind::OneStepLiteralExpression:
+        case SyntaxKind::OpenRangeExpression:
+        case SyntaxKind::OrAssignmentExpression:
+        case SyntaxKind::OrSequenceExpression:
+        case SyntaxKind::OverlappedFollowedByPropertyExpression:
+        case SyntaxKind::OverlappedImplicationPropertyExpression:
+        case SyntaxKind::ParenthesizedExpression:
+        case SyntaxKind::PostdecrementExpression:
+        case SyntaxKind::PostincrementExpression:
+        case SyntaxKind::PowerExpression:
+        case SyntaxKind::PropertyType:
+        case SyntaxKind::RealLiteralExpression:
+        case SyntaxKind::RealTimeType:
+        case SyntaxKind::RealType:
+        case SyntaxKind::RegType:
+        case SyntaxKind::RejectOnPropertyExpression:
+        case SyntaxKind::RootScope:
+        case SyntaxKind::SAlwaysPropertyExpression:
+        case SyntaxKind::SEventuallyPropertyExpression:
+        case SyntaxKind::SNextTimePropertyExpression:
+        case SyntaxKind::SUntilPropertyExpression:
+        case SyntaxKind::SUntilWithPropertyExpression:
+        case SyntaxKind::ScopedName:
+        case SyntaxKind::SequenceType:
+        case SyntaxKind::ShortIntType:
+        case SyntaxKind::ShortRealType:
+        case SyntaxKind::SignedCastExpression:
+        case SyntaxKind::StreamingConcatenationExpression:
+        case SyntaxKind::StringLiteralExpression:
+        case SyntaxKind::StringType:
+        case SyntaxKind::StructType:
+        case SyntaxKind::SubtractAssignmentExpression:
+        case SyntaxKind::SubtractExpression:
+        case SyntaxKind::SuperHandle:
+        case SyntaxKind::SyncAcceptOnPropertyExpression:
+        case SyntaxKind::SyncRejectOnPropertyExpression:
+        case SyntaxKind::SystemName:
+        case SyntaxKind::TaggedUnionExpression:
+        case SyntaxKind::ThisHandle:
+        case SyntaxKind::ThroughoutSequenceExpression:
+        case SyntaxKind::TimeLiteralExpression:
+        case SyntaxKind::TimeType:
+        case SyntaxKind::TimingControlExpression:
+        case SyntaxKind::TimingControlExpressionConcatenation:
+        case SyntaxKind::TypeReference:
+        case SyntaxKind::UnaryBitwiseAndExpression:
+        case SyntaxKind::UnaryBitwiseNandExpression:
+        case SyntaxKind::UnaryBitwiseNorExpression:
+        case SyntaxKind::UnaryBitwiseNotExpression:
+        case SyntaxKind::UnaryBitwiseOrExpression:
+        case SyntaxKind::UnaryBitwiseXnorExpression:
+        case SyntaxKind::UnaryBitwiseXorExpression:
+        case SyntaxKind::UnaryLogicalNotExpression:
+        case SyntaxKind::UnaryMinusExpression:
+        case SyntaxKind::UnaryNotPropertyExpression:
+        case SyntaxKind::UnaryPlusExpression:
+        case SyntaxKind::UnaryPredecrementExpression:
+        case SyntaxKind::UnaryPreincrementExpression:
+        case SyntaxKind::UnarySequenceDelayExpression:
+        case SyntaxKind::UnarySequenceEventExpression:
+        case SyntaxKind::UnbasedUnsizedLiteralExpression:
+        case SyntaxKind::UnionType:
+        case SyntaxKind::UnitScope:
+        case SyntaxKind::UntilPropertyExpression:
+        case SyntaxKind::UntilWithPropertyExpression:
+        case SyntaxKind::Untyped:
+        case SyntaxKind::VirtualInterfaceType:
+        case SyntaxKind::VoidType:
+        case SyntaxKind::WildcardEqualityExpression:
+        case SyntaxKind::WildcardInequalityExpression:
+        case SyntaxKind::WildcardLiteralExpression:
+        case SyntaxKind::WithinSequenceExpression:
+        case SyntaxKind::XorAssignmentExpression:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool ExpressionTimingCheckArgSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ExpressionTimingCheckArg;
+}
+
+TokenOrSyntax ExpressionTimingCheckArgSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return condition;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ExpressionTimingCheckArgSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return condition;
+        default: return nullptr;
+    }
+}
+
+void ExpressionTimingCheckArgSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: condition = &child.node()->as<TimingCheckConditionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ExpressionTimingCheckArgSyntax* ExpressionTimingCheckArgSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ExpressionTimingCheckArgSyntax>(*this);
+}
+
+bool ExtendsClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ExtendsClause;
+}
+
+TokenOrSyntax ExtendsClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return baseName.get();
+        case 2: return arguments;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ExtendsClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return baseName.get();
+        case 2: return arguments;
+        default: return nullptr;
+    }
+}
+
+void ExtendsClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        case 1: baseName = &child.node()->as<NameSyntax>(); return;
+        case 2: arguments = &child.node()->as<ArgumentListSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ExtendsClauseSyntax* ExtendsClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ExtendsClauseSyntax>(*this);
+}
+
+bool ExternModuleSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ExternModule;
+}
+
+TokenOrSyntax ExternModuleSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return externKeyword;
+        case 1: return header.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ExternModuleSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return externKeyword;
+        case 1: return header.get();
+        default: return nullptr;
+    }
+}
+
+void ExternModuleSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: externKeyword = child.token(); return;
+        case 1: header = &child.node()->as<ModuleHeaderSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ExternModuleSyntax* ExternModuleSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ExternModuleSyntax>(*this);
+}
+
+bool ForLoopStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ForLoopStatement;
+}
+
+TokenOrSyntax ForLoopStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return forKeyword;
+        case 3: return openParen;
+        case 4: return &initializers;
+        case 5: return semi1;
+        case 6: return stopExpr.get();
+        case 7: return semi2;
+        case 8: return &steps;
+        case 9: return closeParen;
+        case 10: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ForLoopStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return forKeyword;
+        case 3: return openParen;
+        case 4: return &initializers;
+        case 5: return semi1;
+        case 6: return stopExpr.get();
+        case 7: return semi2;
+        case 8: return &steps;
+        case 9: return closeParen;
+        case 10: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void ForLoopStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: forKeyword = child.token(); return;
+        case 3: openParen = child.token(); return;
+        case 4: initializers = child.node()->as<SeparatedSyntaxList<SyntaxNode>>(); return;
+        case 5: semi1 = child.token(); return;
+        case 6: stopExpr = &child.node()->as<ExpressionSyntax>(); return;
+        case 7: semi2 = child.token(); return;
+        case 8: steps = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 9: closeParen = child.token(); return;
+        case 10: statement = &child.node()->as<StatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ForLoopStatementSyntax* ForLoopStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ForLoopStatementSyntax>(*this);
+}
+
+bool ForVariableDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ForVariableDeclaration;
+}
+
+TokenOrSyntax ForVariableDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return varKeyword;
+        case 1: return type;
+        case 2: return declarator.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ForVariableDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return varKeyword;
+        case 1: return type;
+        case 2: return declarator.get();
+        default: return nullptr;
+    }
+}
+
+void ForVariableDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: varKeyword = child.token(); return;
+        case 1: type = &child.node()->as<DataTypeSyntax>(); return;
+        case 2: declarator = &child.node()->as<DeclaratorSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ForVariableDeclarationSyntax* ForVariableDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ForVariableDeclarationSyntax>(*this);
+}
+
+bool ForeachLoopListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ForeachLoopList;
+}
+
+TokenOrSyntax ForeachLoopListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return arrayName.get();
+        case 2: return openBracket;
+        case 3: return &loopVariables;
+        case 4: return closeBracket;
+        case 5: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ForeachLoopListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return arrayName.get();
+        case 2: return openBracket;
+        case 3: return &loopVariables;
+        case 4: return closeBracket;
+        case 5: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ForeachLoopListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: arrayName = &child.node()->as<NameSyntax>(); return;
+        case 2: openBracket = child.token(); return;
+        case 3: loopVariables = child.node()->as<SeparatedSyntaxList<NameSyntax>>(); return;
+        case 4: closeBracket = child.token(); return;
+        case 5: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ForeachLoopListSyntax* ForeachLoopListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ForeachLoopListSyntax>(*this);
+}
+
+bool ForeachLoopStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ForeachLoopStatement;
+}
+
+TokenOrSyntax ForeachLoopStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return keyword;
+        case 3: return loopList.get();
+        case 4: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ForeachLoopStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return keyword;
+        case 3: return loopList.get();
+        case 4: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void ForeachLoopStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: keyword = child.token(); return;
+        case 3: loopList = &child.node()->as<ForeachLoopListSyntax>(); return;
+        case 4: statement = &child.node()->as<StatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ForeachLoopStatementSyntax* ForeachLoopStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ForeachLoopStatementSyntax>(*this);
+}
+
+bool ForeverStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ForeverStatement;
+}
+
+TokenOrSyntax ForeverStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return foreverKeyword;
+        case 3: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ForeverStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return foreverKeyword;
+        case 3: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void ForeverStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: foreverKeyword = child.token(); return;
+        case 3: statement = &child.node()->as<StatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ForeverStatementSyntax* ForeverStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ForeverStatementSyntax>(*this);
+}
+
+bool ForwardInterfaceClassTypedefDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ForwardInterfaceClassTypedefDeclaration;
+}
+
+TokenOrSyntax ForwardInterfaceClassTypedefDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return typedefKeyword;
+        case 2: return interfaceKeyword;
+        case 3: return classKeyword;
+        case 4: return name;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ForwardInterfaceClassTypedefDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return typedefKeyword;
+        case 2: return interfaceKeyword;
+        case 3: return classKeyword;
+        case 4: return name;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+void ForwardInterfaceClassTypedefDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: typedefKeyword = child.token(); return;
+        case 2: interfaceKeyword = child.token(); return;
+        case 3: classKeyword = child.token(); return;
+        case 4: name = child.token(); return;
+        case 5: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ForwardInterfaceClassTypedefDeclarationSyntax* ForwardInterfaceClassTypedefDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ForwardInterfaceClassTypedefDeclarationSyntax>(*this);
+}
+
+bool ForwardTypedefDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ForwardTypedefDeclaration;
+}
+
+TokenOrSyntax ForwardTypedefDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return typedefKeyword;
+        case 2: return keyword;
+        case 3: return name;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ForwardTypedefDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return typedefKeyword;
+        case 2: return keyword;
+        case 3: return name;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void ForwardTypedefDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: typedefKeyword = child.token(); return;
+        case 2: keyword = child.token(); return;
+        case 3: name = child.token(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ForwardTypedefDeclarationSyntax* ForwardTypedefDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ForwardTypedefDeclarationSyntax>(*this);
+}
+
+bool FunctionDeclarationSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::FunctionDeclaration:
+        case SyntaxKind::TaskDeclaration:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax FunctionDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return prototype.get();
+        case 2: return semi;
+        case 3: return &items;
+        case 4: return end;
+        case 5: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax FunctionDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return prototype.get();
+        case 2: return semi;
+        case 3: return &items;
+        case 4: return end;
+        case 5: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+void FunctionDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: prototype = &child.node()->as<FunctionPrototypeSyntax>(); return;
+        case 2: semi = child.token(); return;
+        case 3: items = child.node()->as<SyntaxList<SyntaxNode>>(); return;
+        case 4: end = child.token(); return;
+        case 5: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+FunctionDeclarationSyntax* FunctionDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<FunctionDeclarationSyntax>(*this);
+}
+
+bool FunctionPortListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::FunctionPortList;
+}
+
+TokenOrSyntax FunctionPortListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ports;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax FunctionPortListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ports;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void FunctionPortListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: ports = child.node()->as<SeparatedSyntaxList<FunctionPortSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+FunctionPortListSyntax* FunctionPortListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<FunctionPortListSyntax>(*this);
+}
+
+bool FunctionPortSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::FunctionPort;
+}
+
+TokenOrSyntax FunctionPortSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return constKeyword;
+        case 2: return direction;
+        case 3: return varKeyword;
+        case 4: return dataType;
+        case 5: return declarator.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax FunctionPortSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return constKeyword;
+        case 2: return direction;
+        case 3: return varKeyword;
+        case 4: return dataType;
+        case 5: return declarator.get();
+        default: return nullptr;
+    }
+}
+
+void FunctionPortSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: constKeyword = child.token(); return;
+        case 2: direction = child.token(); return;
+        case 3: varKeyword = child.token(); return;
+        case 4: dataType = &child.node()->as<DataTypeSyntax>(); return;
+        case 5: declarator = &child.node()->as<DeclaratorSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+FunctionPortSyntax* FunctionPortSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<FunctionPortSyntax>(*this);
+}
+
+bool FunctionPrototypeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::FunctionPrototype;
+}
+
+TokenOrSyntax FunctionPrototypeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return lifetime;
+        case 2: return returnType.get();
+        case 3: return name.get();
+        case 4: return portList;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax FunctionPrototypeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return lifetime;
+        case 2: return returnType.get();
+        case 3: return name.get();
+        case 4: return portList;
+        default: return nullptr;
+    }
+}
+
+void FunctionPrototypeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        case 1: lifetime = child.token(); return;
+        case 2: returnType = &child.node()->as<DataTypeSyntax>(); return;
+        case 3: name = &child.node()->as<NameSyntax>(); return;
+        case 4: portList = &child.node()->as<FunctionPortListSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+FunctionPrototypeSyntax* FunctionPrototypeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<FunctionPrototypeSyntax>(*this);
+}
+
+bool GateInstanceNameSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::GateInstanceName;
+}
+
+TokenOrSyntax GateInstanceNameSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return &dimensions;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax GateInstanceNameSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return &dimensions;
+        default: return nullptr;
+    }
+}
+
+void GateInstanceNameSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+GateInstanceNameSyntax* GateInstanceNameSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<GateInstanceNameSyntax>(*this);
+}
+
+bool GateInstanceSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::GateInstance;
+}
+
+TokenOrSyntax GateInstanceSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return decl;
+        case 1: return openParen;
+        case 2: return &connections;
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax GateInstanceSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return decl;
+        case 1: return openParen;
+        case 2: return &connections;
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void GateInstanceSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: decl = &child.node()->as<GateInstanceNameSyntax>(); return;
+        case 1: openParen = child.token(); return;
+        case 2: connections = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 3: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+GateInstanceSyntax* GateInstanceSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<GateInstanceSyntax>(*this);
+}
+
+bool GateInstantiationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::GateInstantiation;
+}
+
+TokenOrSyntax GateInstantiationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return gateType;
+        case 2: return strength;
+        case 3: return delay;
+        case 4: return &instances;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax GateInstantiationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return gateType;
+        case 2: return strength;
+        case 3: return delay;
+        case 4: return &instances;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+void GateInstantiationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: gateType = child.token(); return;
+        case 2: strength = &child.node()->as<DriveStrengthSyntax>(); return;
+        case 3: delay = &child.node()->as<TimingControlSyntax>(); return;
+        case 4: instances = child.node()->as<SeparatedSyntaxList<GateInstanceSyntax>>(); return;
+        case 5: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+GateInstantiationSyntax* GateInstantiationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<GateInstantiationSyntax>(*this);
+}
+
+bool GenerateBlockSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::GenerateBlock;
+}
+
+TokenOrSyntax GenerateBlockSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return label;
+        case 2: return begin;
+        case 3: return beginName;
+        case 4: return &members;
+        case 5: return end;
+        case 6: return endName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax GenerateBlockSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return label;
+        case 2: return begin;
+        case 3: return beginName;
+        case 4: return &members;
+        case 5: return end;
+        case 6: return endName;
+        default: return nullptr;
+    }
+}
+
+void GenerateBlockSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 2: begin = child.token(); return;
+        case 3: beginName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        case 4: members = child.node()->as<SyntaxList<MemberSyntax>>(); return;
+        case 5: end = child.token(); return;
+        case 6: endName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+GenerateBlockSyntax* GenerateBlockSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<GenerateBlockSyntax>(*this);
+}
+
+bool GenerateRegionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::GenerateRegion;
+}
+
+TokenOrSyntax GenerateRegionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return &members;
+        case 3: return endgenerate;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax GenerateRegionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return &members;
+        case 3: return endgenerate;
+        default: return nullptr;
+    }
+}
+
+void GenerateRegionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: members = child.node()->as<SyntaxList<MemberSyntax>>(); return;
+        case 3: endgenerate = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+GenerateRegionSyntax* GenerateRegionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<GenerateRegionSyntax>(*this);
+}
+
+bool GenvarDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::GenvarDeclaration;
+}
+
+TokenOrSyntax GenvarDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return &identifiers;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax GenvarDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return &identifiers;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void GenvarDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: identifiers = child.node()->as<SeparatedSyntaxList<IdentifierNameSyntax>>(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+GenvarDeclarationSyntax* GenvarDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<GenvarDeclarationSyntax>(*this);
+}
+
+bool HierarchicalInstanceSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::HierarchicalInstance;
+}
+
+TokenOrSyntax HierarchicalInstanceSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return &dimensions;
+        case 2: return openParen;
+        case 3: return &connections;
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax HierarchicalInstanceSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return &dimensions;
+        case 2: return openParen;
+        case 3: return &connections;
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void HierarchicalInstanceSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
+        case 2: openParen = child.token(); return;
+        case 3: connections = child.node()->as<SeparatedSyntaxList<PortConnectionSyntax>>(); return;
+        case 4: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+HierarchicalInstanceSyntax* HierarchicalInstanceSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<HierarchicalInstanceSyntax>(*this);
+}
+
+bool HierarchyInstantiationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::HierarchyInstantiation;
+}
+
+TokenOrSyntax HierarchyInstantiationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return type;
+        case 2: return parameters;
+        case 3: return &instances;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax HierarchyInstantiationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return type;
+        case 2: return parameters;
+        case 3: return &instances;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void HierarchyInstantiationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: type = child.token(); return;
+        case 2: parameters = &child.node()->as<ParameterValueAssignmentSyntax>(); return;
+        case 3: instances = child.node()->as<SeparatedSyntaxList<HierarchicalInstanceSyntax>>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+HierarchyInstantiationSyntax* HierarchyInstantiationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<HierarchyInstantiationSyntax>(*this);
+}
+
+bool IdentifierNameSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::IdentifierName;
+}
+
+TokenOrSyntax IdentifierNameSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return identifier;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax IdentifierNameSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return identifier;
+        default: return nullptr;
+    }
+}
+
+void IdentifierNameSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: identifier = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+IdentifierNameSyntax* IdentifierNameSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<IdentifierNameSyntax>(*this);
+}
+
+bool IdentifierSelectNameSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::IdentifierSelectName;
+}
+
+TokenOrSyntax IdentifierSelectNameSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return identifier;
+        case 1: return &selectors;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax IdentifierSelectNameSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return identifier;
+        case 1: return &selectors;
+        default: return nullptr;
+    }
+}
+
+void IdentifierSelectNameSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: identifier = child.token(); return;
+        case 1: selectors = child.node()->as<SyntaxList<ElementSelectSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+IdentifierSelectNameSyntax* IdentifierSelectNameSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<IdentifierSelectNameSyntax>(*this);
+}
+
+bool IfGenerateSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::IfGenerate;
+}
+
+TokenOrSyntax IfGenerateSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return openParen;
+        case 3: return condition.get();
+        case 4: return closeParen;
+        case 5: return block.get();
+        case 6: return elseClause;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax IfGenerateSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return openParen;
+        case 3: return condition.get();
+        case 4: return closeParen;
+        case 5: return block.get();
+        case 6: return elseClause;
+        default: return nullptr;
+    }
+}
+
+void IfGenerateSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: openParen = child.token(); return;
+        case 3: condition = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: closeParen = child.token(); return;
+        case 5: block = &child.node()->as<MemberSyntax>(); return;
+        case 6: elseClause = &child.node()->as<ElseClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+IfGenerateSyntax* IfGenerateSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<IfGenerateSyntax>(*this);
+}
+
+bool IfNonePathDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::IfNonePathDeclaration;
+}
+
+TokenOrSyntax IfNonePathDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return path.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax IfNonePathDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return path.get();
+        default: return nullptr;
+    }
+}
+
+void IfNonePathDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: path = &child.node()->as<PathDeclarationSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+IfNonePathDeclarationSyntax* IfNonePathDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<IfNonePathDeclarationSyntax>(*this);
+}
+
+bool IffEventClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::IffEventClause;
+}
+
+TokenOrSyntax IffEventClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return iff;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax IffEventClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return iff;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void IffEventClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: iff = child.token(); return;
+        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+IffEventClauseSyntax* IffEventClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<IffEventClauseSyntax>(*this);
+}
+
+bool ImmediateAssertionMemberSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ImmediateAssertionMember;
+}
+
+TokenOrSyntax ImmediateAssertionMemberSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ImmediateAssertionMemberSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void ImmediateAssertionMemberSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: statement = &child.node()->as<ImmediateAssertionStatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ImmediateAssertionMemberSyntax* ImmediateAssertionMemberSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ImmediateAssertionMemberSyntax>(*this);
+}
+
+bool ImmediateAssertionStatementSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ImmediateAssertStatement:
+        case SyntaxKind::ImmediateAssumeStatement:
+        case SyntaxKind::ImmediateCoverStatement:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax ImmediateAssertionStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return keyword;
+        case 3: return delay;
+        case 4: return expr.get();
+        case 5: return action.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ImmediateAssertionStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return keyword;
+        case 3: return delay;
+        case 4: return expr.get();
+        case 5: return action.get();
+        default: return nullptr;
+    }
+}
+
+void ImmediateAssertionStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: keyword = child.token(); return;
+        case 3: delay = &child.node()->as<DeferredAssertionSyntax>(); return;
+        case 4: expr = &child.node()->as<ParenthesizedExpressionSyntax>(); return;
+        case 5: action = &child.node()->as<ActionBlockSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ImmediateAssertionStatementSyntax* ImmediateAssertionStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ImmediateAssertionStatementSyntax>(*this);
+}
+
+bool ImplementsClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ImplementsClause;
+}
+
+TokenOrSyntax ImplementsClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return &interfaces;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ImplementsClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return &interfaces;
+        default: return nullptr;
+    }
+}
+
+void ImplementsClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        case 1: interfaces = child.node()->as<SeparatedSyntaxList<NameSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ImplementsClauseSyntax* ImplementsClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ImplementsClauseSyntax>(*this);
+}
+
+bool ImplicationConstraintSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ImplicationConstraint;
+}
+
+TokenOrSyntax ImplicationConstraintSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return arrow;
+        case 2: return constraints.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ImplicationConstraintSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return arrow;
+        case 2: return constraints.get();
+        default: return nullptr;
+    }
+}
+
+void ImplicationConstraintSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: arrow = child.token(); return;
+        case 2: constraints = &child.node()->as<ConstraintItemSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ImplicationConstraintSyntax* ImplicationConstraintSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ImplicationConstraintSyntax>(*this);
+}
+
+bool ImplicitAnsiPortSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ImplicitAnsiPort;
+}
+
+TokenOrSyntax ImplicitAnsiPortSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return header.get();
+        case 2: return declarator.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ImplicitAnsiPortSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return header.get();
+        case 2: return declarator.get();
+        default: return nullptr;
+    }
+}
+
+void ImplicitAnsiPortSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: header = &child.node()->as<PortHeaderSyntax>(); return;
+        case 2: declarator = &child.node()->as<DeclaratorSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ImplicitAnsiPortSyntax* ImplicitAnsiPortSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ImplicitAnsiPortSyntax>(*this);
+}
+
+bool ImplicitEventControlSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ImplicitEventControl;
+}
+
+TokenOrSyntax ImplicitEventControlSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return at;
+        case 1: return openParen;
+        case 2: return star;
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ImplicitEventControlSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return at;
+        case 1: return openParen;
+        case 2: return star;
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ImplicitEventControlSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: at = child.token(); return;
+        case 1: openParen = child.token(); return;
+        case 2: star = child.token(); return;
+        case 3: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ImplicitEventControlSyntax* ImplicitEventControlSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ImplicitEventControlSyntax>(*this);
+}
+
+bool ImplicitNonAnsiPortSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ImplicitNonAnsiPort;
+}
+
+TokenOrSyntax ImplicitNonAnsiPortSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ImplicitNonAnsiPortSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr;
+        default: return nullptr;
+    }
+}
+
+void ImplicitNonAnsiPortSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<PortExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ImplicitNonAnsiPortSyntax* ImplicitNonAnsiPortSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ImplicitNonAnsiPortSyntax>(*this);
+}
+
+bool ImplicitTypeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ImplicitType;
+}
+
+TokenOrSyntax ImplicitTypeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return signing;
+        case 1: return &dimensions;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ImplicitTypeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return signing;
+        case 1: return &dimensions;
+        default: return nullptr;
+    }
+}
+
+void ImplicitTypeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: signing = child.token(); return;
+        case 1: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ImplicitTypeSyntax* ImplicitTypeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ImplicitTypeSyntax>(*this);
+}
+
+bool IncludeDirectiveSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::IncludeDirective;
+}
+
+TokenOrSyntax IncludeDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return fileName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax IncludeDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return fileName;
+        default: return nullptr;
+    }
+}
+
+void IncludeDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: fileName = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+IncludeDirectiveSyntax* IncludeDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<IncludeDirectiveSyntax>(*this);
+}
+
+bool InsideExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::InsideExpression;
+}
+
+TokenOrSyntax InsideExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return inside;
+        case 2: return ranges.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax InsideExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return inside;
+        case 2: return ranges.get();
+        default: return nullptr;
+    }
+}
+
+void InsideExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: inside = child.token(); return;
+        case 2: ranges = &child.node()->as<OpenRangeListSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+InsideExpressionSyntax* InsideExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<InsideExpressionSyntax>(*this);
+}
+
+bool IntegerTypeSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::BitType:
+        case SyntaxKind::ByteType:
+        case SyntaxKind::IntType:
+        case SyntaxKind::IntegerType:
+        case SyntaxKind::LogicType:
+        case SyntaxKind::LongIntType:
+        case SyntaxKind::RegType:
+        case SyntaxKind::ShortIntType:
+        case SyntaxKind::TimeType:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax IntegerTypeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return signing;
+        case 2: return &dimensions;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax IntegerTypeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return signing;
+        case 2: return &dimensions;
+        default: return nullptr;
+    }
+}
+
+void IntegerTypeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        case 1: signing = child.token(); return;
+        case 2: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+IntegerTypeSyntax* IntegerTypeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<IntegerTypeSyntax>(*this);
+}
+
+bool IntegerVectorExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::IntegerVectorExpression;
+}
+
+TokenOrSyntax IntegerVectorExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return size;
+        case 1: return base;
+        case 2: return value;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax IntegerVectorExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return size;
+        case 1: return base;
+        case 2: return value;
+        default: return nullptr;
+    }
+}
+
+void IntegerVectorExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: size = child.token(); return;
+        case 1: base = child.token(); return;
+        case 2: value = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+IntegerVectorExpressionSyntax* IntegerVectorExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<IntegerVectorExpressionSyntax>(*this);
+}
+
+bool InterconnectPortHeaderSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::InterconnectPortHeader;
+}
+
+TokenOrSyntax InterconnectPortHeaderSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return direction;
+        case 1: return interconnect;
+        case 2: return type.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax InterconnectPortHeaderSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return direction;
+        case 1: return interconnect;
+        case 2: return type.get();
+        default: return nullptr;
+    }
+}
+
+void InterconnectPortHeaderSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: direction = child.token(); return;
+        case 1: interconnect = child.token(); return;
+        case 2: type = &child.node()->as<ImplicitTypeSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+InterconnectPortHeaderSyntax* InterconnectPortHeaderSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<InterconnectPortHeaderSyntax>(*this);
+}
+
+bool InterfacePortHeaderSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::InterfacePortHeader;
+}
+
+TokenOrSyntax InterfacePortHeaderSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return nameOrKeyword;
+        case 1: return modport;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax InterfacePortHeaderSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return nameOrKeyword;
+        case 1: return modport;
+        default: return nullptr;
+    }
+}
+
+void InterfacePortHeaderSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: nameOrKeyword = child.token(); return;
+        case 1: modport = &child.node()->as<DotMemberClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+InterfacePortHeaderSyntax* InterfacePortHeaderSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<InterfacePortHeaderSyntax>(*this);
+}
+
+bool InvocationExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::InvocationExpression;
+}
+
+TokenOrSyntax InvocationExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return &attributes;
+        case 2: return arguments;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax InvocationExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return &attributes;
+        case 2: return arguments;
+        default: return nullptr;
+    }
+}
+
+void InvocationExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: arguments = &child.node()->as<ArgumentListSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+InvocationExpressionSyntax* InvocationExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<InvocationExpressionSyntax>(*this);
+}
+
+bool JumpStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::JumpStatement;
+}
+
+TokenOrSyntax JumpStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return breakOrContinue;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax JumpStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return breakOrContinue;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void JumpStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: breakOrContinue = child.token(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+JumpStatementSyntax* JumpStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<JumpStatementSyntax>(*this);
+}
+
+bool KeywordNameSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ArrayAndMethod:
+        case SyntaxKind::ArrayOrMethod:
+        case SyntaxKind::ArrayUniqueMethod:
+        case SyntaxKind::ArrayXorMethod:
+        case SyntaxKind::ConstructorName:
+        case SyntaxKind::LocalScope:
+        case SyntaxKind::RootScope:
+        case SyntaxKind::SuperHandle:
+        case SyntaxKind::ThisHandle:
+        case SyntaxKind::UnitScope:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax KeywordNameSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax KeywordNameSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        default: return nullptr;
+    }
+}
+
+void KeywordNameSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+KeywordNameSyntax* KeywordNameSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<KeywordNameSyntax>(*this);
+}
+
+bool KeywordTypeSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::CHandleType:
+        case SyntaxKind::EventType:
+        case SyntaxKind::PropertyType:
+        case SyntaxKind::RealTimeType:
+        case SyntaxKind::RealType:
+        case SyntaxKind::SequenceType:
+        case SyntaxKind::ShortRealType:
+        case SyntaxKind::StringType:
+        case SyntaxKind::Untyped:
+        case SyntaxKind::VoidType:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax KeywordTypeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax KeywordTypeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        default: return nullptr;
+    }
+}
+
+void KeywordTypeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+KeywordTypeSyntax* KeywordTypeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<KeywordTypeSyntax>(*this);
+}
+
+bool LetDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::LetDeclaration;
+}
+
+TokenOrSyntax LetDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return let;
+        case 2: return identifier;
+        case 3: return portList;
+        case 4: return initializer.get();
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax LetDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return let;
+        case 2: return identifier;
+        case 3: return portList;
+        case 4: return initializer.get();
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+void LetDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: let = child.token(); return;
+        case 2: identifier = child.token(); return;
+        case 3: portList = &child.node()->as<AssertionItemPortListSyntax>(); return;
+        case 4: initializer = &child.node()->as<EqualsValueClauseSyntax>(); return;
+        case 5: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+LetDeclarationSyntax* LetDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<LetDeclarationSyntax>(*this);
+}
+
+bool LineDirectiveSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::LineDirective;
+}
+
+TokenOrSyntax LineDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return lineNumber;
+        case 2: return fileName;
+        case 3: return level;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax LineDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return lineNumber;
+        case 2: return fileName;
+        case 3: return level;
+        default: return nullptr;
+    }
+}
+
+void LineDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: lineNumber = child.token(); return;
+        case 2: fileName = child.token(); return;
+        case 3: level = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+LineDirectiveSyntax* LineDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<LineDirectiveSyntax>(*this);
+}
+
+bool LiteralExpressionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::DefaultPatternKeyExpression:
+        case SyntaxKind::IntegerLiteralExpression:
+        case SyntaxKind::NullLiteralExpression:
+        case SyntaxKind::OneStepLiteralExpression:
+        case SyntaxKind::RealLiteralExpression:
+        case SyntaxKind::StringLiteralExpression:
+        case SyntaxKind::TimeLiteralExpression:
+        case SyntaxKind::UnbasedUnsizedLiteralExpression:
+        case SyntaxKind::WildcardLiteralExpression:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax LiteralExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return literal;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax LiteralExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return literal;
+        default: return nullptr;
+    }
+}
+
+void LiteralExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: literal = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+LiteralExpressionSyntax* LiteralExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<LiteralExpressionSyntax>(*this);
+}
+
+bool LoopConstraintSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::LoopConstraint;
+}
+
+TokenOrSyntax LoopConstraintSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return foreachKeyword;
+        case 1: return loopList.get();
+        case 2: return constraints.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax LoopConstraintSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return foreachKeyword;
+        case 1: return loopList.get();
+        case 2: return constraints.get();
+        default: return nullptr;
+    }
+}
+
+void LoopConstraintSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: foreachKeyword = child.token(); return;
+        case 1: loopList = &child.node()->as<ForeachLoopListSyntax>(); return;
+        case 2: constraints = &child.node()->as<ConstraintItemSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+LoopConstraintSyntax* LoopConstraintSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<LoopConstraintSyntax>(*this);
+}
+
+bool LoopGenerateSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::LoopGenerate;
+}
+
+TokenOrSyntax LoopGenerateSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return openParen;
+        case 3: return genvar;
+        case 4: return identifier;
+        case 5: return equals;
+        case 6: return initialExpr.get();
+        case 7: return semi1;
+        case 8: return stopExpr.get();
+        case 9: return semi2;
+        case 10: return iterationExpr.get();
+        case 11: return closeParen;
+        case 12: return block.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax LoopGenerateSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return openParen;
+        case 3: return genvar;
+        case 4: return identifier;
+        case 5: return equals;
+        case 6: return initialExpr.get();
+        case 7: return semi1;
+        case 8: return stopExpr.get();
+        case 9: return semi2;
+        case 10: return iterationExpr.get();
+        case 11: return closeParen;
+        case 12: return block.get();
+        default: return nullptr;
+    }
+}
+
+void LoopGenerateSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: openParen = child.token(); return;
+        case 3: genvar = child.token(); return;
+        case 4: identifier = child.token(); return;
+        case 5: equals = child.token(); return;
+        case 6: initialExpr = &child.node()->as<ExpressionSyntax>(); return;
+        case 7: semi1 = child.token(); return;
+        case 8: stopExpr = &child.node()->as<ExpressionSyntax>(); return;
+        case 9: semi2 = child.token(); return;
+        case 10: iterationExpr = &child.node()->as<ExpressionSyntax>(); return;
+        case 11: closeParen = child.token(); return;
+        case 12: block = &child.node()->as<MemberSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+LoopGenerateSyntax* LoopGenerateSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<LoopGenerateSyntax>(*this);
+}
+
+bool LoopStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::LoopStatement;
+}
+
+TokenOrSyntax LoopStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return repeatOrWhile;
+        case 3: return openParen;
+        case 4: return expr.get();
+        case 5: return closeParen;
+        case 6: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax LoopStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return repeatOrWhile;
+        case 3: return openParen;
+        case 4: return expr.get();
+        case 5: return closeParen;
+        case 6: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void LoopStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: repeatOrWhile = child.token(); return;
+        case 3: openParen = child.token(); return;
+        case 4: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 5: closeParen = child.token(); return;
+        case 6: statement = &child.node()->as<StatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+LoopStatementSyntax* LoopStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<LoopStatementSyntax>(*this);
+}
+
+bool MacroActualArgumentListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::MacroActualArgumentList;
+}
+
+TokenOrSyntax MacroActualArgumentListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &args;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MacroActualArgumentListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &args;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void MacroActualArgumentListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: args = child.node()->as<SeparatedSyntaxList<MacroActualArgumentSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MacroActualArgumentListSyntax* MacroActualArgumentListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MacroActualArgumentListSyntax>(*this);
+}
+
+bool MacroActualArgumentSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::MacroActualArgument;
+}
+
+TokenOrSyntax MacroActualArgumentSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &tokens;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MacroActualArgumentSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &tokens;
+        default: return nullptr;
+    }
+}
+
+void MacroActualArgumentSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: tokens = child.node()->as<TokenList>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MacroActualArgumentSyntax* MacroActualArgumentSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MacroActualArgumentSyntax>(*this);
+}
+
+bool MacroArgumentDefaultSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::MacroArgumentDefault;
+}
+
+TokenOrSyntax MacroArgumentDefaultSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return equals;
+        case 1: return &tokens;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MacroArgumentDefaultSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return equals;
+        case 1: return &tokens;
+        default: return nullptr;
+    }
+}
+
+void MacroArgumentDefaultSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: equals = child.token(); return;
+        case 1: tokens = child.node()->as<TokenList>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MacroArgumentDefaultSyntax* MacroArgumentDefaultSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MacroArgumentDefaultSyntax>(*this);
+}
+
+bool MacroFormalArgumentListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::MacroFormalArgumentList;
+}
+
+TokenOrSyntax MacroFormalArgumentListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &args;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MacroFormalArgumentListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &args;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void MacroFormalArgumentListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: args = child.node()->as<SeparatedSyntaxList<MacroFormalArgumentSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MacroFormalArgumentListSyntax* MacroFormalArgumentListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MacroFormalArgumentListSyntax>(*this);
+}
+
+bool MacroFormalArgumentSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::MacroFormalArgument;
+}
+
+TokenOrSyntax MacroFormalArgumentSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return defaultValue;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MacroFormalArgumentSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return defaultValue;
+        default: return nullptr;
+    }
+}
+
+void MacroFormalArgumentSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: defaultValue = &child.node()->as<MacroArgumentDefaultSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MacroFormalArgumentSyntax* MacroFormalArgumentSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MacroFormalArgumentSyntax>(*this);
+}
+
+bool MacroUsageSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::MacroUsage;
+}
+
+TokenOrSyntax MacroUsageSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return args;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MacroUsageSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return args;
+        default: return nullptr;
+    }
+}
+
+void MacroUsageSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: args = &child.node()->as<MacroActualArgumentListSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MacroUsageSyntax* MacroUsageSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MacroUsageSyntax>(*this);
+}
+
+bool MatchesClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::MatchesClause;
+}
+
+TokenOrSyntax MatchesClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return matchesKeyword;
+        case 1: return pattern.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MatchesClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return matchesKeyword;
+        case 1: return pattern.get();
+        default: return nullptr;
+    }
+}
+
+void MatchesClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: matchesKeyword = child.token(); return;
+        case 1: pattern = &child.node()->as<PatternSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MatchesClauseSyntax* MatchesClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MatchesClauseSyntax>(*this);
+}
+
+bool MemberAccessExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::MemberAccessExpression;
+}
+
+TokenOrSyntax MemberAccessExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return dot;
+        case 2: return name;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MemberAccessExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return dot;
+        case 2: return name;
+        default: return nullptr;
+    }
+}
+
+void MemberAccessExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: dot = child.token(); return;
+        case 2: name = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MemberAccessExpressionSyntax* MemberAccessExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MemberAccessExpressionSyntax>(*this);
+}
+
+bool MemberSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AlwaysBlock:
+        case SyntaxKind::AlwaysCombBlock:
+        case SyntaxKind::AlwaysFFBlock:
+        case SyntaxKind::AlwaysLatchBlock:
+        case SyntaxKind::BindDirective:
+        case SyntaxKind::CaseGenerate:
+        case SyntaxKind::ClassDeclaration:
+        case SyntaxKind::ClassMethodDeclaration:
+        case SyntaxKind::ClassMethodPrototype:
+        case SyntaxKind::ClassPropertyDeclaration:
+        case SyntaxKind::ClockingDeclaration:
+        case SyntaxKind::ClockingItem:
+        case SyntaxKind::ConcurrentAssertionMember:
+        case SyntaxKind::ConditionalPathDeclaration:
+        case SyntaxKind::ConstraintDeclaration:
+        case SyntaxKind::ConstraintPrototype:
+        case SyntaxKind::ContinuousAssign:
+        case SyntaxKind::CoverageBins:
+        case SyntaxKind::CoverageOption:
+        case SyntaxKind::CovergroupDeclaration:
+        case SyntaxKind::Coverpoint:
+        case SyntaxKind::DPIExport:
+        case SyntaxKind::DPIImport:
+        case SyntaxKind::DataDeclaration:
+        case SyntaxKind::DefParam:
+        case SyntaxKind::DefaultClockingReference:
+        case SyntaxKind::DefaultSkewItem:
+        case SyntaxKind::ElabSystemTask:
+        case SyntaxKind::EmptyMember:
+        case SyntaxKind::ExplicitAnsiPort:
+        case SyntaxKind::FinalBlock:
+        case SyntaxKind::ForwardInterfaceClassTypedefDeclaration:
+        case SyntaxKind::ForwardTypedefDeclaration:
+        case SyntaxKind::FunctionDeclaration:
+        case SyntaxKind::GateInstantiation:
+        case SyntaxKind::GenerateBlock:
+        case SyntaxKind::GenerateRegion:
+        case SyntaxKind::GenvarDeclaration:
+        case SyntaxKind::HierarchyInstantiation:
+        case SyntaxKind::IfGenerate:
+        case SyntaxKind::IfNonePathDeclaration:
+        case SyntaxKind::ImmediateAssertionMember:
+        case SyntaxKind::ImplicitAnsiPort:
+        case SyntaxKind::InitialBlock:
+        case SyntaxKind::InterfaceDeclaration:
+        case SyntaxKind::LetDeclaration:
+        case SyntaxKind::LoopGenerate:
+        case SyntaxKind::ModportClockingPort:
+        case SyntaxKind::ModportDeclaration:
+        case SyntaxKind::ModportSimplePortList:
+        case SyntaxKind::ModportSubroutinePortList:
+        case SyntaxKind::ModuleDeclaration:
+        case SyntaxKind::NetDeclaration:
+        case SyntaxKind::NetTypeDeclaration:
+        case SyntaxKind::PackageDeclaration:
+        case SyntaxKind::PackageImportDeclaration:
+        case SyntaxKind::ParameterDeclarationStatement:
+        case SyntaxKind::PathDeclaration:
+        case SyntaxKind::PortDeclaration:
+        case SyntaxKind::ProgramDeclaration:
+        case SyntaxKind::PropertyDeclaration:
+        case SyntaxKind::PulseStyleDeclaration:
+        case SyntaxKind::SequenceDeclaration:
+        case SyntaxKind::SpecifyBlock:
+        case SyntaxKind::SpecparamDeclaration:
+        case SyntaxKind::SystemTimingCheck:
+        case SyntaxKind::TaskDeclaration:
+        case SyntaxKind::TimeUnitsDeclaration:
+        case SyntaxKind::TypedefDeclaration:
+        case SyntaxKind::UdpDeclaration:
+        case SyntaxKind::UserDefinedNetDeclaration:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax MemberSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MemberSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        default: return nullptr;
+    }
+}
+
+void MemberSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MemberSyntax* MemberSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MemberSyntax>(*this);
+}
+
+bool MinTypMaxExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::MinTypMaxExpression;
+}
+
+TokenOrSyntax MinTypMaxExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return min.get();
+        case 1: return colon1;
+        case 2: return typ.get();
+        case 3: return colon2;
+        case 4: return max.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MinTypMaxExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return min.get();
+        case 1: return colon1;
+        case 2: return typ.get();
+        case 3: return colon2;
+        case 4: return max.get();
+        default: return nullptr;
+    }
+}
+
+void MinTypMaxExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: min = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: colon1 = child.token(); return;
+        case 2: typ = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: colon2 = child.token(); return;
+        case 4: max = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MinTypMaxExpressionSyntax* MinTypMaxExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MinTypMaxExpressionSyntax>(*this);
+}
+
+bool ModportClockingPortSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ModportClockingPort;
+}
+
+TokenOrSyntax ModportClockingPortSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return clocking;
+        case 2: return name;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ModportClockingPortSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return clocking;
+        case 2: return name;
+        default: return nullptr;
+    }
+}
+
+void ModportClockingPortSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: clocking = child.token(); return;
+        case 2: name = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ModportClockingPortSyntax* ModportClockingPortSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ModportClockingPortSyntax>(*this);
+}
+
+bool ModportDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ModportDeclaration;
+}
+
+TokenOrSyntax ModportDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return &items;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ModportDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return &items;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void ModportDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: items = child.node()->as<SeparatedSyntaxList<ModportItemSyntax>>(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ModportDeclarationSyntax* ModportDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ModportDeclarationSyntax>(*this);
+}
+
+bool ModportExplicitPortSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ModportExplicitPort;
+}
+
+TokenOrSyntax ModportExplicitPortSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return dot;
+        case 1: return name;
+        case 2: return openParen;
+        case 3: return expr;
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ModportExplicitPortSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return dot;
+        case 1: return name;
+        case 2: return openParen;
+        case 3: return expr;
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ModportExplicitPortSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: dot = child.token(); return;
+        case 1: name = child.token(); return;
+        case 2: openParen = child.token(); return;
+        case 3: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ModportExplicitPortSyntax* ModportExplicitPortSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ModportExplicitPortSyntax>(*this);
+}
+
+bool ModportItemSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ModportItem;
+}
+
+TokenOrSyntax ModportItemSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return ports.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ModportItemSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return ports.get();
+        default: return nullptr;
+    }
+}
+
+void ModportItemSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: ports = &child.node()->as<AnsiPortListSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ModportItemSyntax* ModportItemSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ModportItemSyntax>(*this);
+}
+
+bool ModportNamedPortSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ModportNamedPort;
+}
+
+TokenOrSyntax ModportNamedPortSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ModportNamedPortSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        default: return nullptr;
+    }
+}
+
+void ModportNamedPortSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ModportNamedPortSyntax* ModportNamedPortSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ModportNamedPortSyntax>(*this);
+}
+
+bool ModportPortSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ModportExplicitPort:
+        case SyntaxKind::ModportNamedPort:
+        case SyntaxKind::ModportSubroutinePort:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool ModportSimplePortListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ModportSimplePortList;
+}
+
+TokenOrSyntax ModportSimplePortListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return direction;
+        case 2: return &ports;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ModportSimplePortListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return direction;
+        case 2: return &ports;
+        default: return nullptr;
+    }
+}
+
+void ModportSimplePortListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: direction = child.token(); return;
+        case 2: ports = child.node()->as<SeparatedSyntaxList<ModportPortSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ModportSimplePortListSyntax* ModportSimplePortListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ModportSimplePortListSyntax>(*this);
+}
+
+bool ModportSubroutinePortListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ModportSubroutinePortList;
+}
+
+TokenOrSyntax ModportSubroutinePortListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return importExport;
+        case 2: return &ports;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ModportSubroutinePortListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return importExport;
+        case 2: return &ports;
+        default: return nullptr;
+    }
+}
+
+void ModportSubroutinePortListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: importExport = child.token(); return;
+        case 2: ports = child.node()->as<SeparatedSyntaxList<ModportPortSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ModportSubroutinePortListSyntax* ModportSubroutinePortListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ModportSubroutinePortListSyntax>(*this);
+}
+
+bool ModportSubroutinePortSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ModportSubroutinePort;
+}
+
+TokenOrSyntax ModportSubroutinePortSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return prototype.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ModportSubroutinePortSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return prototype.get();
+        default: return nullptr;
+    }
+}
+
+void ModportSubroutinePortSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: prototype = &child.node()->as<FunctionPrototypeSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ModportSubroutinePortSyntax* ModportSubroutinePortSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ModportSubroutinePortSyntax>(*this);
+}
+
+bool ModuleDeclarationSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::InterfaceDeclaration:
+        case SyntaxKind::ModuleDeclaration:
+        case SyntaxKind::PackageDeclaration:
+        case SyntaxKind::ProgramDeclaration:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax ModuleDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return header.get();
+        case 2: return &members;
+        case 3: return endmodule;
+        case 4: return blockName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ModuleDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return header.get();
+        case 2: return &members;
+        case 3: return endmodule;
+        case 4: return blockName;
+        default: return nullptr;
+    }
+}
+
+void ModuleDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: header = &child.node()->as<ModuleHeaderSyntax>(); return;
+        case 2: members = child.node()->as<SyntaxList<MemberSyntax>>(); return;
+        case 3: endmodule = child.token(); return;
+        case 4: blockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ModuleDeclarationSyntax* ModuleDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ModuleDeclarationSyntax>(*this);
+}
+
+bool ModuleHeaderSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::InterfaceHeader:
+        case SyntaxKind::ModuleHeader:
+        case SyntaxKind::PackageHeader:
+        case SyntaxKind::ProgramHeader:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax ModuleHeaderSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return moduleKeyword;
+        case 1: return lifetime;
+        case 2: return name;
+        case 3: return &imports;
+        case 4: return parameters;
+        case 5: return ports;
+        case 6: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ModuleHeaderSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return moduleKeyword;
+        case 1: return lifetime;
+        case 2: return name;
+        case 3: return &imports;
+        case 4: return parameters;
+        case 5: return ports;
+        case 6: return semi;
+        default: return nullptr;
+    }
+}
+
+void ModuleHeaderSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: moduleKeyword = child.token(); return;
+        case 1: lifetime = child.token(); return;
+        case 2: name = child.token(); return;
+        case 3: imports = child.node()->as<SyntaxList<PackageImportDeclarationSyntax>>(); return;
+        case 4: parameters = &child.node()->as<ParameterPortListSyntax>(); return;
+        case 5: ports = &child.node()->as<PortListSyntax>(); return;
+        case 6: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ModuleHeaderSyntax* ModuleHeaderSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ModuleHeaderSyntax>(*this);
+}
+
+bool MultipleConcatenationExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::MultipleConcatenationExpression;
+}
+
+TokenOrSyntax MultipleConcatenationExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return expression.get();
+        case 2: return concatenation.get();
+        case 3: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MultipleConcatenationExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return expression.get();
+        case 2: return concatenation.get();
+        case 3: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void MultipleConcatenationExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: expression = &child.node()->as<ExpressionSyntax>(); return;
+        case 2: concatenation = &child.node()->as<ConcatenationExpressionSyntax>(); return;
+        case 3: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MultipleConcatenationExpressionSyntax* MultipleConcatenationExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MultipleConcatenationExpressionSyntax>(*this);
+}
+
+bool NameSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ArrayAndMethod:
+        case SyntaxKind::ArrayOrMethod:
+        case SyntaxKind::ArrayUniqueMethod:
+        case SyntaxKind::ArrayXorMethod:
+        case SyntaxKind::ClassName:
+        case SyntaxKind::ConstructorName:
+        case SyntaxKind::EmptyIdentifierName:
+        case SyntaxKind::IdentifierName:
+        case SyntaxKind::IdentifierSelectName:
+        case SyntaxKind::LocalScope:
+        case SyntaxKind::RootScope:
+        case SyntaxKind::ScopedName:
+        case SyntaxKind::SuperHandle:
+        case SyntaxKind::SystemName:
+        case SyntaxKind::ThisHandle:
+        case SyntaxKind::UnitScope:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool NameValuePragmaExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NameValuePragmaExpression;
+}
+
+TokenOrSyntax NameValuePragmaExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return equals;
+        case 2: return value.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NameValuePragmaExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return equals;
+        case 2: return value.get();
+        default: return nullptr;
+    }
+}
+
+void NameValuePragmaExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: equals = child.token(); return;
+        case 2: value = &child.node()->as<PragmaExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NameValuePragmaExpressionSyntax* NameValuePragmaExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NameValuePragmaExpressionSyntax>(*this);
+}
+
+bool NamedArgumentSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NamedArgument;
+}
+
+TokenOrSyntax NamedArgumentSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return dot;
+        case 1: return name;
+        case 2: return openParen;
+        case 3: return expr;
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NamedArgumentSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return dot;
+        case 1: return name;
+        case 2: return openParen;
+        case 3: return expr;
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void NamedArgumentSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: dot = child.token(); return;
+        case 1: name = child.token(); return;
+        case 2: openParen = child.token(); return;
+        case 3: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NamedArgumentSyntax* NamedArgumentSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NamedArgumentSyntax>(*this);
+}
+
+bool NamedBlockClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NamedBlockClause;
+}
+
+TokenOrSyntax NamedBlockClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return colon;
+        case 1: return name;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NamedBlockClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return colon;
+        case 1: return name;
+        default: return nullptr;
+    }
+}
+
+void NamedBlockClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: colon = child.token(); return;
+        case 1: name = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NamedBlockClauseSyntax* NamedBlockClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NamedBlockClauseSyntax>(*this);
+}
+
+bool NamedLabelSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NamedLabel;
+}
+
+TokenOrSyntax NamedLabelSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return colon;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NamedLabelSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return colon;
+        default: return nullptr;
+    }
+}
+
+void NamedLabelSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: colon = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NamedLabelSyntax* NamedLabelSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NamedLabelSyntax>(*this);
+}
+
+bool NamedPortConnectionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NamedPortConnection;
+}
+
+TokenOrSyntax NamedPortConnectionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return dot;
+        case 2: return name;
+        case 3: return openParen;
+        case 4: return expr;
+        case 5: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NamedPortConnectionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return dot;
+        case 2: return name;
+        case 3: return openParen;
+        case 4: return expr;
+        case 5: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void NamedPortConnectionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: dot = child.token(); return;
+        case 2: name = child.token(); return;
+        case 3: openParen = child.token(); return;
+        case 4: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 5: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NamedPortConnectionSyntax* NamedPortConnectionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NamedPortConnectionSyntax>(*this);
+}
+
+bool NamedStructurePatternMemberSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NamedStructurePatternMember;
+}
+
+TokenOrSyntax NamedStructurePatternMemberSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return colon;
+        case 2: return pattern.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NamedStructurePatternMemberSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return colon;
+        case 2: return pattern.get();
+        default: return nullptr;
+    }
+}
+
+void NamedStructurePatternMemberSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: colon = child.token(); return;
+        case 2: pattern = &child.node()->as<PatternSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NamedStructurePatternMemberSyntax* NamedStructurePatternMemberSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NamedStructurePatternMemberSyntax>(*this);
+}
+
+bool NamedTypeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NamedType;
+}
+
+TokenOrSyntax NamedTypeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NamedTypeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name.get();
+        default: return nullptr;
+    }
+}
+
+void NamedTypeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = &child.node()->as<NameSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NamedTypeSyntax* NamedTypeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NamedTypeSyntax>(*this);
+}
+
+bool NetDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NetDeclaration;
+}
+
+TokenOrSyntax NetDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return netType;
+        case 2: return strength;
+        case 3: return expansionHint;
+        case 4: return type.get();
+        case 5: return delay;
+        case 6: return &declarators;
+        case 7: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NetDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return netType;
+        case 2: return strength;
+        case 3: return expansionHint;
+        case 4: return type.get();
+        case 5: return delay;
+        case 6: return &declarators;
+        case 7: return semi;
+        default: return nullptr;
+    }
+}
+
+void NetDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: netType = child.token(); return;
+        case 2: strength = &child.node()->as<NetStrengthSyntax>(); return;
+        case 3: expansionHint = child.token(); return;
+        case 4: type = &child.node()->as<DataTypeSyntax>(); return;
+        case 5: delay = &child.node()->as<TimingControlSyntax>(); return;
+        case 6: declarators = child.node()->as<SeparatedSyntaxList<DeclaratorSyntax>>(); return;
+        case 7: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NetDeclarationSyntax* NetDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NetDeclarationSyntax>(*this);
+}
+
+bool NetPortHeaderSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NetPortHeader;
+}
+
+TokenOrSyntax NetPortHeaderSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return direction;
+        case 1: return netType;
+        case 2: return dataType.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NetPortHeaderSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return direction;
+        case 1: return netType;
+        case 2: return dataType.get();
+        default: return nullptr;
+    }
+}
+
+void NetPortHeaderSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: direction = child.token(); return;
+        case 1: netType = child.token(); return;
+        case 2: dataType = &child.node()->as<DataTypeSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NetPortHeaderSyntax* NetPortHeaderSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NetPortHeaderSyntax>(*this);
+}
+
+bool NetStrengthSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ChargeStrength:
+        case SyntaxKind::DriveStrength:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool NetTypeDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NetTypeDeclaration;
+}
+
+TokenOrSyntax NetTypeDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return type.get();
+        case 3: return name;
+        case 4: return withFunction;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NetTypeDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return type.get();
+        case 3: return name;
+        case 4: return withFunction;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+void NetTypeDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: type = &child.node()->as<DataTypeSyntax>(); return;
+        case 3: name = child.token(); return;
+        case 4: withFunction = &child.node()->as<WithFunctionClauseSyntax>(); return;
+        case 5: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NetTypeDeclarationSyntax* NetTypeDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NetTypeDeclarationSyntax>(*this);
+}
+
+bool NewArrayExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NewArrayExpression;
+}
+
+TokenOrSyntax NewArrayExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return newKeyword.get();
+        case 1: return openBracket;
+        case 2: return sizeExpr.get();
+        case 3: return closeBracket;
+        case 4: return initializer;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NewArrayExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return newKeyword.get();
+        case 1: return openBracket;
+        case 2: return sizeExpr.get();
+        case 3: return closeBracket;
+        case 4: return initializer;
+        default: return nullptr;
+    }
+}
+
+void NewArrayExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: newKeyword = &child.node()->as<NameSyntax>(); return;
+        case 1: openBracket = child.token(); return;
+        case 2: sizeExpr = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: closeBracket = child.token(); return;
+        case 4: initializer = &child.node()->as<ParenthesizedExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NewArrayExpressionSyntax* NewArrayExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NewArrayExpressionSyntax>(*this);
+}
+
+bool NewClassExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NewClassExpression;
+}
+
+TokenOrSyntax NewClassExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return scopedNew.get();
+        case 1: return argList;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NewClassExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return scopedNew.get();
+        case 1: return argList;
+        default: return nullptr;
+    }
+}
+
+void NewClassExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: scopedNew = &child.node()->as<NameSyntax>(); return;
+        case 1: argList = &child.node()->as<ArgumentListSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NewClassExpressionSyntax* NewClassExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NewClassExpressionSyntax>(*this);
+}
+
+bool NonAnsiPortListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NonAnsiPortList;
+}
+
+TokenOrSyntax NonAnsiPortListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ports;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NonAnsiPortListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ports;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void NonAnsiPortListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: ports = child.node()->as<SeparatedSyntaxList<NonAnsiPortSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NonAnsiPortListSyntax* NonAnsiPortListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NonAnsiPortListSyntax>(*this);
+}
+
+bool NonAnsiPortSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ExplicitNonAnsiPort:
+        case SyntaxKind::ImplicitNonAnsiPort:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool NonAnsiUdpPortListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NonAnsiUdpPortList;
+}
+
+TokenOrSyntax NonAnsiUdpPortListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ports;
+        case 2: return closeParen;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NonAnsiUdpPortListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ports;
+        case 2: return closeParen;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void NonAnsiUdpPortListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: ports = child.node()->as<SeparatedSyntaxList<IdentifierNameSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NonAnsiUdpPortListSyntax* NonAnsiUdpPortListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NonAnsiUdpPortListSyntax>(*this);
+}
+
+bool NumberPragmaExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NumberPragmaExpression;
+}
+
+TokenOrSyntax NumberPragmaExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return size;
+        case 1: return base;
+        case 2: return value;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NumberPragmaExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return size;
+        case 1: return base;
+        case 2: return value;
+        default: return nullptr;
+    }
+}
+
+void NumberPragmaExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: size = child.token(); return;
+        case 1: base = child.token(); return;
+        case 2: value = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NumberPragmaExpressionSyntax* NumberPragmaExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NumberPragmaExpressionSyntax>(*this);
+}
+
+bool OpenRangeExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::OpenRangeExpression;
+}
+
+TokenOrSyntax OpenRangeExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBracket;
+        case 1: return left.get();
+        case 2: return colon;
+        case 3: return right.get();
+        case 4: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax OpenRangeExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBracket;
+        case 1: return left.get();
+        case 2: return colon;
+        case 3: return right.get();
+        case 4: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+void OpenRangeExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBracket = child.token(); return;
+        case 1: left = &child.node()->as<ExpressionSyntax>(); return;
+        case 2: colon = child.token(); return;
+        case 3: right = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: closeBracket = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+OpenRangeExpressionSyntax* OpenRangeExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<OpenRangeExpressionSyntax>(*this);
+}
+
+bool OpenRangeListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::OpenRangeList;
+}
+
+TokenOrSyntax OpenRangeListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &valueRanges;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax OpenRangeListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &valueRanges;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void OpenRangeListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: valueRanges = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 2: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+OpenRangeListSyntax* OpenRangeListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<OpenRangeListSyntax>(*this);
+}
+
+bool OrderedArgumentSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::OrderedArgument;
+}
+
+TokenOrSyntax OrderedArgumentSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax OrderedArgumentSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void OrderedArgumentSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+OrderedArgumentSyntax* OrderedArgumentSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<OrderedArgumentSyntax>(*this);
+}
+
+bool OrderedPortConnectionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::OrderedPortConnection;
+}
+
+TokenOrSyntax OrderedPortConnectionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax OrderedPortConnectionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void OrderedPortConnectionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+OrderedPortConnectionSyntax* OrderedPortConnectionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<OrderedPortConnectionSyntax>(*this);
+}
+
+bool OrderedStructurePatternMemberSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::OrderedStructurePatternMember;
+}
+
+TokenOrSyntax OrderedStructurePatternMemberSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return pattern.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax OrderedStructurePatternMemberSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return pattern.get();
+        default: return nullptr;
+    }
+}
+
+void OrderedStructurePatternMemberSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: pattern = &child.node()->as<PatternSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+OrderedStructurePatternMemberSyntax* OrderedStructurePatternMemberSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<OrderedStructurePatternMemberSyntax>(*this);
+}
+
+bool PackageImportDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PackageImportDeclaration;
+}
+
+TokenOrSyntax PackageImportDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return &items;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PackageImportDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return &items;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void PackageImportDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: items = child.node()->as<SeparatedSyntaxList<PackageImportItemSyntax>>(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PackageImportDeclarationSyntax* PackageImportDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PackageImportDeclarationSyntax>(*this);
+}
+
+bool PackageImportItemSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PackageImportItem;
+}
+
+TokenOrSyntax PackageImportItemSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return package;
+        case 1: return doubleColon;
+        case 2: return item;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PackageImportItemSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return package;
+        case 1: return doubleColon;
+        case 2: return item;
+        default: return nullptr;
+    }
+}
+
+void PackageImportItemSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: package = child.token(); return;
+        case 1: doubleColon = child.token(); return;
+        case 2: item = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PackageImportItemSyntax* PackageImportItemSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PackageImportItemSyntax>(*this);
+}
+
+bool ParameterDeclarationBaseSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ParameterDeclaration:
+        case SyntaxKind::TypeParameterDeclaration:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax ParameterDeclarationBaseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ParameterDeclarationBaseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        default: return nullptr;
+    }
+}
+
+void ParameterDeclarationBaseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ParameterDeclarationBaseSyntax* ParameterDeclarationBaseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ParameterDeclarationBaseSyntax>(*this);
+}
+
+bool ParameterDeclarationStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ParameterDeclarationStatement;
+}
+
+TokenOrSyntax ParameterDeclarationStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return parameter.get();
+        case 2: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ParameterDeclarationStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return parameter.get();
+        case 2: return semi;
+        default: return nullptr;
+    }
+}
+
+void ParameterDeclarationStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: parameter = &child.node()->as<ParameterDeclarationBaseSyntax>(); return;
+        case 2: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ParameterDeclarationStatementSyntax* ParameterDeclarationStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ParameterDeclarationStatementSyntax>(*this);
+}
+
+bool ParameterDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ParameterDeclaration;
+}
+
+TokenOrSyntax ParameterDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return type.get();
+        case 2: return &declarators;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ParameterDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return type.get();
+        case 2: return &declarators;
+        default: return nullptr;
+    }
+}
+
+void ParameterDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        case 1: type = &child.node()->as<DataTypeSyntax>(); return;
+        case 2: declarators = child.node()->as<SeparatedSyntaxList<DeclaratorSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ParameterDeclarationSyntax* ParameterDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ParameterDeclarationSyntax>(*this);
+}
+
+bool ParameterPortListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ParameterPortList;
+}
+
+TokenOrSyntax ParameterPortListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return hash;
+        case 1: return openParen;
+        case 2: return &declarations;
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ParameterPortListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return hash;
+        case 1: return openParen;
+        case 2: return &declarations;
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ParameterPortListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: hash = child.token(); return;
+        case 1: openParen = child.token(); return;
+        case 2: declarations = child.node()->as<SeparatedSyntaxList<ParameterDeclarationBaseSyntax>>(); return;
+        case 3: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ParameterPortListSyntax* ParameterPortListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ParameterPortListSyntax>(*this);
+}
+
+bool ParameterValueAssignmentSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ParameterValueAssignment;
+}
+
+TokenOrSyntax ParameterValueAssignmentSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return hash;
+        case 1: return assignments.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ParameterValueAssignmentSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return hash;
+        case 1: return assignments.get();
+        default: return nullptr;
+    }
+}
+
+void ParameterValueAssignmentSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: hash = child.token(); return;
+        case 1: assignments = &child.node()->as<ArgumentListSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ParameterValueAssignmentSyntax* ParameterValueAssignmentSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ParameterValueAssignmentSyntax>(*this);
+}
+
+bool ParenExpressionListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ParenExpressionList;
+}
+
+TokenOrSyntax ParenExpressionListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &expressions;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ParenExpressionListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &expressions;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ParenExpressionListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: expressions = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ParenExpressionListSyntax* ParenExpressionListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ParenExpressionListSyntax>(*this);
+}
+
+bool ParenPragmaExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ParenPragmaExpression;
+}
+
+TokenOrSyntax ParenPragmaExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &values;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ParenPragmaExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &values;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ParenPragmaExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: values = child.node()->as<SeparatedSyntaxList<PragmaExpressionSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ParenPragmaExpressionSyntax* ParenPragmaExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ParenPragmaExpressionSyntax>(*this);
+}
+
+bool ParenthesizedEventExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ParenthesizedEventExpression;
+}
+
+TokenOrSyntax ParenthesizedEventExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return expr.get();
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ParenthesizedEventExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return expr.get();
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ParenthesizedEventExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: expr = &child.node()->as<EventExpressionSyntax>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ParenthesizedEventExpressionSyntax* ParenthesizedEventExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ParenthesizedEventExpressionSyntax>(*this);
+}
+
+bool ParenthesizedExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ParenthesizedExpression;
+}
+
+TokenOrSyntax ParenthesizedExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return expression.get();
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ParenthesizedExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return expression.get();
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ParenthesizedExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: expression = &child.node()->as<ExpressionSyntax>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ParenthesizedExpressionSyntax* ParenthesizedExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ParenthesizedExpressionSyntax>(*this);
+}
+
+bool PathDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PathDeclaration;
+}
+
+TokenOrSyntax PathDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return desc.get();
+        case 2: return equals;
+        case 3: return openParen;
+        case 4: return &delays;
+        case 5: return closeParen;
+        case 6: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PathDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return desc.get();
+        case 2: return equals;
+        case 3: return openParen;
+        case 4: return &delays;
+        case 5: return closeParen;
+        case 6: return semi;
+        default: return nullptr;
+    }
+}
+
+void PathDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: desc = &child.node()->as<PathDescriptionSyntax>(); return;
+        case 2: equals = child.token(); return;
+        case 3: openParen = child.token(); return;
+        case 4: delays = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 5: closeParen = child.token(); return;
+        case 6: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PathDeclarationSyntax* PathDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PathDeclarationSyntax>(*this);
+}
+
+bool PathDescriptionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PathDescription;
+}
+
+TokenOrSyntax PathDescriptionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return edgeIdentifier;
+        case 2: return &inputs;
+        case 3: return polarityOperator;
+        case 4: return pathOperator;
+        case 5: return suffix.get();
+        case 6: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PathDescriptionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return edgeIdentifier;
+        case 2: return &inputs;
+        case 3: return polarityOperator;
+        case 4: return pathOperator;
+        case 5: return suffix.get();
+        case 6: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void PathDescriptionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: edgeIdentifier = child.token(); return;
+        case 2: inputs = child.node()->as<SeparatedSyntaxList<NameSyntax>>(); return;
+        case 3: polarityOperator = child.token(); return;
+        case 4: pathOperator = child.token(); return;
+        case 5: suffix = &child.node()->as<PathSuffixSyntax>(); return;
+        case 6: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PathDescriptionSyntax* PathDescriptionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PathDescriptionSyntax>(*this);
+}
+
+bool PathSuffixSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::EdgeSensitivePathSuffix:
+        case SyntaxKind::SimplePathSuffix:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool PatternCaseItemSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PatternCaseItem;
+}
+
+TokenOrSyntax PatternCaseItemSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return pattern.get();
+        case 1: return tripleAnd;
+        case 2: return expr;
+        case 3: return colon;
+        case 4: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PatternCaseItemSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return pattern.get();
+        case 1: return tripleAnd;
+        case 2: return expr;
+        case 3: return colon;
+        case 4: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void PatternCaseItemSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: pattern = &child.node()->as<PatternSyntax>(); return;
+        case 1: tripleAnd = child.token(); return;
+        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: colon = child.token(); return;
+        case 4: statement = &child.node()->as<StatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PatternCaseItemSyntax* PatternCaseItemSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PatternCaseItemSyntax>(*this);
+}
+
+bool PatternSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ExpressionPattern:
+        case SyntaxKind::StructurePattern:
+        case SyntaxKind::TaggedPattern:
+        case SyntaxKind::VariablePattern:
+        case SyntaxKind::WildcardPattern:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool PortConcatenationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PortConcatenation;
+}
+
+TokenOrSyntax PortConcatenationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &references;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PortConcatenationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &references;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void PortConcatenationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: references = child.node()->as<SeparatedSyntaxList<PortReferenceSyntax>>(); return;
+        case 2: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PortConcatenationSyntax* PortConcatenationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PortConcatenationSyntax>(*this);
+}
+
+bool PortConnectionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::EmptyPortConnection:
+        case SyntaxKind::NamedPortConnection:
+        case SyntaxKind::OrderedPortConnection:
+        case SyntaxKind::WildcardPortConnection:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax PortConnectionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PortConnectionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        default: return nullptr;
+    }
+}
+
+void PortConnectionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PortConnectionSyntax* PortConnectionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PortConnectionSyntax>(*this);
+}
+
+bool PortDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PortDeclaration;
+}
+
+TokenOrSyntax PortDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return header.get();
+        case 2: return &declarators;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PortDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return header.get();
+        case 2: return &declarators;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void PortDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: header = &child.node()->as<PortHeaderSyntax>(); return;
+        case 2: declarators = child.node()->as<SeparatedSyntaxList<DeclaratorSyntax>>(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PortDeclarationSyntax* PortDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PortDeclarationSyntax>(*this);
+}
+
+bool PortExpressionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::PortConcatenation:
+        case SyntaxKind::PortReference:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool PortHeaderSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::InterconnectPortHeader:
+        case SyntaxKind::InterfacePortHeader:
+        case SyntaxKind::NetPortHeader:
+        case SyntaxKind::VariablePortHeader:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool PortListSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AnsiPortList:
+        case SyntaxKind::NonAnsiPortList:
+        case SyntaxKind::WildcardPortList:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool PortReferenceSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PortReference;
+}
+
+TokenOrSyntax PortReferenceSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return select;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PortReferenceSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return select;
+        default: return nullptr;
+    }
+}
+
+void PortReferenceSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: select = &child.node()->as<ElementSelectSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PortReferenceSyntax* PortReferenceSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PortReferenceSyntax>(*this);
+}
+
+bool PostfixUnaryExpressionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::PostdecrementExpression:
+        case SyntaxKind::PostincrementExpression:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax PostfixUnaryExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return operand.get();
+        case 1: return &attributes;
+        case 2: return operatorToken;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PostfixUnaryExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return operand.get();
+        case 1: return &attributes;
+        case 2: return operatorToken;
+        default: return nullptr;
+    }
+}
+
+void PostfixUnaryExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: operand = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: operatorToken = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PostfixUnaryExpressionSyntax* PostfixUnaryExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PostfixUnaryExpressionSyntax>(*this);
+}
+
+bool PragmaDirectiveSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PragmaDirective;
+}
+
+TokenOrSyntax PragmaDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return name;
+        case 2: return &args;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PragmaDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return name;
+        case 2: return &args;
+        default: return nullptr;
+    }
+}
+
+void PragmaDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: name = child.token(); return;
+        case 2: args = child.node()->as<SeparatedSyntaxList<PragmaExpressionSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PragmaDirectiveSyntax* PragmaDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PragmaDirectiveSyntax>(*this);
+}
+
+bool PragmaExpressionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::NameValuePragmaExpression:
+        case SyntaxKind::NumberPragmaExpression:
+        case SyntaxKind::ParenPragmaExpression:
+        case SyntaxKind::SimplePragmaExpression:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool PrefixUnaryExpressionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AcceptOnPropertyExpression:
+        case SyntaxKind::AlwaysPropertyExpression:
+        case SyntaxKind::EventuallyPropertyExpression:
+        case SyntaxKind::NextTimePropertyExpression:
+        case SyntaxKind::RejectOnPropertyExpression:
+        case SyntaxKind::SAlwaysPropertyExpression:
+        case SyntaxKind::SEventuallyPropertyExpression:
+        case SyntaxKind::SNextTimePropertyExpression:
+        case SyntaxKind::SyncAcceptOnPropertyExpression:
+        case SyntaxKind::SyncRejectOnPropertyExpression:
+        case SyntaxKind::UnaryBitwiseAndExpression:
+        case SyntaxKind::UnaryBitwiseNandExpression:
+        case SyntaxKind::UnaryBitwiseNorExpression:
+        case SyntaxKind::UnaryBitwiseNotExpression:
+        case SyntaxKind::UnaryBitwiseOrExpression:
+        case SyntaxKind::UnaryBitwiseXnorExpression:
+        case SyntaxKind::UnaryBitwiseXorExpression:
+        case SyntaxKind::UnaryLogicalNotExpression:
+        case SyntaxKind::UnaryMinusExpression:
+        case SyntaxKind::UnaryNotPropertyExpression:
+        case SyntaxKind::UnaryPlusExpression:
+        case SyntaxKind::UnaryPredecrementExpression:
+        case SyntaxKind::UnaryPreincrementExpression:
+        case SyntaxKind::UnarySequenceDelayExpression:
+        case SyntaxKind::UnarySequenceEventExpression:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax PrefixUnaryExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return operatorToken;
+        case 1: return &attributes;
+        case 2: return operand.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PrefixUnaryExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return operatorToken;
+        case 1: return &attributes;
+        case 2: return operand.get();
+        default: return nullptr;
+    }
+}
+
+void PrefixUnaryExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: operatorToken = child.token(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: operand = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PrefixUnaryExpressionSyntax* PrefixUnaryExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PrefixUnaryExpressionSyntax>(*this);
+}
+
+bool PrimaryBlockEventExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PrimaryBlockEventExpression;
+}
+
+TokenOrSyntax PrimaryBlockEventExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return name.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PrimaryBlockEventExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return name.get();
+        default: return nullptr;
+    }
+}
+
+void PrimaryBlockEventExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        case 1: name = &child.node()->as<NameSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PrimaryBlockEventExpressionSyntax* PrimaryBlockEventExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PrimaryBlockEventExpressionSyntax>(*this);
+}
+
+bool PrimaryExpressionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AssignmentPatternExpression:
+        case SyntaxKind::ConcatenationExpression:
+        case SyntaxKind::DefaultPatternKeyExpression:
+        case SyntaxKind::EmptyQueueExpression:
+        case SyntaxKind::IntegerLiteralExpression:
+        case SyntaxKind::IntegerVectorExpression:
+        case SyntaxKind::MultipleConcatenationExpression:
+        case SyntaxKind::NullLiteralExpression:
+        case SyntaxKind::OneStepLiteralExpression:
+        case SyntaxKind::ParenthesizedExpression:
+        case SyntaxKind::RealLiteralExpression:
+        case SyntaxKind::StreamingConcatenationExpression:
+        case SyntaxKind::StringLiteralExpression:
+        case SyntaxKind::TimeLiteralExpression:
+        case SyntaxKind::UnbasedUnsizedLiteralExpression:
+        case SyntaxKind::WildcardLiteralExpression:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool ProceduralAssignStatementSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ProceduralAssignStatement:
+        case SyntaxKind::ProceduralForceStatement:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax ProceduralAssignStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return keyword;
+        case 3: return expr.get();
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ProceduralAssignStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return keyword;
+        case 3: return expr.get();
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void ProceduralAssignStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: keyword = child.token(); return;
+        case 3: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ProceduralAssignStatementSyntax* ProceduralAssignStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ProceduralAssignStatementSyntax>(*this);
+}
+
+bool ProceduralBlockSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AlwaysBlock:
+        case SyntaxKind::AlwaysCombBlock:
+        case SyntaxKind::AlwaysFFBlock:
+        case SyntaxKind::AlwaysLatchBlock:
+        case SyntaxKind::FinalBlock:
+        case SyntaxKind::InitialBlock:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax ProceduralBlockSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ProceduralBlockSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void ProceduralBlockSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: statement = &child.node()->as<StatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ProceduralBlockSyntax* ProceduralBlockSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ProceduralBlockSyntax>(*this);
+}
+
+bool ProceduralDeassignStatementSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ProceduralDeassignStatement:
+        case SyntaxKind::ProceduralReleaseStatement:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax ProceduralDeassignStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return keyword;
+        case 3: return variable.get();
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ProceduralDeassignStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return keyword;
+        case 3: return variable.get();
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void ProceduralDeassignStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: keyword = child.token(); return;
+        case 3: variable = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ProceduralDeassignStatementSyntax* ProceduralDeassignStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ProceduralDeassignStatementSyntax>(*this);
+}
+
+bool PropertyDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PropertyDeclaration;
+}
+
+TokenOrSyntax PropertyDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return name;
+        case 3: return portList;
+        case 4: return semi;
+        case 5: return &assertionVariables;
+        case 6: return propertySpec.get();
+        case 7: return optionalSemi;
+        case 8: return end;
+        case 9: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PropertyDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return name;
+        case 3: return portList;
+        case 4: return semi;
+        case 5: return &assertionVariables;
+        case 6: return propertySpec.get();
+        case 7: return optionalSemi;
+        case 8: return end;
+        case 9: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+void PropertyDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: name = child.token(); return;
+        case 3: portList = &child.node()->as<AssertionItemPortListSyntax>(); return;
+        case 4: semi = child.token(); return;
+        case 5: assertionVariables = child.node()->as<SyntaxList<MemberSyntax>>(); return;
+        case 6: propertySpec = &child.node()->as<PropertySpecSyntax>(); return;
+        case 7: optionalSemi = child.token(); return;
+        case 8: end = child.token(); return;
+        case 9: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PropertyDeclarationSyntax* PropertyDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PropertyDeclarationSyntax>(*this);
+}
+
+bool PropertySpecSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PropertySpec;
+}
+
+TokenOrSyntax PropertySpecSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return clocking;
+        case 1: return disable;
+        case 2: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PropertySpecSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return clocking;
+        case 1: return disable;
+        case 2: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void PropertySpecSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: clocking = &child.node()->as<TimingControlSyntax>(); return;
+        case 1: disable = &child.node()->as<DisableIffSyntax>(); return;
+        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PropertySpecSyntax* PropertySpecSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PropertySpecSyntax>(*this);
+}
+
+bool PulseStyleDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PulseStyleDeclaration;
+}
+
+TokenOrSyntax PulseStyleDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return &inputs;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PulseStyleDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return &inputs;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void PulseStyleDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: inputs = child.node()->as<SeparatedSyntaxList<NameSyntax>>(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PulseStyleDeclarationSyntax* PulseStyleDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PulseStyleDeclarationSyntax>(*this);
+}
+
+bool QueueDimensionSpecifierSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::QueueDimensionSpecifier;
+}
+
+TokenOrSyntax QueueDimensionSpecifierSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return dollar;
+        case 1: return maxSizeClause;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax QueueDimensionSpecifierSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return dollar;
+        case 1: return maxSizeClause;
+        default: return nullptr;
+    }
+}
+
+void QueueDimensionSpecifierSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: dollar = child.token(); return;
+        case 1: maxSizeClause = &child.node()->as<ColonExpressionClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+QueueDimensionSpecifierSyntax* QueueDimensionSpecifierSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<QueueDimensionSpecifierSyntax>(*this);
+}
+
+bool RandCaseItemSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::RandCaseItem;
+}
+
+TokenOrSyntax RandCaseItemSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return colon;
+        case 2: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax RandCaseItemSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return colon;
+        case 2: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void RandCaseItemSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: colon = child.token(); return;
+        case 2: statement = &child.node()->as<StatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+RandCaseItemSyntax* RandCaseItemSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<RandCaseItemSyntax>(*this);
+}
+
+bool RandCaseStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::RandCaseStatement;
+}
+
+TokenOrSyntax RandCaseStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return randCase;
+        case 3: return &items;
+        case 4: return endCase;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax RandCaseStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return randCase;
+        case 3: return &items;
+        case 4: return endCase;
+        default: return nullptr;
+    }
+}
+
+void RandCaseStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: randCase = child.token(); return;
+        case 3: items = child.node()->as<SyntaxList<RandCaseItemSyntax>>(); return;
+        case 4: endCase = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+RandCaseStatementSyntax* RandCaseStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<RandCaseStatementSyntax>(*this);
+}
+
+bool RangeCoverageBinInitializerSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::RangeCoverageBinInitializer;
+}
+
+TokenOrSyntax RangeCoverageBinInitializerSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return ranges.get();
+        case 1: return withClause;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax RangeCoverageBinInitializerSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return ranges.get();
+        case 1: return withClause;
+        default: return nullptr;
+    }
+}
+
+void RangeCoverageBinInitializerSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: ranges = &child.node()->as<OpenRangeListSyntax>(); return;
+        case 1: withClause = &child.node()->as<WithClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+RangeCoverageBinInitializerSyntax* RangeCoverageBinInitializerSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<RangeCoverageBinInitializerSyntax>(*this);
+}
+
+bool RangeDimensionSpecifierSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::RangeDimensionSpecifier;
+}
+
+TokenOrSyntax RangeDimensionSpecifierSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return selector.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax RangeDimensionSpecifierSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return selector.get();
+        default: return nullptr;
+    }
+}
+
+void RangeDimensionSpecifierSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: selector = &child.node()->as<SelectorSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+RangeDimensionSpecifierSyntax* RangeDimensionSpecifierSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<RangeDimensionSpecifierSyntax>(*this);
+}
+
+bool RangeSelectSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AscendingRangeSelect:
+        case SyntaxKind::DescendingRangeSelect:
+        case SyntaxKind::SimpleRangeSelect:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax RangeSelectSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return range;
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax RangeSelectSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return range;
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+void RangeSelectSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: range = child.token(); return;
+        case 2: right = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+RangeSelectSyntax* RangeSelectSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<RangeSelectSyntax>(*this);
+}
+
+bool RepeatedEventControlSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::RepeatedEventControl;
+}
+
+TokenOrSyntax RepeatedEventControlSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return repeat;
+        case 1: return openParen;
+        case 2: return expr.get();
+        case 3: return closeParen;
+        case 4: return eventControl;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax RepeatedEventControlSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return repeat;
+        case 1: return openParen;
+        case 2: return expr.get();
+        case 3: return closeParen;
+        case 4: return eventControl;
+        default: return nullptr;
+    }
+}
+
+void RepeatedEventControlSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: repeat = child.token(); return;
+        case 1: openParen = child.token(); return;
+        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: closeParen = child.token(); return;
+        case 4: eventControl = &child.node()->as<TimingControlSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+RepeatedEventControlSyntax* RepeatedEventControlSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<RepeatedEventControlSyntax>(*this);
+}
+
+bool ReplicatedAssignmentPatternSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ReplicatedAssignmentPattern;
+}
+
+TokenOrSyntax ReplicatedAssignmentPatternSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return countExpr.get();
+        case 2: return innerOpenBrace;
+        case 3: return &items;
+        case 4: return innerCloseBrace;
+        case 5: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ReplicatedAssignmentPatternSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return countExpr.get();
+        case 2: return innerOpenBrace;
+        case 3: return &items;
+        case 4: return innerCloseBrace;
+        case 5: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void ReplicatedAssignmentPatternSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: countExpr = &child.node()->as<ExpressionSyntax>(); return;
+        case 2: innerOpenBrace = child.token(); return;
+        case 3: items = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 4: innerCloseBrace = child.token(); return;
+        case 5: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ReplicatedAssignmentPatternSyntax* ReplicatedAssignmentPatternSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ReplicatedAssignmentPatternSyntax>(*this);
+}
+
+bool ReturnStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ReturnStatement;
+}
+
+TokenOrSyntax ReturnStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return returnKeyword;
+        case 3: return returnValue;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ReturnStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return returnKeyword;
+        case 3: return returnValue;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void ReturnStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: returnKeyword = child.token(); return;
+        case 3: returnValue = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ReturnStatementSyntax* ReturnStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ReturnStatementSyntax>(*this);
+}
+
+bool ScopedNameSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ScopedName;
+}
+
+TokenOrSyntax ScopedNameSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return separator;
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ScopedNameSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return separator;
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+void ScopedNameSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<NameSyntax>(); return;
+        case 1: separator = child.token(); return;
+        case 2: right = &child.node()->as<NameSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ScopedNameSyntax* ScopedNameSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ScopedNameSyntax>(*this);
+}
+
+bool SelectorSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AscendingRangeSelect:
+        case SyntaxKind::BitSelect:
+        case SyntaxKind::DescendingRangeSelect:
+        case SyntaxKind::SimpleRangeSelect:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool SequenceDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::SequenceDeclaration;
+}
+
+TokenOrSyntax SequenceDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return name;
+        case 3: return portList;
+        case 4: return semi;
+        case 5: return &assertionVariables;
+        case 6: return seqExpr.get();
+        case 7: return optionalSemi;
+        case 8: return end;
+        case 9: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SequenceDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return name;
+        case 3: return portList;
+        case 4: return semi;
+        case 5: return &assertionVariables;
+        case 6: return seqExpr.get();
+        case 7: return optionalSemi;
+        case 8: return end;
+        case 9: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+void SequenceDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: name = child.token(); return;
+        case 3: portList = &child.node()->as<AssertionItemPortListSyntax>(); return;
+        case 4: semi = child.token(); return;
+        case 5: assertionVariables = child.node()->as<SyntaxList<MemberSyntax>>(); return;
+        case 6: seqExpr = &child.node()->as<ExpressionSyntax>(); return;
+        case 7: optionalSemi = child.token(); return;
+        case 8: end = child.token(); return;
+        case 9: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SequenceDeclarationSyntax* SequenceDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SequenceDeclarationSyntax>(*this);
+}
+
+bool ShortcutCycleDelayRangeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ShortcutCycleDelayRange;
+}
+
+TokenOrSyntax ShortcutCycleDelayRangeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return doubleHash;
+        case 1: return openBracket;
+        case 2: return op;
+        case 3: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ShortcutCycleDelayRangeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return doubleHash;
+        case 1: return openBracket;
+        case 2: return op;
+        case 3: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+void ShortcutCycleDelayRangeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: doubleHash = child.token(); return;
+        case 1: openBracket = child.token(); return;
+        case 2: op = child.token(); return;
+        case 3: closeBracket = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ShortcutCycleDelayRangeSyntax* ShortcutCycleDelayRangeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ShortcutCycleDelayRangeSyntax>(*this);
+}
+
+bool SignalEventExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::SignalEventExpression;
+}
+
+TokenOrSyntax SignalEventExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return edge;
+        case 1: return expr.get();
+        case 2: return iffClause;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SignalEventExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return edge;
+        case 1: return expr.get();
+        case 2: return iffClause;
+        default: return nullptr;
+    }
+}
+
+void SignalEventExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: edge = child.token(); return;
+        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 2: iffClause = &child.node()->as<IffEventClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SignalEventExpressionSyntax* SignalEventExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SignalEventExpressionSyntax>(*this);
+}
+
+bool SignedCastExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::SignedCastExpression;
+}
+
+TokenOrSyntax SignedCastExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return signing;
+        case 1: return apostrophe;
+        case 2: return inner.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SignedCastExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return signing;
+        case 1: return apostrophe;
+        case 2: return inner.get();
+        default: return nullptr;
+    }
+}
+
+void SignedCastExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: signing = child.token(); return;
+        case 1: apostrophe = child.token(); return;
+        case 2: inner = &child.node()->as<ParenthesizedExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SignedCastExpressionSyntax* SignedCastExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SignedCastExpressionSyntax>(*this);
+}
+
+bool SimpleAssignmentPatternSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::SimpleAssignmentPattern;
+}
+
+TokenOrSyntax SimpleAssignmentPatternSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &items;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SimpleAssignmentPatternSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &items;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void SimpleAssignmentPatternSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: items = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 2: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SimpleAssignmentPatternSyntax* SimpleAssignmentPatternSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SimpleAssignmentPatternSyntax>(*this);
+}
+
+bool SimpleDirectiveSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::CellDefineDirective:
+        case SyntaxKind::EndCellDefineDirective:
+        case SyntaxKind::EndKeywordsDirective:
+        case SyntaxKind::NoUnconnectedDriveDirective:
+        case SyntaxKind::ResetAllDirective:
+        case SyntaxKind::UndefineAllDirective:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax SimpleDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SimpleDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        default: return nullptr;
+    }
+}
+
+void SimpleDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SimpleDirectiveSyntax* SimpleDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SimpleDirectiveSyntax>(*this);
+}
+
+bool SimplePathSuffixSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::SimplePathSuffix;
+}
+
+TokenOrSyntax SimplePathSuffixSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &outputs;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SimplePathSuffixSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &outputs;
+        default: return nullptr;
+    }
+}
+
+void SimplePathSuffixSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: outputs = child.node()->as<SeparatedSyntaxList<NameSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SimplePathSuffixSyntax* SimplePathSuffixSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SimplePathSuffixSyntax>(*this);
+}
+
+bool SimplePragmaExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::SimplePragmaExpression;
+}
+
+TokenOrSyntax SimplePragmaExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return value;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SimplePragmaExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return value;
+        default: return nullptr;
+    }
+}
+
+void SimplePragmaExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: value = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SimplePragmaExpressionSyntax* SimplePragmaExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SimplePragmaExpressionSyntax>(*this);
+}
+
+bool SolveBeforeConstraintSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::SolveBeforeConstraint;
+}
+
+TokenOrSyntax SolveBeforeConstraintSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return solve;
+        case 1: return &beforeExpr;
+        case 2: return before;
+        case 3: return &afterExpr;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SolveBeforeConstraintSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return solve;
+        case 1: return &beforeExpr;
+        case 2: return before;
+        case 3: return &afterExpr;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void SolveBeforeConstraintSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: solve = child.token(); return;
+        case 1: beforeExpr = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 2: before = child.token(); return;
+        case 3: afterExpr = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SolveBeforeConstraintSyntax* SolveBeforeConstraintSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SolveBeforeConstraintSyntax>(*this);
+}
+
+bool SpecifyBlockSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::SpecifyBlock;
+}
+
+TokenOrSyntax SpecifyBlockSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return specify;
+        case 2: return &items;
+        case 3: return endspecify;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SpecifyBlockSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return specify;
+        case 2: return &items;
+        case 3: return endspecify;
+        default: return nullptr;
+    }
+}
+
+void SpecifyBlockSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: specify = child.token(); return;
+        case 2: items = child.node()->as<SyntaxList<MemberSyntax>>(); return;
+        case 3: endspecify = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SpecifyBlockSyntax* SpecifyBlockSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SpecifyBlockSyntax>(*this);
+}
+
+bool SpecparamDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::SpecparamDeclaration;
+}
+
+TokenOrSyntax SpecparamDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return type.get();
+        case 3: return &declarators;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SpecparamDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return type.get();
+        case 3: return &declarators;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void SpecparamDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: type = &child.node()->as<ImplicitTypeSyntax>(); return;
+        case 3: declarators = child.node()->as<SeparatedSyntaxList<SpecparamDeclaratorSyntax>>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SpecparamDeclarationSyntax* SpecparamDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SpecparamDeclarationSyntax>(*this);
+}
+
+bool SpecparamDeclaratorSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::SpecparamDeclarator;
+}
+
+TokenOrSyntax SpecparamDeclaratorSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return equals;
+        case 2: return value.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SpecparamDeclaratorSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return equals;
+        case 2: return value.get();
+        default: return nullptr;
+    }
+}
+
+void SpecparamDeclaratorSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: equals = child.token(); return;
+        case 2: value = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SpecparamDeclaratorSyntax* SpecparamDeclaratorSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SpecparamDeclaratorSyntax>(*this);
+}
+
+bool StandardCaseItemSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::StandardCaseItem;
+}
+
+TokenOrSyntax StandardCaseItemSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &expressions;
+        case 1: return colon;
+        case 2: return clause.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax StandardCaseItemSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &expressions;
+        case 1: return colon;
+        case 2: return clause.get();
+        default: return nullptr;
+    }
+}
+
+void StandardCaseItemSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expressions = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 1: colon = child.token(); return;
+        case 2: clause = &child.node()->as<SyntaxNode>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+StandardCaseItemSyntax* StandardCaseItemSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<StandardCaseItemSyntax>(*this);
+}
+
+bool StatementSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AssertPropertyStatement:
+        case SyntaxKind::AssumePropertyStatement:
+        case SyntaxKind::BlockingEventTriggerStatement:
+        case SyntaxKind::CaseStatement:
+        case SyntaxKind::ConditionalStatement:
+        case SyntaxKind::CoverPropertyStatement:
+        case SyntaxKind::CoverSequenceStatement:
+        case SyntaxKind::DisableForkStatement:
+        case SyntaxKind::DisableStatement:
+        case SyntaxKind::DoWhileStatement:
+        case SyntaxKind::EmptyStatement:
+        case SyntaxKind::ExpectPropertyStatement:
+        case SyntaxKind::ExpressionStatement:
+        case SyntaxKind::ForLoopStatement:
+        case SyntaxKind::ForeachLoopStatement:
+        case SyntaxKind::ForeverStatement:
+        case SyntaxKind::ImmediateAssertStatement:
+        case SyntaxKind::ImmediateAssumeStatement:
+        case SyntaxKind::ImmediateCoverStatement:
+        case SyntaxKind::JumpStatement:
+        case SyntaxKind::LoopStatement:
+        case SyntaxKind::NonblockingEventTriggerStatement:
+        case SyntaxKind::ParallelBlockStatement:
+        case SyntaxKind::ProceduralAssignStatement:
+        case SyntaxKind::ProceduralDeassignStatement:
+        case SyntaxKind::ProceduralForceStatement:
+        case SyntaxKind::ProceduralReleaseStatement:
+        case SyntaxKind::RandCaseStatement:
+        case SyntaxKind::RestrictPropertyStatement:
+        case SyntaxKind::ReturnStatement:
+        case SyntaxKind::SequentialBlockStatement:
+        case SyntaxKind::TimingControlStatement:
+        case SyntaxKind::VoidCastedCallStatement:
+        case SyntaxKind::WaitForkStatement:
+        case SyntaxKind::WaitOrderStatement:
+        case SyntaxKind::WaitStatement:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax StatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax StatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        default: return nullptr;
+    }
+}
+
+void StatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+StatementSyntax* StatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<StatementSyntax>(*this);
+}
+
+bool StreamExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::StreamExpression;
+}
+
+TokenOrSyntax StreamExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expression.get();
+        case 1: return withRange;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax StreamExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expression.get();
+        case 1: return withRange;
+        default: return nullptr;
+    }
+}
+
+void StreamExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expression = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: withRange = &child.node()->as<StreamExpressionWithRangeSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+StreamExpressionSyntax* StreamExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<StreamExpressionSyntax>(*this);
+}
+
+bool StreamExpressionWithRangeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::StreamExpressionWithRange;
+}
+
+TokenOrSyntax StreamExpressionWithRangeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return withKeyword;
+        case 1: return range.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax StreamExpressionWithRangeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return withKeyword;
+        case 1: return range.get();
+        default: return nullptr;
+    }
+}
+
+void StreamExpressionWithRangeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: withKeyword = child.token(); return;
+        case 1: range = &child.node()->as<ElementSelectSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+StreamExpressionWithRangeSyntax* StreamExpressionWithRangeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<StreamExpressionWithRangeSyntax>(*this);
+}
+
+bool StreamingConcatenationExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::StreamingConcatenationExpression;
+}
+
+TokenOrSyntax StreamingConcatenationExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return operatorToken;
+        case 2: return sliceSize;
+        case 3: return innerOpenBrace;
+        case 4: return &expressions;
+        case 5: return innerCloseBrace;
+        case 6: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax StreamingConcatenationExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return operatorToken;
+        case 2: return sliceSize;
+        case 3: return innerOpenBrace;
+        case 4: return &expressions;
+        case 5: return innerCloseBrace;
+        case 6: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void StreamingConcatenationExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: operatorToken = child.token(); return;
+        case 2: sliceSize = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: innerOpenBrace = child.token(); return;
+        case 4: expressions = child.node()->as<SeparatedSyntaxList<StreamExpressionSyntax>>(); return;
+        case 5: innerCloseBrace = child.token(); return;
+        case 6: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+StreamingConcatenationExpressionSyntax* StreamingConcatenationExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<StreamingConcatenationExpressionSyntax>(*this);
+}
+
+bool StructUnionMemberSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::StructUnionMember;
+}
+
+TokenOrSyntax StructUnionMemberSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return randomQualifier;
+        case 2: return type.get();
+        case 3: return &declarators;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax StructUnionMemberSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return randomQualifier;
+        case 2: return type.get();
+        case 3: return &declarators;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void StructUnionMemberSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: randomQualifier = child.token(); return;
+        case 2: type = &child.node()->as<DataTypeSyntax>(); return;
+        case 3: declarators = child.node()->as<SeparatedSyntaxList<DeclaratorSyntax>>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+StructUnionMemberSyntax* StructUnionMemberSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<StructUnionMemberSyntax>(*this);
+}
+
+bool StructUnionTypeSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::StructType:
+        case SyntaxKind::UnionType:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax StructUnionTypeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return tagged;
+        case 2: return packed;
+        case 3: return signing;
+        case 4: return openBrace;
+        case 5: return &members;
+        case 6: return closeBrace;
+        case 7: return &dimensions;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax StructUnionTypeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return tagged;
+        case 2: return packed;
+        case 3: return signing;
+        case 4: return openBrace;
+        case 5: return &members;
+        case 6: return closeBrace;
+        case 7: return &dimensions;
+        default: return nullptr;
+    }
+}
+
+void StructUnionTypeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        case 1: tagged = child.token(); return;
+        case 2: packed = child.token(); return;
+        case 3: signing = child.token(); return;
+        case 4: openBrace = child.token(); return;
+        case 5: members = child.node()->as<SyntaxList<StructUnionMemberSyntax>>(); return;
+        case 6: closeBrace = child.token(); return;
+        case 7: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+StructUnionTypeSyntax* StructUnionTypeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<StructUnionTypeSyntax>(*this);
+}
+
+bool StructurePatternMemberSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::NamedStructurePatternMember:
+        case SyntaxKind::OrderedStructurePatternMember:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool StructurePatternSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::StructurePattern;
+}
+
+TokenOrSyntax StructurePatternSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &members;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax StructurePatternSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &members;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void StructurePatternSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: members = child.node()->as<SeparatedSyntaxList<StructurePatternMemberSyntax>>(); return;
+        case 2: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+StructurePatternSyntax* StructurePatternSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<StructurePatternSyntax>(*this);
+}
+
+bool StructuredAssignmentPatternSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::StructuredAssignmentPattern;
+}
+
+TokenOrSyntax StructuredAssignmentPatternSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &items;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax StructuredAssignmentPatternSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &items;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void StructuredAssignmentPatternSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: items = child.node()->as<SeparatedSyntaxList<AssignmentPatternItemSyntax>>(); return;
+        case 2: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+StructuredAssignmentPatternSyntax* StructuredAssignmentPatternSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<StructuredAssignmentPatternSyntax>(*this);
+}
+
+bool SystemNameSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::SystemName;
+}
+
+TokenOrSyntax SystemNameSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return systemIdentifier;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SystemNameSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return systemIdentifier;
+        default: return nullptr;
+    }
+}
+
+void SystemNameSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: systemIdentifier = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SystemNameSyntax* SystemNameSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SystemNameSyntax>(*this);
+}
+
+bool SystemTimingCheckSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::SystemTimingCheck;
+}
+
+TokenOrSyntax SystemTimingCheckSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return name;
+        case 2: return openParen;
+        case 3: return &args;
+        case 4: return closeParen;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SystemTimingCheckSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return name;
+        case 2: return openParen;
+        case 3: return &args;
+        case 4: return closeParen;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+void SystemTimingCheckSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: name = child.token(); return;
+        case 2: openParen = child.token(); return;
+        case 3: args = child.node()->as<SeparatedSyntaxList<TimingCheckArgSyntax>>(); return;
+        case 4: closeParen = child.token(); return;
+        case 5: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SystemTimingCheckSyntax* SystemTimingCheckSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SystemTimingCheckSyntax>(*this);
+}
+
+bool TaggedPatternSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TaggedPattern;
+}
+
+TokenOrSyntax TaggedPatternSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return tagged;
+        case 1: return memberName;
+        case 2: return pattern;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TaggedPatternSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return tagged;
+        case 1: return memberName;
+        case 2: return pattern;
+        default: return nullptr;
+    }
+}
+
+void TaggedPatternSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: tagged = child.token(); return;
+        case 1: memberName = child.token(); return;
+        case 2: pattern = &child.node()->as<PatternSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TaggedPatternSyntax* TaggedPatternSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TaggedPatternSyntax>(*this);
+}
+
+bool TaggedUnionExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TaggedUnionExpression;
+}
+
+TokenOrSyntax TaggedUnionExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return tagged;
+        case 1: return member;
+        case 2: return expr;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TaggedUnionExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return tagged;
+        case 1: return member;
+        case 2: return expr;
+        default: return nullptr;
+    }
+}
+
+void TaggedUnionExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: tagged = child.token(); return;
+        case 1: member = child.token(); return;
+        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TaggedUnionExpressionSyntax* TaggedUnionExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TaggedUnionExpressionSyntax>(*this);
+}
+
+bool TimeScaleDirectiveSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TimeScaleDirective;
+}
+
+TokenOrSyntax TimeScaleDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return timeUnit;
+        case 2: return slash;
+        case 3: return timePrecision;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TimeScaleDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return timeUnit;
+        case 2: return slash;
+        case 3: return timePrecision;
+        default: return nullptr;
+    }
+}
+
+void TimeScaleDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: timeUnit = child.token(); return;
+        case 2: slash = child.token(); return;
+        case 3: timePrecision = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TimeScaleDirectiveSyntax* TimeScaleDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TimeScaleDirectiveSyntax>(*this);
+}
+
+bool TimeUnitsDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TimeUnitsDeclaration;
+}
+
+TokenOrSyntax TimeUnitsDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return time;
+        case 3: return divider;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TimeUnitsDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return time;
+        case 3: return divider;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void TimeUnitsDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: time = child.token(); return;
+        case 3: divider = &child.node()->as<DividerClauseSyntax>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TimeUnitsDeclarationSyntax* TimeUnitsDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TimeUnitsDeclarationSyntax>(*this);
+}
+
+bool TimingCheckArgSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::DelayedTerminalArg:
+        case SyntaxKind::EmptyTimingCheckArg:
+        case SyntaxKind::ExpressionTimingCheckArg:
+        case SyntaxKind::TimingCheckEvent:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool TimingCheckConditionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TimingCheckCondition;
+}
+
+TokenOrSyntax TimingCheckConditionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return tripleAnd;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TimingCheckConditionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return tripleAnd;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void TimingCheckConditionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: tripleAnd = child.token(); return;
+        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TimingCheckConditionSyntax* TimingCheckConditionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TimingCheckConditionSyntax>(*this);
+}
+
+bool TimingCheckEventSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TimingCheckEvent;
+}
+
+TokenOrSyntax TimingCheckEventSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return edge;
+        case 1: return controlSpecifier;
+        case 2: return terminal.get();
+        case 3: return condition;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TimingCheckEventSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return edge;
+        case 1: return controlSpecifier;
+        case 2: return terminal.get();
+        case 3: return condition;
+        default: return nullptr;
+    }
+}
+
+void TimingCheckEventSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: edge = child.token(); return;
+        case 1: controlSpecifier = &child.node()->as<EdgeControlSpecifierSyntax>(); return;
+        case 2: terminal = &child.node()->as<NameSyntax>(); return;
+        case 3: condition = &child.node()->as<TimingCheckConditionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TimingCheckEventSyntax* TimingCheckEventSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TimingCheckEventSyntax>(*this);
+}
+
+bool TimingControlExpressionConcatenationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TimingControlExpressionConcatenation;
+}
+
+TokenOrSyntax TimingControlExpressionConcatenationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return timing.get();
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TimingControlExpressionConcatenationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return timing.get();
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+void TimingControlExpressionConcatenationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: timing = &child.node()->as<TimingControlSyntax>(); return;
+        case 2: right = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TimingControlExpressionConcatenationSyntax* TimingControlExpressionConcatenationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TimingControlExpressionConcatenationSyntax>(*this);
+}
+
+bool TimingControlExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TimingControlExpression;
+}
+
+TokenOrSyntax TimingControlExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return timing.get();
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TimingControlExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return timing.get();
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void TimingControlExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: timing = &child.node()->as<TimingControlSyntax>(); return;
+        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TimingControlExpressionSyntax* TimingControlExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TimingControlExpressionSyntax>(*this);
+}
+
+bool TimingControlStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TimingControlStatement;
+}
+
+TokenOrSyntax TimingControlStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return timingControl.get();
+        case 3: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TimingControlStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return timingControl.get();
+        case 3: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void TimingControlStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: timingControl = &child.node()->as<TimingControlSyntax>(); return;
+        case 3: statement = &child.node()->as<StatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TimingControlStatementSyntax* TimingControlStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TimingControlStatementSyntax>(*this);
+}
+
+bool TimingControlSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::CycleDelay:
+        case SyntaxKind::Delay3:
+        case SyntaxKind::DelayControl:
+        case SyntaxKind::EventControl:
+        case SyntaxKind::EventControlWithExpression:
+        case SyntaxKind::ImplicitEventControl:
+        case SyntaxKind::RepeatedEventControl:
+        case SyntaxKind::ShortcutCycleDelayRange:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool TransListCoverageBinInitializerSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TransListCoverageBinInitializer;
+}
+
+TokenOrSyntax TransListCoverageBinInitializerSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &sets;
+        case 1: return withClause;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TransListCoverageBinInitializerSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &sets;
+        case 1: return withClause;
+        default: return nullptr;
+    }
+}
+
+void TransListCoverageBinInitializerSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: sets = child.node()->as<SeparatedSyntaxList<TransSetSyntax>>(); return;
+        case 1: withClause = &child.node()->as<WithClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TransListCoverageBinInitializerSyntax* TransListCoverageBinInitializerSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TransListCoverageBinInitializerSyntax>(*this);
+}
+
+bool TransRangeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TransRange;
+}
+
+TokenOrSyntax TransRangeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &items;
+        case 1: return repeat;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TransRangeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &items;
+        case 1: return repeat;
+        default: return nullptr;
+    }
+}
+
+void TransRangeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: items = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 1: repeat = &child.node()->as<TransRepeatRangeSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TransRangeSyntax* TransRangeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TransRangeSyntax>(*this);
+}
+
+bool TransRepeatRangeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TransRepeatRange;
+}
+
+TokenOrSyntax TransRepeatRangeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBracket;
+        case 1: return specifier;
+        case 2: return selector;
+        case 3: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TransRepeatRangeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBracket;
+        case 1: return specifier;
+        case 2: return selector;
+        case 3: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+void TransRepeatRangeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBracket = child.token(); return;
+        case 1: specifier = child.token(); return;
+        case 2: selector = &child.node()->as<SelectorSyntax>(); return;
+        case 3: closeBracket = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TransRepeatRangeSyntax* TransRepeatRangeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TransRepeatRangeSyntax>(*this);
+}
+
+bool TransSetSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TransSet;
+}
+
+TokenOrSyntax TransSetSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ranges;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TransSetSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ranges;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void TransSetSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: ranges = child.node()->as<SeparatedSyntaxList<TransRangeSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TransSetSyntax* TransSetSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TransSetSyntax>(*this);
+}
+
+bool TypeAssignmentSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TypeAssignment;
+}
+
+TokenOrSyntax TypeAssignmentSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return assignment;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TypeAssignmentSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return assignment;
+        default: return nullptr;
+    }
+}
+
+void TypeAssignmentSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: assignment = &child.node()->as<EqualsTypeClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TypeAssignmentSyntax* TypeAssignmentSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TypeAssignmentSyntax>(*this);
+}
+
+bool TypeParameterDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TypeParameterDeclaration;
+}
+
+TokenOrSyntax TypeParameterDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return typeKeyword;
+        case 2: return &declarators;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TypeParameterDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return typeKeyword;
+        case 2: return &declarators;
+        default: return nullptr;
+    }
+}
+
+void TypeParameterDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        case 1: typeKeyword = child.token(); return;
+        case 2: declarators = child.node()->as<SeparatedSyntaxList<TypeAssignmentSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TypeParameterDeclarationSyntax* TypeParameterDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TypeParameterDeclarationSyntax>(*this);
+}
+
+bool TypeReferenceSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TypeReference;
+}
+
+TokenOrSyntax TypeReferenceSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return typeKeyword;
+        case 1: return openParen;
+        case 2: return expr.get();
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TypeReferenceSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return typeKeyword;
+        case 1: return openParen;
+        case 2: return expr.get();
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void TypeReferenceSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: typeKeyword = child.token(); return;
+        case 1: openParen = child.token(); return;
+        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TypeReferenceSyntax* TypeReferenceSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TypeReferenceSyntax>(*this);
+}
+
+bool TypedefDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TypedefDeclaration;
+}
+
+TokenOrSyntax TypedefDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return typedefKeyword;
+        case 2: return type.get();
+        case 3: return name;
+        case 4: return &dimensions;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TypedefDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return typedefKeyword;
+        case 2: return type.get();
+        case 3: return name;
+        case 4: return &dimensions;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+void TypedefDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: typedefKeyword = child.token(); return;
+        case 2: type = &child.node()->as<DataTypeSyntax>(); return;
+        case 3: name = child.token(); return;
+        case 4: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
+        case 5: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TypedefDeclarationSyntax* TypedefDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TypedefDeclarationSyntax>(*this);
+}
+
+bool UdpBodySyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::UdpBody;
+}
+
+TokenOrSyntax UdpBodySyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &portDecls;
+        case 1: return initialStmt;
+        case 2: return table;
+        case 3: return &entries;
+        case 4: return endtable;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax UdpBodySyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &portDecls;
+        case 1: return initialStmt;
+        case 2: return table;
+        case 3: return &entries;
+        case 4: return endtable;
+        default: return nullptr;
+    }
+}
+
+void UdpBodySyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: portDecls = child.node()->as<SeparatedSyntaxList<UdpPortDeclSyntax>>(); return;
+        case 1: initialStmt = &child.node()->as<UdpInitialStmtSyntax>(); return;
+        case 2: table = child.token(); return;
+        case 3: entries = child.node()->as<SyntaxList<UdpEntrySyntax>>(); return;
+        case 4: endtable = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+UdpBodySyntax* UdpBodySyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<UdpBodySyntax>(*this);
+}
+
+bool UdpDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::UdpDeclaration;
+}
+
+TokenOrSyntax UdpDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return primitive;
+        case 2: return name;
+        case 3: return portList.get();
+        case 4: return body.get();
+        case 5: return endprimitive;
+        case 6: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax UdpDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return primitive;
+        case 2: return name;
+        case 3: return portList.get();
+        case 4: return body.get();
+        case 5: return endprimitive;
+        case 6: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+void UdpDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: primitive = child.token(); return;
+        case 2: name = child.token(); return;
+        case 3: portList = &child.node()->as<UdpPortListSyntax>(); return;
+        case 4: body = &child.node()->as<UdpBodySyntax>(); return;
+        case 5: endprimitive = child.token(); return;
+        case 6: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+UdpDeclarationSyntax* UdpDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<UdpDeclarationSyntax>(*this);
+}
+
+bool UdpEdgeIndicatorSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::UdpEdgeIndicator;
+}
+
+TokenOrSyntax UdpEdgeIndicatorSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return first;
+        case 2: return second;
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax UdpEdgeIndicatorSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return first;
+        case 2: return second;
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void UdpEdgeIndicatorSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: first = child.token(); return;
+        case 2: second = child.token(); return;
+        case 3: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+UdpEdgeIndicatorSyntax* UdpEdgeIndicatorSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<UdpEdgeIndicatorSyntax>(*this);
+}
+
+bool UdpEntrySyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::UdpEntry;
+}
+
+TokenOrSyntax UdpEntrySyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &preInputs;
+        case 1: return edgeIndicator;
+        case 2: return &postInputs;
+        case 3: return colon1;
+        case 4: return current;
+        case 5: return colon2;
+        case 6: return next;
+        case 7: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax UdpEntrySyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &preInputs;
+        case 1: return edgeIndicator;
+        case 2: return &postInputs;
+        case 3: return colon1;
+        case 4: return current;
+        case 5: return colon2;
+        case 6: return next;
+        case 7: return semi;
+        default: return nullptr;
+    }
+}
+
+void UdpEntrySyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: preInputs = child.node()->as<TokenList>(); return;
+        case 1: edgeIndicator = &child.node()->as<UdpEdgeIndicatorSyntax>(); return;
+        case 2: postInputs = child.node()->as<TokenList>(); return;
+        case 3: colon1 = child.token(); return;
+        case 4: current = child.token(); return;
+        case 5: colon2 = child.token(); return;
+        case 6: next = child.token(); return;
+        case 7: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+UdpEntrySyntax* UdpEntrySyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<UdpEntrySyntax>(*this);
+}
+
+bool UdpInitialStmtSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::UdpInitialStmt;
+}
+
+TokenOrSyntax UdpInitialStmtSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return initial;
+        case 1: return name;
+        case 2: return equals;
+        case 3: return value.get();
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax UdpInitialStmtSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return initial;
+        case 1: return name;
+        case 2: return equals;
+        case 3: return value.get();
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void UdpInitialStmtSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: initial = child.token(); return;
+        case 1: name = child.token(); return;
+        case 2: equals = child.token(); return;
+        case 3: value = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+UdpInitialStmtSyntax* UdpInitialStmtSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<UdpInitialStmtSyntax>(*this);
+}
+
+bool UdpInputPortDeclSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::UdpInputPortDecl;
+}
+
+TokenOrSyntax UdpInputPortDeclSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return &names;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax UdpInputPortDeclSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return &names;
+        default: return nullptr;
+    }
+}
+
+void UdpInputPortDeclSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: names = child.node()->as<SeparatedSyntaxList<IdentifierNameSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+UdpInputPortDeclSyntax* UdpInputPortDeclSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<UdpInputPortDeclSyntax>(*this);
+}
+
+bool UdpOutputPortDeclSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::UdpOutputPortDecl;
+}
+
+TokenOrSyntax UdpOutputPortDeclSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return reg;
+        case 3: return name;
+        case 4: return initializer;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax UdpOutputPortDeclSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return reg;
+        case 3: return name;
+        case 4: return initializer;
+        default: return nullptr;
+    }
+}
+
+void UdpOutputPortDeclSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: reg = child.token(); return;
+        case 3: name = child.token(); return;
+        case 4: initializer = &child.node()->as<EqualsValueClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+UdpOutputPortDeclSyntax* UdpOutputPortDeclSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<UdpOutputPortDeclSyntax>(*this);
+}
+
+bool UdpPortDeclSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::UdpInputPortDecl:
+        case SyntaxKind::UdpOutputPortDecl:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax UdpPortDeclSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax UdpPortDeclSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        default: return nullptr;
+    }
+}
+
+void UdpPortDeclSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+UdpPortDeclSyntax* UdpPortDeclSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<UdpPortDeclSyntax>(*this);
+}
+
+bool UdpPortListSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AnsiUdpPortList:
+        case SyntaxKind::NonAnsiUdpPortList:
+        case SyntaxKind::WildcardUdpPortList:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool UnconditionalBranchDirectiveSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ElseDirective:
+        case SyntaxKind::EndIfDirective:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax UnconditionalBranchDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return &disabledTokens;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax UnconditionalBranchDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return &disabledTokens;
+        default: return nullptr;
+    }
+}
+
+void UnconditionalBranchDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: disabledTokens = child.node()->as<TokenList>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+UnconditionalBranchDirectiveSyntax* UnconditionalBranchDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<UnconditionalBranchDirectiveSyntax>(*this);
+}
+
+bool UnconnectedDriveDirectiveSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::UnconnectedDriveDirective;
+}
+
+TokenOrSyntax UnconnectedDriveDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return strength;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax UnconnectedDriveDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return strength;
+        default: return nullptr;
+    }
+}
+
+void UnconnectedDriveDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: strength = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+UnconnectedDriveDirectiveSyntax* UnconnectedDriveDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<UnconnectedDriveDirectiveSyntax>(*this);
+}
+
+bool UndefDirectiveSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::UndefDirective;
+}
+
+TokenOrSyntax UndefDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return name;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax UndefDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return name;
+        default: return nullptr;
+    }
+}
+
+void UndefDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: name = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+UndefDirectiveSyntax* UndefDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<UndefDirectiveSyntax>(*this);
+}
+
+bool UniquenessConstraintSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::UniquenessConstraint;
+}
+
+TokenOrSyntax UniquenessConstraintSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return unique;
+        case 1: return ranges.get();
+        case 2: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax UniquenessConstraintSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return unique;
+        case 1: return ranges.get();
+        case 2: return semi;
+        default: return nullptr;
+    }
+}
+
+void UniquenessConstraintSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: unique = child.token(); return;
+        case 1: ranges = &child.node()->as<OpenRangeListSyntax>(); return;
+        case 2: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+UniquenessConstraintSyntax* UniquenessConstraintSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<UniquenessConstraintSyntax>(*this);
+}
+
+bool UserDefinedNetDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::UserDefinedNetDeclaration;
+}
+
+TokenOrSyntax UserDefinedNetDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return netType;
+        case 2: return delay.get();
+        case 3: return &declarators;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax UserDefinedNetDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return netType;
+        case 2: return delay.get();
+        case 3: return &declarators;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void UserDefinedNetDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: netType = child.token(); return;
+        case 2: delay = &child.node()->as<TimingControlSyntax>(); return;
+        case 3: declarators = child.node()->as<SeparatedSyntaxList<DeclaratorSyntax>>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+UserDefinedNetDeclarationSyntax* UserDefinedNetDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<UserDefinedNetDeclarationSyntax>(*this);
+}
+
+bool VariableDimensionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::VariableDimension;
+}
+
+TokenOrSyntax VariableDimensionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBracket;
+        case 1: return specifier;
+        case 2: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax VariableDimensionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBracket;
+        case 1: return specifier;
+        case 2: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+void VariableDimensionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBracket = child.token(); return;
+        case 1: specifier = &child.node()->as<DimensionSpecifierSyntax>(); return;
+        case 2: closeBracket = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+VariableDimensionSyntax* VariableDimensionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<VariableDimensionSyntax>(*this);
+}
+
+bool VariablePatternSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::VariablePattern;
+}
+
+TokenOrSyntax VariablePatternSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return dot;
+        case 1: return variableName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax VariablePatternSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return dot;
+        case 1: return variableName;
+        default: return nullptr;
+    }
+}
+
+void VariablePatternSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: dot = child.token(); return;
+        case 1: variableName = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+VariablePatternSyntax* VariablePatternSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<VariablePatternSyntax>(*this);
+}
+
+bool VariablePortHeaderSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::VariablePortHeader;
+}
+
+TokenOrSyntax VariablePortHeaderSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return constKeyword;
+        case 1: return direction;
+        case 2: return varKeyword;
+        case 3: return dataType.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax VariablePortHeaderSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return constKeyword;
+        case 1: return direction;
+        case 2: return varKeyword;
+        case 3: return dataType.get();
+        default: return nullptr;
+    }
+}
+
+void VariablePortHeaderSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: constKeyword = child.token(); return;
+        case 1: direction = child.token(); return;
+        case 2: varKeyword = child.token(); return;
+        case 3: dataType = &child.node()->as<DataTypeSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+VariablePortHeaderSyntax* VariablePortHeaderSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<VariablePortHeaderSyntax>(*this);
+}
+
+bool VirtualInterfaceTypeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::VirtualInterfaceType;
+}
+
+TokenOrSyntax VirtualInterfaceTypeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return virtualKeyword;
+        case 1: return interfaceKeyword;
+        case 2: return name;
+        case 3: return parameters;
+        case 4: return modport;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax VirtualInterfaceTypeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return virtualKeyword;
+        case 1: return interfaceKeyword;
+        case 2: return name;
+        case 3: return parameters;
+        case 4: return modport;
+        default: return nullptr;
+    }
+}
+
+void VirtualInterfaceTypeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: virtualKeyword = child.token(); return;
+        case 1: interfaceKeyword = child.token(); return;
+        case 2: name = child.token(); return;
+        case 3: parameters = &child.node()->as<ParameterValueAssignmentSyntax>(); return;
+        case 4: modport = &child.node()->as<DotMemberClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+VirtualInterfaceTypeSyntax* VirtualInterfaceTypeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<VirtualInterfaceTypeSyntax>(*this);
+}
+
+bool VoidCastedCallStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::VoidCastedCallStatement;
+}
+
+TokenOrSyntax VoidCastedCallStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return voidKeyword;
+        case 3: return apostrophe;
+        case 4: return openParen;
+        case 5: return expr.get();
+        case 6: return closeParen;
+        case 7: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax VoidCastedCallStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return voidKeyword;
+        case 3: return apostrophe;
+        case 4: return openParen;
+        case 5: return expr.get();
+        case 6: return closeParen;
+        case 7: return semi;
+        default: return nullptr;
+    }
+}
+
+void VoidCastedCallStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: voidKeyword = child.token(); return;
+        case 3: apostrophe = child.token(); return;
+        case 4: openParen = child.token(); return;
+        case 5: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 6: closeParen = child.token(); return;
+        case 7: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+VoidCastedCallStatementSyntax* VoidCastedCallStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<VoidCastedCallStatementSyntax>(*this);
+}
+
+bool WaitForkStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WaitForkStatement;
+}
+
+TokenOrSyntax WaitForkStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return wait;
+        case 3: return fork;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WaitForkStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return wait;
+        case 3: return fork;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void WaitForkStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: wait = child.token(); return;
+        case 3: fork = child.token(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WaitForkStatementSyntax* WaitForkStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WaitForkStatementSyntax>(*this);
+}
+
+bool WaitOrderStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WaitOrderStatement;
+}
+
+TokenOrSyntax WaitOrderStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return wait_order;
+        case 3: return openParen;
+        case 4: return &names;
+        case 5: return closeParen;
+        case 6: return action.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WaitOrderStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return wait_order;
+        case 3: return openParen;
+        case 4: return &names;
+        case 5: return closeParen;
+        case 6: return action.get();
+        default: return nullptr;
+    }
+}
+
+void WaitOrderStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: wait_order = child.token(); return;
+        case 3: openParen = child.token(); return;
+        case 4: names = child.node()->as<SeparatedSyntaxList<NameSyntax>>(); return;
+        case 5: closeParen = child.token(); return;
+        case 6: action = &child.node()->as<ActionBlockSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WaitOrderStatementSyntax* WaitOrderStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WaitOrderStatementSyntax>(*this);
+}
+
+bool WaitStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WaitStatement;
+}
+
+TokenOrSyntax WaitStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return wait;
+        case 3: return openParen;
+        case 4: return expr.get();
+        case 5: return closeParen;
+        case 6: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WaitStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return wait;
+        case 3: return openParen;
+        case 4: return expr.get();
+        case 5: return closeParen;
+        case 6: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void WaitStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: wait = child.token(); return;
+        case 3: openParen = child.token(); return;
+        case 4: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 5: closeParen = child.token(); return;
+        case 6: statement = &child.node()->as<StatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WaitStatementSyntax* WaitStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WaitStatementSyntax>(*this);
+}
+
+bool WildcardDimensionSpecifierSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WildcardDimensionSpecifier;
+}
+
+TokenOrSyntax WildcardDimensionSpecifierSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return star;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WildcardDimensionSpecifierSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return star;
+        default: return nullptr;
+    }
+}
+
+void WildcardDimensionSpecifierSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: star = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WildcardDimensionSpecifierSyntax* WildcardDimensionSpecifierSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WildcardDimensionSpecifierSyntax>(*this);
+}
+
+bool WildcardPatternSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WildcardPattern;
+}
+
+TokenOrSyntax WildcardPatternSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return dotStar;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WildcardPatternSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return dotStar;
+        default: return nullptr;
+    }
+}
+
+void WildcardPatternSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: dotStar = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WildcardPatternSyntax* WildcardPatternSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WildcardPatternSyntax>(*this);
+}
+
+bool WildcardPortConnectionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WildcardPortConnection;
+}
+
+TokenOrSyntax WildcardPortConnectionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return dotStar;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WildcardPortConnectionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return dotStar;
+        default: return nullptr;
+    }
+}
+
+void WildcardPortConnectionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: dotStar = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WildcardPortConnectionSyntax* WildcardPortConnectionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WildcardPortConnectionSyntax>(*this);
+}
+
+bool WildcardPortListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WildcardPortList;
+}
+
+TokenOrSyntax WildcardPortListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return dotStar;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WildcardPortListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return dotStar;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void WildcardPortListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: dotStar = child.token(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WildcardPortListSyntax* WildcardPortListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WildcardPortListSyntax>(*this);
+}
+
+bool WildcardUdpPortListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WildcardUdpPortList;
+}
+
+TokenOrSyntax WildcardUdpPortListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return dotStar;
+        case 2: return closeParen;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WildcardUdpPortListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return dotStar;
+        case 2: return closeParen;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void WildcardUdpPortListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: dotStar = child.token(); return;
+        case 2: closeParen = child.token(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WildcardUdpPortListSyntax* WildcardUdpPortListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WildcardUdpPortListSyntax>(*this);
+}
+
+bool WithClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WithClause;
+}
+
+TokenOrSyntax WithClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return with;
+        case 1: return openParen;
+        case 2: return expr.get();
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WithClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return with;
+        case 1: return openParen;
+        case 2: return expr.get();
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void WithClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: with = child.token(); return;
+        case 1: openParen = child.token(); return;
+        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WithClauseSyntax* WithClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WithClauseSyntax>(*this);
+}
+
+bool WithFunctionClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WithFunctionClause;
+}
+
+TokenOrSyntax WithFunctionClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return with;
+        case 1: return name.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WithFunctionClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return with;
+        case 1: return name.get();
+        default: return nullptr;
+    }
+}
+
+void WithFunctionClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: with = child.token(); return;
+        case 1: name = &child.node()->as<NameSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WithFunctionClauseSyntax* WithFunctionClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WithFunctionClauseSyntax>(*this);
+}
+
+bool WithFunctionSampleSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WithFunctionSample;
+}
+
+TokenOrSyntax WithFunctionSampleSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return with;
+        case 1: return function;
+        case 2: return sample;
+        case 3: return portList.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WithFunctionSampleSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return with;
+        case 1: return function;
+        case 2: return sample;
+        case 3: return portList.get();
+        default: return nullptr;
+    }
+}
+
+void WithFunctionSampleSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: with = child.token(); return;
+        case 1: function = child.token(); return;
+        case 2: sample = child.token(); return;
+        case 3: portList = &child.node()->as<AnsiPortListSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WithFunctionSampleSyntax* WithFunctionSampleSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WithFunctionSampleSyntax>(*this);
+}
+
+ActionBlockSyntax& SyntaxFactory::actionBlock(StatementSyntax* statement, ElseClauseSyntax* elseClause) {
+    return *alloc.emplace<ActionBlockSyntax>(statement, elseClause);
+}
+
+AnsiPortListSyntax& SyntaxFactory::ansiPortList(Token openParen, const SeparatedSyntaxList<MemberSyntax>& ports, Token closeParen) {
+    return *alloc.emplace<AnsiPortListSyntax>(openParen, ports, closeParen);
+}
+
+AnsiUdpPortListSyntax& SyntaxFactory::ansiUdpPortList(Token openParen, const SeparatedSyntaxList<UdpPortDeclSyntax>& ports, Token closeParen, Token semi) {
+    return *alloc.emplace<AnsiUdpPortListSyntax>(openParen, ports, closeParen, semi);
+}
+
+ArgumentListSyntax& SyntaxFactory::argumentList(Token openParen, const SeparatedSyntaxList<ArgumentSyntax>& parameters, Token closeParen) {
+    return *alloc.emplace<ArgumentListSyntax>(openParen, parameters, closeParen);
+}
+
+ArrayOrRandomizeMethodExpressionSyntax& SyntaxFactory::arrayOrRandomizeMethodExpression(ExpressionSyntax& method, Token with, ParenExpressionListSyntax* args, ConstraintBlockSyntax* constraints) {
+    return *alloc.emplace<ArrayOrRandomizeMethodExpressionSyntax>(method, with, args, constraints);
+}
+
+AssertionItemPortListSyntax& SyntaxFactory::assertionItemPortList(Token openParen, const SeparatedSyntaxList<AssertionItemPortSyntax>& ports, Token closeParen) {
+    return *alloc.emplace<AssertionItemPortListSyntax>(openParen, ports, closeParen);
+}
+
+AssertionItemPortSyntax& SyntaxFactory::assertionItemPort(const SyntaxList<AttributeInstanceSyntax>& attributes, Token local, Token direction, DataTypeSyntax& type, DeclaratorSyntax& declarator) {
+    return *alloc.emplace<AssertionItemPortSyntax>(attributes, local, direction, type, declarator);
+}
+
+AssignmentPatternExpressionSyntax& SyntaxFactory::assignmentPatternExpression(DataTypeSyntax* type, AssignmentPatternSyntax& pattern) {
+    return *alloc.emplace<AssignmentPatternExpressionSyntax>(type, pattern);
+}
+
+AssignmentPatternItemSyntax& SyntaxFactory::assignmentPatternItem(ExpressionSyntax& key, Token colon, ExpressionSyntax& expr) {
+    return *alloc.emplace<AssignmentPatternItemSyntax>(key, colon, expr);
+}
+
+AttributeInstanceSyntax& SyntaxFactory::attributeInstance(Token openParen, const SeparatedSyntaxList<AttributeSpecSyntax>& specs, Token closeParen) {
+    return *alloc.emplace<AttributeInstanceSyntax>(openParen, specs, closeParen);
+}
+
+AttributeSpecSyntax& SyntaxFactory::attributeSpec(Token name, EqualsValueClauseSyntax* value) {
+    return *alloc.emplace<AttributeSpecSyntax>(name, value);
+}
+
+BadExpressionSyntax& SyntaxFactory::badExpression(ExpressionSyntax& expr) {
+    return *alloc.emplace<BadExpressionSyntax>(expr);
+}
+
+BeginKeywordsDirectiveSyntax& SyntaxFactory::beginKeywordsDirective(Token directive, Token versionSpecifier) {
+    return *alloc.emplace<BeginKeywordsDirectiveSyntax>(directive, versionSpecifier);
+}
+
+BinaryBlockEventExpressionSyntax& SyntaxFactory::binaryBlockEventExpression(BlockEventExpressionSyntax& left, Token orKeyword, BlockEventExpressionSyntax& right) {
+    return *alloc.emplace<BinaryBlockEventExpressionSyntax>(left, orKeyword, right);
+}
+
+BinaryEventExpressionSyntax& SyntaxFactory::binaryEventExpression(EventExpressionSyntax& left, Token operatorToken, EventExpressionSyntax& right) {
+    return *alloc.emplace<BinaryEventExpressionSyntax>(left, operatorToken, right);
+}
+
+BinaryExpressionSyntax& SyntaxFactory::binaryExpression(SyntaxKind kind, ExpressionSyntax& left, Token operatorToken, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& right) {
+    return *alloc.emplace<BinaryExpressionSyntax>(kind, left, operatorToken, attributes, right);
+}
+
+BindDirectiveSyntax& SyntaxFactory::bindDirective(const SyntaxList<AttributeInstanceSyntax>& attributes, Token bind, NameSyntax& target, BindTargetListSyntax* targetInstances, HierarchyInstantiationSyntax& instantiation) {
+    return *alloc.emplace<BindDirectiveSyntax>(attributes, bind, target, targetInstances, instantiation);
+}
+
+BindTargetListSyntax& SyntaxFactory::bindTargetList(Token colon, const SeparatedSyntaxList<NameSyntax>& targets) {
+    return *alloc.emplace<BindTargetListSyntax>(colon, targets);
+}
+
+BitSelectSyntax& SyntaxFactory::bitSelect(ExpressionSyntax& expr) {
+    return *alloc.emplace<BitSelectSyntax>(expr);
+}
+
+BlockCoverageEventSyntax& SyntaxFactory::blockCoverageEvent(Token atat, Token openParen, BlockEventExpressionSyntax& expr, Token closeParen) {
+    return *alloc.emplace<BlockCoverageEventSyntax>(atat, openParen, expr, closeParen);
+}
+
+BlockStatementSyntax& SyntaxFactory::blockStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token begin, NamedBlockClauseSyntax* blockName, const SyntaxList<SyntaxNode>& items, Token end, NamedBlockClauseSyntax* endBlockName) {
+    return *alloc.emplace<BlockStatementSyntax>(kind, label, attributes, begin, blockName, items, end, endBlockName);
+}
+
+CaseGenerateSyntax& SyntaxFactory::caseGenerate(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, const SyntaxList<CaseItemSyntax>& items, Token endCase) {
+    return *alloc.emplace<CaseGenerateSyntax>(attributes, keyword, openParen, condition, closeParen, items, endCase);
+}
+
+CaseStatementSyntax& SyntaxFactory::caseStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token uniqueOrPriority, Token caseKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token matchesOrInside, const SyntaxList<CaseItemSyntax>& items, Token endcase) {
+    return *alloc.emplace<CaseStatementSyntax>(label, attributes, uniqueOrPriority, caseKeyword, openParen, expr, closeParen, matchesOrInside, items, endcase);
+}
+
+CastExpressionSyntax& SyntaxFactory::castExpression(ExpressionSyntax& left, Token apostrophe, ParenthesizedExpressionSyntax& right) {
+    return *alloc.emplace<CastExpressionSyntax>(left, apostrophe, right);
+}
+
+ChargeStrengthSyntax& SyntaxFactory::chargeStrength(Token openParen, Token strength, Token closeParen) {
+    return *alloc.emplace<ChargeStrengthSyntax>(openParen, strength, closeParen);
+}
+
+ClassDeclarationSyntax& SyntaxFactory::classDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token virtualOrInterface, Token classKeyword, Token lifetime, Token name, ParameterPortListSyntax* parameters, ExtendsClauseSyntax* extendsClause, ImplementsClauseSyntax* implementsClause, Token semi, const SyntaxList<MemberSyntax>& items, Token endClass, NamedBlockClauseSyntax* endBlockName) {
+    return *alloc.emplace<ClassDeclarationSyntax>(attributes, virtualOrInterface, classKeyword, lifetime, name, parameters, extendsClause, implementsClause, semi, items, endClass, endBlockName);
+}
+
+ClassMethodDeclarationSyntax& SyntaxFactory::classMethodDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, FunctionDeclarationSyntax& declaration) {
+    return *alloc.emplace<ClassMethodDeclarationSyntax>(attributes, qualifiers, declaration);
+}
+
+ClassMethodPrototypeSyntax& SyntaxFactory::classMethodPrototype(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, FunctionPrototypeSyntax& prototype, Token semi) {
+    return *alloc.emplace<ClassMethodPrototypeSyntax>(attributes, qualifiers, prototype, semi);
+}
+
+ClassNameSyntax& SyntaxFactory::className(Token identifier, ParameterValueAssignmentSyntax& parameters) {
+    return *alloc.emplace<ClassNameSyntax>(identifier, parameters);
+}
+
+ClassPropertyDeclarationSyntax& SyntaxFactory::classPropertyDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, MemberSyntax& declaration) {
+    return *alloc.emplace<ClassPropertyDeclarationSyntax>(attributes, qualifiers, declaration);
+}
+
+ClockingDeclarationSyntax& SyntaxFactory::clockingDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token globalOrDefault, Token clocking, Token blockName, Token at, EventExpressionSyntax& event, Token semi, const SyntaxList<MemberSyntax>& items, Token endClocking, NamedBlockClauseSyntax* endBlockName) {
+    return *alloc.emplace<ClockingDeclarationSyntax>(attributes, globalOrDefault, clocking, blockName, at, event, semi, items, endClocking, endBlockName);
+}
+
+ClockingDirectionSyntax& SyntaxFactory::clockingDirection(Token input, ClockingSkewSyntax* inputSkew, Token output, ClockingSkewSyntax* ouputSkew) {
+    return *alloc.emplace<ClockingDirectionSyntax>(input, inputSkew, output, ouputSkew);
+}
+
+ClockingItemSyntax& SyntaxFactory::clockingItem(const SyntaxList<AttributeInstanceSyntax>& attributes, ClockingDirectionSyntax& direction, const SeparatedSyntaxList<AttributeSpecSyntax>& decls, Token semi) {
+    return *alloc.emplace<ClockingItemSyntax>(attributes, direction, decls, semi);
+}
+
+ClockingSkewSyntax& SyntaxFactory::clockingSkew(Token edge, DelaySyntax* delay) {
+    return *alloc.emplace<ClockingSkewSyntax>(edge, delay);
+}
+
+ColonExpressionClauseSyntax& SyntaxFactory::colonExpressionClause(Token colon, ExpressionSyntax& expr) {
+    return *alloc.emplace<ColonExpressionClauseSyntax>(colon, expr);
+}
+
+CompilationUnitSyntax& SyntaxFactory::compilationUnit(const SyntaxList<MemberSyntax>& members, Token endOfFile) {
+    return *alloc.emplace<CompilationUnitSyntax>(members, endOfFile);
+}
+
+ConcatenationExpressionSyntax& SyntaxFactory::concatenationExpression(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token closeBrace) {
+    return *alloc.emplace<ConcatenationExpressionSyntax>(openBrace, expressions, closeBrace);
+}
+
+ConcurrentAssertionMemberSyntax& SyntaxFactory::concurrentAssertionMember(const SyntaxList<AttributeInstanceSyntax>& attributes, ConcurrentAssertionStatementSyntax& statement) {
+    return *alloc.emplace<ConcurrentAssertionMemberSyntax>(attributes, statement);
+}
+
+ConcurrentAssertionStatementSyntax& SyntaxFactory::concurrentAssertionStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token propertyOrSequence, Token openParen, PropertySpecSyntax& propertySpec, Token closeParen, ActionBlockSyntax& action) {
+    return *alloc.emplace<ConcurrentAssertionStatementSyntax>(kind, label, attributes, keyword, propertyOrSequence, openParen, propertySpec, closeParen, action);
+}
+
+ConditionalBranchDirectiveSyntax& SyntaxFactory::conditionalBranchDirective(SyntaxKind kind, Token directive, Token name, const TokenList& disabledTokens) {
+    return *alloc.emplace<ConditionalBranchDirectiveSyntax>(kind, directive, name, disabledTokens);
+}
+
+ConditionalConstraintSyntax& SyntaxFactory::conditionalConstraint(Token ifKeyword, Token openParen, ExpressionSyntax& condition, Token closeParen, ConstraintItemSyntax& constraints, ElseConstraintClauseSyntax* elseClause) {
+    return *alloc.emplace<ConditionalConstraintSyntax>(ifKeyword, openParen, condition, closeParen, constraints, elseClause);
+}
+
+ConditionalExpressionSyntax& SyntaxFactory::conditionalExpression(ConditionalPredicateSyntax& predicate, Token question, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& left, Token colon, ExpressionSyntax& right) {
+    return *alloc.emplace<ConditionalExpressionSyntax>(predicate, question, attributes, left, colon, right);
+}
+
+ConditionalPathDeclarationSyntax& SyntaxFactory::conditionalPathDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& predicate, Token closeParen, PathDeclarationSyntax& path) {
+    return *alloc.emplace<ConditionalPathDeclarationSyntax>(attributes, keyword, openParen, predicate, closeParen, path);
+}
+
+ConditionalPatternSyntax& SyntaxFactory::conditionalPattern(ExpressionSyntax& expr, MatchesClauseSyntax* matchesClause) {
+    return *alloc.emplace<ConditionalPatternSyntax>(expr, matchesClause);
+}
+
+ConditionalPredicateSyntax& SyntaxFactory::conditionalPredicate(const SeparatedSyntaxList<ConditionalPatternSyntax>& conditions) {
+    return *alloc.emplace<ConditionalPredicateSyntax>(conditions);
+}
+
+ConditionalStatementSyntax& SyntaxFactory::conditionalStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token uniqueOrPriority, Token ifKeyword, Token openParen, ConditionalPredicateSyntax& predicate, Token closeParen, StatementSyntax& statement, ElseClauseSyntax* elseClause) {
+    return *alloc.emplace<ConditionalStatementSyntax>(label, attributes, uniqueOrPriority, ifKeyword, openParen, predicate, closeParen, statement, elseClause);
+}
+
+ConstraintBlockSyntax& SyntaxFactory::constraintBlock(Token openBrace, const SyntaxList<ConstraintItemSyntax>& items, Token closeBrace) {
+    return *alloc.emplace<ConstraintBlockSyntax>(openBrace, items, closeBrace);
+}
+
+ConstraintDeclarationSyntax& SyntaxFactory::constraintDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token keyword, NameSyntax& name, ConstraintBlockSyntax& block) {
+    return *alloc.emplace<ConstraintDeclarationSyntax>(attributes, qualifiers, keyword, name, block);
+}
+
+ConstraintPrototypeSyntax& SyntaxFactory::constraintPrototype(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token keyword, NameSyntax& name, Token semi) {
+    return *alloc.emplace<ConstraintPrototypeSyntax>(attributes, qualifiers, keyword, name, semi);
+}
+
+ContinuousAssignSyntax& SyntaxFactory::continuousAssign(const SyntaxList<AttributeInstanceSyntax>& attributes, Token assign, DriveStrengthSyntax* strength, TimingControlSyntax* delay, const SeparatedSyntaxList<ExpressionSyntax>& assignments, Token semi) {
+    return *alloc.emplace<ContinuousAssignSyntax>(attributes, assign, strength, delay, assignments, semi);
+}
+
+CopyClassExpressionSyntax& SyntaxFactory::copyClassExpression(NameSyntax& scopedNew, ExpressionSyntax& expr) {
+    return *alloc.emplace<CopyClassExpressionSyntax>(scopedNew, expr);
+}
+
+CoverageBinsSyntax& SyntaxFactory::coverageBins(const SyntaxList<AttributeInstanceSyntax>& attributes, Token wildcard, Token keyword, Token name, ElementSelectSyntax* selector, Token equals, CoverageBinInitializerSyntax& initializer, CoverageIffClauseSyntax* iff, Token semi) {
+    return *alloc.emplace<CoverageBinsSyntax>(attributes, wildcard, keyword, name, selector, equals, initializer, iff, semi);
+}
+
+CoverageIffClauseSyntax& SyntaxFactory::coverageIffClause(Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen) {
+    return *alloc.emplace<CoverageIffClauseSyntax>(iff, openParen, expr, closeParen);
+}
+
+CoverageOptionSyntax& SyntaxFactory::coverageOption(const SyntaxList<AttributeInstanceSyntax>& attributes, Token option, Token dot, Token name, Token equals, ExpressionSyntax& expr, Token semi) {
+    return *alloc.emplace<CoverageOptionSyntax>(attributes, option, dot, name, equals, expr, semi);
+}
+
+CovergroupDeclarationSyntax& SyntaxFactory::covergroupDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token covergroup, Token name, AnsiPortListSyntax* portList, SyntaxNode* event, Token semi, const SyntaxList<MemberSyntax>& members, Token endgroup, NamedBlockClauseSyntax* endBlockName) {
+    return *alloc.emplace<CovergroupDeclarationSyntax>(attributes, covergroup, name, portList, event, semi, members, endgroup, endBlockName);
+}
+
+CoverpointSyntax& SyntaxFactory::coverpoint(const SyntaxList<AttributeInstanceSyntax>& attributes, DataTypeSyntax* type, NamedLabelSyntax* label, Token coverpoint, ExpressionSyntax& expr, Token openBrace, const SyntaxList<MemberSyntax>& members, Token closeBrace, Token emptySemi) {
+    return *alloc.emplace<CoverpointSyntax>(attributes, type, label, coverpoint, expr, openBrace, members, closeBrace, emptySemi);
+}
+
+DPIExportSyntax& SyntaxFactory::dPIExport(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token specString, Token c_identifier, Token equals, Token functionOrTask, Token name, Token semi) {
+    return *alloc.emplace<DPIExportSyntax>(attributes, keyword, specString, c_identifier, equals, functionOrTask, name, semi);
+}
+
+DPIImportSyntax& SyntaxFactory::dPIImport(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token specString, Token property, Token c_identifier, Token equals, FunctionPrototypeSyntax& method, Token semi) {
+    return *alloc.emplace<DPIImportSyntax>(attributes, keyword, specString, property, c_identifier, equals, method, semi);
+}
+
+DataDeclarationSyntax& SyntaxFactory::dataDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& modifiers, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) {
+    return *alloc.emplace<DataDeclarationSyntax>(attributes, modifiers, type, declarators, semi);
+}
+
+DeclaratorSyntax& SyntaxFactory::declarator(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, EqualsValueClauseSyntax* initializer) {
+    return *alloc.emplace<DeclaratorSyntax>(name, dimensions, initializer);
+}
+
+DefParamAssignmentSyntax& SyntaxFactory::defParamAssignment(NameSyntax& name, EqualsValueClauseSyntax& setter) {
+    return *alloc.emplace<DefParamAssignmentSyntax>(name, setter);
+}
+
+DefParamSyntax& SyntaxFactory::defParam(const SyntaxList<AttributeInstanceSyntax>& attributes, Token defparam, const SeparatedSyntaxList<DefParamAssignmentSyntax>& assignments, Token semi) {
+    return *alloc.emplace<DefParamSyntax>(attributes, defparam, assignments, semi);
+}
+
+DefaultCaseItemSyntax& SyntaxFactory::defaultCaseItem(Token defaultKeyword, Token colon, SyntaxNode& clause) {
+    return *alloc.emplace<DefaultCaseItemSyntax>(defaultKeyword, colon, clause);
+}
+
+DefaultClockingReferenceSyntax& SyntaxFactory::defaultClockingReference(const SyntaxList<AttributeInstanceSyntax>& attributes, Token defaultKeyword, Token clocking, Token name, Token semi) {
+    return *alloc.emplace<DefaultClockingReferenceSyntax>(attributes, defaultKeyword, clocking, name, semi);
+}
+
+DefaultCoverageBinInitializerSyntax& SyntaxFactory::defaultCoverageBinInitializer(Token defaultKeyword, Token sequenceKeyword) {
+    return *alloc.emplace<DefaultCoverageBinInitializerSyntax>(defaultKeyword, sequenceKeyword);
+}
+
+DefaultNetTypeDirectiveSyntax& SyntaxFactory::defaultNetTypeDirective(Token directive, Token netType) {
+    return *alloc.emplace<DefaultNetTypeDirectiveSyntax>(directive, netType);
+}
+
+DefaultSkewItemSyntax& SyntaxFactory::defaultSkewItem(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ClockingDirectionSyntax& direction, Token semi) {
+    return *alloc.emplace<DefaultSkewItemSyntax>(attributes, keyword, direction, semi);
+}
+
+DeferredAssertionSyntax& SyntaxFactory::deferredAssertion(Token hash, Token zero, Token finalKeyword) {
+    return *alloc.emplace<DeferredAssertionSyntax>(hash, zero, finalKeyword);
+}
+
+DefineDirectiveSyntax& SyntaxFactory::defineDirective(Token directive, Token name, MacroFormalArgumentListSyntax* formalArguments, const TokenList& body) {
+    return *alloc.emplace<DefineDirectiveSyntax>(directive, name, formalArguments, body);
+}
+
+Delay3Syntax& SyntaxFactory::delay3(Token hash, Token openParen, ExpressionSyntax& delay1, Token comma1, ExpressionSyntax* delay2, Token comma2, ExpressionSyntax* delay3, Token closeParen) {
+    return *alloc.emplace<Delay3Syntax>(hash, openParen, delay1, comma1, delay2, comma2, delay3, closeParen);
+}
+
+DelaySyntax& SyntaxFactory::delay(SyntaxKind kind, Token hash, ExpressionSyntax& delayValue) {
+    return *alloc.emplace<DelaySyntax>(kind, hash, delayValue);
+}
+
+DelayedTerminalArgSyntax& SyntaxFactory::delayedTerminalArg(Token terminal, Token openBracket, ExpressionSyntax& expr, Token closeBracket) {
+    return *alloc.emplace<DelayedTerminalArgSyntax>(terminal, openBracket, expr, closeBracket);
+}
+
+DisableConstraintSyntax& SyntaxFactory::disableConstraint(Token disable, Token soft, NameSyntax& name, Token semi) {
+    return *alloc.emplace<DisableConstraintSyntax>(disable, soft, name, semi);
+}
+
+DisableForkStatementSyntax& SyntaxFactory::disableForkStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token disable, Token fork, Token semi) {
+    return *alloc.emplace<DisableForkStatementSyntax>(label, attributes, disable, fork, semi);
+}
+
+DisableIffSyntax& SyntaxFactory::disableIff(Token disable, Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen) {
+    return *alloc.emplace<DisableIffSyntax>(disable, iff, openParen, expr, closeParen);
+}
+
+DisableStatementSyntax& SyntaxFactory::disableStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token disable, NameSyntax& name, Token semi) {
+    return *alloc.emplace<DisableStatementSyntax>(label, attributes, disable, name, semi);
+}
+
+DistConstraintListSyntax& SyntaxFactory::distConstraintList(Token dist, Token openBrace, const SeparatedSyntaxList<DistItemSyntax>& items, Token closeBrace) {
+    return *alloc.emplace<DistConstraintListSyntax>(dist, openBrace, items, closeBrace);
+}
+
+DistItemSyntax& SyntaxFactory::distItem(ExpressionSyntax& range, DistWeightSyntax* weight) {
+    return *alloc.emplace<DistItemSyntax>(range, weight);
+}
+
+DistWeightSyntax& SyntaxFactory::distWeight(Token op, ExpressionSyntax& expr) {
+    return *alloc.emplace<DistWeightSyntax>(op, expr);
+}
+
+DividerClauseSyntax& SyntaxFactory::dividerClause(Token divide, Token value) {
+    return *alloc.emplace<DividerClauseSyntax>(divide, value);
+}
+
+DoWhileStatementSyntax& SyntaxFactory::doWhileStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token doKeyword, StatementSyntax& statement, Token whileKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi) {
+    return *alloc.emplace<DoWhileStatementSyntax>(label, attributes, doKeyword, statement, whileKeyword, openParen, expr, closeParen, semi);
+}
+
+DotMemberClauseSyntax& SyntaxFactory::dotMemberClause(Token dot, Token member) {
+    return *alloc.emplace<DotMemberClauseSyntax>(dot, member);
+}
+
+DriveStrengthSyntax& SyntaxFactory::driveStrength(Token openParen, Token strength0, Token comma, Token strength1, Token closeParen) {
+    return *alloc.emplace<DriveStrengthSyntax>(openParen, strength0, comma, strength1, closeParen);
+}
+
+EdgeControlSpecifierSyntax& SyntaxFactory::edgeControlSpecifier(Token openBracket, const SeparatedSyntaxList<EdgeDescriptorSyntax>& descriptors, Token closeBracket) {
+    return *alloc.emplace<EdgeControlSpecifierSyntax>(openBracket, descriptors, closeBracket);
+}
+
+EdgeDescriptorSyntax& SyntaxFactory::edgeDescriptor(Token t1, Token t2) {
+    return *alloc.emplace<EdgeDescriptorSyntax>(t1, t2);
+}
+
+EdgeSensitivePathSuffixSyntax& SyntaxFactory::edgeSensitivePathSuffix(Token openParen, const SeparatedSyntaxList<NameSyntax>& outputs, Token polarityOperator, Token colon, ExpressionSyntax& expr, Token closeParen) {
+    return *alloc.emplace<EdgeSensitivePathSuffixSyntax>(openParen, outputs, polarityOperator, colon, expr, closeParen);
+}
+
+ElabSystemTaskSyntax& SyntaxFactory::elabSystemTask(const SyntaxList<AttributeInstanceSyntax>& attributes, Token name, ArgumentListSyntax* arguments, Token semi) {
+    return *alloc.emplace<ElabSystemTaskSyntax>(attributes, name, arguments, semi);
+}
+
+ElementSelectExpressionSyntax& SyntaxFactory::elementSelectExpression(ExpressionSyntax& left, ElementSelectSyntax& select) {
+    return *alloc.emplace<ElementSelectExpressionSyntax>(left, select);
+}
+
+ElementSelectSyntax& SyntaxFactory::elementSelect(Token openBracket, SelectorSyntax* selector, Token closeBracket) {
+    return *alloc.emplace<ElementSelectSyntax>(openBracket, selector, closeBracket);
+}
+
+ElseClauseSyntax& SyntaxFactory::elseClause(Token elseKeyword, SyntaxNode& clause) {
+    return *alloc.emplace<ElseClauseSyntax>(elseKeyword, clause);
+}
+
+ElseConstraintClauseSyntax& SyntaxFactory::elseConstraintClause(Token elseKeyword, ConstraintItemSyntax& constraints) {
+    return *alloc.emplace<ElseConstraintClauseSyntax>(elseKeyword, constraints);
+}
+
+EmptyArgumentSyntax& SyntaxFactory::emptyArgument(Token placeholder) {
+    return *alloc.emplace<EmptyArgumentSyntax>(placeholder);
+}
+
+EmptyIdentifierNameSyntax& SyntaxFactory::emptyIdentifierName(Token placeholder) {
+    return *alloc.emplace<EmptyIdentifierNameSyntax>(placeholder);
+}
+
+EmptyMemberSyntax& SyntaxFactory::emptyMember(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token semi) {
+    return *alloc.emplace<EmptyMemberSyntax>(attributes, qualifiers, semi);
+}
+
+EmptyPortConnectionSyntax& SyntaxFactory::emptyPortConnection(const SyntaxList<AttributeInstanceSyntax>& attributes, Token placeholder) {
+    return *alloc.emplace<EmptyPortConnectionSyntax>(attributes, placeholder);
+}
+
+EmptyQueueExpressionSyntax& SyntaxFactory::emptyQueueExpression(Token openBrace, Token closeBrace) {
+    return *alloc.emplace<EmptyQueueExpressionSyntax>(openBrace, closeBrace);
+}
+
+EmptyStatementSyntax& SyntaxFactory::emptyStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token semicolon) {
+    return *alloc.emplace<EmptyStatementSyntax>(label, attributes, semicolon);
+}
+
+EmptyTimingCheckArgSyntax& SyntaxFactory::emptyTimingCheckArg(Token placeholder) {
+    return *alloc.emplace<EmptyTimingCheckArgSyntax>(placeholder);
+}
+
+EnumTypeSyntax& SyntaxFactory::enumType(Token keyword, DataTypeSyntax* baseType, Token openBrace, const SeparatedSyntaxList<DeclaratorSyntax>& members, Token closeBrace, const SyntaxList<VariableDimensionSyntax>& dimensions) {
+    return *alloc.emplace<EnumTypeSyntax>(keyword, baseType, openBrace, members, closeBrace, dimensions);
+}
+
+EqualsTypeClauseSyntax& SyntaxFactory::equalsTypeClause(Token equals, DataTypeSyntax& type) {
+    return *alloc.emplace<EqualsTypeClauseSyntax>(equals, type);
+}
+
+EqualsValueClauseSyntax& SyntaxFactory::equalsValueClause(Token equals, ExpressionSyntax& expr) {
+    return *alloc.emplace<EqualsValueClauseSyntax>(equals, expr);
+}
+
+EventControlSyntax& SyntaxFactory::eventControl(Token at, NameSyntax& eventName) {
+    return *alloc.emplace<EventControlSyntax>(at, eventName);
+}
+
+EventControlWithExpressionSyntax& SyntaxFactory::eventControlWithExpression(Token at, EventExpressionSyntax& expr) {
+    return *alloc.emplace<EventControlWithExpressionSyntax>(at, expr);
+}
+
+EventTriggerStatementSyntax& SyntaxFactory::eventTriggerStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token trigger, TimingControlSyntax* timing, NameSyntax& name, Token semi) {
+    return *alloc.emplace<EventTriggerStatementSyntax>(kind, label, attributes, trigger, timing, name, semi);
+}
+
+ExplicitAnsiPortSyntax& SyntaxFactory::explicitAnsiPort(const SyntaxList<AttributeInstanceSyntax>& attributes, Token direction, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) {
+    return *alloc.emplace<ExplicitAnsiPortSyntax>(attributes, direction, dot, name, openParen, expr, closeParen);
+}
+
+ExplicitNonAnsiPortSyntax& SyntaxFactory::explicitNonAnsiPort(Token dot, Token name, Token openParen, PortExpressionSyntax* expr, Token closeParen) {
+    return *alloc.emplace<ExplicitNonAnsiPortSyntax>(dot, name, openParen, expr, closeParen);
+}
+
+ExpressionConstraintSyntax& SyntaxFactory::expressionConstraint(Token soft, ExpressionSyntax& expr, Token semi) {
+    return *alloc.emplace<ExpressionConstraintSyntax>(soft, expr, semi);
+}
+
+ExpressionCoverageBinInitializerSyntax& SyntaxFactory::expressionCoverageBinInitializer(ExpressionSyntax& expr, WithClauseSyntax* withClause) {
+    return *alloc.emplace<ExpressionCoverageBinInitializerSyntax>(expr, withClause);
+}
+
+ExpressionOrDistSyntax& SyntaxFactory::expressionOrDist(ExpressionSyntax& expr, DistConstraintListSyntax& distribution) {
+    return *alloc.emplace<ExpressionOrDistSyntax>(expr, distribution);
+}
+
+ExpressionPatternSyntax& SyntaxFactory::expressionPattern(ExpressionSyntax& expr) {
+    return *alloc.emplace<ExpressionPatternSyntax>(expr);
+}
+
+ExpressionStatementSyntax& SyntaxFactory::expressionStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& expr, Token semi) {
+    return *alloc.emplace<ExpressionStatementSyntax>(label, attributes, expr, semi);
+}
+
+ExpressionTimingCheckArgSyntax& SyntaxFactory::expressionTimingCheckArg(ExpressionSyntax& expr, TimingCheckConditionSyntax* condition) {
+    return *alloc.emplace<ExpressionTimingCheckArgSyntax>(expr, condition);
+}
+
+ExtendsClauseSyntax& SyntaxFactory::extendsClause(Token keyword, NameSyntax& baseName, ArgumentListSyntax* arguments) {
+    return *alloc.emplace<ExtendsClauseSyntax>(keyword, baseName, arguments);
+}
+
+ExternModuleSyntax& SyntaxFactory::externModule(Token externKeyword, ModuleHeaderSyntax& header) {
+    return *alloc.emplace<ExternModuleSyntax>(externKeyword, header);
+}
+
+ForLoopStatementSyntax& SyntaxFactory::forLoopStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token forKeyword, Token openParen, const SeparatedSyntaxList<SyntaxNode>& initializers, Token semi1, ExpressionSyntax& stopExpr, Token semi2, const SeparatedSyntaxList<ExpressionSyntax>& steps, Token closeParen, StatementSyntax& statement) {
+    return *alloc.emplace<ForLoopStatementSyntax>(label, attributes, forKeyword, openParen, initializers, semi1, stopExpr, semi2, steps, closeParen, statement);
+}
+
+ForVariableDeclarationSyntax& SyntaxFactory::forVariableDeclaration(Token varKeyword, DataTypeSyntax* type, DeclaratorSyntax& declarator) {
+    return *alloc.emplace<ForVariableDeclarationSyntax>(varKeyword, type, declarator);
+}
+
+ForeachLoopListSyntax& SyntaxFactory::foreachLoopList(Token openParen, NameSyntax& arrayName, Token openBracket, const SeparatedSyntaxList<NameSyntax>& loopVariables, Token closeBracket, Token closeParen) {
+    return *alloc.emplace<ForeachLoopListSyntax>(openParen, arrayName, openBracket, loopVariables, closeBracket, closeParen);
+}
+
+ForeachLoopStatementSyntax& SyntaxFactory::foreachLoopStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ForeachLoopListSyntax& loopList, StatementSyntax& statement) {
+    return *alloc.emplace<ForeachLoopStatementSyntax>(label, attributes, keyword, loopList, statement);
+}
+
+ForeverStatementSyntax& SyntaxFactory::foreverStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token foreverKeyword, StatementSyntax& statement) {
+    return *alloc.emplace<ForeverStatementSyntax>(label, attributes, foreverKeyword, statement);
+}
+
+ForwardInterfaceClassTypedefDeclarationSyntax& SyntaxFactory::forwardInterfaceClassTypedefDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, Token interfaceKeyword, Token classKeyword, Token name, Token semi) {
+    return *alloc.emplace<ForwardInterfaceClassTypedefDeclarationSyntax>(attributes, typedefKeyword, interfaceKeyword, classKeyword, name, semi);
+}
+
+ForwardTypedefDeclarationSyntax& SyntaxFactory::forwardTypedefDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, Token keyword, Token name, Token semi) {
+    return *alloc.emplace<ForwardTypedefDeclarationSyntax>(attributes, typedefKeyword, keyword, name, semi);
+}
+
+FunctionDeclarationSyntax& SyntaxFactory::functionDeclaration(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, FunctionPrototypeSyntax& prototype, Token semi, const SyntaxList<SyntaxNode>& items, Token end, NamedBlockClauseSyntax* endBlockName) {
+    return *alloc.emplace<FunctionDeclarationSyntax>(kind, attributes, prototype, semi, items, end, endBlockName);
+}
+
+FunctionPortListSyntax& SyntaxFactory::functionPortList(Token openParen, const SeparatedSyntaxList<FunctionPortSyntax>& ports, Token closeParen) {
+    return *alloc.emplace<FunctionPortListSyntax>(openParen, ports, closeParen);
+}
+
+FunctionPortSyntax& SyntaxFactory::functionPort(const SyntaxList<AttributeInstanceSyntax>& attributes, Token constKeyword, Token direction, Token varKeyword, DataTypeSyntax* dataType, DeclaratorSyntax& declarator) {
+    return *alloc.emplace<FunctionPortSyntax>(attributes, constKeyword, direction, varKeyword, dataType, declarator);
+}
+
+FunctionPrototypeSyntax& SyntaxFactory::functionPrototype(Token keyword, Token lifetime, DataTypeSyntax& returnType, NameSyntax& name, FunctionPortListSyntax* portList) {
+    return *alloc.emplace<FunctionPrototypeSyntax>(keyword, lifetime, returnType, name, portList);
+}
+
+GateInstanceNameSyntax& SyntaxFactory::gateInstanceName(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions) {
+    return *alloc.emplace<GateInstanceNameSyntax>(name, dimensions);
+}
+
+GateInstanceSyntax& SyntaxFactory::gateInstance(GateInstanceNameSyntax* decl, Token openParen, const SeparatedSyntaxList<ExpressionSyntax>& connections, Token closeParen) {
+    return *alloc.emplace<GateInstanceSyntax>(decl, openParen, connections, closeParen);
+}
+
+GateInstantiationSyntax& SyntaxFactory::gateInstantiation(const SyntaxList<AttributeInstanceSyntax>& attributes, Token gateType, DriveStrengthSyntax* strength, TimingControlSyntax* delay, const SeparatedSyntaxList<GateInstanceSyntax>& instances, Token semi) {
+    return *alloc.emplace<GateInstantiationSyntax>(attributes, gateType, strength, delay, instances, semi);
+}
+
+GenerateBlockSyntax& SyntaxFactory::generateBlock(const SyntaxList<AttributeInstanceSyntax>& attributes, NamedLabelSyntax* label, Token begin, NamedBlockClauseSyntax* beginName, const SyntaxList<MemberSyntax>& members, Token end, NamedBlockClauseSyntax* endName) {
+    return *alloc.emplace<GenerateBlockSyntax>(attributes, label, begin, beginName, members, end, endName);
+}
+
+GenerateRegionSyntax& SyntaxFactory::generateRegion(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SyntaxList<MemberSyntax>& members, Token endgenerate) {
+    return *alloc.emplace<GenerateRegionSyntax>(attributes, keyword, members, endgenerate);
+}
+
+GenvarDeclarationSyntax& SyntaxFactory::genvarDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<IdentifierNameSyntax>& identifiers, Token semi) {
+    return *alloc.emplace<GenvarDeclarationSyntax>(attributes, keyword, identifiers, semi);
+}
+
+HierarchicalInstanceSyntax& SyntaxFactory::hierarchicalInstance(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, Token openParen, const SeparatedSyntaxList<PortConnectionSyntax>& connections, Token closeParen) {
+    return *alloc.emplace<HierarchicalInstanceSyntax>(name, dimensions, openParen, connections, closeParen);
+}
+
+HierarchyInstantiationSyntax& SyntaxFactory::hierarchyInstantiation(const SyntaxList<AttributeInstanceSyntax>& attributes, Token type, ParameterValueAssignmentSyntax* parameters, const SeparatedSyntaxList<HierarchicalInstanceSyntax>& instances, Token semi) {
+    return *alloc.emplace<HierarchyInstantiationSyntax>(attributes, type, parameters, instances, semi);
+}
+
+IdentifierNameSyntax& SyntaxFactory::identifierName(Token identifier) {
+    return *alloc.emplace<IdentifierNameSyntax>(identifier);
+}
+
+IdentifierSelectNameSyntax& SyntaxFactory::identifierSelectName(Token identifier, const SyntaxList<ElementSelectSyntax>& selectors) {
+    return *alloc.emplace<IdentifierSelectNameSyntax>(identifier, selectors);
+}
+
+IfGenerateSyntax& SyntaxFactory::ifGenerate(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, MemberSyntax& block, ElseClauseSyntax* elseClause) {
+    return *alloc.emplace<IfGenerateSyntax>(attributes, keyword, openParen, condition, closeParen, block, elseClause);
+}
+
+IfNonePathDeclarationSyntax& SyntaxFactory::ifNonePathDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, PathDeclarationSyntax& path) {
+    return *alloc.emplace<IfNonePathDeclarationSyntax>(attributes, keyword, path);
+}
+
+IffEventClauseSyntax& SyntaxFactory::iffEventClause(Token iff, ExpressionSyntax& expr) {
+    return *alloc.emplace<IffEventClauseSyntax>(iff, expr);
+}
+
+ImmediateAssertionMemberSyntax& SyntaxFactory::immediateAssertionMember(const SyntaxList<AttributeInstanceSyntax>& attributes, ImmediateAssertionStatementSyntax& statement) {
+    return *alloc.emplace<ImmediateAssertionMemberSyntax>(attributes, statement);
+}
+
+ImmediateAssertionStatementSyntax& SyntaxFactory::immediateAssertionStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, DeferredAssertionSyntax* delay, ParenthesizedExpressionSyntax& expr, ActionBlockSyntax& action) {
+    return *alloc.emplace<ImmediateAssertionStatementSyntax>(kind, label, attributes, keyword, delay, expr, action);
+}
+
+ImplementsClauseSyntax& SyntaxFactory::implementsClause(Token keyword, const SeparatedSyntaxList<NameSyntax>& interfaces) {
+    return *alloc.emplace<ImplementsClauseSyntax>(keyword, interfaces);
+}
+
+ImplicationConstraintSyntax& SyntaxFactory::implicationConstraint(ExpressionSyntax& left, Token arrow, ConstraintItemSyntax& constraints) {
+    return *alloc.emplace<ImplicationConstraintSyntax>(left, arrow, constraints);
+}
+
+ImplicitAnsiPortSyntax& SyntaxFactory::implicitAnsiPort(const SyntaxList<AttributeInstanceSyntax>& attributes, PortHeaderSyntax& header, DeclaratorSyntax& declarator) {
+    return *alloc.emplace<ImplicitAnsiPortSyntax>(attributes, header, declarator);
+}
+
+ImplicitEventControlSyntax& SyntaxFactory::implicitEventControl(Token at, Token openParen, Token star, Token closeParen) {
+    return *alloc.emplace<ImplicitEventControlSyntax>(at, openParen, star, closeParen);
+}
+
+ImplicitNonAnsiPortSyntax& SyntaxFactory::implicitNonAnsiPort(PortExpressionSyntax* expr) {
+    return *alloc.emplace<ImplicitNonAnsiPortSyntax>(expr);
+}
+
+ImplicitTypeSyntax& SyntaxFactory::implicitType(Token signing, const SyntaxList<VariableDimensionSyntax>& dimensions) {
+    return *alloc.emplace<ImplicitTypeSyntax>(signing, dimensions);
+}
+
+IncludeDirectiveSyntax& SyntaxFactory::includeDirective(Token directive, Token fileName) {
+    return *alloc.emplace<IncludeDirectiveSyntax>(directive, fileName);
+}
+
+InsideExpressionSyntax& SyntaxFactory::insideExpression(ExpressionSyntax& expr, Token inside, OpenRangeListSyntax& ranges) {
+    return *alloc.emplace<InsideExpressionSyntax>(expr, inside, ranges);
+}
+
+IntegerTypeSyntax& SyntaxFactory::integerType(SyntaxKind kind, Token keyword, Token signing, const SyntaxList<VariableDimensionSyntax>& dimensions) {
+    return *alloc.emplace<IntegerTypeSyntax>(kind, keyword, signing, dimensions);
+}
+
+IntegerVectorExpressionSyntax& SyntaxFactory::integerVectorExpression(Token size, Token base, Token value) {
+    return *alloc.emplace<IntegerVectorExpressionSyntax>(size, base, value);
+}
+
+InterconnectPortHeaderSyntax& SyntaxFactory::interconnectPortHeader(Token direction, Token interconnect, ImplicitTypeSyntax& type) {
+    return *alloc.emplace<InterconnectPortHeaderSyntax>(direction, interconnect, type);
+}
+
+InterfacePortHeaderSyntax& SyntaxFactory::interfacePortHeader(Token nameOrKeyword, DotMemberClauseSyntax* modport) {
+    return *alloc.emplace<InterfacePortHeaderSyntax>(nameOrKeyword, modport);
+}
+
+InvocationExpressionSyntax& SyntaxFactory::invocationExpression(ExpressionSyntax& left, const SyntaxList<AttributeInstanceSyntax>& attributes, ArgumentListSyntax* arguments) {
+    return *alloc.emplace<InvocationExpressionSyntax>(left, attributes, arguments);
+}
+
+JumpStatementSyntax& SyntaxFactory::jumpStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token breakOrContinue, Token semi) {
+    return *alloc.emplace<JumpStatementSyntax>(label, attributes, breakOrContinue, semi);
+}
+
+KeywordNameSyntax& SyntaxFactory::keywordName(SyntaxKind kind, Token keyword) {
+    return *alloc.emplace<KeywordNameSyntax>(kind, keyword);
+}
+
+KeywordTypeSyntax& SyntaxFactory::keywordType(SyntaxKind kind, Token keyword) {
+    return *alloc.emplace<KeywordTypeSyntax>(kind, keyword);
+}
+
+LetDeclarationSyntax& SyntaxFactory::letDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token let, Token identifier, AssertionItemPortListSyntax* portList, EqualsValueClauseSyntax& initializer, Token semi) {
+    return *alloc.emplace<LetDeclarationSyntax>(attributes, let, identifier, portList, initializer, semi);
+}
+
+LineDirectiveSyntax& SyntaxFactory::lineDirective(Token directive, Token lineNumber, Token fileName, Token level) {
+    return *alloc.emplace<LineDirectiveSyntax>(directive, lineNumber, fileName, level);
+}
+
+LiteralExpressionSyntax& SyntaxFactory::literalExpression(SyntaxKind kind, Token literal) {
+    return *alloc.emplace<LiteralExpressionSyntax>(kind, literal);
+}
+
+LoopConstraintSyntax& SyntaxFactory::loopConstraint(Token foreachKeyword, ForeachLoopListSyntax& loopList, ConstraintItemSyntax& constraints) {
+    return *alloc.emplace<LoopConstraintSyntax>(foreachKeyword, loopList, constraints);
+}
+
+LoopGenerateSyntax& SyntaxFactory::loopGenerate(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, Token genvar, Token identifier, Token equals, ExpressionSyntax& initialExpr, Token semi1, ExpressionSyntax& stopExpr, Token semi2, ExpressionSyntax& iterationExpr, Token closeParen, MemberSyntax& block) {
+    return *alloc.emplace<LoopGenerateSyntax>(attributes, keyword, openParen, genvar, identifier, equals, initialExpr, semi1, stopExpr, semi2, iterationExpr, closeParen, block);
+}
+
+LoopStatementSyntax& SyntaxFactory::loopStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token repeatOrWhile, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement) {
+    return *alloc.emplace<LoopStatementSyntax>(label, attributes, repeatOrWhile, openParen, expr, closeParen, statement);
+}
+
+MacroActualArgumentListSyntax& SyntaxFactory::macroActualArgumentList(Token openParen, const SeparatedSyntaxList<MacroActualArgumentSyntax>& args, Token closeParen) {
+    return *alloc.emplace<MacroActualArgumentListSyntax>(openParen, args, closeParen);
+}
+
+MacroActualArgumentSyntax& SyntaxFactory::macroActualArgument(const TokenList& tokens) {
+    return *alloc.emplace<MacroActualArgumentSyntax>(tokens);
+}
+
+MacroArgumentDefaultSyntax& SyntaxFactory::macroArgumentDefault(Token equals, const TokenList& tokens) {
+    return *alloc.emplace<MacroArgumentDefaultSyntax>(equals, tokens);
+}
+
+MacroFormalArgumentListSyntax& SyntaxFactory::macroFormalArgumentList(Token openParen, const SeparatedSyntaxList<MacroFormalArgumentSyntax>& args, Token closeParen) {
+    return *alloc.emplace<MacroFormalArgumentListSyntax>(openParen, args, closeParen);
+}
+
+MacroFormalArgumentSyntax& SyntaxFactory::macroFormalArgument(Token name, MacroArgumentDefaultSyntax* defaultValue) {
+    return *alloc.emplace<MacroFormalArgumentSyntax>(name, defaultValue);
+}
+
+MacroUsageSyntax& SyntaxFactory::macroUsage(Token directive, MacroActualArgumentListSyntax* args) {
+    return *alloc.emplace<MacroUsageSyntax>(directive, args);
+}
+
+MatchesClauseSyntax& SyntaxFactory::matchesClause(Token matchesKeyword, PatternSyntax& pattern) {
+    return *alloc.emplace<MatchesClauseSyntax>(matchesKeyword, pattern);
+}
+
+MemberAccessExpressionSyntax& SyntaxFactory::memberAccessExpression(ExpressionSyntax& left, Token dot, Token name) {
+    return *alloc.emplace<MemberAccessExpressionSyntax>(left, dot, name);
+}
+
+MinTypMaxExpressionSyntax& SyntaxFactory::minTypMaxExpression(ExpressionSyntax& min, Token colon1, ExpressionSyntax& typ, Token colon2, ExpressionSyntax& max) {
+    return *alloc.emplace<MinTypMaxExpressionSyntax>(min, colon1, typ, colon2, max);
+}
+
+ModportClockingPortSyntax& SyntaxFactory::modportClockingPort(const SyntaxList<AttributeInstanceSyntax>& attributes, Token clocking, Token name) {
+    return *alloc.emplace<ModportClockingPortSyntax>(attributes, clocking, name);
+}
+
+ModportDeclarationSyntax& SyntaxFactory::modportDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<ModportItemSyntax>& items, Token semi) {
+    return *alloc.emplace<ModportDeclarationSyntax>(attributes, keyword, items, semi);
+}
+
+ModportExplicitPortSyntax& SyntaxFactory::modportExplicitPort(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) {
+    return *alloc.emplace<ModportExplicitPortSyntax>(dot, name, openParen, expr, closeParen);
+}
+
+ModportItemSyntax& SyntaxFactory::modportItem(Token name, AnsiPortListSyntax& ports) {
+    return *alloc.emplace<ModportItemSyntax>(name, ports);
+}
+
+ModportNamedPortSyntax& SyntaxFactory::modportNamedPort(Token name) {
+    return *alloc.emplace<ModportNamedPortSyntax>(name);
+}
+
+ModportSimplePortListSyntax& SyntaxFactory::modportSimplePortList(const SyntaxList<AttributeInstanceSyntax>& attributes, Token direction, const SeparatedSyntaxList<ModportPortSyntax>& ports) {
+    return *alloc.emplace<ModportSimplePortListSyntax>(attributes, direction, ports);
+}
+
+ModportSubroutinePortListSyntax& SyntaxFactory::modportSubroutinePortList(const SyntaxList<AttributeInstanceSyntax>& attributes, Token importExport, const SeparatedSyntaxList<ModportPortSyntax>& ports) {
+    return *alloc.emplace<ModportSubroutinePortListSyntax>(attributes, importExport, ports);
+}
+
+ModportSubroutinePortSyntax& SyntaxFactory::modportSubroutinePort(FunctionPrototypeSyntax& prototype) {
+    return *alloc.emplace<ModportSubroutinePortSyntax>(prototype);
+}
+
+ModuleDeclarationSyntax& SyntaxFactory::moduleDeclaration(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, ModuleHeaderSyntax& header, const SyntaxList<MemberSyntax>& members, Token endmodule, NamedBlockClauseSyntax* blockName) {
+    return *alloc.emplace<ModuleDeclarationSyntax>(kind, attributes, header, members, endmodule, blockName);
+}
+
+ModuleHeaderSyntax& SyntaxFactory::moduleHeader(SyntaxKind kind, Token moduleKeyword, Token lifetime, Token name, const SyntaxList<PackageImportDeclarationSyntax>& imports, ParameterPortListSyntax* parameters, PortListSyntax* ports, Token semi) {
+    return *alloc.emplace<ModuleHeaderSyntax>(kind, moduleKeyword, lifetime, name, imports, parameters, ports, semi);
+}
+
+MultipleConcatenationExpressionSyntax& SyntaxFactory::multipleConcatenationExpression(Token openBrace, ExpressionSyntax& expression, ConcatenationExpressionSyntax& concatenation, Token closeBrace) {
+    return *alloc.emplace<MultipleConcatenationExpressionSyntax>(openBrace, expression, concatenation, closeBrace);
+}
+
+NameValuePragmaExpressionSyntax& SyntaxFactory::nameValuePragmaExpression(Token name, Token equals, PragmaExpressionSyntax& value) {
+    return *alloc.emplace<NameValuePragmaExpressionSyntax>(name, equals, value);
+}
+
+NamedArgumentSyntax& SyntaxFactory::namedArgument(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) {
+    return *alloc.emplace<NamedArgumentSyntax>(dot, name, openParen, expr, closeParen);
+}
+
+NamedBlockClauseSyntax& SyntaxFactory::namedBlockClause(Token colon, Token name) {
+    return *alloc.emplace<NamedBlockClauseSyntax>(colon, name);
+}
+
+NamedLabelSyntax& SyntaxFactory::namedLabel(Token name, Token colon) {
+    return *alloc.emplace<NamedLabelSyntax>(name, colon);
+}
+
+NamedPortConnectionSyntax& SyntaxFactory::namedPortConnection(const SyntaxList<AttributeInstanceSyntax>& attributes, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) {
+    return *alloc.emplace<NamedPortConnectionSyntax>(attributes, dot, name, openParen, expr, closeParen);
+}
+
+NamedStructurePatternMemberSyntax& SyntaxFactory::namedStructurePatternMember(Token name, Token colon, PatternSyntax& pattern) {
+    return *alloc.emplace<NamedStructurePatternMemberSyntax>(name, colon, pattern);
+}
+
+NamedTypeSyntax& SyntaxFactory::namedType(NameSyntax& name) {
+    return *alloc.emplace<NamedTypeSyntax>(name);
+}
+
+NetDeclarationSyntax& SyntaxFactory::netDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token netType, NetStrengthSyntax* strength, Token expansionHint, DataTypeSyntax& type, TimingControlSyntax* delay, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) {
+    return *alloc.emplace<NetDeclarationSyntax>(attributes, netType, strength, expansionHint, type, delay, declarators, semi);
+}
+
+NetPortHeaderSyntax& SyntaxFactory::netPortHeader(Token direction, Token netType, DataTypeSyntax& dataType) {
+    return *alloc.emplace<NetPortHeaderSyntax>(direction, netType, dataType);
+}
+
+NetTypeDeclarationSyntax& SyntaxFactory::netTypeDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, DataTypeSyntax& type, Token name, WithFunctionClauseSyntax* withFunction, Token semi) {
+    return *alloc.emplace<NetTypeDeclarationSyntax>(attributes, keyword, type, name, withFunction, semi);
+}
+
+NewArrayExpressionSyntax& SyntaxFactory::newArrayExpression(NameSyntax& newKeyword, Token openBracket, ExpressionSyntax& sizeExpr, Token closeBracket, ParenthesizedExpressionSyntax* initializer) {
+    return *alloc.emplace<NewArrayExpressionSyntax>(newKeyword, openBracket, sizeExpr, closeBracket, initializer);
+}
+
+NewClassExpressionSyntax& SyntaxFactory::newClassExpression(NameSyntax& scopedNew, ArgumentListSyntax* argList) {
+    return *alloc.emplace<NewClassExpressionSyntax>(scopedNew, argList);
+}
+
+NonAnsiPortListSyntax& SyntaxFactory::nonAnsiPortList(Token openParen, const SeparatedSyntaxList<NonAnsiPortSyntax>& ports, Token closeParen) {
+    return *alloc.emplace<NonAnsiPortListSyntax>(openParen, ports, closeParen);
+}
+
+NonAnsiUdpPortListSyntax& SyntaxFactory::nonAnsiUdpPortList(Token openParen, const SeparatedSyntaxList<IdentifierNameSyntax>& ports, Token closeParen, Token semi) {
+    return *alloc.emplace<NonAnsiUdpPortListSyntax>(openParen, ports, closeParen, semi);
+}
+
+NumberPragmaExpressionSyntax& SyntaxFactory::numberPragmaExpression(Token size, Token base, Token value) {
+    return *alloc.emplace<NumberPragmaExpressionSyntax>(size, base, value);
+}
+
+OpenRangeExpressionSyntax& SyntaxFactory::openRangeExpression(Token openBracket, ExpressionSyntax& left, Token colon, ExpressionSyntax& right, Token closeBracket) {
+    return *alloc.emplace<OpenRangeExpressionSyntax>(openBracket, left, colon, right, closeBracket);
+}
+
+OpenRangeListSyntax& SyntaxFactory::openRangeList(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& valueRanges, Token closeBrace) {
+    return *alloc.emplace<OpenRangeListSyntax>(openBrace, valueRanges, closeBrace);
+}
+
+OrderedArgumentSyntax& SyntaxFactory::orderedArgument(ExpressionSyntax& expr) {
+    return *alloc.emplace<OrderedArgumentSyntax>(expr);
+}
+
+OrderedPortConnectionSyntax& SyntaxFactory::orderedPortConnection(const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& expr) {
+    return *alloc.emplace<OrderedPortConnectionSyntax>(attributes, expr);
+}
+
+OrderedStructurePatternMemberSyntax& SyntaxFactory::orderedStructurePatternMember(PatternSyntax& pattern) {
+    return *alloc.emplace<OrderedStructurePatternMemberSyntax>(pattern);
+}
+
+PackageImportDeclarationSyntax& SyntaxFactory::packageImportDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<PackageImportItemSyntax>& items, Token semi) {
+    return *alloc.emplace<PackageImportDeclarationSyntax>(attributes, keyword, items, semi);
+}
+
+PackageImportItemSyntax& SyntaxFactory::packageImportItem(Token package, Token doubleColon, Token item) {
+    return *alloc.emplace<PackageImportItemSyntax>(package, doubleColon, item);
+}
+
+ParameterDeclarationStatementSyntax& SyntaxFactory::parameterDeclarationStatement(const SyntaxList<AttributeInstanceSyntax>& attributes, ParameterDeclarationBaseSyntax& parameter, Token semi) {
+    return *alloc.emplace<ParameterDeclarationStatementSyntax>(attributes, parameter, semi);
+}
+
+ParameterDeclarationSyntax& SyntaxFactory::parameterDeclaration(Token keyword, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators) {
+    return *alloc.emplace<ParameterDeclarationSyntax>(keyword, type, declarators);
+}
+
+ParameterPortListSyntax& SyntaxFactory::parameterPortList(Token hash, Token openParen, const SeparatedSyntaxList<ParameterDeclarationBaseSyntax>& declarations, Token closeParen) {
+    return *alloc.emplace<ParameterPortListSyntax>(hash, openParen, declarations, closeParen);
+}
+
+ParameterValueAssignmentSyntax& SyntaxFactory::parameterValueAssignment(Token hash, ArgumentListSyntax& assignments) {
+    return *alloc.emplace<ParameterValueAssignmentSyntax>(hash, assignments);
+}
+
+ParenExpressionListSyntax& SyntaxFactory::parenExpressionList(Token openParen, const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token closeParen) {
+    return *alloc.emplace<ParenExpressionListSyntax>(openParen, expressions, closeParen);
+}
+
+ParenPragmaExpressionSyntax& SyntaxFactory::parenPragmaExpression(Token openParen, const SeparatedSyntaxList<PragmaExpressionSyntax>& values, Token closeParen) {
+    return *alloc.emplace<ParenPragmaExpressionSyntax>(openParen, values, closeParen);
+}
+
+ParenthesizedEventExpressionSyntax& SyntaxFactory::parenthesizedEventExpression(Token openParen, EventExpressionSyntax& expr, Token closeParen) {
+    return *alloc.emplace<ParenthesizedEventExpressionSyntax>(openParen, expr, closeParen);
+}
+
+ParenthesizedExpressionSyntax& SyntaxFactory::parenthesizedExpression(Token openParen, ExpressionSyntax& expression, Token closeParen) {
+    return *alloc.emplace<ParenthesizedExpressionSyntax>(openParen, expression, closeParen);
+}
+
+PathDeclarationSyntax& SyntaxFactory::pathDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, PathDescriptionSyntax& desc, Token equals, Token openParen, const SeparatedSyntaxList<ExpressionSyntax>& delays, Token closeParen, Token semi) {
+    return *alloc.emplace<PathDeclarationSyntax>(attributes, desc, equals, openParen, delays, closeParen, semi);
+}
+
+PathDescriptionSyntax& SyntaxFactory::pathDescription(Token openParen, Token edgeIdentifier, const SeparatedSyntaxList<NameSyntax>& inputs, Token polarityOperator, Token pathOperator, PathSuffixSyntax& suffix, Token closeParen) {
+    return *alloc.emplace<PathDescriptionSyntax>(openParen, edgeIdentifier, inputs, polarityOperator, pathOperator, suffix, closeParen);
+}
+
+PatternCaseItemSyntax& SyntaxFactory::patternCaseItem(PatternSyntax& pattern, Token tripleAnd, ExpressionSyntax* expr, Token colon, StatementSyntax& statement) {
+    return *alloc.emplace<PatternCaseItemSyntax>(pattern, tripleAnd, expr, colon, statement);
+}
+
+PortConcatenationSyntax& SyntaxFactory::portConcatenation(Token openBrace, const SeparatedSyntaxList<PortReferenceSyntax>& references, Token closeBrace) {
+    return *alloc.emplace<PortConcatenationSyntax>(openBrace, references, closeBrace);
+}
+
+PortDeclarationSyntax& SyntaxFactory::portDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, PortHeaderSyntax& header, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) {
+    return *alloc.emplace<PortDeclarationSyntax>(attributes, header, declarators, semi);
+}
+
+PortReferenceSyntax& SyntaxFactory::portReference(Token name, ElementSelectSyntax* select) {
+    return *alloc.emplace<PortReferenceSyntax>(name, select);
+}
+
+PostfixUnaryExpressionSyntax& SyntaxFactory::postfixUnaryExpression(SyntaxKind kind, ExpressionSyntax& operand, const SyntaxList<AttributeInstanceSyntax>& attributes, Token operatorToken) {
+    return *alloc.emplace<PostfixUnaryExpressionSyntax>(kind, operand, attributes, operatorToken);
+}
+
+PragmaDirectiveSyntax& SyntaxFactory::pragmaDirective(Token directive, Token name, const SeparatedSyntaxList<PragmaExpressionSyntax>& args) {
+    return *alloc.emplace<PragmaDirectiveSyntax>(directive, name, args);
+}
+
+PrefixUnaryExpressionSyntax& SyntaxFactory::prefixUnaryExpression(SyntaxKind kind, Token operatorToken, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& operand) {
+    return *alloc.emplace<PrefixUnaryExpressionSyntax>(kind, operatorToken, attributes, operand);
+}
+
+PrimaryBlockEventExpressionSyntax& SyntaxFactory::primaryBlockEventExpression(Token keyword, NameSyntax& name) {
+    return *alloc.emplace<PrimaryBlockEventExpressionSyntax>(keyword, name);
+}
+
+ProceduralAssignStatementSyntax& SyntaxFactory::proceduralAssignStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ExpressionSyntax& expr, Token semi) {
+    return *alloc.emplace<ProceduralAssignStatementSyntax>(kind, label, attributes, keyword, expr, semi);
+}
+
+ProceduralBlockSyntax& SyntaxFactory::proceduralBlock(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, StatementSyntax& statement) {
+    return *alloc.emplace<ProceduralBlockSyntax>(kind, attributes, keyword, statement);
+}
+
+ProceduralDeassignStatementSyntax& SyntaxFactory::proceduralDeassignStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ExpressionSyntax& variable, Token semi) {
+    return *alloc.emplace<ProceduralDeassignStatementSyntax>(kind, label, attributes, keyword, variable, semi);
+}
+
+PropertyDeclarationSyntax& SyntaxFactory::propertyDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, const SyntaxList<MemberSyntax>& assertionVariables, PropertySpecSyntax& propertySpec, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName) {
+    return *alloc.emplace<PropertyDeclarationSyntax>(attributes, keyword, name, portList, semi, assertionVariables, propertySpec, optionalSemi, end, endBlockName);
+}
+
+PropertySpecSyntax& SyntaxFactory::propertySpec(TimingControlSyntax* clocking, DisableIffSyntax* disable, ExpressionSyntax& expr) {
+    return *alloc.emplace<PropertySpecSyntax>(clocking, disable, expr);
+}
+
+PulseStyleDeclarationSyntax& SyntaxFactory::pulseStyleDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<NameSyntax>& inputs, Token semi) {
+    return *alloc.emplace<PulseStyleDeclarationSyntax>(attributes, keyword, inputs, semi);
+}
+
+QueueDimensionSpecifierSyntax& SyntaxFactory::queueDimensionSpecifier(Token dollar, ColonExpressionClauseSyntax* maxSizeClause) {
+    return *alloc.emplace<QueueDimensionSpecifierSyntax>(dollar, maxSizeClause);
+}
+
+RandCaseItemSyntax& SyntaxFactory::randCaseItem(ExpressionSyntax& expr, Token colon, StatementSyntax& statement) {
+    return *alloc.emplace<RandCaseItemSyntax>(expr, colon, statement);
+}
+
+RandCaseStatementSyntax& SyntaxFactory::randCaseStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token randCase, const SyntaxList<RandCaseItemSyntax>& items, Token endCase) {
+    return *alloc.emplace<RandCaseStatementSyntax>(label, attributes, randCase, items, endCase);
+}
+
+RangeCoverageBinInitializerSyntax& SyntaxFactory::rangeCoverageBinInitializer(OpenRangeListSyntax& ranges, WithClauseSyntax* withClause) {
+    return *alloc.emplace<RangeCoverageBinInitializerSyntax>(ranges, withClause);
+}
+
+RangeDimensionSpecifierSyntax& SyntaxFactory::rangeDimensionSpecifier(SelectorSyntax& selector) {
+    return *alloc.emplace<RangeDimensionSpecifierSyntax>(selector);
+}
+
+RangeSelectSyntax& SyntaxFactory::rangeSelect(SyntaxKind kind, ExpressionSyntax& left, Token range, ExpressionSyntax& right) {
+    return *alloc.emplace<RangeSelectSyntax>(kind, left, range, right);
+}
+
+RepeatedEventControlSyntax& SyntaxFactory::repeatedEventControl(Token repeat, Token openParen, ExpressionSyntax& expr, Token closeParen, TimingControlSyntax* eventControl) {
+    return *alloc.emplace<RepeatedEventControlSyntax>(repeat, openParen, expr, closeParen, eventControl);
+}
+
+ReplicatedAssignmentPatternSyntax& SyntaxFactory::replicatedAssignmentPattern(Token openBrace, ExpressionSyntax& countExpr, Token innerOpenBrace, const SeparatedSyntaxList<ExpressionSyntax>& items, Token innerCloseBrace, Token closeBrace) {
+    return *alloc.emplace<ReplicatedAssignmentPatternSyntax>(openBrace, countExpr, innerOpenBrace, items, innerCloseBrace, closeBrace);
+}
+
+ReturnStatementSyntax& SyntaxFactory::returnStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token returnKeyword, ExpressionSyntax* returnValue, Token semi) {
+    return *alloc.emplace<ReturnStatementSyntax>(label, attributes, returnKeyword, returnValue, semi);
+}
+
+ScopedNameSyntax& SyntaxFactory::scopedName(NameSyntax& left, Token separator, NameSyntax& right) {
+    return *alloc.emplace<ScopedNameSyntax>(left, separator, right);
+}
+
+SequenceDeclarationSyntax& SyntaxFactory::sequenceDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, const SyntaxList<MemberSyntax>& assertionVariables, ExpressionSyntax& seqExpr, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName) {
+    return *alloc.emplace<SequenceDeclarationSyntax>(attributes, keyword, name, portList, semi, assertionVariables, seqExpr, optionalSemi, end, endBlockName);
+}
+
+ShortcutCycleDelayRangeSyntax& SyntaxFactory::shortcutCycleDelayRange(Token doubleHash, Token openBracket, Token op, Token closeBracket) {
+    return *alloc.emplace<ShortcutCycleDelayRangeSyntax>(doubleHash, openBracket, op, closeBracket);
+}
+
+SignalEventExpressionSyntax& SyntaxFactory::signalEventExpression(Token edge, ExpressionSyntax& expr, IffEventClauseSyntax* iffClause) {
+    return *alloc.emplace<SignalEventExpressionSyntax>(edge, expr, iffClause);
+}
+
+SignedCastExpressionSyntax& SyntaxFactory::signedCastExpression(Token signing, Token apostrophe, ParenthesizedExpressionSyntax& inner) {
+    return *alloc.emplace<SignedCastExpressionSyntax>(signing, apostrophe, inner);
+}
+
+SimpleAssignmentPatternSyntax& SyntaxFactory::simpleAssignmentPattern(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& items, Token closeBrace) {
+    return *alloc.emplace<SimpleAssignmentPatternSyntax>(openBrace, items, closeBrace);
+}
+
+SimpleDirectiveSyntax& SyntaxFactory::simpleDirective(SyntaxKind kind, Token directive) {
+    return *alloc.emplace<SimpleDirectiveSyntax>(kind, directive);
+}
+
+SimplePathSuffixSyntax& SyntaxFactory::simplePathSuffix(const SeparatedSyntaxList<NameSyntax>& outputs) {
+    return *alloc.emplace<SimplePathSuffixSyntax>(outputs);
+}
+
+SimplePragmaExpressionSyntax& SyntaxFactory::simplePragmaExpression(Token value) {
+    return *alloc.emplace<SimplePragmaExpressionSyntax>(value);
+}
+
+SolveBeforeConstraintSyntax& SyntaxFactory::solveBeforeConstraint(Token solve, const SeparatedSyntaxList<ExpressionSyntax>& beforeExpr, Token before, const SeparatedSyntaxList<ExpressionSyntax>& afterExpr, Token semi) {
+    return *alloc.emplace<SolveBeforeConstraintSyntax>(solve, beforeExpr, before, afterExpr, semi);
+}
+
+SpecifyBlockSyntax& SyntaxFactory::specifyBlock(const SyntaxList<AttributeInstanceSyntax>& attributes, Token specify, const SyntaxList<MemberSyntax>& items, Token endspecify) {
+    return *alloc.emplace<SpecifyBlockSyntax>(attributes, specify, items, endspecify);
+}
+
+SpecparamDeclarationSyntax& SyntaxFactory::specparamDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ImplicitTypeSyntax& type, const SeparatedSyntaxList<SpecparamDeclaratorSyntax>& declarators, Token semi) {
+    return *alloc.emplace<SpecparamDeclarationSyntax>(attributes, keyword, type, declarators, semi);
+}
+
+SpecparamDeclaratorSyntax& SyntaxFactory::specparamDeclarator(Token name, Token equals, ExpressionSyntax& value) {
+    return *alloc.emplace<SpecparamDeclaratorSyntax>(name, equals, value);
+}
+
+StandardCaseItemSyntax& SyntaxFactory::standardCaseItem(const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token colon, SyntaxNode& clause) {
+    return *alloc.emplace<StandardCaseItemSyntax>(expressions, colon, clause);
+}
+
+StreamExpressionSyntax& SyntaxFactory::streamExpression(ExpressionSyntax& expression, StreamExpressionWithRangeSyntax* withRange) {
+    return *alloc.emplace<StreamExpressionSyntax>(expression, withRange);
+}
+
+StreamExpressionWithRangeSyntax& SyntaxFactory::streamExpressionWithRange(Token withKeyword, ElementSelectSyntax& range) {
+    return *alloc.emplace<StreamExpressionWithRangeSyntax>(withKeyword, range);
+}
+
+StreamingConcatenationExpressionSyntax& SyntaxFactory::streamingConcatenationExpression(Token openBrace, Token operatorToken, ExpressionSyntax* sliceSize, Token innerOpenBrace, const SeparatedSyntaxList<StreamExpressionSyntax>& expressions, Token innerCloseBrace, Token closeBrace) {
+    return *alloc.emplace<StreamingConcatenationExpressionSyntax>(openBrace, operatorToken, sliceSize, innerOpenBrace, expressions, innerCloseBrace, closeBrace);
+}
+
+StructUnionMemberSyntax& SyntaxFactory::structUnionMember(const SyntaxList<AttributeInstanceSyntax>& attributes, Token randomQualifier, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) {
+    return *alloc.emplace<StructUnionMemberSyntax>(attributes, randomQualifier, type, declarators, semi);
+}
+
+StructUnionTypeSyntax& SyntaxFactory::structUnionType(SyntaxKind kind, Token keyword, Token tagged, Token packed, Token signing, Token openBrace, const SyntaxList<StructUnionMemberSyntax>& members, Token closeBrace, const SyntaxList<VariableDimensionSyntax>& dimensions) {
+    return *alloc.emplace<StructUnionTypeSyntax>(kind, keyword, tagged, packed, signing, openBrace, members, closeBrace, dimensions);
+}
+
+StructurePatternSyntax& SyntaxFactory::structurePattern(Token openBrace, const SeparatedSyntaxList<StructurePatternMemberSyntax>& members, Token closeBrace) {
+    return *alloc.emplace<StructurePatternSyntax>(openBrace, members, closeBrace);
+}
+
+StructuredAssignmentPatternSyntax& SyntaxFactory::structuredAssignmentPattern(Token openBrace, const SeparatedSyntaxList<AssignmentPatternItemSyntax>& items, Token closeBrace) {
+    return *alloc.emplace<StructuredAssignmentPatternSyntax>(openBrace, items, closeBrace);
+}
+
+SystemNameSyntax& SyntaxFactory::systemName(Token systemIdentifier) {
+    return *alloc.emplace<SystemNameSyntax>(systemIdentifier);
+}
+
+SystemTimingCheckSyntax& SyntaxFactory::systemTimingCheck(const SyntaxList<AttributeInstanceSyntax>& attributes, Token name, Token openParen, const SeparatedSyntaxList<TimingCheckArgSyntax>& args, Token closeParen, Token semi) {
+    return *alloc.emplace<SystemTimingCheckSyntax>(attributes, name, openParen, args, closeParen, semi);
+}
+
+TaggedPatternSyntax& SyntaxFactory::taggedPattern(Token tagged, Token memberName, PatternSyntax* pattern) {
+    return *alloc.emplace<TaggedPatternSyntax>(tagged, memberName, pattern);
+}
+
+TaggedUnionExpressionSyntax& SyntaxFactory::taggedUnionExpression(Token tagged, Token member, ExpressionSyntax* expr) {
+    return *alloc.emplace<TaggedUnionExpressionSyntax>(tagged, member, expr);
+}
+
+TimeScaleDirectiveSyntax& SyntaxFactory::timeScaleDirective(Token directive, Token timeUnit, Token slash, Token timePrecision) {
+    return *alloc.emplace<TimeScaleDirectiveSyntax>(directive, timeUnit, slash, timePrecision);
+}
+
+TimeUnitsDeclarationSyntax& SyntaxFactory::timeUnitsDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token time, DividerClauseSyntax* divider, Token semi) {
+    return *alloc.emplace<TimeUnitsDeclarationSyntax>(attributes, keyword, time, divider, semi);
+}
+
+TimingCheckConditionSyntax& SyntaxFactory::timingCheckCondition(Token tripleAnd, ExpressionSyntax& expr) {
+    return *alloc.emplace<TimingCheckConditionSyntax>(tripleAnd, expr);
+}
+
+TimingCheckEventSyntax& SyntaxFactory::timingCheckEvent(Token edge, EdgeControlSpecifierSyntax* controlSpecifier, NameSyntax& terminal, TimingCheckConditionSyntax* condition) {
+    return *alloc.emplace<TimingCheckEventSyntax>(edge, controlSpecifier, terminal, condition);
+}
+
+TimingControlExpressionConcatenationSyntax& SyntaxFactory::timingControlExpressionConcatenation(ExpressionSyntax& left, TimingControlSyntax& timing, ExpressionSyntax& right) {
+    return *alloc.emplace<TimingControlExpressionConcatenationSyntax>(left, timing, right);
+}
+
+TimingControlExpressionSyntax& SyntaxFactory::timingControlExpression(TimingControlSyntax& timing, ExpressionSyntax& expr) {
+    return *alloc.emplace<TimingControlExpressionSyntax>(timing, expr);
+}
+
+TimingControlStatementSyntax& SyntaxFactory::timingControlStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, TimingControlSyntax& timingControl, StatementSyntax& statement) {
+    return *alloc.emplace<TimingControlStatementSyntax>(label, attributes, timingControl, statement);
+}
+
+TransListCoverageBinInitializerSyntax& SyntaxFactory::transListCoverageBinInitializer(const SeparatedSyntaxList<TransSetSyntax>& sets, WithClauseSyntax* withClause) {
+    return *alloc.emplace<TransListCoverageBinInitializerSyntax>(sets, withClause);
+}
+
+TransRangeSyntax& SyntaxFactory::transRange(const SeparatedSyntaxList<ExpressionSyntax>& items, TransRepeatRangeSyntax* repeat) {
+    return *alloc.emplace<TransRangeSyntax>(items, repeat);
+}
+
+TransRepeatRangeSyntax& SyntaxFactory::transRepeatRange(Token openBracket, Token specifier, SelectorSyntax* selector, Token closeBracket) {
+    return *alloc.emplace<TransRepeatRangeSyntax>(openBracket, specifier, selector, closeBracket);
+}
+
+TransSetSyntax& SyntaxFactory::transSet(Token openParen, const SeparatedSyntaxList<TransRangeSyntax>& ranges, Token closeParen) {
+    return *alloc.emplace<TransSetSyntax>(openParen, ranges, closeParen);
+}
+
+TypeAssignmentSyntax& SyntaxFactory::typeAssignment(Token name, EqualsTypeClauseSyntax* assignment) {
+    return *alloc.emplace<TypeAssignmentSyntax>(name, assignment);
+}
+
+TypeParameterDeclarationSyntax& SyntaxFactory::typeParameterDeclaration(Token keyword, Token typeKeyword, const SeparatedSyntaxList<TypeAssignmentSyntax>& declarators) {
+    return *alloc.emplace<TypeParameterDeclarationSyntax>(keyword, typeKeyword, declarators);
+}
+
+TypeReferenceSyntax& SyntaxFactory::typeReference(Token typeKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen) {
+    return *alloc.emplace<TypeReferenceSyntax>(typeKeyword, openParen, expr, closeParen);
+}
+
+TypedefDeclarationSyntax& SyntaxFactory::typedefDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, DataTypeSyntax& type, Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, Token semi) {
+    return *alloc.emplace<TypedefDeclarationSyntax>(attributes, typedefKeyword, type, name, dimensions, semi);
+}
+
+UdpBodySyntax& SyntaxFactory::udpBody(const SeparatedSyntaxList<UdpPortDeclSyntax>& portDecls, UdpInitialStmtSyntax* initialStmt, Token table, const SyntaxList<UdpEntrySyntax>& entries, Token endtable) {
+    return *alloc.emplace<UdpBodySyntax>(portDecls, initialStmt, table, entries, endtable);
+}
+
+UdpDeclarationSyntax& SyntaxFactory::udpDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token primitive, Token name, UdpPortListSyntax& portList, UdpBodySyntax& body, Token endprimitive, NamedBlockClauseSyntax* endBlockName) {
+    return *alloc.emplace<UdpDeclarationSyntax>(attributes, primitive, name, portList, body, endprimitive, endBlockName);
+}
+
+UdpEdgeIndicatorSyntax& SyntaxFactory::udpEdgeIndicator(Token openParen, Token first, Token second, Token closeParen) {
+    return *alloc.emplace<UdpEdgeIndicatorSyntax>(openParen, first, second, closeParen);
+}
+
+UdpEntrySyntax& SyntaxFactory::udpEntry(const TokenList& preInputs, UdpEdgeIndicatorSyntax* edgeIndicator, const TokenList& postInputs, Token colon1, Token current, Token colon2, Token next, Token semi) {
+    return *alloc.emplace<UdpEntrySyntax>(preInputs, edgeIndicator, postInputs, colon1, current, colon2, next, semi);
+}
+
+UdpInitialStmtSyntax& SyntaxFactory::udpInitialStmt(Token initial, Token name, Token equals, ExpressionSyntax& value, Token semi) {
+    return *alloc.emplace<UdpInitialStmtSyntax>(initial, name, equals, value, semi);
+}
+
+UdpInputPortDeclSyntax& SyntaxFactory::udpInputPortDecl(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<IdentifierNameSyntax>& names) {
+    return *alloc.emplace<UdpInputPortDeclSyntax>(attributes, keyword, names);
+}
+
+UdpOutputPortDeclSyntax& SyntaxFactory::udpOutputPortDecl(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token reg, Token name, EqualsValueClauseSyntax* initializer) {
+    return *alloc.emplace<UdpOutputPortDeclSyntax>(attributes, keyword, reg, name, initializer);
+}
+
+UnconditionalBranchDirectiveSyntax& SyntaxFactory::unconditionalBranchDirective(SyntaxKind kind, Token directive, const TokenList& disabledTokens) {
+    return *alloc.emplace<UnconditionalBranchDirectiveSyntax>(kind, directive, disabledTokens);
+}
+
+UnconnectedDriveDirectiveSyntax& SyntaxFactory::unconnectedDriveDirective(Token directive, Token strength) {
+    return *alloc.emplace<UnconnectedDriveDirectiveSyntax>(directive, strength);
+}
+
+UndefDirectiveSyntax& SyntaxFactory::undefDirective(Token directive, Token name) {
+    return *alloc.emplace<UndefDirectiveSyntax>(directive, name);
+}
+
+UniquenessConstraintSyntax& SyntaxFactory::uniquenessConstraint(Token unique, OpenRangeListSyntax& ranges, Token semi) {
+    return *alloc.emplace<UniquenessConstraintSyntax>(unique, ranges, semi);
+}
+
+UserDefinedNetDeclarationSyntax& SyntaxFactory::userDefinedNetDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token netType, TimingControlSyntax& delay, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) {
+    return *alloc.emplace<UserDefinedNetDeclarationSyntax>(attributes, netType, delay, declarators, semi);
+}
+
+VariableDimensionSyntax& SyntaxFactory::variableDimension(Token openBracket, DimensionSpecifierSyntax* specifier, Token closeBracket) {
+    return *alloc.emplace<VariableDimensionSyntax>(openBracket, specifier, closeBracket);
+}
+
+VariablePatternSyntax& SyntaxFactory::variablePattern(Token dot, Token variableName) {
+    return *alloc.emplace<VariablePatternSyntax>(dot, variableName);
+}
+
+VariablePortHeaderSyntax& SyntaxFactory::variablePortHeader(Token constKeyword, Token direction, Token varKeyword, DataTypeSyntax& dataType) {
+    return *alloc.emplace<VariablePortHeaderSyntax>(constKeyword, direction, varKeyword, dataType);
+}
+
+VirtualInterfaceTypeSyntax& SyntaxFactory::virtualInterfaceType(Token virtualKeyword, Token interfaceKeyword, Token name, ParameterValueAssignmentSyntax* parameters, DotMemberClauseSyntax* modport) {
+    return *alloc.emplace<VirtualInterfaceTypeSyntax>(virtualKeyword, interfaceKeyword, name, parameters, modport);
+}
+
+VoidCastedCallStatementSyntax& SyntaxFactory::voidCastedCallStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token voidKeyword, Token apostrophe, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi) {
+    return *alloc.emplace<VoidCastedCallStatementSyntax>(label, attributes, voidKeyword, apostrophe, openParen, expr, closeParen, semi);
+}
+
+WaitForkStatementSyntax& SyntaxFactory::waitForkStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait, Token fork, Token semi) {
+    return *alloc.emplace<WaitForkStatementSyntax>(label, attributes, wait, fork, semi);
+}
+
+WaitOrderStatementSyntax& SyntaxFactory::waitOrderStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait_order, Token openParen, const SeparatedSyntaxList<NameSyntax>& names, Token closeParen, ActionBlockSyntax& action) {
+    return *alloc.emplace<WaitOrderStatementSyntax>(label, attributes, wait_order, openParen, names, closeParen, action);
+}
+
+WaitStatementSyntax& SyntaxFactory::waitStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement) {
+    return *alloc.emplace<WaitStatementSyntax>(label, attributes, wait, openParen, expr, closeParen, statement);
+}
+
+WildcardDimensionSpecifierSyntax& SyntaxFactory::wildcardDimensionSpecifier(Token star) {
+    return *alloc.emplace<WildcardDimensionSpecifierSyntax>(star);
+}
+
+WildcardPatternSyntax& SyntaxFactory::wildcardPattern(Token dotStar) {
+    return *alloc.emplace<WildcardPatternSyntax>(dotStar);
+}
+
+WildcardPortConnectionSyntax& SyntaxFactory::wildcardPortConnection(const SyntaxList<AttributeInstanceSyntax>& attributes, Token dotStar) {
+    return *alloc.emplace<WildcardPortConnectionSyntax>(attributes, dotStar);
+}
+
+WildcardPortListSyntax& SyntaxFactory::wildcardPortList(Token openParen, Token dotStar, Token closeParen) {
+    return *alloc.emplace<WildcardPortListSyntax>(openParen, dotStar, closeParen);
+}
+
+WildcardUdpPortListSyntax& SyntaxFactory::wildcardUdpPortList(Token openParen, Token dotStar, Token closeParen, Token semi) {
+    return *alloc.emplace<WildcardUdpPortListSyntax>(openParen, dotStar, closeParen, semi);
+}
+
+WithClauseSyntax& SyntaxFactory::withClause(Token with, Token openParen, ExpressionSyntax& expr, Token closeParen) {
+    return *alloc.emplace<WithClauseSyntax>(with, openParen, expr, closeParen);
+}
+
+WithFunctionClauseSyntax& SyntaxFactory::withFunctionClause(Token with, NameSyntax& name) {
+    return *alloc.emplace<WithFunctionClauseSyntax>(with, name);
+}
+
+WithFunctionSampleSyntax& SyntaxFactory::withFunctionSample(Token with, Token function, Token sample, AnsiPortListSyntax& portList) {
+    return *alloc.emplace<WithFunctionSampleSyntax>(with, function, sample, portList);
+}
+
+
+std::ostream& operator<<(std::ostream& os, SyntaxKind kind) {
+    os << toString(kind);
+    return os;
+}
+
+string_view toString(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AcceptOnPropertyExpression: return "AcceptOnPropertyExpression";
+        case SyntaxKind::ActionBlock: return "ActionBlock";
+        case SyntaxKind::AddAssignmentExpression: return "AddAssignmentExpression";
+        case SyntaxKind::AddExpression: return "AddExpression";
+        case SyntaxKind::AlwaysBlock: return "AlwaysBlock";
+        case SyntaxKind::AlwaysCombBlock: return "AlwaysCombBlock";
+        case SyntaxKind::AlwaysFFBlock: return "AlwaysFFBlock";
+        case SyntaxKind::AlwaysLatchBlock: return "AlwaysLatchBlock";
+        case SyntaxKind::AlwaysPropertyExpression: return "AlwaysPropertyExpression";
+        case SyntaxKind::AndAssignmentExpression: return "AndAssignmentExpression";
+        case SyntaxKind::AndSequenceExpression: return "AndSequenceExpression";
+        case SyntaxKind::AnsiPortList: return "AnsiPortList";
+        case SyntaxKind::AnsiUdpPortList: return "AnsiUdpPortList";
+        case SyntaxKind::ArgumentList: return "ArgumentList";
+        case SyntaxKind::ArithmeticLeftShiftAssignmentExpression: return "ArithmeticLeftShiftAssignmentExpression";
+        case SyntaxKind::ArithmeticRightShiftAssignmentExpression: return "ArithmeticRightShiftAssignmentExpression";
+        case SyntaxKind::ArithmeticShiftLeftExpression: return "ArithmeticShiftLeftExpression";
+        case SyntaxKind::ArithmeticShiftRightExpression: return "ArithmeticShiftRightExpression";
+        case SyntaxKind::ArrayAndMethod: return "ArrayAndMethod";
+        case SyntaxKind::ArrayOrMethod: return "ArrayOrMethod";
+        case SyntaxKind::ArrayOrRandomizeMethodExpression: return "ArrayOrRandomizeMethodExpression";
+        case SyntaxKind::ArrayUniqueMethod: return "ArrayUniqueMethod";
+        case SyntaxKind::ArrayXorMethod: return "ArrayXorMethod";
+        case SyntaxKind::AscendingRangeSelect: return "AscendingRangeSelect";
+        case SyntaxKind::AssertPropertyStatement: return "AssertPropertyStatement";
+        case SyntaxKind::AssertionItemPort: return "AssertionItemPort";
+        case SyntaxKind::AssertionItemPortList: return "AssertionItemPortList";
+        case SyntaxKind::AssignmentExpression: return "AssignmentExpression";
+        case SyntaxKind::AssignmentPatternExpression: return "AssignmentPatternExpression";
+        case SyntaxKind::AssignmentPatternItem: return "AssignmentPatternItem";
+        case SyntaxKind::AssumePropertyStatement: return "AssumePropertyStatement";
+        case SyntaxKind::AttributeInstance: return "AttributeInstance";
+        case SyntaxKind::AttributeSpec: return "AttributeSpec";
+        case SyntaxKind::BadExpression: return "BadExpression";
+        case SyntaxKind::BeginKeywordsDirective: return "BeginKeywordsDirective";
+        case SyntaxKind::BinaryAndExpression: return "BinaryAndExpression";
+        case SyntaxKind::BinaryBlockEventExpression: return "BinaryBlockEventExpression";
+        case SyntaxKind::BinaryEventExpression: return "BinaryEventExpression";
+        case SyntaxKind::BinaryOrExpression: return "BinaryOrExpression";
+        case SyntaxKind::BinarySequenceDelayExpression: return "BinarySequenceDelayExpression";
+        case SyntaxKind::BinaryXnorExpression: return "BinaryXnorExpression";
+        case SyntaxKind::BinaryXorExpression: return "BinaryXorExpression";
+        case SyntaxKind::BindDirective: return "BindDirective";
+        case SyntaxKind::BindTargetList: return "BindTargetList";
+        case SyntaxKind::BitSelect: return "BitSelect";
+        case SyntaxKind::BitType: return "BitType";
+        case SyntaxKind::BlockCoverageEvent: return "BlockCoverageEvent";
+        case SyntaxKind::BlockingEventTriggerStatement: return "BlockingEventTriggerStatement";
+        case SyntaxKind::ByteType: return "ByteType";
+        case SyntaxKind::CHandleType: return "CHandleType";
+        case SyntaxKind::CaseEqualityExpression: return "CaseEqualityExpression";
+        case SyntaxKind::CaseGenerate: return "CaseGenerate";
+        case SyntaxKind::CaseInequalityExpression: return "CaseInequalityExpression";
+        case SyntaxKind::CaseStatement: return "CaseStatement";
+        case SyntaxKind::CastExpression: return "CastExpression";
+        case SyntaxKind::CellDefineDirective: return "CellDefineDirective";
+        case SyntaxKind::ChargeStrength: return "ChargeStrength";
+        case SyntaxKind::ClassDeclaration: return "ClassDeclaration";
+        case SyntaxKind::ClassMethodDeclaration: return "ClassMethodDeclaration";
+        case SyntaxKind::ClassMethodPrototype: return "ClassMethodPrototype";
+        case SyntaxKind::ClassName: return "ClassName";
+        case SyntaxKind::ClassPropertyDeclaration: return "ClassPropertyDeclaration";
+        case SyntaxKind::ClockingDeclaration: return "ClockingDeclaration";
+        case SyntaxKind::ClockingDirection: return "ClockingDirection";
+        case SyntaxKind::ClockingItem: return "ClockingItem";
+        case SyntaxKind::ClockingSkew: return "ClockingSkew";
+        case SyntaxKind::ColonExpressionClause: return "ColonExpressionClause";
+        case SyntaxKind::CompilationUnit: return "CompilationUnit";
+        case SyntaxKind::ConcatenationExpression: return "ConcatenationExpression";
+        case SyntaxKind::ConcurrentAssertionMember: return "ConcurrentAssertionMember";
+        case SyntaxKind::ConditionalConstraint: return "ConditionalConstraint";
+        case SyntaxKind::ConditionalExpression: return "ConditionalExpression";
+        case SyntaxKind::ConditionalPathDeclaration: return "ConditionalPathDeclaration";
+        case SyntaxKind::ConditionalPattern: return "ConditionalPattern";
+        case SyntaxKind::ConditionalPredicate: return "ConditionalPredicate";
+        case SyntaxKind::ConditionalStatement: return "ConditionalStatement";
+        case SyntaxKind::ConstraintBlock: return "ConstraintBlock";
+        case SyntaxKind::ConstraintDeclaration: return "ConstraintDeclaration";
+        case SyntaxKind::ConstraintPrototype: return "ConstraintPrototype";
+        case SyntaxKind::ConstructorName: return "ConstructorName";
+        case SyntaxKind::ContinuousAssign: return "ContinuousAssign";
+        case SyntaxKind::CopyClassExpression: return "CopyClassExpression";
+        case SyntaxKind::CoverPropertyStatement: return "CoverPropertyStatement";
+        case SyntaxKind::CoverSequenceStatement: return "CoverSequenceStatement";
+        case SyntaxKind::CoverageBins: return "CoverageBins";
+        case SyntaxKind::CoverageIffClause: return "CoverageIffClause";
+        case SyntaxKind::CoverageOption: return "CoverageOption";
+        case SyntaxKind::CovergroupDeclaration: return "CovergroupDeclaration";
+        case SyntaxKind::Coverpoint: return "Coverpoint";
+        case SyntaxKind::CycleDelay: return "CycleDelay";
+        case SyntaxKind::DPIExport: return "DPIExport";
+        case SyntaxKind::DPIImport: return "DPIImport";
+        case SyntaxKind::DataDeclaration: return "DataDeclaration";
+        case SyntaxKind::Declarator: return "Declarator";
+        case SyntaxKind::DefParam: return "DefParam";
+        case SyntaxKind::DefParamAssignment: return "DefParamAssignment";
+        case SyntaxKind::DefaultCaseItem: return "DefaultCaseItem";
+        case SyntaxKind::DefaultClockingReference: return "DefaultClockingReference";
+        case SyntaxKind::DefaultCoverageBinInitializer: return "DefaultCoverageBinInitializer";
+        case SyntaxKind::DefaultNetTypeDirective: return "DefaultNetTypeDirective";
+        case SyntaxKind::DefaultPatternKeyExpression: return "DefaultPatternKeyExpression";
+        case SyntaxKind::DefaultSkewItem: return "DefaultSkewItem";
+        case SyntaxKind::DeferredAssertion: return "DeferredAssertion";
+        case SyntaxKind::DefineDirective: return "DefineDirective";
+        case SyntaxKind::Delay3: return "Delay3";
+        case SyntaxKind::DelayControl: return "DelayControl";
+        case SyntaxKind::DelayedTerminalArg: return "DelayedTerminalArg";
+        case SyntaxKind::DescendingRangeSelect: return "DescendingRangeSelect";
+        case SyntaxKind::DisableConstraint: return "DisableConstraint";
+        case SyntaxKind::DisableForkStatement: return "DisableForkStatement";
+        case SyntaxKind::DisableIff: return "DisableIff";
+        case SyntaxKind::DisableStatement: return "DisableStatement";
+        case SyntaxKind::DistConstraintList: return "DistConstraintList";
+        case SyntaxKind::DistItem: return "DistItem";
+        case SyntaxKind::DistWeight: return "DistWeight";
+        case SyntaxKind::DivideAssignmentExpression: return "DivideAssignmentExpression";
+        case SyntaxKind::DivideExpression: return "DivideExpression";
+        case SyntaxKind::DividerClause: return "DividerClause";
+        case SyntaxKind::DoWhileStatement: return "DoWhileStatement";
+        case SyntaxKind::DotMemberClause: return "DotMemberClause";
+        case SyntaxKind::DriveStrength: return "DriveStrength";
+        case SyntaxKind::EdgeControlSpecifier: return "EdgeControlSpecifier";
+        case SyntaxKind::EdgeDescriptor: return "EdgeDescriptor";
+        case SyntaxKind::EdgeSensitivePathSuffix: return "EdgeSensitivePathSuffix";
+        case SyntaxKind::ElabSystemTask: return "ElabSystemTask";
+        case SyntaxKind::ElementSelect: return "ElementSelect";
+        case SyntaxKind::ElementSelectExpression: return "ElementSelectExpression";
+        case SyntaxKind::ElsIfDirective: return "ElsIfDirective";
+        case SyntaxKind::ElseClause: return "ElseClause";
+        case SyntaxKind::ElseConstraintClause: return "ElseConstraintClause";
+        case SyntaxKind::ElseDirective: return "ElseDirective";
+        case SyntaxKind::EmptyArgument: return "EmptyArgument";
+        case SyntaxKind::EmptyIdentifierName: return "EmptyIdentifierName";
+        case SyntaxKind::EmptyMember: return "EmptyMember";
+        case SyntaxKind::EmptyPortConnection: return "EmptyPortConnection";
+        case SyntaxKind::EmptyQueueExpression: return "EmptyQueueExpression";
+        case SyntaxKind::EmptyStatement: return "EmptyStatement";
+        case SyntaxKind::EmptyTimingCheckArg: return "EmptyTimingCheckArg";
+        case SyntaxKind::EndCellDefineDirective: return "EndCellDefineDirective";
+        case SyntaxKind::EndIfDirective: return "EndIfDirective";
+        case SyntaxKind::EndKeywordsDirective: return "EndKeywordsDirective";
+        case SyntaxKind::EnumType: return "EnumType";
+        case SyntaxKind::EqualityExpression: return "EqualityExpression";
+        case SyntaxKind::EqualsTypeClause: return "EqualsTypeClause";
+        case SyntaxKind::EqualsValueClause: return "EqualsValueClause";
+        case SyntaxKind::EventControl: return "EventControl";
+        case SyntaxKind::EventControlWithExpression: return "EventControlWithExpression";
+        case SyntaxKind::EventType: return "EventType";
+        case SyntaxKind::EventuallyPropertyExpression: return "EventuallyPropertyExpression";
+        case SyntaxKind::ExpectPropertyStatement: return "ExpectPropertyStatement";
+        case SyntaxKind::ExplicitAnsiPort: return "ExplicitAnsiPort";
+        case SyntaxKind::ExplicitNonAnsiPort: return "ExplicitNonAnsiPort";
+        case SyntaxKind::ExpressionConstraint: return "ExpressionConstraint";
+        case SyntaxKind::ExpressionCoverageBinInitializer: return "ExpressionCoverageBinInitializer";
+        case SyntaxKind::ExpressionOrDist: return "ExpressionOrDist";
+        case SyntaxKind::ExpressionPattern: return "ExpressionPattern";
+        case SyntaxKind::ExpressionStatement: return "ExpressionStatement";
+        case SyntaxKind::ExpressionTimingCheckArg: return "ExpressionTimingCheckArg";
+        case SyntaxKind::ExtendsClause: return "ExtendsClause";
+        case SyntaxKind::ExternModule: return "ExternModule";
+        case SyntaxKind::FinalBlock: return "FinalBlock";
+        case SyntaxKind::ForLoopStatement: return "ForLoopStatement";
+        case SyntaxKind::ForVariableDeclaration: return "ForVariableDeclaration";
+        case SyntaxKind::ForeachLoopList: return "ForeachLoopList";
+        case SyntaxKind::ForeachLoopStatement: return "ForeachLoopStatement";
+        case SyntaxKind::ForeverStatement: return "ForeverStatement";
+        case SyntaxKind::ForwardInterfaceClassTypedefDeclaration: return "ForwardInterfaceClassTypedefDeclaration";
+        case SyntaxKind::ForwardTypedefDeclaration: return "ForwardTypedefDeclaration";
+        case SyntaxKind::FunctionDeclaration: return "FunctionDeclaration";
+        case SyntaxKind::FunctionPort: return "FunctionPort";
+        case SyntaxKind::FunctionPortList: return "FunctionPortList";
+        case SyntaxKind::FunctionPrototype: return "FunctionPrototype";
+        case SyntaxKind::GateInstance: return "GateInstance";
+        case SyntaxKind::GateInstanceName: return "GateInstanceName";
+        case SyntaxKind::GateInstantiation: return "GateInstantiation";
+        case SyntaxKind::GenerateBlock: return "GenerateBlock";
+        case SyntaxKind::GenerateRegion: return "GenerateRegion";
+        case SyntaxKind::GenvarDeclaration: return "GenvarDeclaration";
+        case SyntaxKind::GreaterThanEqualExpression: return "GreaterThanEqualExpression";
+        case SyntaxKind::GreaterThanExpression: return "GreaterThanExpression";
+        case SyntaxKind::HierarchicalInstance: return "HierarchicalInstance";
+        case SyntaxKind::HierarchyInstantiation: return "HierarchyInstantiation";
+        case SyntaxKind::IdentifierName: return "IdentifierName";
+        case SyntaxKind::IdentifierSelectName: return "IdentifierSelectName";
+        case SyntaxKind::IfDefDirective: return "IfDefDirective";
+        case SyntaxKind::IfGenerate: return "IfGenerate";
+        case SyntaxKind::IfNDefDirective: return "IfNDefDirective";
+        case SyntaxKind::IfNonePathDeclaration: return "IfNonePathDeclaration";
+        case SyntaxKind::IffEventClause: return "IffEventClause";
+        case SyntaxKind::IffPropertyExpression: return "IffPropertyExpression";
+        case SyntaxKind::ImmediateAssertStatement: return "ImmediateAssertStatement";
+        case SyntaxKind::ImmediateAssertionMember: return "ImmediateAssertionMember";
+        case SyntaxKind::ImmediateAssumeStatement: return "ImmediateAssumeStatement";
+        case SyntaxKind::ImmediateCoverStatement: return "ImmediateCoverStatement";
+        case SyntaxKind::ImplementsClause: return "ImplementsClause";
+        case SyntaxKind::ImplicationConstraint: return "ImplicationConstraint";
+        case SyntaxKind::ImplicitAnsiPort: return "ImplicitAnsiPort";
+        case SyntaxKind::ImplicitEventControl: return "ImplicitEventControl";
+        case SyntaxKind::ImplicitNonAnsiPort: return "ImplicitNonAnsiPort";
+        case SyntaxKind::ImplicitType: return "ImplicitType";
+        case SyntaxKind::ImpliesPropertyExpression: return "ImpliesPropertyExpression";
+        case SyntaxKind::IncludeDirective: return "IncludeDirective";
+        case SyntaxKind::InequalityExpression: return "InequalityExpression";
+        case SyntaxKind::InitialBlock: return "InitialBlock";
+        case SyntaxKind::InsideExpression: return "InsideExpression";
+        case SyntaxKind::IntType: return "IntType";
+        case SyntaxKind::IntegerLiteralExpression: return "IntegerLiteralExpression";
+        case SyntaxKind::IntegerType: return "IntegerType";
+        case SyntaxKind::IntegerVectorExpression: return "IntegerVectorExpression";
+        case SyntaxKind::InterconnectPortHeader: return "InterconnectPortHeader";
+        case SyntaxKind::InterfaceDeclaration: return "InterfaceDeclaration";
+        case SyntaxKind::InterfaceHeader: return "InterfaceHeader";
+        case SyntaxKind::InterfacePortHeader: return "InterfacePortHeader";
+        case SyntaxKind::IntersectSequenceExpression: return "IntersectSequenceExpression";
+        case SyntaxKind::InvocationExpression: return "InvocationExpression";
+        case SyntaxKind::JumpStatement: return "JumpStatement";
+        case SyntaxKind::LessThanEqualExpression: return "LessThanEqualExpression";
+        case SyntaxKind::LessThanExpression: return "LessThanExpression";
+        case SyntaxKind::LetDeclaration: return "LetDeclaration";
+        case SyntaxKind::LineDirective: return "LineDirective";
+        case SyntaxKind::LocalScope: return "LocalScope";
+        case SyntaxKind::LogicType: return "LogicType";
+        case SyntaxKind::LogicalAndExpression: return "LogicalAndExpression";
+        case SyntaxKind::LogicalEquivalenceExpression: return "LogicalEquivalenceExpression";
+        case SyntaxKind::LogicalImplicationExpression: return "LogicalImplicationExpression";
+        case SyntaxKind::LogicalLeftShiftAssignmentExpression: return "LogicalLeftShiftAssignmentExpression";
+        case SyntaxKind::LogicalOrExpression: return "LogicalOrExpression";
+        case SyntaxKind::LogicalRightShiftAssignmentExpression: return "LogicalRightShiftAssignmentExpression";
+        case SyntaxKind::LogicalShiftLeftExpression: return "LogicalShiftLeftExpression";
+        case SyntaxKind::LogicalShiftRightExpression: return "LogicalShiftRightExpression";
+        case SyntaxKind::LongIntType: return "LongIntType";
+        case SyntaxKind::LoopConstraint: return "LoopConstraint";
+        case SyntaxKind::LoopGenerate: return "LoopGenerate";
+        case SyntaxKind::LoopStatement: return "LoopStatement";
+        case SyntaxKind::MacroActualArgument: return "MacroActualArgument";
+        case SyntaxKind::MacroActualArgumentList: return "MacroActualArgumentList";
+        case SyntaxKind::MacroArgumentDefault: return "MacroArgumentDefault";
+        case SyntaxKind::MacroFormalArgument: return "MacroFormalArgument";
+        case SyntaxKind::MacroFormalArgumentList: return "MacroFormalArgumentList";
+        case SyntaxKind::MacroUsage: return "MacroUsage";
+        case SyntaxKind::MatchesClause: return "MatchesClause";
+        case SyntaxKind::MemberAccessExpression: return "MemberAccessExpression";
+        case SyntaxKind::MinTypMaxExpression: return "MinTypMaxExpression";
+        case SyntaxKind::ModAssignmentExpression: return "ModAssignmentExpression";
+        case SyntaxKind::ModExpression: return "ModExpression";
+        case SyntaxKind::ModportClockingPort: return "ModportClockingPort";
+        case SyntaxKind::ModportDeclaration: return "ModportDeclaration";
+        case SyntaxKind::ModportExplicitPort: return "ModportExplicitPort";
+        case SyntaxKind::ModportItem: return "ModportItem";
+        case SyntaxKind::ModportNamedPort: return "ModportNamedPort";
+        case SyntaxKind::ModportSimplePortList: return "ModportSimplePortList";
+        case SyntaxKind::ModportSubroutinePort: return "ModportSubroutinePort";
+        case SyntaxKind::ModportSubroutinePortList: return "ModportSubroutinePortList";
+        case SyntaxKind::ModuleDeclaration: return "ModuleDeclaration";
+        case SyntaxKind::ModuleHeader: return "ModuleHeader";
+        case SyntaxKind::MultipleConcatenationExpression: return "MultipleConcatenationExpression";
+        case SyntaxKind::MultiplyAssignmentExpression: return "MultiplyAssignmentExpression";
+        case SyntaxKind::MultiplyExpression: return "MultiplyExpression";
+        case SyntaxKind::NameValuePragmaExpression: return "NameValuePragmaExpression";
+        case SyntaxKind::NamedArgument: return "NamedArgument";
+        case SyntaxKind::NamedBlockClause: return "NamedBlockClause";
+        case SyntaxKind::NamedLabel: return "NamedLabel";
+        case SyntaxKind::NamedPortConnection: return "NamedPortConnection";
+        case SyntaxKind::NamedStructurePatternMember: return "NamedStructurePatternMember";
+        case SyntaxKind::NamedType: return "NamedType";
+        case SyntaxKind::NetDeclaration: return "NetDeclaration";
+        case SyntaxKind::NetPortHeader: return "NetPortHeader";
+        case SyntaxKind::NetTypeDeclaration: return "NetTypeDeclaration";
+        case SyntaxKind::NewArrayExpression: return "NewArrayExpression";
+        case SyntaxKind::NewClassExpression: return "NewClassExpression";
+        case SyntaxKind::NextTimePropertyExpression: return "NextTimePropertyExpression";
+        case SyntaxKind::NoUnconnectedDriveDirective: return "NoUnconnectedDriveDirective";
+        case SyntaxKind::NonAnsiPortList: return "NonAnsiPortList";
+        case SyntaxKind::NonAnsiUdpPortList: return "NonAnsiUdpPortList";
+        case SyntaxKind::NonOverlappedFollowedByPropertyExpression: return "NonOverlappedFollowedByPropertyExpression";
+        case SyntaxKind::NonOverlappedImplicationPropertyExpression: return "NonOverlappedImplicationPropertyExpression";
+        case SyntaxKind::NonblockingAssignmentExpression: return "NonblockingAssignmentExpression";
+        case SyntaxKind::NonblockingEventTriggerStatement: return "NonblockingEventTriggerStatement";
+        case SyntaxKind::NullLiteralExpression: return "NullLiteralExpression";
+        case SyntaxKind::NumberPragmaExpression: return "NumberPragmaExpression";
+        case SyntaxKind::OneStepLiteralExpression: return "OneStepLiteralExpression";
+        case SyntaxKind::OpenRangeExpression: return "OpenRangeExpression";
+        case SyntaxKind::OpenRangeList: return "OpenRangeList";
+        case SyntaxKind::OrAssignmentExpression: return "OrAssignmentExpression";
+        case SyntaxKind::OrSequenceExpression: return "OrSequenceExpression";
+        case SyntaxKind::OrderedArgument: return "OrderedArgument";
+        case SyntaxKind::OrderedPortConnection: return "OrderedPortConnection";
+        case SyntaxKind::OrderedStructurePatternMember: return "OrderedStructurePatternMember";
+        case SyntaxKind::OverlappedFollowedByPropertyExpression: return "OverlappedFollowedByPropertyExpression";
+        case SyntaxKind::OverlappedImplicationPropertyExpression: return "OverlappedImplicationPropertyExpression";
+        case SyntaxKind::PackageDeclaration: return "PackageDeclaration";
+        case SyntaxKind::PackageHeader: return "PackageHeader";
+        case SyntaxKind::PackageImportDeclaration: return "PackageImportDeclaration";
+        case SyntaxKind::PackageImportItem: return "PackageImportItem";
+        case SyntaxKind::ParallelBlockStatement: return "ParallelBlockStatement";
+        case SyntaxKind::ParameterDeclaration: return "ParameterDeclaration";
+        case SyntaxKind::ParameterDeclarationStatement: return "ParameterDeclarationStatement";
+        case SyntaxKind::ParameterPortList: return "ParameterPortList";
+        case SyntaxKind::ParameterValueAssignment: return "ParameterValueAssignment";
+        case SyntaxKind::ParenExpressionList: return "ParenExpressionList";
+        case SyntaxKind::ParenPragmaExpression: return "ParenPragmaExpression";
+        case SyntaxKind::ParenthesizedEventExpression: return "ParenthesizedEventExpression";
+        case SyntaxKind::ParenthesizedExpression: return "ParenthesizedExpression";
+        case SyntaxKind::PathDeclaration: return "PathDeclaration";
+        case SyntaxKind::PathDescription: return "PathDescription";
+        case SyntaxKind::PatternCaseItem: return "PatternCaseItem";
+        case SyntaxKind::PortConcatenation: return "PortConcatenation";
+        case SyntaxKind::PortDeclaration: return "PortDeclaration";
+        case SyntaxKind::PortReference: return "PortReference";
+        case SyntaxKind::PostdecrementExpression: return "PostdecrementExpression";
+        case SyntaxKind::PostincrementExpression: return "PostincrementExpression";
+        case SyntaxKind::PowerExpression: return "PowerExpression";
+        case SyntaxKind::PragmaDirective: return "PragmaDirective";
+        case SyntaxKind::PrimaryBlockEventExpression: return "PrimaryBlockEventExpression";
+        case SyntaxKind::ProceduralAssignStatement: return "ProceduralAssignStatement";
+        case SyntaxKind::ProceduralDeassignStatement: return "ProceduralDeassignStatement";
+        case SyntaxKind::ProceduralForceStatement: return "ProceduralForceStatement";
+        case SyntaxKind::ProceduralReleaseStatement: return "ProceduralReleaseStatement";
+        case SyntaxKind::ProgramDeclaration: return "ProgramDeclaration";
+        case SyntaxKind::ProgramHeader: return "ProgramHeader";
+        case SyntaxKind::PropertyDeclaration: return "PropertyDeclaration";
+        case SyntaxKind::PropertySpec: return "PropertySpec";
+        case SyntaxKind::PropertyType: return "PropertyType";
+        case SyntaxKind::PulseStyleDeclaration: return "PulseStyleDeclaration";
+        case SyntaxKind::QueueDimensionSpecifier: return "QueueDimensionSpecifier";
+        case SyntaxKind::RandCaseItem: return "RandCaseItem";
+        case SyntaxKind::RandCaseStatement: return "RandCaseStatement";
+        case SyntaxKind::RangeCoverageBinInitializer: return "RangeCoverageBinInitializer";
+        case SyntaxKind::RangeDimensionSpecifier: return "RangeDimensionSpecifier";
+        case SyntaxKind::RealLiteralExpression: return "RealLiteralExpression";
+        case SyntaxKind::RealTimeType: return "RealTimeType";
+        case SyntaxKind::RealType: return "RealType";
+        case SyntaxKind::RegType: return "RegType";
+        case SyntaxKind::RejectOnPropertyExpression: return "RejectOnPropertyExpression";
+        case SyntaxKind::RepeatedEventControl: return "RepeatedEventControl";
+        case SyntaxKind::ReplicatedAssignmentPattern: return "ReplicatedAssignmentPattern";
+        case SyntaxKind::ResetAllDirective: return "ResetAllDirective";
+        case SyntaxKind::RestrictPropertyStatement: return "RestrictPropertyStatement";
+        case SyntaxKind::ReturnStatement: return "ReturnStatement";
+        case SyntaxKind::RootScope: return "RootScope";
+        case SyntaxKind::SAlwaysPropertyExpression: return "SAlwaysPropertyExpression";
+        case SyntaxKind::SEventuallyPropertyExpression: return "SEventuallyPropertyExpression";
+        case SyntaxKind::SNextTimePropertyExpression: return "SNextTimePropertyExpression";
+        case SyntaxKind::SUntilPropertyExpression: return "SUntilPropertyExpression";
+        case SyntaxKind::SUntilWithPropertyExpression: return "SUntilWithPropertyExpression";
+        case SyntaxKind::ScopedName: return "ScopedName";
+        case SyntaxKind::SequenceDeclaration: return "SequenceDeclaration";
+        case SyntaxKind::SequenceType: return "SequenceType";
+        case SyntaxKind::SequentialBlockStatement: return "SequentialBlockStatement";
+        case SyntaxKind::ShortIntType: return "ShortIntType";
+        case SyntaxKind::ShortRealType: return "ShortRealType";
+        case SyntaxKind::ShortcutCycleDelayRange: return "ShortcutCycleDelayRange";
+        case SyntaxKind::SignalEventExpression: return "SignalEventExpression";
+        case SyntaxKind::SignedCastExpression: return "SignedCastExpression";
+        case SyntaxKind::SimpleAssignmentPattern: return "SimpleAssignmentPattern";
+        case SyntaxKind::SimplePathSuffix: return "SimplePathSuffix";
+        case SyntaxKind::SimplePragmaExpression: return "SimplePragmaExpression";
+        case SyntaxKind::SimpleRangeSelect: return "SimpleRangeSelect";
+        case SyntaxKind::SolveBeforeConstraint: return "SolveBeforeConstraint";
+        case SyntaxKind::SpecifyBlock: return "SpecifyBlock";
+        case SyntaxKind::SpecparamDeclaration: return "SpecparamDeclaration";
+        case SyntaxKind::SpecparamDeclarator: return "SpecparamDeclarator";
+        case SyntaxKind::StandardCaseItem: return "StandardCaseItem";
+        case SyntaxKind::StreamExpression: return "StreamExpression";
+        case SyntaxKind::StreamExpressionWithRange: return "StreamExpressionWithRange";
+        case SyntaxKind::StreamingConcatenationExpression: return "StreamingConcatenationExpression";
+        case SyntaxKind::StringLiteralExpression: return "StringLiteralExpression";
+        case SyntaxKind::StringType: return "StringType";
+        case SyntaxKind::StructType: return "StructType";
+        case SyntaxKind::StructUnionMember: return "StructUnionMember";
+        case SyntaxKind::StructurePattern: return "StructurePattern";
+        case SyntaxKind::StructuredAssignmentPattern: return "StructuredAssignmentPattern";
+        case SyntaxKind::SubtractAssignmentExpression: return "SubtractAssignmentExpression";
+        case SyntaxKind::SubtractExpression: return "SubtractExpression";
+        case SyntaxKind::SuperHandle: return "SuperHandle";
+        case SyntaxKind::SyncAcceptOnPropertyExpression: return "SyncAcceptOnPropertyExpression";
+        case SyntaxKind::SyncRejectOnPropertyExpression: return "SyncRejectOnPropertyExpression";
+        case SyntaxKind::SystemName: return "SystemName";
+        case SyntaxKind::SystemTimingCheck: return "SystemTimingCheck";
+        case SyntaxKind::TaggedPattern: return "TaggedPattern";
+        case SyntaxKind::TaggedUnionExpression: return "TaggedUnionExpression";
+        case SyntaxKind::TaskDeclaration: return "TaskDeclaration";
+        case SyntaxKind::ThisHandle: return "ThisHandle";
+        case SyntaxKind::ThroughoutSequenceExpression: return "ThroughoutSequenceExpression";
+        case SyntaxKind::TimeLiteralExpression: return "TimeLiteralExpression";
+        case SyntaxKind::TimeScaleDirective: return "TimeScaleDirective";
+        case SyntaxKind::TimeType: return "TimeType";
+        case SyntaxKind::TimeUnitsDeclaration: return "TimeUnitsDeclaration";
+        case SyntaxKind::TimingCheckCondition: return "TimingCheckCondition";
+        case SyntaxKind::TimingCheckEvent: return "TimingCheckEvent";
+        case SyntaxKind::TimingControlExpression: return "TimingControlExpression";
+        case SyntaxKind::TimingControlExpressionConcatenation: return "TimingControlExpressionConcatenation";
+        case SyntaxKind::TimingControlStatement: return "TimingControlStatement";
+        case SyntaxKind::TransListCoverageBinInitializer: return "TransListCoverageBinInitializer";
+        case SyntaxKind::TransRange: return "TransRange";
+        case SyntaxKind::TransRepeatRange: return "TransRepeatRange";
+        case SyntaxKind::TransSet: return "TransSet";
+        case SyntaxKind::TypeAssignment: return "TypeAssignment";
+        case SyntaxKind::TypeParameterDeclaration: return "TypeParameterDeclaration";
+        case SyntaxKind::TypeReference: return "TypeReference";
+        case SyntaxKind::TypedefDeclaration: return "TypedefDeclaration";
+        case SyntaxKind::UdpBody: return "UdpBody";
+        case SyntaxKind::UdpDeclaration: return "UdpDeclaration";
+        case SyntaxKind::UdpEdgeIndicator: return "UdpEdgeIndicator";
+        case SyntaxKind::UdpEntry: return "UdpEntry";
+        case SyntaxKind::UdpInitialStmt: return "UdpInitialStmt";
+        case SyntaxKind::UdpInputPortDecl: return "UdpInputPortDecl";
+        case SyntaxKind::UdpOutputPortDecl: return "UdpOutputPortDecl";
+        case SyntaxKind::UnaryBitwiseAndExpression: return "UnaryBitwiseAndExpression";
+        case SyntaxKind::UnaryBitwiseNandExpression: return "UnaryBitwiseNandExpression";
+        case SyntaxKind::UnaryBitwiseNorExpression: return "UnaryBitwiseNorExpression";
+        case SyntaxKind::UnaryBitwiseNotExpression: return "UnaryBitwiseNotExpression";
+        case SyntaxKind::UnaryBitwiseOrExpression: return "UnaryBitwiseOrExpression";
+        case SyntaxKind::UnaryBitwiseXnorExpression: return "UnaryBitwiseXnorExpression";
+        case SyntaxKind::UnaryBitwiseXorExpression: return "UnaryBitwiseXorExpression";
+        case SyntaxKind::UnaryLogicalNotExpression: return "UnaryLogicalNotExpression";
+        case SyntaxKind::UnaryMinusExpression: return "UnaryMinusExpression";
+        case SyntaxKind::UnaryNotPropertyExpression: return "UnaryNotPropertyExpression";
+        case SyntaxKind::UnaryPlusExpression: return "UnaryPlusExpression";
+        case SyntaxKind::UnaryPredecrementExpression: return "UnaryPredecrementExpression";
+        case SyntaxKind::UnaryPreincrementExpression: return "UnaryPreincrementExpression";
+        case SyntaxKind::UnarySequenceDelayExpression: return "UnarySequenceDelayExpression";
+        case SyntaxKind::UnarySequenceEventExpression: return "UnarySequenceEventExpression";
+        case SyntaxKind::UnbasedUnsizedLiteralExpression: return "UnbasedUnsizedLiteralExpression";
+        case SyntaxKind::UnconnectedDriveDirective: return "UnconnectedDriveDirective";
+        case SyntaxKind::UndefDirective: return "UndefDirective";
+        case SyntaxKind::UndefineAllDirective: return "UndefineAllDirective";
+        case SyntaxKind::UnionType: return "UnionType";
+        case SyntaxKind::UniquenessConstraint: return "UniquenessConstraint";
+        case SyntaxKind::UnitScope: return "UnitScope";
+        case SyntaxKind::UntilPropertyExpression: return "UntilPropertyExpression";
+        case SyntaxKind::UntilWithPropertyExpression: return "UntilWithPropertyExpression";
+        case SyntaxKind::Untyped: return "Untyped";
+        case SyntaxKind::UserDefinedNetDeclaration: return "UserDefinedNetDeclaration";
+        case SyntaxKind::VariableDimension: return "VariableDimension";
+        case SyntaxKind::VariablePattern: return "VariablePattern";
+        case SyntaxKind::VariablePortHeader: return "VariablePortHeader";
+        case SyntaxKind::VirtualInterfaceType: return "VirtualInterfaceType";
+        case SyntaxKind::VoidCastedCallStatement: return "VoidCastedCallStatement";
+        case SyntaxKind::VoidType: return "VoidType";
+        case SyntaxKind::WaitForkStatement: return "WaitForkStatement";
+        case SyntaxKind::WaitOrderStatement: return "WaitOrderStatement";
+        case SyntaxKind::WaitStatement: return "WaitStatement";
+        case SyntaxKind::WildcardDimensionSpecifier: return "WildcardDimensionSpecifier";
+        case SyntaxKind::WildcardEqualityExpression: return "WildcardEqualityExpression";
+        case SyntaxKind::WildcardInequalityExpression: return "WildcardInequalityExpression";
+        case SyntaxKind::WildcardLiteralExpression: return "WildcardLiteralExpression";
+        case SyntaxKind::WildcardPattern: return "WildcardPattern";
+        case SyntaxKind::WildcardPortConnection: return "WildcardPortConnection";
+        case SyntaxKind::WildcardPortList: return "WildcardPortList";
+        case SyntaxKind::WildcardUdpPortList: return "WildcardUdpPortList";
+        case SyntaxKind::WithClause: return "WithClause";
+        case SyntaxKind::WithFunctionClause: return "WithFunctionClause";
+        case SyntaxKind::WithFunctionSample: return "WithFunctionSample";
+        case SyntaxKind::WithinSequenceExpression: return "WithinSequenceExpression";
+        case SyntaxKind::XorAssignmentExpression: return "XorAssignmentExpression";
+        default: return "";
+    }
+}
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./generated/DiagCode.cpp ./generated/DiagCode.cpp
--- ./generated/DiagCode.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/DiagCode.cpp	2021-03-02 17:50:54.001601827 -0800
@@ -0,0 +1,733 @@
+//------------------------------------------------------------------------------
+// DiagCode.cpp
+// Generated diagnostic helpers
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#include "slang/diagnostics/AllDiags.h"
+
+#include <ostream>
+
+#include <flat_hash_map.hpp>
+
+namespace slang {
+
+static const flat_hash_map<DiagCode, std::tuple<string_view, string_view, DiagnosticSeverity, string_view>> data = {
+    {diag::MaxInstanceDepthExceeded, std::make_tuple("MaxInstanceDepthExceeded"sv, "{} instantiation exceeded maximum depth of {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InfinitelyRecursiveHierarchy, std::make_tuple("InfinitelyRecursiveHierarchy"sv, "infinitely recursive instantiation of {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidTopModule, std::make_tuple("InvalidTopModule"sv, "'{}' is not a valid top-level module"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NoDeclInClass, std::make_tuple("NoDeclInClass"sv, "out-of-block definition of '{}' does not match any declaration in '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidParamOverrideOpt, std::make_tuple("InvalidParamOverrideOpt"sv, "'{}' is not a valid form of parameter override"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DPIExportKindMismatch, std::make_tuple("DPIExportKindMismatch"sv, "mismatch between 'function' and 'task' declared in DPI export"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DPIExportDifferentScope, std::make_tuple("DPIExportDifferentScope"sv, "exported subroutines must be defined in the same scope as the export directive"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DPIExportDuplicate, std::make_tuple("DPIExportDuplicate"sv, "duplicate export of '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DPIExportImportedFunc, std::make_tuple("DPIExportImportedFunc"sv, "cannot export an imported DPI subroutine"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidDPICIdentifier, std::make_tuple("InvalidDPICIdentifier"sv, "'{}' is not a valid C identifier for DPI subroutine"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DPISignatureMismatch, std::make_tuple("DPISignatureMismatch"sv, "more than one DPI subroutine with C identifier '{}' declared with mismatching type signatures"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DPIExportDuplicateCId, std::make_tuple("DPIExportDuplicateCId"sv, "more than one DPI export with the same C identifier '{}' in the same scope"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DefParamTargetChange, std::make_tuple("DefParamTargetChange"sv, "defparam target resolves differently post-elaboration; see '{}' vs '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DefParamCycle, std::make_tuple("DefParamCycle"sv, "cyclic dependency found when resolving defparam"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnusedDefinition, std::make_tuple("UnusedDefinition"sv, "{} definition is unused"sv, DiagnosticSeverity::Warning, "unused-def"sv)},
+    {diag::NoTopModules, std::make_tuple("NoTopModules"sv, "no top-level modules found in design"sv, DiagnosticSeverity::Warning, "no-top"sv)},
+    {diag::NoteInCallTo, std::make_tuple("NoteInCallTo"sv, "in call to '{}'"sv, DiagnosticSeverity::Note, ""sv)},
+    {diag::NoteSkippingFrames, std::make_tuple("NoteSkippingFrames"sv, "(skipping {} calls in backtrace; use --constexpr-backtrace-limit=0 to see all)"sv, DiagnosticSeverity::Note, ""sv)},
+    {diag::ConstEvalNonConstVariable, std::make_tuple("ConstEvalNonConstVariable"sv, "reference to non-constant variable '{}' is not allowed in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalBitsNotFixedSize, std::make_tuple("ConstEvalBitsNotFixedSize"sv, "$bits argument type {} is not fixed-size in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalBitstreamCastSize, std::make_tuple("ConstEvalBitstreamCastSize"sv, "bit-stream casting argument size {} cannot fit casting type {} in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalArrayIndexInvalid, std::make_tuple("ConstEvalArrayIndexInvalid"sv, "cannot refer to element {} of {} in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalPartSelectInvalid, std::make_tuple("ConstEvalPartSelectInvalid"sv, "cannot select range of [{}:{}] from {} in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalStringIndexInvalid, std::make_tuple("ConstEvalStringIndexInvalid"sv, "cannot select index {} from string of length {} in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalReplicationCountInvalid, std::make_tuple("ConstEvalReplicationCountInvalid"sv, "string replication count {} is invalid in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalHierarchicalNameInCE, std::make_tuple("ConstEvalHierarchicalNameInCE"sv, "reference to '{}' by hierarchical name is not allowed in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalFunctionIdentifiersMustBeLocal, std::make_tuple("ConstEvalFunctionIdentifiersMustBeLocal"sv, "all identifiers that are not parameters or enums must be declared locally to a constant function"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalIdUsedInCEBeforeDecl, std::make_tuple("ConstEvalIdUsedInCEBeforeDecl"sv, "identifier '{}' is declared after the invocation of the current constant function"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalNoCaseItemsMatched, std::make_tuple("ConstEvalNoCaseItemsMatched"sv, "no items in {} case statement matched value {} in constant function"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalCaseItemsNotUnique, std::make_tuple("ConstEvalCaseItemsNotUnique"sv, "more than one match found in unique case statement for value {} in constant function"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalTimedStmtNotConst, std::make_tuple("ConstEvalTimedStmtNotConst"sv, "constant expressions cannot schedule events"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalAssertionFailed, std::make_tuple("ConstEvalAssertionFailed"sv, "assertion failed in constant function"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalParallelBlockNotConst, std::make_tuple("ConstEvalParallelBlockNotConst"sv, "parallel blocks are not allowed in constant functions"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalExceededMaxCallDepth, std::make_tuple("ConstEvalExceededMaxCallDepth"sv, "constant evaluation exceeded maximum depth of {} calls"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalExceededMaxSteps, std::make_tuple("ConstEvalExceededMaxSteps"sv, "constant evaluation hit maximum step limit; possible infinite loop?"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalTaskNotConstant, std::make_tuple("ConstEvalTaskNotConstant"sv, "cannot invoke a task in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalVoidNotConstant, std::make_tuple("ConstEvalVoidNotConstant"sv, "cannot call a void function in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalDPINotConstant, std::make_tuple("ConstEvalDPINotConstant"sv, "cannot call DPI import function in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalMethodNotConstant, std::make_tuple("ConstEvalMethodNotConstant"sv, "cannot call class method in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalSubroutineNotConstant, std::make_tuple("ConstEvalSubroutineNotConstant"sv, "'{}' is not callable in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalFunctionArgDirection, std::make_tuple("ConstEvalFunctionArgDirection"sv, "cannot call a function with output, inout, or ref arguments in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalFunctionInsideGenerate, std::make_tuple("ConstEvalFunctionInsideGenerate"sv, "cannot call a function declared inside a generate block in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalDynamicToFixedSize, std::make_tuple("ConstEvalDynamicToFixedSize"sv, "cannot assign {} of length {} to {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalAssociativeIndexInvalid, std::make_tuple("ConstEvalAssociativeIndexInvalid"sv, "index {} has x or z bits which is invalid"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalDisableTarget, std::make_tuple("ConstEvalDisableTarget"sv, "disable statement in a constant function cannot target a block that is not currently executing"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalClassType, std::make_tuple("ConstEvalClassType"sv, "class types are not allowed in constant expressions"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalProceduralAssign, std::make_tuple("ConstEvalProceduralAssign"sv, "procedural assign and deassign statements are not allowed in constant functions"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalAssociativeElementNotFound, std::make_tuple("ConstEvalAssociativeElementNotFound"sv, "element {} does not exist in associative array"sv, DiagnosticSeverity::Warning, "elem-not-found"sv)},
+    {diag::ConstEvalStaticSkipped, std::make_tuple("ConstEvalStaticSkipped"sv, "static variable initialization is skipped in constant function calls"sv, DiagnosticSeverity::Warning, "static-skipped"sv)},
+    {diag::ConstEvalDynamicArrayIndex, std::make_tuple("ConstEvalDynamicArrayIndex"sv, "invalid index {} for {} of length {}"sv, DiagnosticSeverity::Warning, "dynarray-index"sv)},
+    {diag::ConstEvalDynamicArrayRange, std::make_tuple("ConstEvalDynamicArrayRange"sv, "invalid range [{}:{}] for {} of length {}"sv, DiagnosticSeverity::Warning, "dynarray-range"sv)},
+    {diag::ConstEvalQueueRange, std::make_tuple("ConstEvalQueueRange"sv, "reversed selection range [{}:{}] for queue will always yield an empty result"sv, DiagnosticSeverity::Warning, "queue-range"sv)},
+    {diag::ConstEvalEmptyQueue, std::make_tuple("ConstEvalEmptyQueue"sv, "pop from empty queue"sv, DiagnosticSeverity::Warning, "empty-queue"sv)},
+    {diag::ConstSysTaskIgnored, std::make_tuple("ConstSysTaskIgnored"sv, "system task '{}' is ignored in constant expression"sv, DiagnosticSeverity::Warning, "task-ignored"sv)},
+    {diag::LocalParamNoInitializer, std::make_tuple("LocalParamNoInitializer"sv, "local parameter is missing an initializer"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BodyParamNoInitializer, std::make_tuple("BodyParamNoInitializer"sv, "parameter declaration is missing an initializer"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidDimensionRange, std::make_tuple("InvalidDimensionRange"sv, "invalid dimension range"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DimensionRequiresConstRange, std::make_tuple("DimensionRequiresConstRange"sv, "dimension requires a constant range"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PackedDimsRequireFullRange, std::make_tuple("PackedDimsRequireFullRange"sv, "packed dimensions require a full range specification"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MixingOrderedAndNamedParams, std::make_tuple("MixingOrderedAndNamedParams"sv, "mixing ordered and named parameter assignments is not allowed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DuplicateParamAssignment, std::make_tuple("DuplicateParamAssignment"sv, "duplicate assignment for parameter '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ParamHasNoValue, std::make_tuple("ParamHasNoValue"sv, "instance of '{}' does not provide a value for parameter '{}' and it does not have a default value"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TooManyParamAssignments, std::make_tuple("TooManyParamAssignments"sv, "too many parameter assignments given for '{}' ({} given, expected {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignedToLocalPortParam, std::make_tuple("AssignedToLocalPortParam"sv, "can't assign a value to a localparam"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignedToLocalBodyParam, std::make_tuple("AssignedToLocalBodyParam"sv, "can't assign a value to a localparam (parameters in the body of a module are implicitly local when you have a parameter port list)"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ParameterDoesNotExist, std::make_tuple("ParameterDoesNotExist"sv, "parameter '{}' does not exist in '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadTypeParamExpr, std::make_tuple("BadTypeParamExpr"sv, "invalid initializer for type parameter '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PortTypeNotInterfaceOrData, std::make_tuple("PortTypeNotInterfaceOrData"sv, "port type '{}' is neither an interface nor a data type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::VarWithInterfacePort, std::make_tuple("VarWithInterfacePort"sv, "'var' keyword may not be used with an interface port"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DirectionWithInterfacePort, std::make_tuple("DirectionWithInterfacePort"sv, "port direction not allowed on an interface port"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InOutPortCannotBeVariable, std::make_tuple("InOutPortCannotBeVariable"sv, "variable port '{}' cannot have direction inout"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RefPortMustBeVariable, std::make_tuple("RefPortMustBeVariable"sv, "ref port '{}' cannot be of net type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MissingPortIODeclaration, std::make_tuple("MissingPortIODeclaration"sv, "port '{}' has no I/O member declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::CantDeclarePortSigned, std::make_tuple("CantDeclarePortSigned"sv, "'{}' cannot be declared '{}' because its type {} is not integral"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PortDeclDimensionsMismatch, std::make_tuple("PortDeclDimensionsMismatch"sv, "inconsistent dimensions declared for '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PortDeclInANSIModule, std::make_tuple("PortDeclInANSIModule"sv, "can't use port declaration in module with ANSI style port list"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnusedPortDecl, std::make_tuple("UnusedPortDecl"sv, "port declaration '{}' does not match any port in the module's port list"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownPackage, std::make_tuple("UnknownPackage"sv, "unknown package '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownModule, std::make_tuple("UnknownModule"sv, "unknown module '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownInterface, std::make_tuple("UnknownInterface"sv, "unknown interface '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MixingOrderedAndNamedPorts, std::make_tuple("MixingOrderedAndNamedPorts"sv, "mixing ordered and named port connections is not allowed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DuplicateWildcardPortConnection, std::make_tuple("DuplicateWildcardPortConnection"sv, "duplicate wildcard port connection"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DuplicatePortConnection, std::make_tuple("DuplicatePortConnection"sv, "duplicate connection for port '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TooManyPortConnections, std::make_tuple("TooManyPortConnections"sv, "too many port connections given to instantiation of module '{}' ({} given, expected {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PortDoesNotExist, std::make_tuple("PortDoesNotExist"sv, "port '{}' does not exist in module '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PortConnDimensionsMismatch, std::make_tuple("PortConnDimensionsMismatch"sv, "dimensions of connection for port '{}' do not match its declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InterfacePortNotConnected, std::make_tuple("InterfacePortNotConnected"sv, "interface port '{}' not connected"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InterfacePortInvalidExpression, std::make_tuple("InterfacePortInvalidExpression"sv, "invalid expression for interface port '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InterfacePortTypeMismatch, std::make_tuple("InterfacePortTypeMismatch"sv, "cannot connect instance of interface '{}' to port of interface '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MismatchedTimeScales, std::make_tuple("MismatchedTimeScales"sv, "duplicate time scale declaration must match previous value"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TimeScaleFirstInScope, std::make_tuple("TimeScaleFirstInScope"sv, "time scale declaration must come before all other items in scope"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::GenvarDuplicate, std::make_tuple("GenvarDuplicate"sv, "loop generation value {} repeats more than once"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::GenvarUnknownBits, std::make_tuple("GenvarUnknownBits"sv, "value of {} is invalid for loop generation value"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ImplicitNamedPortNotFound, std::make_tuple("ImplicitNamedPortNotFound"sv, "could not find connection for implicit named port '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ImplicitNamedPortTypeMismatch, std::make_tuple("ImplicitNamedPortTypeMismatch"sv, "implicit named port '{}' of type {} connects to value of inequivalent type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MaxGenerateStepsExceeded, std::make_tuple("MaxGenerateStepsExceeded"sv, "generate loop hit maximum step limit; possible infinite loop?"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MixingSubroutinePortKinds, std::make_tuple("MixingSubroutinePortKinds"sv, "port declarations not allowed when subroutine defines a formal argument list"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnpackedArrayParamType, std::make_tuple("UnpackedArrayParamType"sv, "unpacked array parameter requires explicit data type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AutomaticNotAllowed, std::make_tuple("AutomaticNotAllowed"sv, "automatic variables can only be declared in procedural contexts"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NoMemberImplFound, std::make_tuple("NoMemberImplFound"sv, "no implementation found in parent scope for '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MethodKindMismatch, std::make_tuple("MethodKindMismatch"sv, "mismatch between 'function' and 'task' declared in prototype"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MethodReturnMismatch, std::make_tuple("MethodReturnMismatch"sv, "return type {} of method '{}' does not match {} declared in its prototype"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MethodArgCountMismatch, std::make_tuple("MethodArgCountMismatch"sv, "definition of method '{}' has different number of arguments from its prototype"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MethodArgNameMismatch, std::make_tuple("MethodArgNameMismatch"sv, "method argument name '{}' doesn't match '{}' given in its prototype"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MethodArgTypeMismatch, std::make_tuple("MethodArgTypeMismatch"sv, "method argument '{}' is of type {} which differs from {} given in its prototype"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MethodArgNoDefault, std::make_tuple("MethodArgNoDefault"sv, "method argument '{}' provides a default value but its prototype does not"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MethodArgDefaultMismatch, std::make_tuple("MethodArgDefaultMismatch"sv, "default value for method argument '{}' must exactly match the expression given in its prototype"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MethodArgDirectionMismatch, std::make_tuple("MethodArgDirectionMismatch"sv, "direction of method argument '{}' differs from the direction given in its prototype"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MemberDefinitionBeforeClass, std::make_tuple("MemberDefinitionBeforeClass"sv, "definition of '{}' must come after its containing class '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MethodReturnTypeScoped, std::make_tuple("MethodReturnTypeScoped"sv, "return type for out-of-block method '{}' must use class scope '{}::' to access nested type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::VirtualKindMismatch, std::make_tuple("VirtualKindMismatch"sv, "mismatch between 'function' and 'task' declared in superclass method"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::VirtualReturnMismatch, std::make_tuple("VirtualReturnMismatch"sv, "return type {} of virtual method '{}' does not match {} declared in its superclass"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::VirtualArgCountMismatch, std::make_tuple("VirtualArgCountMismatch"sv, "virtual method '{}' has different number of arguments from its superclass method"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::VirtualArgNameMismatch, std::make_tuple("VirtualArgNameMismatch"sv, "virtual method argument name '{}' doesn't match '{}' given in its superclass method"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::VirtualArgTypeMismatch, std::make_tuple("VirtualArgTypeMismatch"sv, "virtual method argument '{}' is of type {} which differs from {} given in its superclass method"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::VirtualArgNoParentDefault, std::make_tuple("VirtualArgNoParentDefault"sv, "virtual method argument '{}' provides a default value but its superclass method argument does not"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::VirtualArgNoDerivedDefault, std::make_tuple("VirtualArgNoDerivedDefault"sv, "virtual method argument '{}' does not provide a default value but its superclass method argument does"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::VirtualArgDirectionMismatch, std::make_tuple("VirtualArgDirectionMismatch"sv, "direction of virtual method argument '{}' differs from the direction given in its superclass method"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BaseConstructorDuplicate, std::make_tuple("BaseConstructorDuplicate"sv, "cannot provide both 'super.new' as well as class constructor arguments in 'extends' clause"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BaseConstructorNotCalled, std::make_tuple("BaseConstructorNotCalled"sv, "class '{}' must provide arguments for constructing base class '{}' via 'super.new' or the 'extends' clause"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstVarNoInitializer, std::make_tuple("ConstVarNoInitializer"sv, "constant variable must have an initializer"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::StaticConstNoInitializer, std::make_tuple("StaticConstNoInitializer"sv, "static constant class properties must have initializers"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PureInAbstract, std::make_tuple("PureInAbstract"sv, "pure virtual methods can only be declared in virtual classes"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PureConstraintInAbstract, std::make_tuple("PureConstraintInAbstract"sv, "pure constraints can only be declared in virtual classes"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BodyForPure, std::make_tuple("BodyForPure"sv, "pure virtual methods cannot have a function body defined"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BodyForPureConstraint, std::make_tuple("BodyForPureConstraint"sv, "pure constraints cannot have a body defined"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InheritFromAbstract, std::make_tuple("InheritFromAbstract"sv, "'{}' cannot inherit from virtual class '{}' without providing an implementation for pure virtual method '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InheritFromAbstractConstraint, std::make_tuple("InheritFromAbstractConstraint"sv, "'{}' cannot inherit from virtual class '{}' without providing an implementation for pure constraint '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidPortType, std::make_tuple("InvalidPortType"sv, "{} is not a valid type for a port"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidNetType, std::make_tuple("InvalidNetType"sv, "{} is not a valid type for a net; only 4-state integral types and unpacked structs and arrays of such types are allowed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidUserDefinedNetType, std::make_tuple("InvalidUserDefinedNetType"sv, "{} is not a valid type for a user-defined nettype; only integral types, floating types, and unpacked structs, unions, and arrays of such types are allowed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExtendIfaceFromClass, std::make_tuple("ExtendIfaceFromClass"sv, "a normal (or virtual) class cannot extend interface class '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExtendClassFromIface, std::make_tuple("ExtendClassFromIface"sv, "an interface class cannot extend non-interface class '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ImplementNonIface, std::make_tuple("ImplementNonIface"sv, "cannot implement non-interface class '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::IfaceNameConflict, std::make_tuple("IfaceNameConflict"sv, "'{}' in '{}' conflicts with another member already inherited from '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::IfaceMethodHidden, std::make_tuple("IfaceMethodHidden"sv, "'{}' hides method inherited from '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::IfaceMethodNoImpl, std::make_tuple("IfaceMethodNoImpl"sv, "class '{}' must provide an implementation for method '{}' specified in interface class '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::IfaceMethodNotVirtual, std::make_tuple("IfaceMethodNotVirtual"sv, "class '{}' must provide an implementation for method '{}' specified in interface class '{}' (existing method is not virtual)"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAllowedInModport, std::make_tuple("NotAllowedInModport"sv, "'{}' cannot be listed in a modport"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ModportConnMismatch, std::make_tuple("ModportConnMismatch"sv, "cannot connect modport '{}.{}' to port requiring modport '{}.{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedImportExport, std::make_tuple("ExpectedImportExport"sv, "expected 'import' or 'export' for subroutine '{}' in modport"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::SingleBitVectored, std::make_tuple("SingleBitVectored"sv, "net of width 1 cannot be 'vectored' or 'scalared'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::VarDeclWithDelay, std::make_tuple("VarDeclWithDelay"sv, "cannot specify a net delay for a variable declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidRandType, std::make_tuple("InvalidRandType"sv, "{} is not a valid type for a '{}' property"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidMethodOverride, std::make_tuple("InvalidMethodOverride"sv, "cannot override built-in method '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidRandomizeOverride, std::make_tuple("InvalidRandomizeOverride"sv, "override for '{}' should be a public non-static function that returns void and takes no parameters"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MismatchStaticConstraint, std::make_tuple("MismatchStaticConstraint"sv, "mismatch of 'static' keyword between constraint prototype and declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DPIRefArg, std::make_tuple("DPIRefArg"sv, "DPI subroutines cannot have 'ref' arguments"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DPIPureArg, std::make_tuple("DPIPureArg"sv, "DPI imports marked 'pure' cannot have 'output' or 'inout' arguments"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DPIPureReturn, std::make_tuple("DPIPureReturn"sv, "DPI imports marked 'pure' cannot return 'void'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidDPIReturnType, std::make_tuple("InvalidDPIReturnType"sv, "{} is not a valid return type for a DPI subroutine"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidDPIArgType, std::make_tuple("InvalidDPIArgType"sv, "{} is not a valid argument type in a DPI subroutine"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::Delay3OnVar, std::make_tuple("Delay3OnVar"sv, "continuous assignments to variables cannot have multi-value delays"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DefParamTarget, std::make_tuple("DefParamTarget"sv, "target of defparam must be a parameter"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DefParamLocal, std::make_tuple("DefParamLocal"sv, "'{}' is a localparam and so cannot be the target of a defparam"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::FatalTask, std::make_tuple("FatalTask"sv, "$fatal encountered{}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ErrorTask, std::make_tuple("ErrorTask"sv, "$error encountered{}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::WarningTask, std::make_tuple("WarningTask"sv, "$warning encountered{}"sv, DiagnosticSeverity::Warning, "warning-task"sv)},
+    {diag::InfoTask, std::make_tuple("InfoTask"sv, "$info encountered{}"sv, DiagnosticSeverity::Note, ""sv)},
+    {diag::StaticInitializerMustBeExplicit, std::make_tuple("StaticInitializerMustBeExplicit"sv, "initializing a static variable in a procedural context requires an explicit 'static' keyword"sv, DiagnosticSeverity::Warning, "explicit-static"sv)},
+    {diag::CaseGenerateDup, std::make_tuple("CaseGenerateDup"sv, "more than one case generate block matches the value {}"sv, DiagnosticSeverity::Warning, "case-gen-dup"sv)},
+    {diag::CaseGenerateNoBlock, std::make_tuple("CaseGenerateNoBlock"sv, "no case generate expression matches the value {}"sv, DiagnosticSeverity::Warning, "case-gen-none"sv)},
+    {diag::UnconnectedNamedPort, std::make_tuple("UnconnectedNamedPort"sv, "port '{}' has no connection"sv, DiagnosticSeverity::Warning, "unconnected-port"sv)},
+    {diag::UnconnectedUnnamedPort, std::make_tuple("UnconnectedUnnamedPort"sv, "instance does not provide a connection for an unnamed port"sv, DiagnosticSeverity::Warning, "unconnected-unnamed-port"sv)},
+    {diag::ImplicitNetPortNoDefault, std::make_tuple("ImplicitNetPortNoDefault"sv, "implicit net port disallowed because `default_nettype is set to 'none'"sv, DiagnosticSeverity::Warning, "implicit-net-port"sv)},
+    {diag::DuplicateAttribute, std::make_tuple("DuplicateAttribute"sv, "duplicate attribute definition '{}'; taking last value"sv, DiagnosticSeverity::Warning, "dup-attr"sv)},
+    {diag::EmptyMember, std::make_tuple("EmptyMember"sv, "extra ';' has no effect"sv, DiagnosticSeverity::Warning, "empty-member"sv)},
+    {diag::SignednessNoEffect, std::make_tuple("SignednessNoEffect"sv, "'{}' on I/O declaration has no effect on type {}"sv, DiagnosticSeverity::Warning, "ineffective-sign"sv)},
+    {diag::NoConstraintBody, std::make_tuple("NoConstraintBody"sv, "no body for implicit constraint block '{}'"sv, DiagnosticSeverity::Warning, "constraint-missing"sv)},
+    {diag::DPISpecDisallowed, std::make_tuple("DPISpecDisallowed"sv, "'DPI' specified subroutines are not supported and will be treated as 'DPI-C'. Note that this may require changes to the application's C code."sv, DiagnosticSeverity::Warning, "dpi-spec"sv)},
+    {diag::BadUnaryExpression, std::make_tuple("BadUnaryExpression"sv, "invalid operand type {} to unary expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadBinaryExpression, std::make_tuple("BadBinaryExpression"sv, "invalid operands to binary expression ({} and {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadConditionalExpression, std::make_tuple("BadConditionalExpression"sv, "invalid operands to conditional expression ({} and {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadIndexExpression, std::make_tuple("BadIndexExpression"sv, "value of type {} cannot be indexed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadConcatExpression, std::make_tuple("BadConcatExpression"sv, "invalid operand type {} in concatenation"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadReplicationExpression, std::make_tuple("BadReplicationExpression"sv, "invalid operands to replication expression ({} and {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadOpenRange, std::make_tuple("BadOpenRange"sv, "invalid bounds in open range ({} and {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadCastType, std::make_tuple("BadCastType"sv, "invalid casting type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadSetMembershipType, std::make_tuple("BadSetMembershipType"sv, "invalid type {} for {} expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConcatWithStringInt, std::make_tuple("ConcatWithStringInt"sv, "cannot mix strings and integers in a concatenation (use a cast if this is desired)"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadRangeExpression, std::make_tuple("BadRangeExpression"sv, "cannot select range of [{}:{}] from {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RangeWidthTooLarge, std::make_tuple("RangeWidthTooLarge"sv, "cannot select range of {} elements from {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RangeSelectAssociative, std::make_tuple("RangeSelectAssociative"sv, "cannot take a slice of an associative array"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::CannotIndexScalar, std::make_tuple("CannotIndexScalar"sv, "scalar type cannot be indexed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExprMustBeIntegral, std::make_tuple("ExprMustBeIntegral"sv, "expression must be integral"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::IndexValueInvalid, std::make_tuple("IndexValueInvalid"sv, "cannot refer to element {} of {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::SelectEndianMismatch, std::make_tuple("SelectEndianMismatch"sv, "endianness of selection must match declared range (type is {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::SelectEndianDynamic, std::make_tuple("SelectEndianDynamic"sv, "range of selection [{}:{}] into {} is reversed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadAssignment, std::make_tuple("BadAssignment"sv, "value of type {} cannot be assigned to type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadConversion, std::make_tuple("BadConversion"sv, "value of type {} cannot be converted to type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadIntegerCast, std::make_tuple("BadIntegerCast"sv, "cannot change width or signedness of non-integral expression (type is {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NoImplicitConversion, std::make_tuple("NoImplicitConversion"sv, "no implicit conversion from {} to {}; explicit conversion exists, are you missing a cast?"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TooManyArguments, std::make_tuple("TooManyArguments"sv, "too many arguments to subroutine call; expected {} but {} were provided"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TooFewArguments, std::make_tuple("TooFewArguments"sv, "too few arguments to subroutine call; expected {} but {} were provided"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpressionNotAssignable, std::make_tuple("ExpressionNotAssignable"sv, "expression is not assignable"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ReplicationZeroOutsideConcat, std::make_tuple("ReplicationZeroOutsideConcat"sv, "replication constant can only be zero inside of a concatenation"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidMemberAccess, std::make_tuple("InvalidMemberAccess"sv, "invalid member access for type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpressionNotCallable, std::make_tuple("ExpressionNotCallable"sv, "expression is not callable"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnexpectedWithClause, std::make_tuple("UnexpectedWithClause"sv, "unexpected 'with' clause"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::WithClauseNotAllowed, std::make_tuple("WithClauseNotAllowed"sv, "cannot use 'with' expression with '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::IteratorArgsWithoutWithClause, std::make_tuple("IteratorArgsWithoutWithClause"sv, "cannot provide arguments to '{}' without corresponding 'with' clause"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedIteratorName, std::make_tuple("ExpectedIteratorName"sv, "expected name of iterator for use with 'with' expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnexpectedConstraintBlock, std::make_tuple("UnexpectedConstraintBlock"sv, "unexpected constraint block"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MissingConstraintBlock, std::make_tuple("MissingConstraintBlock"sv, "missing inline constraint block for 'randomize' call"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedIterationExpression, std::make_tuple("ExpectedIterationExpression"sv, "expected a single array iteration expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotBooleanConvertible, std::make_tuple("NotBooleanConvertible"sv, "value of type {} is not convertible to a boolean predicate"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EnumValueSizeMismatch, std::make_tuple("EnumValueSizeMismatch"sv, "expression width of {} does not exactly match declared enum type width of {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NoCommonComparisonType, std::make_tuple("NoCommonComparisonType"sv, "{} expression of type {} is not comparable to common type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentPatternNoContext, std::make_tuple("AssignmentPatternNoContext"sv, "assignment pattern target type cannot be deduced in this context"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadAssignmentPatternType, std::make_tuple("BadAssignmentPatternType"sv, "invalid target type {} for assignment pattern"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::WrongNumberAssignmentPatterns, std::make_tuple("WrongNumberAssignmentPatterns"sv, "assignment pattern for {} requires {} elements but {} were provided"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentPatternKeyExpr, std::make_tuple("AssignmentPatternKeyExpr"sv, "expression is not a valid assignment pattern member name or type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentPatternKeyDupDefault, std::make_tuple("AssignmentPatternKeyDupDefault"sv, "assignment pattern has multiple default keys"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentPatternKeyDupValue, std::make_tuple("AssignmentPatternKeyDupValue"sv, "assignment pattern has multiple keys for value {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentPatternKeyDupName, std::make_tuple("AssignmentPatternKeyDupName"sv, "assignment pattern has multiple keys for member '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentPatternNoMember, std::make_tuple("AssignmentPatternNoMember"sv, "member '{}' is not covered by any assignment pattern key"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentPatternNestedNoMember, std::make_tuple("AssignmentPatternNestedNoMember"sv, "member '{}' has nested elements that are not covered by any assignment pattern key"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentPatternMissingElements, std::make_tuple("AssignmentPatternMissingElements"sv, "not all elements of array are covered by an assignment pattern key"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentPatternDynamicDefault, std::make_tuple("AssignmentPatternDynamicDefault"sv, "assignment pattern for dynamic array or queue cannot have default key"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentPatternDynamicType, std::make_tuple("AssignmentPatternDynamicType"sv, "assignment patterns for dynamic array, associative arrays, and queues cannot have type keys"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentPatternAssociativeType, std::make_tuple("AssignmentPatternAssociativeType"sv, "assignment pattern for associative array must specify key:value pairs"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EmptyArgNotAllowed, std::make_tuple("EmptyArgNotAllowed"sv, "empty argument not allowed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NamedArgNotAllowed, std::make_tuple("NamedArgNotAllowed"sv, "named argument not allowed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DuplicateArgAssignment, std::make_tuple("DuplicateArgAssignment"sv, "duplicate assignment for argument '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MixingOrderedAndNamedArgs, std::make_tuple("MixingOrderedAndNamedArgs"sv, "ordered arguments are not allowed after named arguments"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ArgDoesNotExist, std::make_tuple("ArgDoesNotExist"sv, "argument '{}' does not exist in subroutine '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ArgCannotBeEmpty, std::make_tuple("ArgCannotBeEmpty"sv, "argument '{}' cannot be empty because it does not have a default value"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnconnectedArg, std::make_tuple("UnconnectedArg"sv, "argument '{}' is missing a value"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MissingReturnValue, std::make_tuple("MissingReturnValue"sv, "must provide a return value for non-void function"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentNotAllowed, std::make_tuple("AssignmentNotAllowed"sv, "assignment expressions are not allowed in this context"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::IncDecNotAllowed, std::make_tuple("IncDecNotAllowed"sv, "increment and decrement expressions are not allowed in this context"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentRequiresParens, std::make_tuple("AssignmentRequiresParens"sv, "assignment expressions must be parenthesized"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PortConnArrayMismatch, std::make_tuple("PortConnArrayMismatch"sv, "cannot connect {} to each port of type {} in '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AutoFromStaticInit, std::make_tuple("AutoFromStaticInit"sv, "cannot refer to automatic variable '{}' from static initializer"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NonblockingAssignmentToAuto, std::make_tuple("NonblockingAssignmentToAuto"sv, "nonblocking assignment to automatic variable '{}' is not allowed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentToConst, std::make_tuple("AssignmentToConst"sv, "cannot assign to read-only variable '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EmptyConcatNotAllowed, std::make_tuple("EmptyConcatNotAllowed"sv, "concatenation cannot be empty"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TimingControlNotAllowed, std::make_tuple("TimingControlNotAllowed"sv, "timing control is not allowed in this context"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NewArrayTarget, std::make_tuple("NewArrayTarget"sv, "new array expression can only be used in an assignment to a dynamic array type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NewClassTarget, std::make_tuple("NewClassTarget"sv, "new class expression can only be used in an assignment to a class type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnpackedConcatSize, std::make_tuple("UnpackedConcatSize"sv, "array concatenation for {} requires {} elements but {} were provided"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnpackedConcatAssociative, std::make_tuple("UnpackedConcatAssociative"sv, "array concatenations cannot be used for associative arrays"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidClassAccess, std::make_tuple("InvalidClassAccess"sv, "cannot access '{}' in {} with '.'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::CopyClassTarget, std::make_tuple("CopyClassTarget"sv, "expected {} to be a class type for shallow copy expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadStreamSlice, std::make_tuple("BadStreamSlice"sv, "streaming operator slice size cannot be a dynamically sized type identifier"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadStreamExprType, std::make_tuple("BadStreamExprType"sv, "stream expression type {} is not a bit-stream type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadStreamTargetType, std::make_tuple("BadStreamTargetType"sv, "target type {} of streaming concatenation is not a bit-stream type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadStreamSourceType, std::make_tuple("BadStreamSourceType"sv, "source type {} of streaming concatenation is not a bit-stream type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadStreamContext, std::make_tuple("BadStreamContext"sv, "streaming operator can only be used in an assignment or bit-stream cast argument"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadStreamSize, std::make_tuple("BadStreamSize"sv, "streaming operator target size {} does not fit source size {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadStreamCast, std::make_tuple("BadStreamCast"sv, "streaming concatenation cannot be converted to type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadStreamWithType, std::make_tuple("BadStreamWithType"sv, "stream expression type before 'with' must be a one-dimensional unpacked array"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadStreamWithOrder, std::make_tuple("BadStreamWithOrder"sv, "'with' expression cannot appear after unconstrained dynamically sized stream expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NewVirtualClass, std::make_tuple("NewVirtualClass"sv, "cannot create instance of virtual class '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NewInterfaceClass, std::make_tuple("NewInterfaceClass"sv, "cannot create instance of interface class '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignToCHandle, std::make_tuple("AssignToCHandle"sv, "cannot assign to a chandle outside of a procedural context"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignToNet, std::make_tuple("AssignToNet"sv, "cannot assign to a net within a procedural context"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::SelectOfVectoredNet, std::make_tuple("SelectOfVectoredNet"sv, "bit-selects and part-selects of vectored nets are disallowed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedNetDelay, std::make_tuple("ExpectedNetDelay"sv, "invalid net delay; expected min:typ:max or single expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidRefArg, std::make_tuple("InvalidRefArg"sv, "invalid expression for pass by reference; only variables, class properties, and members of unpacked structs and arrays are allowed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RefTypeMismatch, std::make_tuple("RefTypeMismatch"sv, "argument of type {} connects to 'ref' port of inequivalent type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstVarToRef, std::make_tuple("ConstVarToRef"sv, "cannot bind const variable to 'ref' argument"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MissingInvocationParens, std::make_tuple("MissingInvocationParens"sv, "parentheses are required when invoking function '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NameListWithScopeRandomize, std::make_tuple("NameListWithScopeRandomize"sv, "lookup restriction list not allowed for std::randomize call"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnboundedNotAllowed, std::make_tuple("UnboundedNotAllowed"sv, "unbounded literal '$' not allowed here"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DynamicNotProcedural, std::make_tuple("DynamicNotProcedural"sv, "cannot refer to an element or member of a dynamic type outside of a procedural context"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::SpecparamInConstant, std::make_tuple("SpecparamInConstant"sv, "specparams cannot be used in general constant expressions"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::IgnoredSlice, std::make_tuple("IgnoredSlice"sv, "slice size ignored for left-to-right streaming operator"sv, DiagnosticSeverity::Warning, "ignored-slice"sv)},
+    {diag::UnsizedInConcat, std::make_tuple("UnsizedInConcat"sv, "unsized integer in concat; using a width of {}"sv, DiagnosticSeverity::Warning, "unsized-concat"sv)},
+    {diag::WidthExpand, std::make_tuple("WidthExpand"sv, "implicit conversion expands from {} to {} bits"sv, DiagnosticSeverity::Warning, "width-expand"sv)},
+    {diag::WidthTruncate, std::make_tuple("WidthTruncate"sv, "implicit conversion truncates from {} to {} bits"sv, DiagnosticSeverity::Warning, "width-trunc"sv)},
+    {diag::ImplicitConvert, std::make_tuple("ImplicitConvert"sv, "implicit conversion from {} to {}"sv, DiagnosticSeverity::Warning, "implicit-conv"sv)},
+    {diag::NotYetSupported, std::make_tuple("NotYetSupported"sv, "language feature not yet supported"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedExpression, std::make_tuple("ExpectedExpression"sv, "expected expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotePreviousDefinition, std::make_tuple("NotePreviousDefinition"sv, "previous definition here"sv, DiagnosticSeverity::Note, ""sv)},
+    {diag::NotePreviousUsage, std::make_tuple("NotePreviousUsage"sv, "previous usage here"sv, DiagnosticSeverity::Note, ""sv)},
+    {diag::NoteDeclarationHere, std::make_tuple("NoteDeclarationHere"sv, "declared here"sv, DiagnosticSeverity::Note, ""sv)},
+    {diag::NotePreviousMatch, std::make_tuple("NotePreviousMatch"sv, "previous match here"sv, DiagnosticSeverity::Note, ""sv)},
+    {diag::AttributesNotAllowed, std::make_tuple("AttributesNotAllowed"sv, "attributes are not allowed here"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::WarnNotYetSupported, std::make_tuple("WarnNotYetSupported"sv, "language feature not yet supported"sv, DiagnosticSeverity::Warning, "not-supported"sv)},
+    {diag::NonPrintableChar, std::make_tuple("NonPrintableChar"sv, "non-printable character in source text; SystemVerilog only supports ASCII text"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UTF8Char, std::make_tuple("UTF8Char"sv, "UTF-8 sequence in source text; SystemVerilog only supports ASCII text"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnicodeBOM, std::make_tuple("UnicodeBOM"sv, "Unicode BOM at start of source text; SystemVerilog only supports ASCII text"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EmbeddedNull, std::make_tuple("EmbeddedNull"sv, "embedded NUL in source text; are you sure this is source code?"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MisplacedDirectiveChar, std::make_tuple("MisplacedDirectiveChar"sv, "expected directive name"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EscapedWhitespace, std::make_tuple("EscapedWhitespace"sv, "unexpected whitespace after escape character"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedClosingQuote, std::make_tuple("ExpectedClosingQuote"sv, "missing closing quote"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnterminatedBlockComment, std::make_tuple("UnterminatedBlockComment"sv, "block comment unclosed at end of file"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NestedBlockComment, std::make_tuple("NestedBlockComment"sv, "nested block comments are disallowed by SystemVerilog"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedIntegerBaseAfterSigned, std::make_tuple("ExpectedIntegerBaseAfterSigned"sv, "expected integer base specifier after signed specifier"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MissingFractionalDigits, std::make_tuple("MissingFractionalDigits"sv, "expected fractional digits after decimal"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::OctalEscapeCodeTooBig, std::make_tuple("OctalEscapeCodeTooBig"sv, "octal escape code is too large to be an ASCII character"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidHexEscapeCode, std::make_tuple("InvalidHexEscapeCode"sv, "invalid hexadecimal number"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MissingExponentDigits, std::make_tuple("MissingExponentDigits"sv, "expected exponent digits"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DigitsLeadingUnderscore, std::make_tuple("DigitsLeadingUnderscore"sv, "numeric literals must not start with a leading underscore"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DecimalDigitMultipleUnknown, std::make_tuple("DecimalDigitMultipleUnknown"sv, "decimal literals cannot have multiple digits if at least one of them is X or Z"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadBinaryDigit, std::make_tuple("BadBinaryDigit"sv, "expected binary digit"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadOctalDigit, std::make_tuple("BadOctalDigit"sv, "expected octal digit"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadDecimalDigit, std::make_tuple("BadDecimalDigit"sv, "expected decimal digit"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadHexDigit, std::make_tuple("BadHexDigit"sv, "expected hexadecimal digit"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TooManyLexerErrors, std::make_tuple("TooManyLexerErrors"sv, "lexer has encountered too many errors (input is a binary file?)"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownEscapeCode, std::make_tuple("UnknownEscapeCode"sv, "unknown character escape sequence '\\{}'"sv, DiagnosticSeverity::Warning, "unknown-escape-code"sv)},
+    {diag::NonstandardEscapeCode, std::make_tuple("NonstandardEscapeCode"sv, "non-standard character escape sequence '\\{}'"sv, DiagnosticSeverity::Warning, "nonstandard-escape-code"sv)},
+    {diag::Redefinition, std::make_tuple("Redefinition"sv, "redefinition of '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RedefinitionDifferentType, std::make_tuple("RedefinitionDifferentType"sv, "redefinition of '{}' with a different type: {} vs {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RedefinitionDifferentSymbolKind, std::make_tuple("RedefinitionDifferentSymbolKind"sv, "redefinition of '{}' as different kind of symbol"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AmbiguousWildcardImport, std::make_tuple("AmbiguousWildcardImport"sv, "multiple imports found for identifier '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NoteImportedFrom, std::make_tuple("NoteImportedFrom"sv, "imported from here"sv, DiagnosticSeverity::Note, ""sv)},
+    {diag::NoteHierarchicalNameInCE, std::make_tuple("NoteHierarchicalNameInCE"sv, "reference to '{}' by hierarchical name is not allowed in a constant expression"sv, DiagnosticSeverity::Note, ""sv)},
+    {diag::ImportNameCollision, std::make_tuple("ImportNameCollision"sv, "import of '{}' collides with an existing declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UndeclaredIdentifier, std::make_tuple("UndeclaredIdentifier"sv, "use of undeclared identifier '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TypoIdentifier, std::make_tuple("TypoIdentifier"sv, "use of undeclared identifier '{}'; did you mean '{}'?"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownSystemName, std::make_tuple("UnknownSystemName"sv, "unknown system name '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownClassOrPackage, std::make_tuple("UnknownClassOrPackage"sv, "unknown class or package '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UsedBeforeDeclared, std::make_tuple("UsedBeforeDeclared"sv, "identifier '{}' used before its declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAType, std::make_tuple("NotAType"sv, "'{}' is not a type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAValue, std::make_tuple("NotAValue"sv, "'{}' does not refer to a value"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAHierarchicalScope, std::make_tuple("NotAHierarchicalScope"sv, "cannot use dot operator on '{}'; it is not a variable or hierarchical scope"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAModport, std::make_tuple("NotAModport"sv, "'{}' is not a modport of '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAnInterface, std::make_tuple("NotAnInterface"sv, "'{}' is not an interface instance or array of instances"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAGenvar, std::make_tuple("NotAGenvar"sv, "'{}' is not a genvar"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAClass, std::make_tuple("NotAClass"sv, "'{}' is not a class type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAGenericClass, std::make_tuple("NotAGenericClass"sv, "'{}' is not a generic class type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotASubroutine, std::make_tuple("NotASubroutine"sv, "'{}' is not a task or function"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DotOnType, std::make_tuple("DotOnType"sv, "cannot use dot operator on a type name"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::HierarchicalNotAllowedInConstant, std::make_tuple("HierarchicalNotAllowedInConstant"sv, "hierarchical names are not allowed in constant expressions"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownMember, std::make_tuple("UnknownMember"sv, "no member named '{}' in {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownPackageMember, std::make_tuple("UnknownPackageMember"sv, "no member named '{}' in package '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownClassMember, std::make_tuple("UnknownClassMember"sv, "no member named '{}' in class '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownUnitMember, std::make_tuple("UnknownUnitMember"sv, "no member named '{}' in compilation unit"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RecursiveDefinition, std::make_tuple("RecursiveDefinition"sv, "'{}' recursively depends on its own definition"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownSystemMethod, std::make_tuple("UnknownSystemMethod"sv, "unknown built-in method '{}' on type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ScopeNotIndexable, std::make_tuple("ScopeNotIndexable"sv, "hierarchical scope '{}' is not indexable"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidScopeIndexExpression, std::make_tuple("InvalidScopeIndexExpression"sv, "invalid hierarchical index expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ScopeIndexOutOfRange, std::make_tuple("ScopeIndexOutOfRange"sv, "hierarchical index {} is out of scope's declared range"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::CouldNotResolveHierarchicalPath, std::make_tuple("CouldNotResolveHierarchicalPath"sv, "could not resolve hierarchical path name '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnresolvedForwardTypedef, std::make_tuple("UnresolvedForwardTypedef"sv, "forward typedef '{}' does not resolve to a data type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DefinitionUsedAsType, std::make_tuple("DefinitionUsedAsType"sv, "'{}' is {} definition but is used like a type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DefinitionUsedAsValue, std::make_tuple("DefinitionUsedAsValue"sv, "'{}' is {} definition but is used as a value"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AutoVariableHierarchical, std::make_tuple("AutoVariableHierarchical"sv, "cannot refer to automatic variable via hierarchical reference"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NonStaticClassProperty, std::make_tuple("NonStaticClassProperty"sv, "invalid use of non-static class property '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NonStaticClassMethod, std::make_tuple("NonStaticClassMethod"sv, "call to non-static member function without object handle"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NestedNonStaticClassProperty, std::make_tuple("NestedNonStaticClassProperty"sv, "invalid use of non-static class property '{}' from nested class '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NestedNonStaticClassMethod, std::make_tuple("NestedNonStaticClassMethod"sv, "call to non-static member function without object handle from nested class '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NoDefaultSpecialization, std::make_tuple("NoDefaultSpecialization"sv, "generic class '{}' does not have a default specialization because some parameters have no default value"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::GenericClassScopeResolution, std::make_tuple("GenericClassScopeResolution"sv, "cannot refer to generic class with '::' without providing parameter assignments"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidThisHandle, std::make_tuple("InvalidThisHandle"sv, "invalid use of 'this' outside of a non-static method"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::LocalMemberAccess, std::make_tuple("LocalMemberAccess"sv, "'{}' is a local member of '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ProtectedMemberAccess, std::make_tuple("ProtectedMemberAccess"sv, "'{}' is a protected member of '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidConstructorAccess, std::make_tuple("InvalidConstructorAccess"sv, "cannot create instance of class '{}' because its constructor is declared '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::SuperOutsideClass, std::make_tuple("SuperOutsideClass"sv, "cannot use 'super' handle outside of class scope"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::SuperNoBase, std::make_tuple("SuperNoBase"sv, "class '{}' does not have a super class"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::IfaceExtendTypeParam, std::make_tuple("IfaceExtendTypeParam"sv, "cannot extend or implement a type parameter"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::IfaceExtendIncomplete, std::make_tuple("IfaceExtendIncomplete"sv, "cannot extend or implement an incomplete forward typedef"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ScopeIncompleteTypedef, std::make_tuple("ScopeIncompleteTypedef"sv, "cannot resolve scoped class member via incomplete forward typedef"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidModportAccess, std::make_tuple("InvalidModportAccess"sv, "cannot access '{}' via modport '{}.{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::LocalNotAllowed, std::make_tuple("LocalNotAllowed"sv, "'local' qualifier not allowed here"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnexpectedSelection, std::make_tuple("UnexpectedSelection"sv, "unexpected selection expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DuplicateImport, std::make_tuple("DuplicateImport"sv, "duplicate import declaration is redundant"sv, DiagnosticSeverity::Warning, "dup-import"sv)},
+    {diag::TooManyErrors, std::make_tuple("TooManyErrors"sv, "too many errors emitted, stopping now [--error-limit=]"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownWarningOption, std::make_tuple("UnknownWarningOption"sv, "unknown warning option '{}'"sv, DiagnosticSeverity::Warning, "unknown-warning-option"sv)},
+    {diag::LiteralSizeIsZero, std::make_tuple("LiteralSizeIsZero"sv, "size of vector literal cannot be zero"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::LiteralSizeTooLarge, std::make_tuple("LiteralSizeTooLarge"sv, "size of vector literal is too large (> {} bits)"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::SignedIntegerOverflow, std::make_tuple("SignedIntegerOverflow"sv, "signed integer overflows 32 bits"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ValueMustBeIntegral, std::make_tuple("ValueMustBeIntegral"sv, "value must be integral"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ValueMustNotBeUnknown, std::make_tuple("ValueMustNotBeUnknown"sv, "value must not have any unknown bits"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ValueMustBePositive, std::make_tuple("ValueMustBePositive"sv, "value must be positive"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ValueExceedsMaxBitWidth, std::make_tuple("ValueExceedsMaxBitWidth"sv, "value exceeds maximum vector width ({} bits)"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ValueOutOfRange, std::make_tuple("ValueOutOfRange"sv, "{} is out of allowed range ({} to {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedVectorDigits, std::make_tuple("ExpectedVectorDigits"sv, "expected vector literal digits"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RealLiteralUnderflow, std::make_tuple("RealLiteralUnderflow"sv, "value of real literal is too small; minimum is {:.5e}"sv, DiagnosticSeverity::Warning, "real-underflow"sv)},
+    {diag::RealLiteralOverflow, std::make_tuple("RealLiteralOverflow"sv, "value of real literal is too large; maximum is {:.5e}"sv, DiagnosticSeverity::Warning, "real-overflow"sv)},
+    {diag::VectorLiteralOverflow, std::make_tuple("VectorLiteralOverflow"sv, "vector literal too large for the given number of bits"sv, DiagnosticSeverity::Warning, "literal-overflow"sv)},
+    {diag::ExpectedIdentifier, std::make_tuple("ExpectedIdentifier"sv, "expected identifier"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedStringLiteral, std::make_tuple("ExpectedStringLiteral"sv, "expected string literal"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedIntegerLiteral, std::make_tuple("ExpectedIntegerLiteral"sv, "expected integer literal"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedToken, std::make_tuple("ExpectedToken"sv, "expected '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MisplacedTrailingSeparator, std::make_tuple("MisplacedTrailingSeparator"sv, "misplaced trailing '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ImplicitNotAllowed, std::make_tuple("ImplicitNotAllowed"sv, "expected data type (implicit type name not allowed)"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidAccessDotColon, std::make_tuple("InvalidAccessDotColon"sv, "invalid access token; '{}' should be '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedMember, std::make_tuple("ExpectedMember"sv, "expected member"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedStatement, std::make_tuple("ExpectedStatement"sv, "expected statement"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedParameterPort, std::make_tuple("ExpectedParameterPort"sv, "expected parameter declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedNonAnsiPort, std::make_tuple("ExpectedNonAnsiPort"sv, "expected non-ansi port declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedAnsiPort, std::make_tuple("ExpectedAnsiPort"sv, "expected ansi port declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedModportPort, std::make_tuple("ExpectedModportPort"sv, "expected modport item port declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedFunctionPort, std::make_tuple("ExpectedFunctionPort"sv, "expected subroutine port declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedAssertionItemPort, std::make_tuple("ExpectedAssertionItemPort"sv, "expected assertion item construct port declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedForInitializer, std::make_tuple("ExpectedForInitializer"sv, "expected for loop initializer"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedOpenRangeElement, std::make_tuple("ExpectedOpenRangeElement"sv, "expected open range element"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedStreamExpression, std::make_tuple("ExpectedStreamExpression"sv, "expected stream expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedArgument, std::make_tuple("ExpectedArgument"sv, "expected argument"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedDeclarator, std::make_tuple("ExpectedDeclarator"sv, "expected declarator"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedConditionalPattern, std::make_tuple("ExpectedConditionalPattern"sv, "expected conditional pattern"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedAttribute, std::make_tuple("ExpectedAttribute"sv, "expected attribute"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedPackageImport, std::make_tuple("ExpectedPackageImport"sv, "expected package import"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedHierarchicalInstantiation, std::make_tuple("ExpectedHierarchicalInstantiation"sv, "expected hierarchical instantiation"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedGateInstance, std::make_tuple("ExpectedGateInstance"sv, "expected gate instance"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedPortConnection, std::make_tuple("ExpectedPortConnection"sv, "expected port connection"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedVariableAssignment, std::make_tuple("ExpectedVariableAssignment"sv, "expected variable assignment"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedContinuousAssignment, std::make_tuple("ExpectedContinuousAssignment"sv, "expected continuous assignment"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedInterfaceClassName, std::make_tuple("ExpectedInterfaceClassName"sv, "expected interface class name"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedAssignmentKey, std::make_tuple("ExpectedAssignmentKey"sv, "expected assignment key"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedDistItem, std::make_tuple("ExpectedDistItem"sv, "expected dist item"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedIfOrCase, std::make_tuple("ExpectedIfOrCase"sv, "expected 'if' or 'case' after '{}' keyword"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedNetStrength, std::make_tuple("ExpectedNetStrength"sv, "expected net strength keyword"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedEnumBase, std::make_tuple("ExpectedEnumBase"sv, "expected enum base type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedCaseItem, std::make_tuple("ExpectedCaseItem"sv, "expected case item"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedSubroutineName, std::make_tuple("ExpectedSubroutineName"sv, "expected subroutine name"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedConstraintName, std::make_tuple("ExpectedConstraintName"sv, "invalid constraint block name"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedUdpPort, std::make_tuple("ExpectedUdpPort"sv, "expected UDP port"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedUdpEntry, std::make_tuple("ExpectedUdpEntry"sv, "expected UDP table entry"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedPathName, std::make_tuple("ExpectedPathName"sv, "expected path name"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedPathOp, std::make_tuple("ExpectedPathOp"sv, "expected path operator ('*>' or '=>')"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedEdgeDescriptor, std::make_tuple("ExpectedEdgeDescriptor"sv, "expected edge descriptor"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NoLabelOnSemicolon, std::make_tuple("NoLabelOnSemicolon"sv, "labels are not allowed on empty semicolon"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DeferredDelayMustBeZero, std::make_tuple("DeferredDelayMustBeZero"sv, "deferred assertion delay must be zero"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidGenvarIterExpression, std::make_tuple("InvalidGenvarIterExpression"sv, "invalid genvar iteration expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedGenvarIterVar, std::make_tuple("ExpectedGenvarIterVar"sv, "expected genvar iteration variable"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstFunctionPortRequiresRef, std::make_tuple("ConstFunctionPortRequiresRef"sv, "'const' in subroutine formal port requires 'ref' direction specifier"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedClockingSkew, std::make_tuple("ExpectedClockingSkew"sv, "expected clocking skew"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InOutDefaultSkew, std::make_tuple("InOutDefaultSkew"sv, "inout direction for default skew not allowed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::GlobalClockingEmpty, std::make_tuple("GlobalClockingEmpty"sv, "global clocking block cannot declare items"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedDPISpecString, std::make_tuple("ExpectedDPISpecString"sv, "expected DPI spec string"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ParseTreeTooDeep, std::make_tuple("ParseTreeTooDeep"sv, "language constructs are too deeply nested"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MissingModportPortDirection, std::make_tuple("MissingModportPortDirection"sv, "modport port declaration is missing direction specifier"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::CaseStatementEmpty, std::make_tuple("CaseStatementEmpty"sv, "{} statement has no items"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MultipleDefaultCases, std::make_tuple("MultipleDefaultCases"sv, "{} statement has multiple default cases"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DirectionOnInterfacePort, std::make_tuple("DirectionOnInterfacePort"sv, "direction specifier on interface port is not allowed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnexpectedQualifiers, std::make_tuple("UnexpectedQualifiers"sv, "unexpected qualifiers on class member"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedSampleKeyword, std::make_tuple("ExpectedSampleKeyword"sv, "expected 'sample' keyword"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MultipleGenerateDefaultCases, std::make_tuple("MultipleGenerateDefaultCases"sv, "case generate has multiple default cases"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::CaseGenerateEmpty, std::make_tuple("CaseGenerateEmpty"sv, "case generate has no items"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::LabelAndName, std::make_tuple("LabelAndName"sv, "cannot specify both a label and a name for the same block"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EndNameMismatch, std::make_tuple("EndNameMismatch"sv, "'{}' doesn't match previous name '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EndNameNotEmpty, std::make_tuple("EndNameNotEmpty"sv, "trailing name not allowed on previously unnamed block"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DeclarationsAtStart, std::make_tuple("DeclarationsAtStart"sv, "declaration must come before all statements in the block"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::VoidNotAllowed, std::make_tuple("VoidNotAllowed"sv, "'void' type not allowed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DuplicateDeclModifier, std::make_tuple("DuplicateDeclModifier"sv, "duplicate '{}' modifier in declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DeclModifierOrdering, std::make_tuple("DeclModifierOrdering"sv, "modifier '{}' must come before '{}' in a declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DeclModifierConflict, std::make_tuple("DeclModifierConflict"sv, "modifier '{}' cannot be used together with '{}' in a declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DuplicateQualifier, std::make_tuple("DuplicateQualifier"sv, "duplicate '{}' qualifier in declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::QualifierConflict, std::make_tuple("QualifierConflict"sv, "qualifier '{}' cannot be used together with '{}' in a declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::QualifierNotFirst, std::make_tuple("QualifierNotFirst"sv, "'{}' must come first in a list of qualifiers"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PureRequiresVirtual, std::make_tuple("PureRequiresVirtual"sv, "'pure' keyword must be followed by 'virtual'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidMethodQualifier, std::make_tuple("InvalidMethodQualifier"sv, "invalid method qualifier '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidPropertyQualifier, std::make_tuple("InvalidPropertyQualifier"sv, "invalid property qualifier '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidConstraintQualifier, std::make_tuple("InvalidConstraintQualifier"sv, "invalid constraint qualifier '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidQualifierForMember, std::make_tuple("InvalidQualifierForMember"sv, "invalid qualifier for member"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidQualifierForIfaceMember, std::make_tuple("InvalidQualifierForIfaceMember"sv, "invalid qualifier for interface class member"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidQualifierForConstructor, std::make_tuple("InvalidQualifierForConstructor"sv, "invalid qualifier for constructor"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MethodStaticLifetime, std::make_tuple("MethodStaticLifetime"sv, "class methods cannot have static lifetime"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TypeRefDeclVar, std::make_tuple("TypeRefDeclVar"sv, "a type reference cannot be used in a variable declaration without a preceeding 'var' keyword"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ScopedClassCopy, std::make_tuple("ScopedClassCopy"sv, "typed constructor calls are not allowed for a shallow copy"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAllowedInCU, std::make_tuple("NotAllowedInCU"sv, "member not allowed at compilation unit scope"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAllowedInGenerate, std::make_tuple("NotAllowedInGenerate"sv, "member not allowed in generate block"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAllowedInModule, std::make_tuple("NotAllowedInModule"sv, "member not allowed in module declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAllowedInInterface, std::make_tuple("NotAllowedInInterface"sv, "member not allowed in interface declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAllowedInProgram, std::make_tuple("NotAllowedInProgram"sv, "member not allowed in program declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAllowedInPackage, std::make_tuple("NotAllowedInPackage"sv, "member not allowed in package"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAllowedInClocking, std::make_tuple("NotAllowedInClocking"sv, "member not allowed in clocking block"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAllowedInClass, std::make_tuple("NotAllowedInClass"sv, "member not allowed in class declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAllowedInIfaceClass, std::make_tuple("NotAllowedInIfaceClass"sv, "member not allowed in interface class declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TaskReturnType, std::make_tuple("TaskReturnType"sv, "tasks cannot declare a return type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TaskConstructor, std::make_tuple("TaskConstructor"sv, "class constructors cannot be tasks"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstructorReturnType, std::make_tuple("ConstructorReturnType"sv, "class constructors cannot declare a return type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NewKeywordQualified, std::make_tuple("NewKeywordQualified"sv, "invalid scope access on 'new' keyword"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::SubroutinePrototypeScoped, std::make_tuple("SubroutinePrototypeScoped"sv, "subroutine prototype cannot have a scoped name"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::QualifiersOnOutOfBlock, std::make_tuple("QualifiersOnOutOfBlock"sv, "qualifiers are not allowed on out-of-block method definitions"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstraintQualOutOfBlock, std::make_tuple("ConstraintQualOutOfBlock"sv, "'{}' qualifier is not allowed on out-of-block constraint definitions"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstructorOutsideClass, std::make_tuple("ConstructorOutsideClass"sv, "constructor cannot be declared outside of a class"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidSuperNew, std::make_tuple("InvalidSuperNew"sv, "super class constructor can only be called from the first statement in a derived class's constructor"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::IfaceMethodPure, std::make_tuple("IfaceMethodPure"sv, "method in interface class must be marked 'pure'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NestedIface, std::make_tuple("NestedIface"sv, "interface classes cannot be nested"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RegAfterNettype, std::make_tuple("RegAfterNettype"sv, "net type keyword cannot be followed by the 'reg' keyword"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ChargeWithTriReg, std::make_tuple("ChargeWithTriReg"sv, "charge strength can only be specified for 'trireg' nets"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InitializerRequired, std::make_tuple("InitializerRequired"sv, "initializer expression required"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DriveStrengthInvalid, std::make_tuple("DriveStrengthInvalid"sv, "combination of drive strengths is invalid; need one for value '0' and one for '1'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DriveStrengthHighZ, std::make_tuple("DriveStrengthHighZ"sv, "combination of drive strengths is invalid; cannot combine 'highz0' and 'highz1'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RandOnPackedMember, std::make_tuple("RandOnPackedMember"sv, "packed members cannot have random modifiers"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RandOnUnionMember, std::make_tuple("RandOnUnionMember"sv, "members of unions cannot have random modifiers"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::SolveBeforeDisallowed, std::make_tuple("SolveBeforeDisallowed"sv, "constraint ordering directive is not allowed within a nested constraint block"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::LifetimeForPrototype, std::make_tuple("LifetimeForPrototype"sv, "lifetime specifier is not allowed on prototype declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NonStandardGenBlock, std::make_tuple("NonStandardGenBlock"sv, "standalone generate block without loop or condition is not allowed in SystemVerilog"sv, DiagnosticSeverity::Warning, "nonstandard-generate"sv)},
+    {diag::EmptyAssignmentPattern, std::make_tuple("EmptyAssignmentPattern"sv, "empty assignment patterns are disallowed by SystemVerilog"sv, DiagnosticSeverity::Warning, "empty-pattern"sv)},
+    {diag::NoteToMatchThis, std::make_tuple("NoteToMatchThis"sv, "to match this '{}'"sv, DiagnosticSeverity::Note, ""sv)},
+    {diag::CouldNotOpenIncludeFile, std::make_tuple("CouldNotOpenIncludeFile"sv, "could not find or open include file"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExceededMaxIncludeDepth, std::make_tuple("ExceededMaxIncludeDepth"sv, "exceeded max include depth"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownDirective, std::make_tuple("UnknownDirective"sv, "unknown macro or compiler directive '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnexpectedConditionalDirective, std::make_tuple("UnexpectedConditionalDirective"sv, "unexpected conditional directive"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MissingEndIfDirective, std::make_tuple("MissingEndIfDirective"sv, "missing `endif directive"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnbalancedMacroArgDims, std::make_tuple("UnbalancedMacroArgDims"sv, "unbalanced macro argument delimiters ((), [], or {{}}); didn't see an end '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedMacroArgs, std::make_tuple("ExpectedMacroArgs"sv, "expected macro arguments for function-like macro"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedNetType, std::make_tuple("ExpectedNetType"sv, "expected net type specifier"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedDriveStrength, std::make_tuple("ExpectedDriveStrength"sv, "expected pull1 or pull0 strength"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidMacroName, std::make_tuple("InvalidMacroName"sv, "can't redefine compiler directive as a macro"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TooManyActualMacroArgs, std::make_tuple("TooManyActualMacroArgs"sv, "too many arguments provided to function-like macro"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotEnoughMacroArgs, std::make_tuple("NotEnoughMacroArgs"sv, "not enough arguments provided to function-like macro"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidLineDirectiveLevel, std::make_tuple("InvalidLineDirectiveLevel"sv, "invalid level for `line directive, must be 0, 1, or 2"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UndefineBuiltinDirective, std::make_tuple("UndefineBuiltinDirective"sv, "cannot `undef built-in directives"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnrecognizedKeywordVersion, std::make_tuple("UnrecognizedKeywordVersion"sv, "unsupported keyword version specified for `begin_keywords"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MismatchedEndKeywordsDirective, std::make_tuple("MismatchedEndKeywordsDirective"sv, "no opening `begin_keywords directive"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidTimeScaleSpecifier, std::make_tuple("InvalidTimeScaleSpecifier"sv, "time scale must have a value of 1, 10, or 100"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidTimeScalePrecision, std::make_tuple("InvalidTimeScalePrecision"sv, "time precision must be at least as precise as the time unit (i.e. it cannot be a longer unit of time)"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RecursiveMacro, std::make_tuple("RecursiveMacro"sv, "expansion of macro '{}' is recursive"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MacroOpsOutsideDefinition, std::make_tuple("MacroOpsOutsideDefinition"sv, "macro operators may only be used within a macro definition"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::SplitBlockCommentInDirective, std::make_tuple("SplitBlockCommentInDirective"sv, "block comments on the same line as a directive must also be terminated on that line"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedIncludeFileName, std::make_tuple("ExpectedIncludeFileName"sv, "expected an include file name"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedTimeLiteral, std::make_tuple("ExpectedTimeLiteral"sv, "expected time literal"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedMacroStringifyEnd, std::make_tuple("ExpectedMacroStringifyEnd"sv, "expected closing quote to end macro stringification"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedPragmaName, std::make_tuple("ExpectedPragmaName"sv, "expected pragma name"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedPragmaExpression, std::make_tuple("ExpectedPragmaExpression"sv, "expected pragma expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DirectiveInsideDesignElement, std::make_tuple("DirectiveInsideDesignElement"sv, "directive is not allowed inside a design element"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::IgnoredMacroPaste, std::make_tuple("IgnoredMacroPaste"sv, "paste token is pointless because it is adjacent to whitespace"sv, DiagnosticSeverity::Warning, "ignored-macro-paste"sv)},
+    {diag::RedefiningMacro, std::make_tuple("RedefiningMacro"sv, "macro '{}' redefined"sv, DiagnosticSeverity::Warning, "redef-macro"sv)},
+    {diag::UnknownPragma, std::make_tuple("UnknownPragma"sv, "unknown pragma '{}'"sv, DiagnosticSeverity::Warning, "unknown-pragma"sv)},
+    {diag::ExtraPragmaArgs, std::make_tuple("ExtraPragmaArgs"sv, "too many arguments provided for pragma '{}'"sv, DiagnosticSeverity::Warning, "extra-pragma-args"sv)},
+    {diag::ExpectedDiagPragmaArg, std::make_tuple("ExpectedDiagPragmaArg"sv, "expected diagnostic pragma argument"sv, DiagnosticSeverity::Warning, "expected-diag-arg"sv)},
+    {diag::UnknownDiagPragmaArg, std::make_tuple("UnknownDiagPragmaArg"sv, "unknown diagnostic pragma argument '{}'"sv, DiagnosticSeverity::Warning, "unknown-diag-arg"sv)},
+    {diag::ExpectedDiagPragmaLevel, std::make_tuple("ExpectedDiagPragmaLevel"sv, "expected diagnostic severity (ignore,warn,error,fatal)"sv, DiagnosticSeverity::Warning, "pragma-diag-level"sv)},
+    {diag::ReturnNotInSubroutine, std::make_tuple("ReturnNotInSubroutine"sv, "return statement is only valid inside task and function blocks"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ReturnInParallel, std::make_tuple("ReturnInParallel"sv, "return statement is not allowed in fork-join block"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DelayNotNumeric, std::make_tuple("DelayNotNumeric"sv, "delay expression type {} is not numeric"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidEventExpression, std::make_tuple("InvalidEventExpression"sv, "invalid type {} for event expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::CoverStmtNoFail, std::make_tuple("CoverStmtNoFail"sv, "cover statement cannot have a fail statement"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::StatementNotInLoop, std::make_tuple("StatementNotInLoop"sv, "statement can only be used inside a loop"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExprNotStatement, std::make_tuple("ExprNotStatement"sv, "expression is not allowed as a statement"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExprNotConstraint, std::make_tuple("ExprNotConstraint"sv, "expression is not allowed in a constraint"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::VoidCastFuncCall, std::make_tuple("VoidCastFuncCall"sv, "void casting is only allowed for function calls"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAnArray, std::make_tuple("NotAnArray"sv, "name must refer to an iterable array"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TooManyForeachVars, std::make_tuple("TooManyForeachVars"sv, "too many loop variables for array of type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ForeachDynamicDimAfterSkipped, std::make_tuple("ForeachDynamicDimAfterSkipped"sv, "foreach index '{}' can't iterate over a dynamically sized dimension since a previous dimension was omitted"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::LoopVarShadowsArray, std::make_tuple("LoopVarShadowsArray"sv, "loop variable '{}' shadows foreach array target"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ForeachWildcardIndex, std::make_tuple("ForeachWildcardIndex"sv, "foreach loops cannot be used with associative arrays that have a wildcard index"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::CaseInsideKeyword, std::make_tuple("CaseInsideKeyword"sv, "set membership cannot be used with {} statements"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidDisableTarget, std::make_tuple("InvalidDisableTarget"sv, "disable statement must specify a task or block name"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAnEvent, std::make_tuple("NotAnEvent"sv, "expression is not a triggerable event"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RepeatNotNumeric, std::make_tuple("RepeatNotNumeric"sv, "repeat type {} is not numeric"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RepeatControlNotEvent, std::make_tuple("RepeatControlNotEvent"sv, "repeat control must be an event to count"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnexpectedPortDecl, std::make_tuple("UnexpectedPortDecl"sv, "unexpected port declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NonIntegralConstraintExpr, std::make_tuple("NonIntegralConstraintExpr"sv, "{} is not a valid type for a constraint expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NonIntegralConstraintLiteral, std::make_tuple("NonIntegralConstraintLiteral"sv, "literals in constraints must be integers"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownConstraintLiteral, std::make_tuple("UnknownConstraintLiteral"sv, "'x' and 'z' values are not allowed in constraints"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RandCInDist, std::make_tuple("RandCInDist"sv, "'randc' variables cannot be used in 'dist' constraints"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RandCInUnique, std::make_tuple("RandCInUnique"sv, "'randc' variables cannot be used in 'unique' constraints"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RandCInSolveBefore, std::make_tuple("RandCInSolveBefore"sv, "'randc' variables cannot be used in 'solve before' constraints"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RandCInSoft, std::make_tuple("RandCInSoft"sv, "'randc' variables cannot be used in 'soft' constraints"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RandNeededInDist, std::make_tuple("RandNeededInDist"sv, "'dist' expression must reference at least one 'rand' variable"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidUniquenessExpr, std::make_tuple("InvalidUniquenessExpr"sv, "uniqueness constraints can only contain references to integral or array random variables"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InequivalentUniquenessTypes, std::make_tuple("InequivalentUniquenessTypes"sv, "type of '{}' is {} which is not equivalent to the type of other variables in the constraint (previously saw {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TaskInConstraint, std::make_tuple("TaskInConstraint"sv, "cannot invoke tasks in constraints"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::OutRefFuncConstraint, std::make_tuple("OutRefFuncConstraint"sv, "cannot call a function with ref or output arguments in constraints"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadDisableSoft, std::make_tuple("BadDisableSoft"sv, "target of 'disable soft' constraint must be a 'rand' variable"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadSolveBefore, std::make_tuple("BadSolveBefore"sv, "target of 'solve before' constraint must be a random variable"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadProceduralAssign, std::make_tuple("BadProceduralAssign"sv, "lvalue of procedural assign/deassign must be a variable or concatenation of variables -- bit-selects, part-selects, and references to nets are disallowed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadProceduralForce, std::make_tuple("BadProceduralForce"sv, "lvalue of force/release must be a net, a variable, a constant select of a net, or a concatenation of these"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadForceNetType, std::make_tuple("BadForceNetType"sv, "force and release cannot be applied to nets with a user-defined nettype"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EventExpressionConstant, std::make_tuple("EventExpressionConstant"sv, "edge expression is constant"sv, DiagnosticSeverity::Warning, "event-const"sv)},
+    {diag::EmptyStatement, std::make_tuple("EmptyStatement"sv, "extra ';' has no effect"sv, DiagnosticSeverity::Warning, "empty-stmt"sv)},
+    {diag::PointlessVoidCast, std::make_tuple("PointlessVoidCast"sv, "cast to void for void-returning function '{}' has no effect"sv, DiagnosticSeverity::Warning, "pointless-void-cast"sv)},
+    {diag::UnusedResult, std::make_tuple("UnusedResult"sv, "ignoring return value of '{}', cast to void to suppress"sv, DiagnosticSeverity::Warning, "unused-result"sv)},
+    {diag::BadSystemSubroutineArg, std::make_tuple("BadSystemSubroutineArg"sv, "invalid argument type {} to system {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownFormatSpecifier, std::make_tuple("UnknownFormatSpecifier"sv, "unknown format specifier '%{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::FormatSpecifierWidthNotAllowed, std::make_tuple("FormatSpecifierWidthNotAllowed"sv, "field width not allowed on '%{}' format specifiers"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::FormatSpecifierInvalidWidth, std::make_tuple("FormatSpecifierInvalidWidth"sv, "field width is invalid"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::FormatSpecifierNotFloat, std::make_tuple("FormatSpecifierNotFloat"sv, "floating point format specifier options used on non-floating point field"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::FormatUnspecifiedType, std::make_tuple("FormatUnspecifiedType"sv, "cannot format values of type {} without a specification string"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::FormatMismatchedType, std::make_tuple("FormatMismatchedType"sv, "value of type {} is invalid for '%{}' format specifier"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::FormatNoArgument, std::make_tuple("FormatNoArgument"sv, "no argument provided for '%{}' format specifier"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::FormatEmptyArg, std::make_tuple("FormatEmptyArg"sv, "empty argument not allowed -- expecting value for '%{}' format specifier"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::FormatTooManyArgs, std::make_tuple("FormatTooManyArgs"sv, "too many arguments provided for format string"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidStringArg, std::make_tuple("InvalidStringArg"sv, "value of type {} is not a valid string argument"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ArrayMethodIntegral, std::make_tuple("ArrayMethodIntegral"sv, "array method '{}' can only be called on unpacked arrays of integral values"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ArrayMethodComparable, std::make_tuple("ArrayMethodComparable"sv, "array method '{}' can only be called on unpacked arrays of comparable values"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::SysFuncNotConst, std::make_tuple("SysFuncNotConst"sv, "'{}' is not allowed in a constant context"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::QueryOnDynamicType, std::make_tuple("QueryOnDynamicType"sv, "array query function '{}' cannot be called on a dynamically sized type identifier"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DimensionIndexInvalid, std::make_tuple("DimensionIndexInvalid"sv, "{} is not a valid dimension for {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DynamicDimensionIndex, std::make_tuple("DynamicDimensionIndex"sv, "cannot refer to a dynamically sized dimension with index {} greater than 1"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::QueryOnAssociativeNonIntegral, std::make_tuple("QueryOnAssociativeNonIntegral"sv, "'{}' cannot be called with an associative array with non-integral index type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::QueryOnAssociativeWildcard, std::make_tuple("QueryOnAssociativeWildcard"sv, "'{}' cannot be called with an associative array with non-integral (or wildcard) index type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssociativeWildcardNotAllowed, std::make_tuple("AssociativeWildcardNotAllowed"sv, "'{}' cannot be called with an associative array with wildcard index type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedModuleName, std::make_tuple("ExpectedModuleName"sv, "expected module name"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedModOrVarName, std::make_tuple("ExpectedModOrVarName"sv, "expected module or variable name"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedScopeOrAssert, std::make_tuple("ExpectedScopeOrAssert"sv, "expected scope or assertion name"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedClassPropertyName, std::make_tuple("ExpectedClassPropertyName"sv, "expected class property name"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedVariableName, std::make_tuple("ExpectedVariableName"sv, "expected variable name"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedModuleInstance, std::make_tuple("ExpectedModuleInstance"sv, "expected module instance"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::CastArgSingular, std::make_tuple("CastArgSingular"sv, "argument to $cast cannot be of aggregate type (type is {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ArrayLocatorWithClause, std::make_tuple("ArrayLocatorWithClause"sv, "'{}' requires 'with' expression for searching"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::FormatRealInt, std::make_tuple("FormatRealInt"sv, "real value provided for integer format specifier '%{}'"sv, DiagnosticSeverity::Warning, "format-real"sv)},
+    {diag::BadFinishNum, std::make_tuple("BadFinishNum"sv, "finish argument must have value of 0, 1, or 2"sv, DiagnosticSeverity::Warning, "finish-num"sv)},
+    {diag::MissingFormatSpecifier, std::make_tuple("MissingFormatSpecifier"sv, "missing format specifier"sv, DiagnosticSeverity::Warning, "missing-format"sv)},
+    {diag::InvalidEnumBase, std::make_tuple("InvalidEnumBase"sv, "invalid enum base type {} (must be a single dimensional integer type)"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EnumValueOverflow, std::make_tuple("EnumValueOverflow"sv, "incrementing previous value {} would overflow enum base type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EnumIncrementUnknown, std::make_tuple("EnumIncrementUnknown"sv, "cannot increment previous value {} because it has unknown bits"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EnumValueDuplicate, std::make_tuple("EnumValueDuplicate"sv, "redefinition of enum value {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EnumValueUnknownBits, std::make_tuple("EnumValueUnknownBits"sv, "value of {} is invalid for enum with base type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EnumValueOutOfRange, std::make_tuple("EnumValueOutOfRange"sv, "enum value {} is out of range for base type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EnumRangeMultiDimensional, std::make_tuple("EnumRangeMultiDimensional"sv, "enum range cannot be multidimensional"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ForwardTypedefDoesNotMatch, std::make_tuple("ForwardTypedefDoesNotMatch"sv, "forward typedef basic type '{}' does not match declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ForwardTypedefVisibility, std::make_tuple("ForwardTypedefVisibility"sv, "declared visibility of forward typedef does not match the visibility of the actual type declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PackedMemberNotIntegral, std::make_tuple("PackedMemberNotIntegral"sv, "packed members must be of integral type (not {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PackedMemberHasInitializer, std::make_tuple("PackedMemberHasInitializer"sv, "packed members can not have initializers"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PackedDimsOnPredefinedType, std::make_tuple("PackedDimsOnPredefinedType"sv, "packed dimensions not allowed on predefined integer type '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PackedDimsOnUnpacked, std::make_tuple("PackedDimsOnUnpacked"sv, "unpacked types cannot have packed dimensions"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PackedUnionWidthMismatch, std::make_tuple("PackedUnionWidthMismatch"sv, "all members of a packed union must have the same width; '{}' has width of {}, previously seen width was {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidArraySize, std::make_tuple("InvalidArraySize"sv, "{} is not a valid size for an array"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::CannotDeclareType, std::make_tuple("CannotDeclareType"sv, "cannot declare a type here"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidAssociativeIndexType, std::make_tuple("InvalidAssociativeIndexType"sv, "index type cannot be or contain floating point types"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PackedArrayNotIntegral, std::make_tuple("PackedArrayNotIntegral"sv, "packed array elements must be of integral type (not {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PackedArrayTooLarge, std::make_tuple("PackedArrayTooLarge"sv, "packed array of {} bits is too large; maximum width is {} bits"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ArrayDimTooLarge, std::make_tuple("ArrayDimTooLarge"sv, "array dimension of {} is too large; maximum number of elements is {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnpackedSigned, std::make_tuple("UnpackedSigned"sv, "unpacked type cannot have signedness declared"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidUnionMember, std::make_tuple("InvalidUnionMember"sv, "untagged unions cannot have members of type {}"sv, DiagnosticSeverity::Error, ""sv)},
+};
+
+static const flat_hash_map<string_view, DiagCode> optionMap = {
+    {"unused-def"sv, diag::UnusedDefinition},
+    {"no-top"sv, diag::NoTopModules},
+    {"elem-not-found"sv, diag::ConstEvalAssociativeElementNotFound},
+    {"static-skipped"sv, diag::ConstEvalStaticSkipped},
+    {"dynarray-index"sv, diag::ConstEvalDynamicArrayIndex},
+    {"dynarray-range"sv, diag::ConstEvalDynamicArrayRange},
+    {"queue-range"sv, diag::ConstEvalQueueRange},
+    {"empty-queue"sv, diag::ConstEvalEmptyQueue},
+    {"task-ignored"sv, diag::ConstSysTaskIgnored},
+    {"warning-task"sv, diag::WarningTask},
+    {"explicit-static"sv, diag::StaticInitializerMustBeExplicit},
+    {"case-gen-dup"sv, diag::CaseGenerateDup},
+    {"case-gen-none"sv, diag::CaseGenerateNoBlock},
+    {"unconnected-port"sv, diag::UnconnectedNamedPort},
+    {"unconnected-unnamed-port"sv, diag::UnconnectedUnnamedPort},
+    {"implicit-net-port"sv, diag::ImplicitNetPortNoDefault},
+    {"dup-attr"sv, diag::DuplicateAttribute},
+    {"empty-member"sv, diag::EmptyMember},
+    {"ineffective-sign"sv, diag::SignednessNoEffect},
+    {"constraint-missing"sv, diag::NoConstraintBody},
+    {"dpi-spec"sv, diag::DPISpecDisallowed},
+    {"ignored-slice"sv, diag::IgnoredSlice},
+    {"unsized-concat"sv, diag::UnsizedInConcat},
+    {"width-expand"sv, diag::WidthExpand},
+    {"width-trunc"sv, diag::WidthTruncate},
+    {"implicit-conv"sv, diag::ImplicitConvert},
+    {"not-supported"sv, diag::WarnNotYetSupported},
+    {"unknown-escape-code"sv, diag::UnknownEscapeCode},
+    {"nonstandard-escape-code"sv, diag::NonstandardEscapeCode},
+    {"dup-import"sv, diag::DuplicateImport},
+    {"unknown-warning-option"sv, diag::UnknownWarningOption},
+    {"real-underflow"sv, diag::RealLiteralUnderflow},
+    {"real-overflow"sv, diag::RealLiteralOverflow},
+    {"literal-overflow"sv, diag::VectorLiteralOverflow},
+    {"nonstandard-generate"sv, diag::NonStandardGenBlock},
+    {"empty-pattern"sv, diag::EmptyAssignmentPattern},
+    {"ignored-macro-paste"sv, diag::IgnoredMacroPaste},
+    {"redef-macro"sv, diag::RedefiningMacro},
+    {"unknown-pragma"sv, diag::UnknownPragma},
+    {"extra-pragma-args"sv, diag::ExtraPragmaArgs},
+    {"expected-diag-arg"sv, diag::ExpectedDiagPragmaArg},
+    {"unknown-diag-arg"sv, diag::UnknownDiagPragmaArg},
+    {"pragma-diag-level"sv, diag::ExpectedDiagPragmaLevel},
+    {"event-const"sv, diag::EventExpressionConstant},
+    {"empty-stmt"sv, diag::EmptyStatement},
+    {"pointless-void-cast"sv, diag::PointlessVoidCast},
+    {"unused-result"sv, diag::UnusedResult},
+    {"format-real"sv, diag::FormatRealInt},
+    {"finish-num"sv, diag::BadFinishNum},
+    {"missing-format"sv, diag::MissingFormatSpecifier},
+};
+
+static const flat_hash_map<string_view, DiagGroup> groupMap = {
+    {"conversion"sv, DiagGroup("conversion", { diag::WidthTruncate, diag::WidthExpand, diag::ImplicitConvert })},
+    {"default"sv, DiagGroup("default", { diag::RealLiteralUnderflow, diag::RealLiteralOverflow, diag::VectorLiteralOverflow, diag::UnconnectedNamedPort, diag::UnconnectedUnnamedPort, diag::EventExpressionConstant, diag::RedefiningMacro, diag::WarnNotYetSupported, diag::UnknownPragma, diag::ExtraPragmaArgs, diag::ExpectedDiagPragmaArg, diag::UnknownDiagPragmaArg, diag::ExpectedDiagPragmaLevel, diag::StaticInitializerMustBeExplicit, diag::ConstEvalStaticSkipped, diag::ConstEvalAssociativeElementNotFound, diag::ConstEvalDynamicArrayIndex, diag::ConstEvalDynamicArrayRange, diag::ConstEvalQueueRange, diag::ConstEvalEmptyQueue, diag::UnknownEscapeCode, diag::NoTopModules, diag::WarningTask, diag::UnsizedInConcat, diag::BadFinishNum, diag::ImplicitConvert, diag::NoConstraintBody, diag::MissingFormatSpecifier, diag::DPISpecDisallowed })},
+    {"extra"sv, DiagGroup("extra", { diag::EmptyMember, diag::EmptyStatement, diag::DuplicateImport, diag::PointlessVoidCast, diag::CaseGenerateNoBlock, diag::CaseGenerateDup, diag::UnusedResult, diag::FormatRealInt, diag::IgnoredSlice, diag::ConstSysTaskIgnored, diag::WidthTruncate, diag::DuplicateAttribute })},
+    {"pedantic"sv, DiagGroup("pedantic", { diag::EmptyAssignmentPattern, diag::ImplicitNetPortNoDefault, diag::NonstandardEscapeCode, diag::NonStandardGenBlock })},
+};
+
+std::ostream& operator<<(std::ostream& os, DiagCode code) {
+    os << toString(code);
+    return os;
+}
+
+string_view toString(DiagCode code) {
+    if (auto it = data.find(code); it != data.end())
+        return std::get<0>(it->second);
+    return "<user-diag>"sv;
+}
+
+string_view getDefaultMessage(DiagCode code) {
+    if (auto it = data.find(code); it != data.end())
+        return std::get<1>(it->second);
+    return ""sv;
+}
+
+DiagnosticSeverity getDefaultSeverity(DiagCode code) {
+    if (auto it = data.find(code); it != data.end())
+        return std::get<2>(it->second);
+    return DiagnosticSeverity::Ignored;
+}
+
+string_view getDefaultOptionName(DiagCode code) {
+    if (auto it = data.find(code); it != data.end())
+        return std::get<3>(it->second);
+    return ""sv;
+}
+
+DiagCode findDiagFromOptionName(string_view name) {
+    if (auto it = optionMap.find(name); it != optionMap.end())
+        return it->second;
+    return DiagCode();
+}
+
+const DiagGroup* findDefaultDiagGroup(string_view name) {
+    if (auto it = groupMap.find(name); it != groupMap.end())
+        return &it->second;
+    return nullptr;
+}
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./generated/slang/diagnostics/AllDiags.h ./generated/slang/diagnostics/AllDiags.h
--- ./generated/slang/diagnostics/AllDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/AllDiags.h	2021-03-02 17:50:53.981602243 -0800
@@ -0,0 +1,23 @@
+//------------------------------------------------------------------------------
+//! @file AllDiags.h
+//! @brief Combined header that includes all subsystem-specific diagnostic headers
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/CompilationDiags.h"
+#include "slang/diagnostics/ConstEvalDiags.h"
+#include "slang/diagnostics/DeclarationsDiags.h"
+#include "slang/diagnostics/ExpressionsDiags.h"
+#include "slang/diagnostics/GeneralDiags.h"
+#include "slang/diagnostics/LexerDiags.h"
+#include "slang/diagnostics/LookupDiags.h"
+#include "slang/diagnostics/MetaDiags.h"
+#include "slang/diagnostics/NumericDiags.h"
+#include "slang/diagnostics/ParserDiags.h"
+#include "slang/diagnostics/PreprocessorDiags.h"
+#include "slang/diagnostics/StatementsDiags.h"
+#include "slang/diagnostics/SysFuncsDiags.h"
+#include "slang/diagnostics/TypesDiags.h"
+
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./generated/slang/diagnostics/CompilationDiags.h ./generated/slang/diagnostics/CompilationDiags.h
--- ./generated/slang/diagnostics/CompilationDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/CompilationDiags.h	2021-03-02 17:50:53.961602660 -0800
@@ -0,0 +1,30 @@
+//------------------------------------------------------------------------------
+//! @file CompilationDiags.h
+//! @brief Generated diagnostic enums for the Compilation subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode MaxInstanceDepthExceeded(DiagSubsystem::Compilation, 0);
+inline constexpr DiagCode InfinitelyRecursiveHierarchy(DiagSubsystem::Compilation, 1);
+inline constexpr DiagCode InvalidTopModule(DiagSubsystem::Compilation, 2);
+inline constexpr DiagCode NoDeclInClass(DiagSubsystem::Compilation, 3);
+inline constexpr DiagCode InvalidParamOverrideOpt(DiagSubsystem::Compilation, 4);
+inline constexpr DiagCode DPIExportKindMismatch(DiagSubsystem::Compilation, 5);
+inline constexpr DiagCode DPIExportDifferentScope(DiagSubsystem::Compilation, 6);
+inline constexpr DiagCode DPIExportDuplicate(DiagSubsystem::Compilation, 7);
+inline constexpr DiagCode DPIExportImportedFunc(DiagSubsystem::Compilation, 8);
+inline constexpr DiagCode InvalidDPICIdentifier(DiagSubsystem::Compilation, 9);
+inline constexpr DiagCode DPISignatureMismatch(DiagSubsystem::Compilation, 10);
+inline constexpr DiagCode DPIExportDuplicateCId(DiagSubsystem::Compilation, 11);
+inline constexpr DiagCode DefParamTargetChange(DiagSubsystem::Compilation, 12);
+inline constexpr DiagCode DefParamCycle(DiagSubsystem::Compilation, 13);
+inline constexpr DiagCode UnusedDefinition(DiagSubsystem::Compilation, 14);
+inline constexpr DiagCode NoTopModules(DiagSubsystem::Compilation, 15);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./generated/slang/diagnostics/ConstEvalDiags.h ./generated/slang/diagnostics/ConstEvalDiags.h
--- ./generated/slang/diagnostics/ConstEvalDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/ConstEvalDiags.h	2021-03-02 17:50:53.961602660 -0800
@@ -0,0 +1,52 @@
+//------------------------------------------------------------------------------
+//! @file ConstEvalDiags.h
+//! @brief Generated diagnostic enums for the ConstEval subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode NoteInCallTo(DiagSubsystem::ConstEval, 0);
+inline constexpr DiagCode NoteSkippingFrames(DiagSubsystem::ConstEval, 1);
+inline constexpr DiagCode ConstEvalNonConstVariable(DiagSubsystem::ConstEval, 2);
+inline constexpr DiagCode ConstEvalBitsNotFixedSize(DiagSubsystem::ConstEval, 3);
+inline constexpr DiagCode ConstEvalBitstreamCastSize(DiagSubsystem::ConstEval, 4);
+inline constexpr DiagCode ConstEvalArrayIndexInvalid(DiagSubsystem::ConstEval, 5);
+inline constexpr DiagCode ConstEvalPartSelectInvalid(DiagSubsystem::ConstEval, 6);
+inline constexpr DiagCode ConstEvalStringIndexInvalid(DiagSubsystem::ConstEval, 7);
+inline constexpr DiagCode ConstEvalReplicationCountInvalid(DiagSubsystem::ConstEval, 8);
+inline constexpr DiagCode ConstEvalHierarchicalNameInCE(DiagSubsystem::ConstEval, 9);
+inline constexpr DiagCode ConstEvalFunctionIdentifiersMustBeLocal(DiagSubsystem::ConstEval, 10);
+inline constexpr DiagCode ConstEvalIdUsedInCEBeforeDecl(DiagSubsystem::ConstEval, 11);
+inline constexpr DiagCode ConstEvalNoCaseItemsMatched(DiagSubsystem::ConstEval, 12);
+inline constexpr DiagCode ConstEvalCaseItemsNotUnique(DiagSubsystem::ConstEval, 13);
+inline constexpr DiagCode ConstEvalTimedStmtNotConst(DiagSubsystem::ConstEval, 14);
+inline constexpr DiagCode ConstEvalAssertionFailed(DiagSubsystem::ConstEval, 15);
+inline constexpr DiagCode ConstEvalParallelBlockNotConst(DiagSubsystem::ConstEval, 16);
+inline constexpr DiagCode ConstEvalExceededMaxCallDepth(DiagSubsystem::ConstEval, 17);
+inline constexpr DiagCode ConstEvalExceededMaxSteps(DiagSubsystem::ConstEval, 18);
+inline constexpr DiagCode ConstEvalTaskNotConstant(DiagSubsystem::ConstEval, 19);
+inline constexpr DiagCode ConstEvalVoidNotConstant(DiagSubsystem::ConstEval, 20);
+inline constexpr DiagCode ConstEvalDPINotConstant(DiagSubsystem::ConstEval, 21);
+inline constexpr DiagCode ConstEvalMethodNotConstant(DiagSubsystem::ConstEval, 22);
+inline constexpr DiagCode ConstEvalSubroutineNotConstant(DiagSubsystem::ConstEval, 23);
+inline constexpr DiagCode ConstEvalFunctionArgDirection(DiagSubsystem::ConstEval, 24);
+inline constexpr DiagCode ConstEvalFunctionInsideGenerate(DiagSubsystem::ConstEval, 25);
+inline constexpr DiagCode ConstEvalDynamicToFixedSize(DiagSubsystem::ConstEval, 26);
+inline constexpr DiagCode ConstEvalAssociativeIndexInvalid(DiagSubsystem::ConstEval, 27);
+inline constexpr DiagCode ConstEvalDisableTarget(DiagSubsystem::ConstEval, 28);
+inline constexpr DiagCode ConstEvalClassType(DiagSubsystem::ConstEval, 29);
+inline constexpr DiagCode ConstEvalProceduralAssign(DiagSubsystem::ConstEval, 30);
+inline constexpr DiagCode ConstEvalAssociativeElementNotFound(DiagSubsystem::ConstEval, 31);
+inline constexpr DiagCode ConstEvalStaticSkipped(DiagSubsystem::ConstEval, 32);
+inline constexpr DiagCode ConstEvalDynamicArrayIndex(DiagSubsystem::ConstEval, 33);
+inline constexpr DiagCode ConstEvalDynamicArrayRange(DiagSubsystem::ConstEval, 34);
+inline constexpr DiagCode ConstEvalQueueRange(DiagSubsystem::ConstEval, 35);
+inline constexpr DiagCode ConstEvalEmptyQueue(DiagSubsystem::ConstEval, 36);
+inline constexpr DiagCode ConstSysTaskIgnored(DiagSubsystem::ConstEval, 37);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./generated/slang/diagnostics/DeclarationsDiags.h ./generated/slang/diagnostics/DeclarationsDiags.h
--- ./generated/slang/diagnostics/DeclarationsDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/DeclarationsDiags.h	2021-03-02 17:50:53.961602660 -0800
@@ -0,0 +1,130 @@
+//------------------------------------------------------------------------------
+//! @file DeclarationsDiags.h
+//! @brief Generated diagnostic enums for the Declarations subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode LocalParamNoInitializer(DiagSubsystem::Declarations, 0);
+inline constexpr DiagCode BodyParamNoInitializer(DiagSubsystem::Declarations, 1);
+inline constexpr DiagCode InvalidDimensionRange(DiagSubsystem::Declarations, 2);
+inline constexpr DiagCode DimensionRequiresConstRange(DiagSubsystem::Declarations, 3);
+inline constexpr DiagCode PackedDimsRequireFullRange(DiagSubsystem::Declarations, 4);
+inline constexpr DiagCode MixingOrderedAndNamedParams(DiagSubsystem::Declarations, 5);
+inline constexpr DiagCode DuplicateParamAssignment(DiagSubsystem::Declarations, 6);
+inline constexpr DiagCode ParamHasNoValue(DiagSubsystem::Declarations, 7);
+inline constexpr DiagCode TooManyParamAssignments(DiagSubsystem::Declarations, 8);
+inline constexpr DiagCode AssignedToLocalPortParam(DiagSubsystem::Declarations, 9);
+inline constexpr DiagCode AssignedToLocalBodyParam(DiagSubsystem::Declarations, 10);
+inline constexpr DiagCode ParameterDoesNotExist(DiagSubsystem::Declarations, 11);
+inline constexpr DiagCode BadTypeParamExpr(DiagSubsystem::Declarations, 12);
+inline constexpr DiagCode PortTypeNotInterfaceOrData(DiagSubsystem::Declarations, 13);
+inline constexpr DiagCode VarWithInterfacePort(DiagSubsystem::Declarations, 14);
+inline constexpr DiagCode DirectionWithInterfacePort(DiagSubsystem::Declarations, 15);
+inline constexpr DiagCode InOutPortCannotBeVariable(DiagSubsystem::Declarations, 16);
+inline constexpr DiagCode RefPortMustBeVariable(DiagSubsystem::Declarations, 17);
+inline constexpr DiagCode MissingPortIODeclaration(DiagSubsystem::Declarations, 18);
+inline constexpr DiagCode CantDeclarePortSigned(DiagSubsystem::Declarations, 19);
+inline constexpr DiagCode PortDeclDimensionsMismatch(DiagSubsystem::Declarations, 20);
+inline constexpr DiagCode PortDeclInANSIModule(DiagSubsystem::Declarations, 21);
+inline constexpr DiagCode UnusedPortDecl(DiagSubsystem::Declarations, 22);
+inline constexpr DiagCode UnknownPackage(DiagSubsystem::Declarations, 23);
+inline constexpr DiagCode UnknownModule(DiagSubsystem::Declarations, 24);
+inline constexpr DiagCode UnknownInterface(DiagSubsystem::Declarations, 25);
+inline constexpr DiagCode MixingOrderedAndNamedPorts(DiagSubsystem::Declarations, 26);
+inline constexpr DiagCode DuplicateWildcardPortConnection(DiagSubsystem::Declarations, 27);
+inline constexpr DiagCode DuplicatePortConnection(DiagSubsystem::Declarations, 28);
+inline constexpr DiagCode TooManyPortConnections(DiagSubsystem::Declarations, 29);
+inline constexpr DiagCode PortDoesNotExist(DiagSubsystem::Declarations, 30);
+inline constexpr DiagCode PortConnDimensionsMismatch(DiagSubsystem::Declarations, 31);
+inline constexpr DiagCode InterfacePortNotConnected(DiagSubsystem::Declarations, 32);
+inline constexpr DiagCode InterfacePortInvalidExpression(DiagSubsystem::Declarations, 33);
+inline constexpr DiagCode InterfacePortTypeMismatch(DiagSubsystem::Declarations, 34);
+inline constexpr DiagCode MismatchedTimeScales(DiagSubsystem::Declarations, 35);
+inline constexpr DiagCode TimeScaleFirstInScope(DiagSubsystem::Declarations, 36);
+inline constexpr DiagCode GenvarDuplicate(DiagSubsystem::Declarations, 37);
+inline constexpr DiagCode GenvarUnknownBits(DiagSubsystem::Declarations, 38);
+inline constexpr DiagCode ImplicitNamedPortNotFound(DiagSubsystem::Declarations, 39);
+inline constexpr DiagCode ImplicitNamedPortTypeMismatch(DiagSubsystem::Declarations, 40);
+inline constexpr DiagCode MaxGenerateStepsExceeded(DiagSubsystem::Declarations, 41);
+inline constexpr DiagCode MixingSubroutinePortKinds(DiagSubsystem::Declarations, 42);
+inline constexpr DiagCode UnpackedArrayParamType(DiagSubsystem::Declarations, 43);
+inline constexpr DiagCode AutomaticNotAllowed(DiagSubsystem::Declarations, 44);
+inline constexpr DiagCode NoMemberImplFound(DiagSubsystem::Declarations, 45);
+inline constexpr DiagCode MethodKindMismatch(DiagSubsystem::Declarations, 46);
+inline constexpr DiagCode MethodReturnMismatch(DiagSubsystem::Declarations, 47);
+inline constexpr DiagCode MethodArgCountMismatch(DiagSubsystem::Declarations, 48);
+inline constexpr DiagCode MethodArgNameMismatch(DiagSubsystem::Declarations, 49);
+inline constexpr DiagCode MethodArgTypeMismatch(DiagSubsystem::Declarations, 50);
+inline constexpr DiagCode MethodArgNoDefault(DiagSubsystem::Declarations, 51);
+inline constexpr DiagCode MethodArgDefaultMismatch(DiagSubsystem::Declarations, 52);
+inline constexpr DiagCode MethodArgDirectionMismatch(DiagSubsystem::Declarations, 53);
+inline constexpr DiagCode MemberDefinitionBeforeClass(DiagSubsystem::Declarations, 54);
+inline constexpr DiagCode MethodReturnTypeScoped(DiagSubsystem::Declarations, 55);
+inline constexpr DiagCode VirtualKindMismatch(DiagSubsystem::Declarations, 56);
+inline constexpr DiagCode VirtualReturnMismatch(DiagSubsystem::Declarations, 57);
+inline constexpr DiagCode VirtualArgCountMismatch(DiagSubsystem::Declarations, 58);
+inline constexpr DiagCode VirtualArgNameMismatch(DiagSubsystem::Declarations, 59);
+inline constexpr DiagCode VirtualArgTypeMismatch(DiagSubsystem::Declarations, 60);
+inline constexpr DiagCode VirtualArgNoParentDefault(DiagSubsystem::Declarations, 61);
+inline constexpr DiagCode VirtualArgNoDerivedDefault(DiagSubsystem::Declarations, 62);
+inline constexpr DiagCode VirtualArgDirectionMismatch(DiagSubsystem::Declarations, 63);
+inline constexpr DiagCode BaseConstructorDuplicate(DiagSubsystem::Declarations, 64);
+inline constexpr DiagCode BaseConstructorNotCalled(DiagSubsystem::Declarations, 65);
+inline constexpr DiagCode ConstVarNoInitializer(DiagSubsystem::Declarations, 66);
+inline constexpr DiagCode StaticConstNoInitializer(DiagSubsystem::Declarations, 67);
+inline constexpr DiagCode PureInAbstract(DiagSubsystem::Declarations, 68);
+inline constexpr DiagCode PureConstraintInAbstract(DiagSubsystem::Declarations, 69);
+inline constexpr DiagCode BodyForPure(DiagSubsystem::Declarations, 70);
+inline constexpr DiagCode BodyForPureConstraint(DiagSubsystem::Declarations, 71);
+inline constexpr DiagCode InheritFromAbstract(DiagSubsystem::Declarations, 72);
+inline constexpr DiagCode InheritFromAbstractConstraint(DiagSubsystem::Declarations, 73);
+inline constexpr DiagCode InvalidPortType(DiagSubsystem::Declarations, 74);
+inline constexpr DiagCode InvalidNetType(DiagSubsystem::Declarations, 75);
+inline constexpr DiagCode InvalidUserDefinedNetType(DiagSubsystem::Declarations, 76);
+inline constexpr DiagCode ExtendIfaceFromClass(DiagSubsystem::Declarations, 77);
+inline constexpr DiagCode ExtendClassFromIface(DiagSubsystem::Declarations, 78);
+inline constexpr DiagCode ImplementNonIface(DiagSubsystem::Declarations, 79);
+inline constexpr DiagCode IfaceNameConflict(DiagSubsystem::Declarations, 80);
+inline constexpr DiagCode IfaceMethodHidden(DiagSubsystem::Declarations, 81);
+inline constexpr DiagCode IfaceMethodNoImpl(DiagSubsystem::Declarations, 82);
+inline constexpr DiagCode IfaceMethodNotVirtual(DiagSubsystem::Declarations, 83);
+inline constexpr DiagCode NotAllowedInModport(DiagSubsystem::Declarations, 84);
+inline constexpr DiagCode ModportConnMismatch(DiagSubsystem::Declarations, 85);
+inline constexpr DiagCode ExpectedImportExport(DiagSubsystem::Declarations, 86);
+inline constexpr DiagCode SingleBitVectored(DiagSubsystem::Declarations, 87);
+inline constexpr DiagCode VarDeclWithDelay(DiagSubsystem::Declarations, 88);
+inline constexpr DiagCode InvalidRandType(DiagSubsystem::Declarations, 89);
+inline constexpr DiagCode InvalidMethodOverride(DiagSubsystem::Declarations, 90);
+inline constexpr DiagCode InvalidRandomizeOverride(DiagSubsystem::Declarations, 91);
+inline constexpr DiagCode MismatchStaticConstraint(DiagSubsystem::Declarations, 92);
+inline constexpr DiagCode DPIRefArg(DiagSubsystem::Declarations, 93);
+inline constexpr DiagCode DPIPureArg(DiagSubsystem::Declarations, 94);
+inline constexpr DiagCode DPIPureReturn(DiagSubsystem::Declarations, 95);
+inline constexpr DiagCode InvalidDPIReturnType(DiagSubsystem::Declarations, 96);
+inline constexpr DiagCode InvalidDPIArgType(DiagSubsystem::Declarations, 97);
+inline constexpr DiagCode Delay3OnVar(DiagSubsystem::Declarations, 98);
+inline constexpr DiagCode DefParamTarget(DiagSubsystem::Declarations, 99);
+inline constexpr DiagCode DefParamLocal(DiagSubsystem::Declarations, 100);
+inline constexpr DiagCode FatalTask(DiagSubsystem::Declarations, 101);
+inline constexpr DiagCode ErrorTask(DiagSubsystem::Declarations, 102);
+inline constexpr DiagCode WarningTask(DiagSubsystem::Declarations, 103);
+inline constexpr DiagCode InfoTask(DiagSubsystem::Declarations, 104);
+inline constexpr DiagCode StaticInitializerMustBeExplicit(DiagSubsystem::Declarations, 105);
+inline constexpr DiagCode CaseGenerateDup(DiagSubsystem::Declarations, 106);
+inline constexpr DiagCode CaseGenerateNoBlock(DiagSubsystem::Declarations, 107);
+inline constexpr DiagCode UnconnectedNamedPort(DiagSubsystem::Declarations, 108);
+inline constexpr DiagCode UnconnectedUnnamedPort(DiagSubsystem::Declarations, 109);
+inline constexpr DiagCode ImplicitNetPortNoDefault(DiagSubsystem::Declarations, 110);
+inline constexpr DiagCode DuplicateAttribute(DiagSubsystem::Declarations, 111);
+inline constexpr DiagCode EmptyMember(DiagSubsystem::Declarations, 112);
+inline constexpr DiagCode SignednessNoEffect(DiagSubsystem::Declarations, 113);
+inline constexpr DiagCode NoConstraintBody(DiagSubsystem::Declarations, 114);
+inline constexpr DiagCode DPISpecDisallowed(DiagSubsystem::Declarations, 115);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./generated/slang/diagnostics/ExpressionsDiags.h ./generated/slang/diagnostics/ExpressionsDiags.h
--- ./generated/slang/diagnostics/ExpressionsDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/ExpressionsDiags.h	2021-03-02 17:50:53.961602660 -0800
@@ -0,0 +1,116 @@
+//------------------------------------------------------------------------------
+//! @file ExpressionsDiags.h
+//! @brief Generated diagnostic enums for the Expressions subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode BadUnaryExpression(DiagSubsystem::Expressions, 0);
+inline constexpr DiagCode BadBinaryExpression(DiagSubsystem::Expressions, 1);
+inline constexpr DiagCode BadConditionalExpression(DiagSubsystem::Expressions, 2);
+inline constexpr DiagCode BadIndexExpression(DiagSubsystem::Expressions, 3);
+inline constexpr DiagCode BadConcatExpression(DiagSubsystem::Expressions, 4);
+inline constexpr DiagCode BadReplicationExpression(DiagSubsystem::Expressions, 5);
+inline constexpr DiagCode BadOpenRange(DiagSubsystem::Expressions, 6);
+inline constexpr DiagCode BadCastType(DiagSubsystem::Expressions, 7);
+inline constexpr DiagCode BadSetMembershipType(DiagSubsystem::Expressions, 8);
+inline constexpr DiagCode ConcatWithStringInt(DiagSubsystem::Expressions, 9);
+inline constexpr DiagCode BadRangeExpression(DiagSubsystem::Expressions, 10);
+inline constexpr DiagCode RangeWidthTooLarge(DiagSubsystem::Expressions, 11);
+inline constexpr DiagCode RangeSelectAssociative(DiagSubsystem::Expressions, 12);
+inline constexpr DiagCode CannotIndexScalar(DiagSubsystem::Expressions, 13);
+inline constexpr DiagCode ExprMustBeIntegral(DiagSubsystem::Expressions, 14);
+inline constexpr DiagCode IndexValueInvalid(DiagSubsystem::Expressions, 15);
+inline constexpr DiagCode SelectEndianMismatch(DiagSubsystem::Expressions, 16);
+inline constexpr DiagCode SelectEndianDynamic(DiagSubsystem::Expressions, 17);
+inline constexpr DiagCode BadAssignment(DiagSubsystem::Expressions, 18);
+inline constexpr DiagCode BadConversion(DiagSubsystem::Expressions, 19);
+inline constexpr DiagCode BadIntegerCast(DiagSubsystem::Expressions, 20);
+inline constexpr DiagCode NoImplicitConversion(DiagSubsystem::Expressions, 21);
+inline constexpr DiagCode TooManyArguments(DiagSubsystem::Expressions, 22);
+inline constexpr DiagCode TooFewArguments(DiagSubsystem::Expressions, 23);
+inline constexpr DiagCode ExpressionNotAssignable(DiagSubsystem::Expressions, 24);
+inline constexpr DiagCode ReplicationZeroOutsideConcat(DiagSubsystem::Expressions, 25);
+inline constexpr DiagCode InvalidMemberAccess(DiagSubsystem::Expressions, 26);
+inline constexpr DiagCode ExpressionNotCallable(DiagSubsystem::Expressions, 27);
+inline constexpr DiagCode UnexpectedWithClause(DiagSubsystem::Expressions, 28);
+inline constexpr DiagCode WithClauseNotAllowed(DiagSubsystem::Expressions, 29);
+inline constexpr DiagCode IteratorArgsWithoutWithClause(DiagSubsystem::Expressions, 30);
+inline constexpr DiagCode ExpectedIteratorName(DiagSubsystem::Expressions, 31);
+inline constexpr DiagCode UnexpectedConstraintBlock(DiagSubsystem::Expressions, 32);
+inline constexpr DiagCode MissingConstraintBlock(DiagSubsystem::Expressions, 33);
+inline constexpr DiagCode ExpectedIterationExpression(DiagSubsystem::Expressions, 34);
+inline constexpr DiagCode NotBooleanConvertible(DiagSubsystem::Expressions, 35);
+inline constexpr DiagCode EnumValueSizeMismatch(DiagSubsystem::Expressions, 36);
+inline constexpr DiagCode NoCommonComparisonType(DiagSubsystem::Expressions, 37);
+inline constexpr DiagCode AssignmentPatternNoContext(DiagSubsystem::Expressions, 38);
+inline constexpr DiagCode BadAssignmentPatternType(DiagSubsystem::Expressions, 39);
+inline constexpr DiagCode WrongNumberAssignmentPatterns(DiagSubsystem::Expressions, 40);
+inline constexpr DiagCode AssignmentPatternKeyExpr(DiagSubsystem::Expressions, 41);
+inline constexpr DiagCode AssignmentPatternKeyDupDefault(DiagSubsystem::Expressions, 42);
+inline constexpr DiagCode AssignmentPatternKeyDupValue(DiagSubsystem::Expressions, 43);
+inline constexpr DiagCode AssignmentPatternKeyDupName(DiagSubsystem::Expressions, 44);
+inline constexpr DiagCode AssignmentPatternNoMember(DiagSubsystem::Expressions, 45);
+inline constexpr DiagCode AssignmentPatternNestedNoMember(DiagSubsystem::Expressions, 46);
+inline constexpr DiagCode AssignmentPatternMissingElements(DiagSubsystem::Expressions, 47);
+inline constexpr DiagCode AssignmentPatternDynamicDefault(DiagSubsystem::Expressions, 48);
+inline constexpr DiagCode AssignmentPatternDynamicType(DiagSubsystem::Expressions, 49);
+inline constexpr DiagCode AssignmentPatternAssociativeType(DiagSubsystem::Expressions, 50);
+inline constexpr DiagCode EmptyArgNotAllowed(DiagSubsystem::Expressions, 51);
+inline constexpr DiagCode NamedArgNotAllowed(DiagSubsystem::Expressions, 52);
+inline constexpr DiagCode DuplicateArgAssignment(DiagSubsystem::Expressions, 53);
+inline constexpr DiagCode MixingOrderedAndNamedArgs(DiagSubsystem::Expressions, 54);
+inline constexpr DiagCode ArgDoesNotExist(DiagSubsystem::Expressions, 55);
+inline constexpr DiagCode ArgCannotBeEmpty(DiagSubsystem::Expressions, 56);
+inline constexpr DiagCode UnconnectedArg(DiagSubsystem::Expressions, 57);
+inline constexpr DiagCode MissingReturnValue(DiagSubsystem::Expressions, 58);
+inline constexpr DiagCode AssignmentNotAllowed(DiagSubsystem::Expressions, 59);
+inline constexpr DiagCode IncDecNotAllowed(DiagSubsystem::Expressions, 60);
+inline constexpr DiagCode AssignmentRequiresParens(DiagSubsystem::Expressions, 61);
+inline constexpr DiagCode PortConnArrayMismatch(DiagSubsystem::Expressions, 62);
+inline constexpr DiagCode AutoFromStaticInit(DiagSubsystem::Expressions, 63);
+inline constexpr DiagCode NonblockingAssignmentToAuto(DiagSubsystem::Expressions, 64);
+inline constexpr DiagCode AssignmentToConst(DiagSubsystem::Expressions, 65);
+inline constexpr DiagCode EmptyConcatNotAllowed(DiagSubsystem::Expressions, 66);
+inline constexpr DiagCode TimingControlNotAllowed(DiagSubsystem::Expressions, 67);
+inline constexpr DiagCode NewArrayTarget(DiagSubsystem::Expressions, 68);
+inline constexpr DiagCode NewClassTarget(DiagSubsystem::Expressions, 69);
+inline constexpr DiagCode UnpackedConcatSize(DiagSubsystem::Expressions, 70);
+inline constexpr DiagCode UnpackedConcatAssociative(DiagSubsystem::Expressions, 71);
+inline constexpr DiagCode InvalidClassAccess(DiagSubsystem::Expressions, 72);
+inline constexpr DiagCode CopyClassTarget(DiagSubsystem::Expressions, 73);
+inline constexpr DiagCode BadStreamSlice(DiagSubsystem::Expressions, 74);
+inline constexpr DiagCode BadStreamExprType(DiagSubsystem::Expressions, 75);
+inline constexpr DiagCode BadStreamTargetType(DiagSubsystem::Expressions, 76);
+inline constexpr DiagCode BadStreamSourceType(DiagSubsystem::Expressions, 77);
+inline constexpr DiagCode BadStreamContext(DiagSubsystem::Expressions, 78);
+inline constexpr DiagCode BadStreamSize(DiagSubsystem::Expressions, 79);
+inline constexpr DiagCode BadStreamCast(DiagSubsystem::Expressions, 80);
+inline constexpr DiagCode BadStreamWithType(DiagSubsystem::Expressions, 81);
+inline constexpr DiagCode BadStreamWithOrder(DiagSubsystem::Expressions, 82);
+inline constexpr DiagCode NewVirtualClass(DiagSubsystem::Expressions, 83);
+inline constexpr DiagCode NewInterfaceClass(DiagSubsystem::Expressions, 84);
+inline constexpr DiagCode AssignToCHandle(DiagSubsystem::Expressions, 85);
+inline constexpr DiagCode AssignToNet(DiagSubsystem::Expressions, 86);
+inline constexpr DiagCode SelectOfVectoredNet(DiagSubsystem::Expressions, 87);
+inline constexpr DiagCode ExpectedNetDelay(DiagSubsystem::Expressions, 88);
+inline constexpr DiagCode InvalidRefArg(DiagSubsystem::Expressions, 89);
+inline constexpr DiagCode RefTypeMismatch(DiagSubsystem::Expressions, 90);
+inline constexpr DiagCode ConstVarToRef(DiagSubsystem::Expressions, 91);
+inline constexpr DiagCode MissingInvocationParens(DiagSubsystem::Expressions, 92);
+inline constexpr DiagCode NameListWithScopeRandomize(DiagSubsystem::Expressions, 93);
+inline constexpr DiagCode UnboundedNotAllowed(DiagSubsystem::Expressions, 94);
+inline constexpr DiagCode DynamicNotProcedural(DiagSubsystem::Expressions, 95);
+inline constexpr DiagCode SpecparamInConstant(DiagSubsystem::Expressions, 96);
+inline constexpr DiagCode IgnoredSlice(DiagSubsystem::Expressions, 97);
+inline constexpr DiagCode UnsizedInConcat(DiagSubsystem::Expressions, 98);
+inline constexpr DiagCode WidthExpand(DiagSubsystem::Expressions, 99);
+inline constexpr DiagCode WidthTruncate(DiagSubsystem::Expressions, 100);
+inline constexpr DiagCode ImplicitConvert(DiagSubsystem::Expressions, 101);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./generated/slang/diagnostics/GeneralDiags.h ./generated/slang/diagnostics/GeneralDiags.h
--- ./generated/slang/diagnostics/GeneralDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/GeneralDiags.h	2021-03-02 17:50:53.971602450 -0800
@@ -0,0 +1,22 @@
+//------------------------------------------------------------------------------
+//! @file GeneralDiags.h
+//! @brief Generated diagnostic enums for the General subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode NotYetSupported(DiagSubsystem::General, 0);
+inline constexpr DiagCode ExpectedExpression(DiagSubsystem::General, 1);
+inline constexpr DiagCode NotePreviousDefinition(DiagSubsystem::General, 2);
+inline constexpr DiagCode NotePreviousUsage(DiagSubsystem::General, 3);
+inline constexpr DiagCode NoteDeclarationHere(DiagSubsystem::General, 4);
+inline constexpr DiagCode NotePreviousMatch(DiagSubsystem::General, 5);
+inline constexpr DiagCode AttributesNotAllowed(DiagSubsystem::General, 6);
+inline constexpr DiagCode WarnNotYetSupported(DiagSubsystem::General, 7);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./generated/slang/diagnostics/LexerDiags.h ./generated/slang/diagnostics/LexerDiags.h
--- ./generated/slang/diagnostics/LexerDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/LexerDiags.h	2021-03-02 17:50:53.971602450 -0800
@@ -0,0 +1,37 @@
+//------------------------------------------------------------------------------
+//! @file LexerDiags.h
+//! @brief Generated diagnostic enums for the Lexer subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode NonPrintableChar(DiagSubsystem::Lexer, 0);
+inline constexpr DiagCode UTF8Char(DiagSubsystem::Lexer, 1);
+inline constexpr DiagCode UnicodeBOM(DiagSubsystem::Lexer, 2);
+inline constexpr DiagCode EmbeddedNull(DiagSubsystem::Lexer, 3);
+inline constexpr DiagCode MisplacedDirectiveChar(DiagSubsystem::Lexer, 4);
+inline constexpr DiagCode EscapedWhitespace(DiagSubsystem::Lexer, 5);
+inline constexpr DiagCode ExpectedClosingQuote(DiagSubsystem::Lexer, 6);
+inline constexpr DiagCode UnterminatedBlockComment(DiagSubsystem::Lexer, 7);
+inline constexpr DiagCode NestedBlockComment(DiagSubsystem::Lexer, 8);
+inline constexpr DiagCode ExpectedIntegerBaseAfterSigned(DiagSubsystem::Lexer, 9);
+inline constexpr DiagCode MissingFractionalDigits(DiagSubsystem::Lexer, 10);
+inline constexpr DiagCode OctalEscapeCodeTooBig(DiagSubsystem::Lexer, 11);
+inline constexpr DiagCode InvalidHexEscapeCode(DiagSubsystem::Lexer, 12);
+inline constexpr DiagCode MissingExponentDigits(DiagSubsystem::Lexer, 13);
+inline constexpr DiagCode DigitsLeadingUnderscore(DiagSubsystem::Lexer, 14);
+inline constexpr DiagCode DecimalDigitMultipleUnknown(DiagSubsystem::Lexer, 15);
+inline constexpr DiagCode BadBinaryDigit(DiagSubsystem::Lexer, 16);
+inline constexpr DiagCode BadOctalDigit(DiagSubsystem::Lexer, 17);
+inline constexpr DiagCode BadDecimalDigit(DiagSubsystem::Lexer, 18);
+inline constexpr DiagCode BadHexDigit(DiagSubsystem::Lexer, 19);
+inline constexpr DiagCode TooManyLexerErrors(DiagSubsystem::Lexer, 20);
+inline constexpr DiagCode UnknownEscapeCode(DiagSubsystem::Lexer, 21);
+inline constexpr DiagCode NonstandardEscapeCode(DiagSubsystem::Lexer, 22);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./generated/slang/diagnostics/LookupDiags.h ./generated/slang/diagnostics/LookupDiags.h
--- ./generated/slang/diagnostics/LookupDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/LookupDiags.h	2021-03-02 17:50:53.971602450 -0800
@@ -0,0 +1,70 @@
+//------------------------------------------------------------------------------
+//! @file LookupDiags.h
+//! @brief Generated diagnostic enums for the Lookup subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode Redefinition(DiagSubsystem::Lookup, 0);
+inline constexpr DiagCode RedefinitionDifferentType(DiagSubsystem::Lookup, 1);
+inline constexpr DiagCode RedefinitionDifferentSymbolKind(DiagSubsystem::Lookup, 2);
+inline constexpr DiagCode AmbiguousWildcardImport(DiagSubsystem::Lookup, 3);
+inline constexpr DiagCode NoteImportedFrom(DiagSubsystem::Lookup, 4);
+inline constexpr DiagCode NoteHierarchicalNameInCE(DiagSubsystem::Lookup, 5);
+inline constexpr DiagCode ImportNameCollision(DiagSubsystem::Lookup, 6);
+inline constexpr DiagCode UndeclaredIdentifier(DiagSubsystem::Lookup, 7);
+inline constexpr DiagCode TypoIdentifier(DiagSubsystem::Lookup, 8);
+inline constexpr DiagCode UnknownSystemName(DiagSubsystem::Lookup, 9);
+inline constexpr DiagCode UnknownClassOrPackage(DiagSubsystem::Lookup, 10);
+inline constexpr DiagCode UsedBeforeDeclared(DiagSubsystem::Lookup, 11);
+inline constexpr DiagCode NotAType(DiagSubsystem::Lookup, 12);
+inline constexpr DiagCode NotAValue(DiagSubsystem::Lookup, 13);
+inline constexpr DiagCode NotAHierarchicalScope(DiagSubsystem::Lookup, 14);
+inline constexpr DiagCode NotAModport(DiagSubsystem::Lookup, 15);
+inline constexpr DiagCode NotAnInterface(DiagSubsystem::Lookup, 16);
+inline constexpr DiagCode NotAGenvar(DiagSubsystem::Lookup, 17);
+inline constexpr DiagCode NotAClass(DiagSubsystem::Lookup, 18);
+inline constexpr DiagCode NotAGenericClass(DiagSubsystem::Lookup, 19);
+inline constexpr DiagCode NotASubroutine(DiagSubsystem::Lookup, 20);
+inline constexpr DiagCode DotOnType(DiagSubsystem::Lookup, 21);
+inline constexpr DiagCode HierarchicalNotAllowedInConstant(DiagSubsystem::Lookup, 22);
+inline constexpr DiagCode UnknownMember(DiagSubsystem::Lookup, 23);
+inline constexpr DiagCode UnknownPackageMember(DiagSubsystem::Lookup, 24);
+inline constexpr DiagCode UnknownClassMember(DiagSubsystem::Lookup, 25);
+inline constexpr DiagCode UnknownUnitMember(DiagSubsystem::Lookup, 26);
+inline constexpr DiagCode RecursiveDefinition(DiagSubsystem::Lookup, 27);
+inline constexpr DiagCode UnknownSystemMethod(DiagSubsystem::Lookup, 28);
+inline constexpr DiagCode ScopeNotIndexable(DiagSubsystem::Lookup, 29);
+inline constexpr DiagCode InvalidScopeIndexExpression(DiagSubsystem::Lookup, 30);
+inline constexpr DiagCode ScopeIndexOutOfRange(DiagSubsystem::Lookup, 31);
+inline constexpr DiagCode CouldNotResolveHierarchicalPath(DiagSubsystem::Lookup, 32);
+inline constexpr DiagCode UnresolvedForwardTypedef(DiagSubsystem::Lookup, 33);
+inline constexpr DiagCode DefinitionUsedAsType(DiagSubsystem::Lookup, 34);
+inline constexpr DiagCode DefinitionUsedAsValue(DiagSubsystem::Lookup, 35);
+inline constexpr DiagCode AutoVariableHierarchical(DiagSubsystem::Lookup, 36);
+inline constexpr DiagCode NonStaticClassProperty(DiagSubsystem::Lookup, 37);
+inline constexpr DiagCode NonStaticClassMethod(DiagSubsystem::Lookup, 38);
+inline constexpr DiagCode NestedNonStaticClassProperty(DiagSubsystem::Lookup, 39);
+inline constexpr DiagCode NestedNonStaticClassMethod(DiagSubsystem::Lookup, 40);
+inline constexpr DiagCode NoDefaultSpecialization(DiagSubsystem::Lookup, 41);
+inline constexpr DiagCode GenericClassScopeResolution(DiagSubsystem::Lookup, 42);
+inline constexpr DiagCode InvalidThisHandle(DiagSubsystem::Lookup, 43);
+inline constexpr DiagCode LocalMemberAccess(DiagSubsystem::Lookup, 44);
+inline constexpr DiagCode ProtectedMemberAccess(DiagSubsystem::Lookup, 45);
+inline constexpr DiagCode InvalidConstructorAccess(DiagSubsystem::Lookup, 46);
+inline constexpr DiagCode SuperOutsideClass(DiagSubsystem::Lookup, 47);
+inline constexpr DiagCode SuperNoBase(DiagSubsystem::Lookup, 48);
+inline constexpr DiagCode IfaceExtendTypeParam(DiagSubsystem::Lookup, 49);
+inline constexpr DiagCode IfaceExtendIncomplete(DiagSubsystem::Lookup, 50);
+inline constexpr DiagCode ScopeIncompleteTypedef(DiagSubsystem::Lookup, 51);
+inline constexpr DiagCode InvalidModportAccess(DiagSubsystem::Lookup, 52);
+inline constexpr DiagCode LocalNotAllowed(DiagSubsystem::Lookup, 53);
+inline constexpr DiagCode UnexpectedSelection(DiagSubsystem::Lookup, 54);
+inline constexpr DiagCode DuplicateImport(DiagSubsystem::Lookup, 55);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./generated/slang/diagnostics/MetaDiags.h ./generated/slang/diagnostics/MetaDiags.h
--- ./generated/slang/diagnostics/MetaDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/MetaDiags.h	2021-03-02 17:50:53.971602450 -0800
@@ -0,0 +1,16 @@
+//------------------------------------------------------------------------------
+//! @file MetaDiags.h
+//! @brief Generated diagnostic enums for the Meta subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode TooManyErrors(DiagSubsystem::Meta, 0);
+inline constexpr DiagCode UnknownWarningOption(DiagSubsystem::Meta, 1);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./generated/slang/diagnostics/NumericDiags.h ./generated/slang/diagnostics/NumericDiags.h
--- ./generated/slang/diagnostics/NumericDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/NumericDiags.h	2021-03-02 17:50:53.971602450 -0800
@@ -0,0 +1,26 @@
+//------------------------------------------------------------------------------
+//! @file NumericDiags.h
+//! @brief Generated diagnostic enums for the Numeric subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode LiteralSizeIsZero(DiagSubsystem::Numeric, 0);
+inline constexpr DiagCode LiteralSizeTooLarge(DiagSubsystem::Numeric, 1);
+inline constexpr DiagCode SignedIntegerOverflow(DiagSubsystem::Numeric, 2);
+inline constexpr DiagCode ValueMustBeIntegral(DiagSubsystem::Numeric, 3);
+inline constexpr DiagCode ValueMustNotBeUnknown(DiagSubsystem::Numeric, 4);
+inline constexpr DiagCode ValueMustBePositive(DiagSubsystem::Numeric, 5);
+inline constexpr DiagCode ValueExceedsMaxBitWidth(DiagSubsystem::Numeric, 6);
+inline constexpr DiagCode ValueOutOfRange(DiagSubsystem::Numeric, 7);
+inline constexpr DiagCode ExpectedVectorDigits(DiagSubsystem::Numeric, 8);
+inline constexpr DiagCode RealLiteralUnderflow(DiagSubsystem::Numeric, 9);
+inline constexpr DiagCode RealLiteralOverflow(DiagSubsystem::Numeric, 10);
+inline constexpr DiagCode VectorLiteralOverflow(DiagSubsystem::Numeric, 11);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./generated/slang/diagnostics/ParserDiags.h ./generated/slang/diagnostics/ParserDiags.h
--- ./generated/slang/diagnostics/ParserDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/ParserDiags.h	2021-03-02 17:50:53.971602450 -0800
@@ -0,0 +1,127 @@
+//------------------------------------------------------------------------------
+//! @file ParserDiags.h
+//! @brief Generated diagnostic enums for the Parser subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode ExpectedIdentifier(DiagSubsystem::Parser, 0);
+inline constexpr DiagCode ExpectedStringLiteral(DiagSubsystem::Parser, 1);
+inline constexpr DiagCode ExpectedIntegerLiteral(DiagSubsystem::Parser, 2);
+inline constexpr DiagCode ExpectedToken(DiagSubsystem::Parser, 3);
+inline constexpr DiagCode MisplacedTrailingSeparator(DiagSubsystem::Parser, 4);
+inline constexpr DiagCode ImplicitNotAllowed(DiagSubsystem::Parser, 5);
+inline constexpr DiagCode InvalidAccessDotColon(DiagSubsystem::Parser, 6);
+inline constexpr DiagCode ExpectedMember(DiagSubsystem::Parser, 7);
+inline constexpr DiagCode ExpectedStatement(DiagSubsystem::Parser, 8);
+inline constexpr DiagCode ExpectedParameterPort(DiagSubsystem::Parser, 9);
+inline constexpr DiagCode ExpectedNonAnsiPort(DiagSubsystem::Parser, 10);
+inline constexpr DiagCode ExpectedAnsiPort(DiagSubsystem::Parser, 11);
+inline constexpr DiagCode ExpectedModportPort(DiagSubsystem::Parser, 12);
+inline constexpr DiagCode ExpectedFunctionPort(DiagSubsystem::Parser, 13);
+inline constexpr DiagCode ExpectedAssertionItemPort(DiagSubsystem::Parser, 14);
+inline constexpr DiagCode ExpectedForInitializer(DiagSubsystem::Parser, 15);
+inline constexpr DiagCode ExpectedOpenRangeElement(DiagSubsystem::Parser, 16);
+inline constexpr DiagCode ExpectedStreamExpression(DiagSubsystem::Parser, 17);
+inline constexpr DiagCode ExpectedArgument(DiagSubsystem::Parser, 18);
+inline constexpr DiagCode ExpectedDeclarator(DiagSubsystem::Parser, 19);
+inline constexpr DiagCode ExpectedConditionalPattern(DiagSubsystem::Parser, 20);
+inline constexpr DiagCode ExpectedAttribute(DiagSubsystem::Parser, 21);
+inline constexpr DiagCode ExpectedPackageImport(DiagSubsystem::Parser, 22);
+inline constexpr DiagCode ExpectedHierarchicalInstantiation(DiagSubsystem::Parser, 23);
+inline constexpr DiagCode ExpectedGateInstance(DiagSubsystem::Parser, 24);
+inline constexpr DiagCode ExpectedPortConnection(DiagSubsystem::Parser, 25);
+inline constexpr DiagCode ExpectedVariableAssignment(DiagSubsystem::Parser, 26);
+inline constexpr DiagCode ExpectedContinuousAssignment(DiagSubsystem::Parser, 27);
+inline constexpr DiagCode ExpectedInterfaceClassName(DiagSubsystem::Parser, 28);
+inline constexpr DiagCode ExpectedAssignmentKey(DiagSubsystem::Parser, 29);
+inline constexpr DiagCode ExpectedDistItem(DiagSubsystem::Parser, 30);
+inline constexpr DiagCode ExpectedIfOrCase(DiagSubsystem::Parser, 31);
+inline constexpr DiagCode ExpectedNetStrength(DiagSubsystem::Parser, 32);
+inline constexpr DiagCode ExpectedEnumBase(DiagSubsystem::Parser, 33);
+inline constexpr DiagCode ExpectedCaseItem(DiagSubsystem::Parser, 34);
+inline constexpr DiagCode ExpectedSubroutineName(DiagSubsystem::Parser, 35);
+inline constexpr DiagCode ExpectedConstraintName(DiagSubsystem::Parser, 36);
+inline constexpr DiagCode ExpectedUdpPort(DiagSubsystem::Parser, 37);
+inline constexpr DiagCode ExpectedUdpEntry(DiagSubsystem::Parser, 38);
+inline constexpr DiagCode ExpectedPathName(DiagSubsystem::Parser, 39);
+inline constexpr DiagCode ExpectedPathOp(DiagSubsystem::Parser, 40);
+inline constexpr DiagCode ExpectedEdgeDescriptor(DiagSubsystem::Parser, 41);
+inline constexpr DiagCode NoLabelOnSemicolon(DiagSubsystem::Parser, 42);
+inline constexpr DiagCode DeferredDelayMustBeZero(DiagSubsystem::Parser, 43);
+inline constexpr DiagCode InvalidGenvarIterExpression(DiagSubsystem::Parser, 44);
+inline constexpr DiagCode ExpectedGenvarIterVar(DiagSubsystem::Parser, 45);
+inline constexpr DiagCode ConstFunctionPortRequiresRef(DiagSubsystem::Parser, 46);
+inline constexpr DiagCode ExpectedClockingSkew(DiagSubsystem::Parser, 47);
+inline constexpr DiagCode InOutDefaultSkew(DiagSubsystem::Parser, 48);
+inline constexpr DiagCode GlobalClockingEmpty(DiagSubsystem::Parser, 49);
+inline constexpr DiagCode ExpectedDPISpecString(DiagSubsystem::Parser, 50);
+inline constexpr DiagCode ParseTreeTooDeep(DiagSubsystem::Parser, 51);
+inline constexpr DiagCode MissingModportPortDirection(DiagSubsystem::Parser, 52);
+inline constexpr DiagCode CaseStatementEmpty(DiagSubsystem::Parser, 53);
+inline constexpr DiagCode MultipleDefaultCases(DiagSubsystem::Parser, 54);
+inline constexpr DiagCode DirectionOnInterfacePort(DiagSubsystem::Parser, 55);
+inline constexpr DiagCode UnexpectedQualifiers(DiagSubsystem::Parser, 56);
+inline constexpr DiagCode ExpectedSampleKeyword(DiagSubsystem::Parser, 57);
+inline constexpr DiagCode MultipleGenerateDefaultCases(DiagSubsystem::Parser, 58);
+inline constexpr DiagCode CaseGenerateEmpty(DiagSubsystem::Parser, 59);
+inline constexpr DiagCode LabelAndName(DiagSubsystem::Parser, 60);
+inline constexpr DiagCode EndNameMismatch(DiagSubsystem::Parser, 61);
+inline constexpr DiagCode EndNameNotEmpty(DiagSubsystem::Parser, 62);
+inline constexpr DiagCode DeclarationsAtStart(DiagSubsystem::Parser, 63);
+inline constexpr DiagCode VoidNotAllowed(DiagSubsystem::Parser, 64);
+inline constexpr DiagCode DuplicateDeclModifier(DiagSubsystem::Parser, 65);
+inline constexpr DiagCode DeclModifierOrdering(DiagSubsystem::Parser, 66);
+inline constexpr DiagCode DeclModifierConflict(DiagSubsystem::Parser, 67);
+inline constexpr DiagCode DuplicateQualifier(DiagSubsystem::Parser, 68);
+inline constexpr DiagCode QualifierConflict(DiagSubsystem::Parser, 69);
+inline constexpr DiagCode QualifierNotFirst(DiagSubsystem::Parser, 70);
+inline constexpr DiagCode PureRequiresVirtual(DiagSubsystem::Parser, 71);
+inline constexpr DiagCode InvalidMethodQualifier(DiagSubsystem::Parser, 72);
+inline constexpr DiagCode InvalidPropertyQualifier(DiagSubsystem::Parser, 73);
+inline constexpr DiagCode InvalidConstraintQualifier(DiagSubsystem::Parser, 74);
+inline constexpr DiagCode InvalidQualifierForMember(DiagSubsystem::Parser, 75);
+inline constexpr DiagCode InvalidQualifierForIfaceMember(DiagSubsystem::Parser, 76);
+inline constexpr DiagCode InvalidQualifierForConstructor(DiagSubsystem::Parser, 77);
+inline constexpr DiagCode MethodStaticLifetime(DiagSubsystem::Parser, 78);
+inline constexpr DiagCode TypeRefDeclVar(DiagSubsystem::Parser, 79);
+inline constexpr DiagCode ScopedClassCopy(DiagSubsystem::Parser, 80);
+inline constexpr DiagCode NotAllowedInCU(DiagSubsystem::Parser, 81);
+inline constexpr DiagCode NotAllowedInGenerate(DiagSubsystem::Parser, 82);
+inline constexpr DiagCode NotAllowedInModule(DiagSubsystem::Parser, 83);
+inline constexpr DiagCode NotAllowedInInterface(DiagSubsystem::Parser, 84);
+inline constexpr DiagCode NotAllowedInProgram(DiagSubsystem::Parser, 85);
+inline constexpr DiagCode NotAllowedInPackage(DiagSubsystem::Parser, 86);
+inline constexpr DiagCode NotAllowedInClocking(DiagSubsystem::Parser, 87);
+inline constexpr DiagCode NotAllowedInClass(DiagSubsystem::Parser, 88);
+inline constexpr DiagCode NotAllowedInIfaceClass(DiagSubsystem::Parser, 89);
+inline constexpr DiagCode TaskReturnType(DiagSubsystem::Parser, 90);
+inline constexpr DiagCode TaskConstructor(DiagSubsystem::Parser, 91);
+inline constexpr DiagCode ConstructorReturnType(DiagSubsystem::Parser, 92);
+inline constexpr DiagCode NewKeywordQualified(DiagSubsystem::Parser, 93);
+inline constexpr DiagCode SubroutinePrototypeScoped(DiagSubsystem::Parser, 94);
+inline constexpr DiagCode QualifiersOnOutOfBlock(DiagSubsystem::Parser, 95);
+inline constexpr DiagCode ConstraintQualOutOfBlock(DiagSubsystem::Parser, 96);
+inline constexpr DiagCode ConstructorOutsideClass(DiagSubsystem::Parser, 97);
+inline constexpr DiagCode InvalidSuperNew(DiagSubsystem::Parser, 98);
+inline constexpr DiagCode IfaceMethodPure(DiagSubsystem::Parser, 99);
+inline constexpr DiagCode NestedIface(DiagSubsystem::Parser, 100);
+inline constexpr DiagCode RegAfterNettype(DiagSubsystem::Parser, 101);
+inline constexpr DiagCode ChargeWithTriReg(DiagSubsystem::Parser, 102);
+inline constexpr DiagCode InitializerRequired(DiagSubsystem::Parser, 103);
+inline constexpr DiagCode DriveStrengthInvalid(DiagSubsystem::Parser, 104);
+inline constexpr DiagCode DriveStrengthHighZ(DiagSubsystem::Parser, 105);
+inline constexpr DiagCode RandOnPackedMember(DiagSubsystem::Parser, 106);
+inline constexpr DiagCode RandOnUnionMember(DiagSubsystem::Parser, 107);
+inline constexpr DiagCode SolveBeforeDisallowed(DiagSubsystem::Parser, 108);
+inline constexpr DiagCode LifetimeForPrototype(DiagSubsystem::Parser, 109);
+inline constexpr DiagCode NonStandardGenBlock(DiagSubsystem::Parser, 110);
+inline constexpr DiagCode EmptyAssignmentPattern(DiagSubsystem::Parser, 111);
+inline constexpr DiagCode NoteToMatchThis(DiagSubsystem::Parser, 112);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./generated/slang/diagnostics/PreprocessorDiags.h ./generated/slang/diagnostics/PreprocessorDiags.h
--- ./generated/slang/diagnostics/PreprocessorDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/PreprocessorDiags.h	2021-03-02 17:50:53.971602450 -0800
@@ -0,0 +1,48 @@
+//------------------------------------------------------------------------------
+//! @file PreprocessorDiags.h
+//! @brief Generated diagnostic enums for the Preprocessor subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode CouldNotOpenIncludeFile(DiagSubsystem::Preprocessor, 0);
+inline constexpr DiagCode ExceededMaxIncludeDepth(DiagSubsystem::Preprocessor, 1);
+inline constexpr DiagCode UnknownDirective(DiagSubsystem::Preprocessor, 2);
+inline constexpr DiagCode UnexpectedConditionalDirective(DiagSubsystem::Preprocessor, 3);
+inline constexpr DiagCode MissingEndIfDirective(DiagSubsystem::Preprocessor, 4);
+inline constexpr DiagCode UnbalancedMacroArgDims(DiagSubsystem::Preprocessor, 5);
+inline constexpr DiagCode ExpectedMacroArgs(DiagSubsystem::Preprocessor, 6);
+inline constexpr DiagCode ExpectedNetType(DiagSubsystem::Preprocessor, 7);
+inline constexpr DiagCode ExpectedDriveStrength(DiagSubsystem::Preprocessor, 8);
+inline constexpr DiagCode InvalidMacroName(DiagSubsystem::Preprocessor, 9);
+inline constexpr DiagCode TooManyActualMacroArgs(DiagSubsystem::Preprocessor, 10);
+inline constexpr DiagCode NotEnoughMacroArgs(DiagSubsystem::Preprocessor, 11);
+inline constexpr DiagCode InvalidLineDirectiveLevel(DiagSubsystem::Preprocessor, 12);
+inline constexpr DiagCode UndefineBuiltinDirective(DiagSubsystem::Preprocessor, 13);
+inline constexpr DiagCode UnrecognizedKeywordVersion(DiagSubsystem::Preprocessor, 14);
+inline constexpr DiagCode MismatchedEndKeywordsDirective(DiagSubsystem::Preprocessor, 15);
+inline constexpr DiagCode InvalidTimeScaleSpecifier(DiagSubsystem::Preprocessor, 16);
+inline constexpr DiagCode InvalidTimeScalePrecision(DiagSubsystem::Preprocessor, 17);
+inline constexpr DiagCode RecursiveMacro(DiagSubsystem::Preprocessor, 18);
+inline constexpr DiagCode MacroOpsOutsideDefinition(DiagSubsystem::Preprocessor, 19);
+inline constexpr DiagCode SplitBlockCommentInDirective(DiagSubsystem::Preprocessor, 20);
+inline constexpr DiagCode ExpectedIncludeFileName(DiagSubsystem::Preprocessor, 21);
+inline constexpr DiagCode ExpectedTimeLiteral(DiagSubsystem::Preprocessor, 22);
+inline constexpr DiagCode ExpectedMacroStringifyEnd(DiagSubsystem::Preprocessor, 23);
+inline constexpr DiagCode ExpectedPragmaName(DiagSubsystem::Preprocessor, 24);
+inline constexpr DiagCode ExpectedPragmaExpression(DiagSubsystem::Preprocessor, 25);
+inline constexpr DiagCode DirectiveInsideDesignElement(DiagSubsystem::Preprocessor, 26);
+inline constexpr DiagCode IgnoredMacroPaste(DiagSubsystem::Preprocessor, 27);
+inline constexpr DiagCode RedefiningMacro(DiagSubsystem::Preprocessor, 28);
+inline constexpr DiagCode UnknownPragma(DiagSubsystem::Preprocessor, 29);
+inline constexpr DiagCode ExtraPragmaArgs(DiagSubsystem::Preprocessor, 30);
+inline constexpr DiagCode ExpectedDiagPragmaArg(DiagSubsystem::Preprocessor, 31);
+inline constexpr DiagCode UnknownDiagPragmaArg(DiagSubsystem::Preprocessor, 32);
+inline constexpr DiagCode ExpectedDiagPragmaLevel(DiagSubsystem::Preprocessor, 33);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./generated/slang/diagnostics/StatementsDiags.h ./generated/slang/diagnostics/StatementsDiags.h
--- ./generated/slang/diagnostics/StatementsDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/StatementsDiags.h	2021-03-02 17:50:53.971602450 -0800
@@ -0,0 +1,55 @@
+//------------------------------------------------------------------------------
+//! @file StatementsDiags.h
+//! @brief Generated diagnostic enums for the Statements subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode ReturnNotInSubroutine(DiagSubsystem::Statements, 0);
+inline constexpr DiagCode ReturnInParallel(DiagSubsystem::Statements, 1);
+inline constexpr DiagCode DelayNotNumeric(DiagSubsystem::Statements, 2);
+inline constexpr DiagCode InvalidEventExpression(DiagSubsystem::Statements, 3);
+inline constexpr DiagCode CoverStmtNoFail(DiagSubsystem::Statements, 4);
+inline constexpr DiagCode StatementNotInLoop(DiagSubsystem::Statements, 5);
+inline constexpr DiagCode ExprNotStatement(DiagSubsystem::Statements, 6);
+inline constexpr DiagCode ExprNotConstraint(DiagSubsystem::Statements, 7);
+inline constexpr DiagCode VoidCastFuncCall(DiagSubsystem::Statements, 8);
+inline constexpr DiagCode NotAnArray(DiagSubsystem::Statements, 9);
+inline constexpr DiagCode TooManyForeachVars(DiagSubsystem::Statements, 10);
+inline constexpr DiagCode ForeachDynamicDimAfterSkipped(DiagSubsystem::Statements, 11);
+inline constexpr DiagCode LoopVarShadowsArray(DiagSubsystem::Statements, 12);
+inline constexpr DiagCode ForeachWildcardIndex(DiagSubsystem::Statements, 13);
+inline constexpr DiagCode CaseInsideKeyword(DiagSubsystem::Statements, 14);
+inline constexpr DiagCode InvalidDisableTarget(DiagSubsystem::Statements, 15);
+inline constexpr DiagCode NotAnEvent(DiagSubsystem::Statements, 16);
+inline constexpr DiagCode RepeatNotNumeric(DiagSubsystem::Statements, 17);
+inline constexpr DiagCode RepeatControlNotEvent(DiagSubsystem::Statements, 18);
+inline constexpr DiagCode UnexpectedPortDecl(DiagSubsystem::Statements, 19);
+inline constexpr DiagCode NonIntegralConstraintExpr(DiagSubsystem::Statements, 20);
+inline constexpr DiagCode NonIntegralConstraintLiteral(DiagSubsystem::Statements, 21);
+inline constexpr DiagCode UnknownConstraintLiteral(DiagSubsystem::Statements, 22);
+inline constexpr DiagCode RandCInDist(DiagSubsystem::Statements, 23);
+inline constexpr DiagCode RandCInUnique(DiagSubsystem::Statements, 24);
+inline constexpr DiagCode RandCInSolveBefore(DiagSubsystem::Statements, 25);
+inline constexpr DiagCode RandCInSoft(DiagSubsystem::Statements, 26);
+inline constexpr DiagCode RandNeededInDist(DiagSubsystem::Statements, 27);
+inline constexpr DiagCode InvalidUniquenessExpr(DiagSubsystem::Statements, 28);
+inline constexpr DiagCode InequivalentUniquenessTypes(DiagSubsystem::Statements, 29);
+inline constexpr DiagCode TaskInConstraint(DiagSubsystem::Statements, 30);
+inline constexpr DiagCode OutRefFuncConstraint(DiagSubsystem::Statements, 31);
+inline constexpr DiagCode BadDisableSoft(DiagSubsystem::Statements, 32);
+inline constexpr DiagCode BadSolveBefore(DiagSubsystem::Statements, 33);
+inline constexpr DiagCode BadProceduralAssign(DiagSubsystem::Statements, 34);
+inline constexpr DiagCode BadProceduralForce(DiagSubsystem::Statements, 35);
+inline constexpr DiagCode BadForceNetType(DiagSubsystem::Statements, 36);
+inline constexpr DiagCode EventExpressionConstant(DiagSubsystem::Statements, 37);
+inline constexpr DiagCode EmptyStatement(DiagSubsystem::Statements, 38);
+inline constexpr DiagCode PointlessVoidCast(DiagSubsystem::Statements, 39);
+inline constexpr DiagCode UnusedResult(DiagSubsystem::Statements, 40);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./generated/slang/diagnostics/SysFuncsDiags.h ./generated/slang/diagnostics/SysFuncsDiags.h
--- ./generated/slang/diagnostics/SysFuncsDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/SysFuncsDiags.h	2021-03-02 17:50:53.981602243 -0800
@@ -0,0 +1,45 @@
+//------------------------------------------------------------------------------
+//! @file SysFuncsDiags.h
+//! @brief Generated diagnostic enums for the SysFuncs subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode BadSystemSubroutineArg(DiagSubsystem::SysFuncs, 0);
+inline constexpr DiagCode UnknownFormatSpecifier(DiagSubsystem::SysFuncs, 1);
+inline constexpr DiagCode FormatSpecifierWidthNotAllowed(DiagSubsystem::SysFuncs, 2);
+inline constexpr DiagCode FormatSpecifierInvalidWidth(DiagSubsystem::SysFuncs, 3);
+inline constexpr DiagCode FormatSpecifierNotFloat(DiagSubsystem::SysFuncs, 4);
+inline constexpr DiagCode FormatUnspecifiedType(DiagSubsystem::SysFuncs, 5);
+inline constexpr DiagCode FormatMismatchedType(DiagSubsystem::SysFuncs, 6);
+inline constexpr DiagCode FormatNoArgument(DiagSubsystem::SysFuncs, 7);
+inline constexpr DiagCode FormatEmptyArg(DiagSubsystem::SysFuncs, 8);
+inline constexpr DiagCode FormatTooManyArgs(DiagSubsystem::SysFuncs, 9);
+inline constexpr DiagCode InvalidStringArg(DiagSubsystem::SysFuncs, 10);
+inline constexpr DiagCode ArrayMethodIntegral(DiagSubsystem::SysFuncs, 11);
+inline constexpr DiagCode ArrayMethodComparable(DiagSubsystem::SysFuncs, 12);
+inline constexpr DiagCode SysFuncNotConst(DiagSubsystem::SysFuncs, 13);
+inline constexpr DiagCode QueryOnDynamicType(DiagSubsystem::SysFuncs, 14);
+inline constexpr DiagCode DimensionIndexInvalid(DiagSubsystem::SysFuncs, 15);
+inline constexpr DiagCode DynamicDimensionIndex(DiagSubsystem::SysFuncs, 16);
+inline constexpr DiagCode QueryOnAssociativeNonIntegral(DiagSubsystem::SysFuncs, 17);
+inline constexpr DiagCode QueryOnAssociativeWildcard(DiagSubsystem::SysFuncs, 18);
+inline constexpr DiagCode AssociativeWildcardNotAllowed(DiagSubsystem::SysFuncs, 19);
+inline constexpr DiagCode ExpectedModuleName(DiagSubsystem::SysFuncs, 20);
+inline constexpr DiagCode ExpectedModOrVarName(DiagSubsystem::SysFuncs, 21);
+inline constexpr DiagCode ExpectedScopeOrAssert(DiagSubsystem::SysFuncs, 22);
+inline constexpr DiagCode ExpectedClassPropertyName(DiagSubsystem::SysFuncs, 23);
+inline constexpr DiagCode ExpectedVariableName(DiagSubsystem::SysFuncs, 24);
+inline constexpr DiagCode ExpectedModuleInstance(DiagSubsystem::SysFuncs, 25);
+inline constexpr DiagCode CastArgSingular(DiagSubsystem::SysFuncs, 26);
+inline constexpr DiagCode ArrayLocatorWithClause(DiagSubsystem::SysFuncs, 27);
+inline constexpr DiagCode FormatRealInt(DiagSubsystem::SysFuncs, 28);
+inline constexpr DiagCode BadFinishNum(DiagSubsystem::SysFuncs, 29);
+inline constexpr DiagCode MissingFormatSpecifier(DiagSubsystem::SysFuncs, 30);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./generated/slang/diagnostics/TypesDiags.h ./generated/slang/diagnostics/TypesDiags.h
--- ./generated/slang/diagnostics/TypesDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/TypesDiags.h	2021-03-02 17:50:53.981602243 -0800
@@ -0,0 +1,36 @@
+//------------------------------------------------------------------------------
+//! @file TypesDiags.h
+//! @brief Generated diagnostic enums for the Types subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode InvalidEnumBase(DiagSubsystem::Types, 0);
+inline constexpr DiagCode EnumValueOverflow(DiagSubsystem::Types, 1);
+inline constexpr DiagCode EnumIncrementUnknown(DiagSubsystem::Types, 2);
+inline constexpr DiagCode EnumValueDuplicate(DiagSubsystem::Types, 3);
+inline constexpr DiagCode EnumValueUnknownBits(DiagSubsystem::Types, 4);
+inline constexpr DiagCode EnumValueOutOfRange(DiagSubsystem::Types, 5);
+inline constexpr DiagCode EnumRangeMultiDimensional(DiagSubsystem::Types, 6);
+inline constexpr DiagCode ForwardTypedefDoesNotMatch(DiagSubsystem::Types, 7);
+inline constexpr DiagCode ForwardTypedefVisibility(DiagSubsystem::Types, 8);
+inline constexpr DiagCode PackedMemberNotIntegral(DiagSubsystem::Types, 9);
+inline constexpr DiagCode PackedMemberHasInitializer(DiagSubsystem::Types, 10);
+inline constexpr DiagCode PackedDimsOnPredefinedType(DiagSubsystem::Types, 11);
+inline constexpr DiagCode PackedDimsOnUnpacked(DiagSubsystem::Types, 12);
+inline constexpr DiagCode PackedUnionWidthMismatch(DiagSubsystem::Types, 13);
+inline constexpr DiagCode InvalidArraySize(DiagSubsystem::Types, 14);
+inline constexpr DiagCode CannotDeclareType(DiagSubsystem::Types, 15);
+inline constexpr DiagCode InvalidAssociativeIndexType(DiagSubsystem::Types, 16);
+inline constexpr DiagCode PackedArrayNotIntegral(DiagSubsystem::Types, 17);
+inline constexpr DiagCode PackedArrayTooLarge(DiagSubsystem::Types, 18);
+inline constexpr DiagCode ArrayDimTooLarge(DiagSubsystem::Types, 19);
+inline constexpr DiagCode UnpackedSigned(DiagSubsystem::Types, 20);
+inline constexpr DiagCode InvalidUnionMember(DiagSubsystem::Types, 21);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./generated/slang/syntax/AllSyntax.h ./generated/slang/syntax/AllSyntax.h
--- ./generated/slang/syntax/AllSyntax.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/syntax/AllSyntax.h	2021-03-02 17:51:09.111286812 -0800
@@ -0,0 +1,8096 @@
+//------------------------------------------------------------------------------
+//! @file AllSyntax.h
+//! @brief All generated syntax node data structures
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/parsing/Token.h"
+#include "slang/syntax/SyntaxNode.h"
+#include "slang/util/BumpAllocator.h"
+
+// This file contains all parse tree syntax nodes.
+// It is auto-generated by the syntax_gen.py script under the scripts/ directory.
+
+namespace slang {
+
+struct ExpressionSyntax : public SyntaxNode {
+
+    ExpressionSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit ExpressionSyntax(const ExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct DataTypeSyntax : public ExpressionSyntax {
+
+    DataTypeSyntax(SyntaxKind kind) :
+        ExpressionSyntax(kind) {
+    }
+
+    explicit DataTypeSyntax(const DataTypeSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+// ----- ATTRIBUTES -----
+
+struct EqualsValueClauseSyntax : public SyntaxNode {
+    Token equals;
+    not_null<ExpressionSyntax*> expr;
+
+    EqualsValueClauseSyntax(Token equals, ExpressionSyntax& expr) :
+        SyntaxNode(SyntaxKind::EqualsValueClause), equals(equals), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    explicit EqualsValueClauseSyntax(const EqualsValueClauseSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EqualsValueClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct AttributeSpecSyntax : public SyntaxNode {
+    Token name;
+    EqualsValueClauseSyntax* value;
+
+    AttributeSpecSyntax(Token name, EqualsValueClauseSyntax* value) :
+        SyntaxNode(SyntaxKind::AttributeSpec), name(name), value(value) {
+        if (this->value) this->value->parent = this;
+    }
+
+    explicit AttributeSpecSyntax(const AttributeSpecSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    AttributeSpecSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct AttributeInstanceSyntax : public SyntaxNode {
+    Token openParen;
+    SeparatedSyntaxList<AttributeSpecSyntax> specs;
+    Token closeParen;
+
+    AttributeInstanceSyntax(Token openParen, const SeparatedSyntaxList<AttributeSpecSyntax>& specs, Token closeParen) :
+        SyntaxNode(SyntaxKind::AttributeInstance), openParen(openParen), specs(specs), closeParen(closeParen) {
+        this->specs.parent = this;
+        for (auto child : this->specs)
+            child->parent = this;
+    }
+
+    explicit AttributeInstanceSyntax(const AttributeInstanceSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    AttributeInstanceSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NamedLabelSyntax : public SyntaxNode {
+    Token name;
+    Token colon;
+
+    NamedLabelSyntax(Token name, Token colon) :
+        SyntaxNode(SyntaxKind::NamedLabel), name(name), colon(colon) {
+    }
+
+    explicit NamedLabelSyntax(const NamedLabelSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NamedLabelSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct StatementSyntax : public SyntaxNode {
+    NamedLabelSyntax* label;
+    SyntaxList<AttributeInstanceSyntax> attributes;
+
+    StatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes) :
+        SyntaxNode(kind), label(label), attributes(attributes) {
+        if (this->label) this->label->parent = this;
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+    }
+
+    explicit StatementSyntax(const StatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    StatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MemberSyntax : public SyntaxNode {
+    SyntaxList<AttributeInstanceSyntax> attributes;
+
+    MemberSyntax(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes) :
+        SyntaxNode(kind), attributes(attributes) {
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+    }
+
+    explicit MemberSyntax(const MemberSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MemberSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- ARGUMENTS -----
+
+struct ArgumentSyntax : public SyntaxNode {
+
+    ArgumentSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit ArgumentSyntax(const ArgumentSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct EmptyArgumentSyntax : public ArgumentSyntax {
+    Token placeholder;
+
+    EmptyArgumentSyntax(Token placeholder) :
+        ArgumentSyntax(SyntaxKind::EmptyArgument), placeholder(placeholder) {
+    }
+
+    explicit EmptyArgumentSyntax(const EmptyArgumentSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EmptyArgumentSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct OrderedArgumentSyntax : public ArgumentSyntax {
+    not_null<ExpressionSyntax*> expr;
+
+    OrderedArgumentSyntax(ExpressionSyntax& expr) :
+        ArgumentSyntax(SyntaxKind::OrderedArgument), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    explicit OrderedArgumentSyntax(const OrderedArgumentSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    OrderedArgumentSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NamedArgumentSyntax : public ArgumentSyntax {
+    Token dot;
+    Token name;
+    Token openParen;
+    ExpressionSyntax* expr;
+    Token closeParen;
+
+    NamedArgumentSyntax(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
+        ArgumentSyntax(SyntaxKind::NamedArgument), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
+        if (this->expr) this->expr->parent = this;
+    }
+
+    explicit NamedArgumentSyntax(const NamedArgumentSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NamedArgumentSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ArgumentListSyntax : public SyntaxNode {
+    Token openParen;
+    SeparatedSyntaxList<ArgumentSyntax> parameters;
+    Token closeParen;
+
+    ArgumentListSyntax(Token openParen, const SeparatedSyntaxList<ArgumentSyntax>& parameters, Token closeParen) :
+        SyntaxNode(SyntaxKind::ArgumentList), openParen(openParen), parameters(parameters), closeParen(closeParen) {
+        this->parameters.parent = this;
+        for (auto child : this->parameters)
+            child->parent = this;
+    }
+
+    explicit ArgumentListSyntax(const ArgumentListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ArgumentListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ParameterValueAssignmentSyntax : public SyntaxNode {
+    Token hash;
+    not_null<ArgumentListSyntax*> assignments;
+
+    ParameterValueAssignmentSyntax(Token hash, ArgumentListSyntax& assignments) :
+        SyntaxNode(SyntaxKind::ParameterValueAssignment), hash(hash), assignments(&assignments) {
+        this->assignments->parent = this;
+    }
+
+    explicit ParameterValueAssignmentSyntax(const ParameterValueAssignmentSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ParameterValueAssignmentSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- PATTERNS -----
+
+struct PatternSyntax : public SyntaxNode {
+
+    PatternSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit PatternSyntax(const PatternSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct VariablePatternSyntax : public PatternSyntax {
+    Token dot;
+    Token variableName;
+
+    VariablePatternSyntax(Token dot, Token variableName) :
+        PatternSyntax(SyntaxKind::VariablePattern), dot(dot), variableName(variableName) {
+    }
+
+    explicit VariablePatternSyntax(const VariablePatternSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    VariablePatternSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct WildcardPatternSyntax : public PatternSyntax {
+    Token dotStar;
+
+    WildcardPatternSyntax(Token dotStar) :
+        PatternSyntax(SyntaxKind::WildcardPattern), dotStar(dotStar) {
+    }
+
+    explicit WildcardPatternSyntax(const WildcardPatternSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WildcardPatternSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ExpressionPatternSyntax : public PatternSyntax {
+    not_null<ExpressionSyntax*> expr;
+
+    ExpressionPatternSyntax(ExpressionSyntax& expr) :
+        PatternSyntax(SyntaxKind::ExpressionPattern), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    explicit ExpressionPatternSyntax(const ExpressionPatternSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ExpressionPatternSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TaggedPatternSyntax : public PatternSyntax {
+    Token tagged;
+    Token memberName;
+    PatternSyntax* pattern;
+
+    TaggedPatternSyntax(Token tagged, Token memberName, PatternSyntax* pattern) :
+        PatternSyntax(SyntaxKind::TaggedPattern), tagged(tagged), memberName(memberName), pattern(pattern) {
+        if (this->pattern) this->pattern->parent = this;
+    }
+
+    explicit TaggedPatternSyntax(const TaggedPatternSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TaggedPatternSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct StructurePatternMemberSyntax : public SyntaxNode {
+
+    StructurePatternMemberSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit StructurePatternMemberSyntax(const StructurePatternMemberSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct OrderedStructurePatternMemberSyntax : public StructurePatternMemberSyntax {
+    not_null<PatternSyntax*> pattern;
+
+    OrderedStructurePatternMemberSyntax(PatternSyntax& pattern) :
+        StructurePatternMemberSyntax(SyntaxKind::OrderedStructurePatternMember), pattern(&pattern) {
+        this->pattern->parent = this;
+    }
+
+    explicit OrderedStructurePatternMemberSyntax(const OrderedStructurePatternMemberSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    OrderedStructurePatternMemberSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NamedStructurePatternMemberSyntax : public StructurePatternMemberSyntax {
+    Token name;
+    Token colon;
+    not_null<PatternSyntax*> pattern;
+
+    NamedStructurePatternMemberSyntax(Token name, Token colon, PatternSyntax& pattern) :
+        StructurePatternMemberSyntax(SyntaxKind::NamedStructurePatternMember), name(name), colon(colon), pattern(&pattern) {
+        this->pattern->parent = this;
+    }
+
+    explicit NamedStructurePatternMemberSyntax(const NamedStructurePatternMemberSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NamedStructurePatternMemberSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct StructurePatternSyntax : public PatternSyntax {
+    Token openBrace;
+    SeparatedSyntaxList<StructurePatternMemberSyntax> members;
+    Token closeBrace;
+
+    StructurePatternSyntax(Token openBrace, const SeparatedSyntaxList<StructurePatternMemberSyntax>& members, Token closeBrace) :
+        PatternSyntax(SyntaxKind::StructurePattern), openBrace(openBrace), members(members), closeBrace(closeBrace) {
+        this->members.parent = this;
+        for (auto child : this->members)
+            child->parent = this;
+    }
+
+    explicit StructurePatternSyntax(const StructurePatternSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    StructurePatternSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MatchesClauseSyntax : public SyntaxNode {
+    Token matchesKeyword;
+    not_null<PatternSyntax*> pattern;
+
+    MatchesClauseSyntax(Token matchesKeyword, PatternSyntax& pattern) :
+        SyntaxNode(SyntaxKind::MatchesClause), matchesKeyword(matchesKeyword), pattern(&pattern) {
+        this->pattern->parent = this;
+    }
+
+    explicit MatchesClauseSyntax(const MatchesClauseSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MatchesClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConditionalPatternSyntax : public SyntaxNode {
+    not_null<ExpressionSyntax*> expr;
+    MatchesClauseSyntax* matchesClause;
+
+    ConditionalPatternSyntax(ExpressionSyntax& expr, MatchesClauseSyntax* matchesClause) :
+        SyntaxNode(SyntaxKind::ConditionalPattern), expr(&expr), matchesClause(matchesClause) {
+        this->expr->parent = this;
+        if (this->matchesClause) this->matchesClause->parent = this;
+    }
+
+    explicit ConditionalPatternSyntax(const ConditionalPatternSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConditionalPatternSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConditionalPredicateSyntax : public SyntaxNode {
+    SeparatedSyntaxList<ConditionalPatternSyntax> conditions;
+
+    ConditionalPredicateSyntax(const SeparatedSyntaxList<ConditionalPatternSyntax>& conditions) :
+        SyntaxNode(SyntaxKind::ConditionalPredicate), conditions(conditions) {
+        this->conditions.parent = this;
+        for (auto child : this->conditions)
+            child->parent = this;
+    }
+
+    explicit ConditionalPredicateSyntax(const ConditionalPredicateSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConditionalPredicateSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct AssignmentPatternSyntax : public SyntaxNode {
+
+    AssignmentPatternSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit AssignmentPatternSyntax(const AssignmentPatternSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct SimpleAssignmentPatternSyntax : public AssignmentPatternSyntax {
+    Token openBrace;
+    SeparatedSyntaxList<ExpressionSyntax> items;
+    Token closeBrace;
+
+    SimpleAssignmentPatternSyntax(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& items, Token closeBrace) :
+        AssignmentPatternSyntax(SyntaxKind::SimpleAssignmentPattern), openBrace(openBrace), items(items), closeBrace(closeBrace) {
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    explicit SimpleAssignmentPatternSyntax(const SimpleAssignmentPatternSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SimpleAssignmentPatternSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct AssignmentPatternItemSyntax : public SyntaxNode {
+    not_null<ExpressionSyntax*> key;
+    Token colon;
+    not_null<ExpressionSyntax*> expr;
+
+    AssignmentPatternItemSyntax(ExpressionSyntax& key, Token colon, ExpressionSyntax& expr) :
+        SyntaxNode(SyntaxKind::AssignmentPatternItem), key(&key), colon(colon), expr(&expr) {
+        this->key->parent = this;
+        this->expr->parent = this;
+    }
+
+    explicit AssignmentPatternItemSyntax(const AssignmentPatternItemSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    AssignmentPatternItemSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct StructuredAssignmentPatternSyntax : public AssignmentPatternSyntax {
+    Token openBrace;
+    SeparatedSyntaxList<AssignmentPatternItemSyntax> items;
+    Token closeBrace;
+
+    StructuredAssignmentPatternSyntax(Token openBrace, const SeparatedSyntaxList<AssignmentPatternItemSyntax>& items, Token closeBrace) :
+        AssignmentPatternSyntax(SyntaxKind::StructuredAssignmentPattern), openBrace(openBrace), items(items), closeBrace(closeBrace) {
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    explicit StructuredAssignmentPatternSyntax(const StructuredAssignmentPatternSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    StructuredAssignmentPatternSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ReplicatedAssignmentPatternSyntax : public AssignmentPatternSyntax {
+    Token openBrace;
+    not_null<ExpressionSyntax*> countExpr;
+    Token innerOpenBrace;
+    SeparatedSyntaxList<ExpressionSyntax> items;
+    Token innerCloseBrace;
+    Token closeBrace;
+
+    ReplicatedAssignmentPatternSyntax(Token openBrace, ExpressionSyntax& countExpr, Token innerOpenBrace, const SeparatedSyntaxList<ExpressionSyntax>& items, Token innerCloseBrace, Token closeBrace) :
+        AssignmentPatternSyntax(SyntaxKind::ReplicatedAssignmentPattern), openBrace(openBrace), countExpr(&countExpr), innerOpenBrace(innerOpenBrace), items(items), innerCloseBrace(innerCloseBrace), closeBrace(closeBrace) {
+        this->countExpr->parent = this;
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    explicit ReplicatedAssignmentPatternSyntax(const ReplicatedAssignmentPatternSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ReplicatedAssignmentPatternSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- EXPRESSIONS -----
+
+struct BadExpressionSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> expr;
+
+    BadExpressionSyntax(ExpressionSyntax& expr) :
+        ExpressionSyntax(SyntaxKind::BadExpression), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    explicit BadExpressionSyntax(const BadExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    BadExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PrimaryExpressionSyntax : public ExpressionSyntax {
+
+    PrimaryExpressionSyntax(SyntaxKind kind) :
+        ExpressionSyntax(kind) {
+    }
+
+    explicit PrimaryExpressionSyntax(const PrimaryExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct PrefixUnaryExpressionSyntax : public ExpressionSyntax {
+    Token operatorToken;
+    SyntaxList<AttributeInstanceSyntax> attributes;
+    not_null<ExpressionSyntax*> operand;
+
+    PrefixUnaryExpressionSyntax(SyntaxKind kind, Token operatorToken, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& operand) :
+        ExpressionSyntax(kind), operatorToken(operatorToken), attributes(attributes), operand(&operand) {
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+        this->operand->parent = this;
+    }
+
+    explicit PrefixUnaryExpressionSyntax(const PrefixUnaryExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PrefixUnaryExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PostfixUnaryExpressionSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> operand;
+    SyntaxList<AttributeInstanceSyntax> attributes;
+    Token operatorToken;
+
+    PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax& operand, const SyntaxList<AttributeInstanceSyntax>& attributes, Token operatorToken) :
+        ExpressionSyntax(kind), operand(&operand), attributes(attributes), operatorToken(operatorToken) {
+        this->operand->parent = this;
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+    }
+
+    explicit PostfixUnaryExpressionSyntax(const PostfixUnaryExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PostfixUnaryExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct BinaryExpressionSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> left;
+    Token operatorToken;
+    SyntaxList<AttributeInstanceSyntax> attributes;
+    not_null<ExpressionSyntax*> right;
+
+    BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax& left, Token operatorToken, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& right) :
+        ExpressionSyntax(kind), left(&left), operatorToken(operatorToken), attributes(attributes), right(&right) {
+        this->left->parent = this;
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+        this->right->parent = this;
+    }
+
+    explicit BinaryExpressionSyntax(const BinaryExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    BinaryExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MinTypMaxExpressionSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> min;
+    Token colon1;
+    not_null<ExpressionSyntax*> typ;
+    Token colon2;
+    not_null<ExpressionSyntax*> max;
+
+    MinTypMaxExpressionSyntax(ExpressionSyntax& min, Token colon1, ExpressionSyntax& typ, Token colon2, ExpressionSyntax& max) :
+        ExpressionSyntax(SyntaxKind::MinTypMaxExpression), min(&min), colon1(colon1), typ(&typ), colon2(colon2), max(&max) {
+        this->min->parent = this;
+        this->typ->parent = this;
+        this->max->parent = this;
+    }
+
+    explicit MinTypMaxExpressionSyntax(const MinTypMaxExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MinTypMaxExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TaggedUnionExpressionSyntax : public ExpressionSyntax {
+    Token tagged;
+    Token member;
+    ExpressionSyntax* expr;
+
+    TaggedUnionExpressionSyntax(Token tagged, Token member, ExpressionSyntax* expr) :
+        ExpressionSyntax(SyntaxKind::TaggedUnionExpression), tagged(tagged), member(member), expr(expr) {
+        if (this->expr) this->expr->parent = this;
+    }
+
+    explicit TaggedUnionExpressionSyntax(const TaggedUnionExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TaggedUnionExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct OpenRangeExpressionSyntax : public ExpressionSyntax {
+    Token openBracket;
+    not_null<ExpressionSyntax*> left;
+    Token colon;
+    not_null<ExpressionSyntax*> right;
+    Token closeBracket;
+
+    OpenRangeExpressionSyntax(Token openBracket, ExpressionSyntax& left, Token colon, ExpressionSyntax& right, Token closeBracket) :
+        ExpressionSyntax(SyntaxKind::OpenRangeExpression), openBracket(openBracket), left(&left), colon(colon), right(&right), closeBracket(closeBracket) {
+        this->left->parent = this;
+        this->right->parent = this;
+    }
+
+    explicit OpenRangeExpressionSyntax(const OpenRangeExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    OpenRangeExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct OpenRangeListSyntax : public SyntaxNode {
+    Token openBrace;
+    SeparatedSyntaxList<ExpressionSyntax> valueRanges;
+    Token closeBrace;
+
+    OpenRangeListSyntax(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& valueRanges, Token closeBrace) :
+        SyntaxNode(SyntaxKind::OpenRangeList), openBrace(openBrace), valueRanges(valueRanges), closeBrace(closeBrace) {
+        this->valueRanges.parent = this;
+        for (auto child : this->valueRanges)
+            child->parent = this;
+    }
+
+    explicit OpenRangeListSyntax(const OpenRangeListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    OpenRangeListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct InsideExpressionSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> expr;
+    Token inside;
+    not_null<OpenRangeListSyntax*> ranges;
+
+    InsideExpressionSyntax(ExpressionSyntax& expr, Token inside, OpenRangeListSyntax& ranges) :
+        ExpressionSyntax(SyntaxKind::InsideExpression), expr(&expr), inside(inside), ranges(&ranges) {
+        this->expr->parent = this;
+        this->ranges->parent = this;
+    }
+
+    explicit InsideExpressionSyntax(const InsideExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    InsideExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConditionalExpressionSyntax : public ExpressionSyntax {
+    not_null<ConditionalPredicateSyntax*> predicate;
+    Token question;
+    SyntaxList<AttributeInstanceSyntax> attributes;
+    not_null<ExpressionSyntax*> left;
+    Token colon;
+    not_null<ExpressionSyntax*> right;
+
+    ConditionalExpressionSyntax(ConditionalPredicateSyntax& predicate, Token question, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& left, Token colon, ExpressionSyntax& right) :
+        ExpressionSyntax(SyntaxKind::ConditionalExpression), predicate(&predicate), question(question), attributes(attributes), left(&left), colon(colon), right(&right) {
+        this->predicate->parent = this;
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+        this->left->parent = this;
+        this->right->parent = this;
+    }
+
+    explicit ConditionalExpressionSyntax(const ConditionalExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConditionalExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct AssignmentPatternExpressionSyntax : public PrimaryExpressionSyntax {
+    DataTypeSyntax* type;
+    not_null<AssignmentPatternSyntax*> pattern;
+
+    AssignmentPatternExpressionSyntax(DataTypeSyntax* type, AssignmentPatternSyntax& pattern) :
+        PrimaryExpressionSyntax(SyntaxKind::AssignmentPatternExpression), type(type), pattern(&pattern) {
+        if (this->type) this->type->parent = this;
+        this->pattern->parent = this;
+    }
+
+    explicit AssignmentPatternExpressionSyntax(const AssignmentPatternExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    AssignmentPatternExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- SELECTORS -----
+
+struct SelectorSyntax : public SyntaxNode {
+
+    SelectorSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit SelectorSyntax(const SelectorSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct BitSelectSyntax : public SelectorSyntax {
+    not_null<ExpressionSyntax*> expr;
+
+    BitSelectSyntax(ExpressionSyntax& expr) :
+        SelectorSyntax(SyntaxKind::BitSelect), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    explicit BitSelectSyntax(const BitSelectSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    BitSelectSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct RangeSelectSyntax : public SelectorSyntax {
+    not_null<ExpressionSyntax*> left;
+    Token range;
+    not_null<ExpressionSyntax*> right;
+
+    RangeSelectSyntax(SyntaxKind kind, ExpressionSyntax& left, Token range, ExpressionSyntax& right) :
+        SelectorSyntax(kind), left(&left), range(range), right(&right) {
+        this->left->parent = this;
+        this->right->parent = this;
+    }
+
+    explicit RangeSelectSyntax(const RangeSelectSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    RangeSelectSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ElementSelectSyntax : public SyntaxNode {
+    Token openBracket;
+    SelectorSyntax* selector;
+    Token closeBracket;
+
+    ElementSelectSyntax(Token openBracket, SelectorSyntax* selector, Token closeBracket) :
+        SyntaxNode(SyntaxKind::ElementSelect), openBracket(openBracket), selector(selector), closeBracket(closeBracket) {
+        if (this->selector) this->selector->parent = this;
+    }
+
+    explicit ElementSelectSyntax(const ElementSelectSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ElementSelectSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- NAMES -----
+
+struct NameSyntax : public ExpressionSyntax {
+
+    NameSyntax(SyntaxKind kind) :
+        ExpressionSyntax(kind) {
+    }
+
+    explicit NameSyntax(const NameSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct IdentifierNameSyntax : public NameSyntax {
+    Token identifier;
+
+    IdentifierNameSyntax(Token identifier) :
+        NameSyntax(SyntaxKind::IdentifierName), identifier(identifier) {
+    }
+
+    explicit IdentifierNameSyntax(const IdentifierNameSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    IdentifierNameSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct SystemNameSyntax : public NameSyntax {
+    Token systemIdentifier;
+
+    SystemNameSyntax(Token systemIdentifier) :
+        NameSyntax(SyntaxKind::SystemName), systemIdentifier(systemIdentifier) {
+    }
+
+    explicit SystemNameSyntax(const SystemNameSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SystemNameSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct IdentifierSelectNameSyntax : public NameSyntax {
+    Token identifier;
+    SyntaxList<ElementSelectSyntax> selectors;
+
+    IdentifierSelectNameSyntax(Token identifier, const SyntaxList<ElementSelectSyntax>& selectors) :
+        NameSyntax(SyntaxKind::IdentifierSelectName), identifier(identifier), selectors(selectors) {
+        this->selectors.parent = this;
+        for (auto child : this->selectors)
+            child->parent = this;
+    }
+
+    explicit IdentifierSelectNameSyntax(const IdentifierSelectNameSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    IdentifierSelectNameSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct EmptyIdentifierNameSyntax : public NameSyntax {
+    Token placeholder;
+
+    EmptyIdentifierNameSyntax(Token placeholder) :
+        NameSyntax(SyntaxKind::EmptyIdentifierName), placeholder(placeholder) {
+    }
+
+    explicit EmptyIdentifierNameSyntax(const EmptyIdentifierNameSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EmptyIdentifierNameSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct KeywordNameSyntax : public NameSyntax {
+    Token keyword;
+
+    KeywordNameSyntax(SyntaxKind kind, Token keyword) :
+        NameSyntax(kind), keyword(keyword) {
+    }
+
+    explicit KeywordNameSyntax(const KeywordNameSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    KeywordNameSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ClassNameSyntax : public NameSyntax {
+    Token identifier;
+    not_null<ParameterValueAssignmentSyntax*> parameters;
+
+    ClassNameSyntax(Token identifier, ParameterValueAssignmentSyntax& parameters) :
+        NameSyntax(SyntaxKind::ClassName), identifier(identifier), parameters(&parameters) {
+        this->parameters->parent = this;
+    }
+
+    explicit ClassNameSyntax(const ClassNameSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ClassNameSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ScopedNameSyntax : public NameSyntax {
+    not_null<NameSyntax*> left;
+    Token separator;
+    not_null<NameSyntax*> right;
+
+    ScopedNameSyntax(NameSyntax& left, Token separator, NameSyntax& right) :
+        NameSyntax(SyntaxKind::ScopedName), left(&left), separator(separator), right(&right) {
+        this->left->parent = this;
+        this->right->parent = this;
+    }
+
+    explicit ScopedNameSyntax(const ScopedNameSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ScopedNameSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- PRIMARY EXPRESSIONS -----
+
+struct LiteralExpressionSyntax : public PrimaryExpressionSyntax {
+    Token literal;
+
+    LiteralExpressionSyntax(SyntaxKind kind, Token literal) :
+        PrimaryExpressionSyntax(kind), literal(literal) {
+    }
+
+    explicit LiteralExpressionSyntax(const LiteralExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    LiteralExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct IntegerVectorExpressionSyntax : public PrimaryExpressionSyntax {
+    Token size;
+    Token base;
+    Token value;
+
+    IntegerVectorExpressionSyntax(Token size, Token base, Token value) :
+        PrimaryExpressionSyntax(SyntaxKind::IntegerVectorExpression), size(size), base(base), value(value) {
+    }
+
+    explicit IntegerVectorExpressionSyntax(const IntegerVectorExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    IntegerVectorExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct EmptyQueueExpressionSyntax : public PrimaryExpressionSyntax {
+    Token openBrace;
+    Token closeBrace;
+
+    EmptyQueueExpressionSyntax(Token openBrace, Token closeBrace) :
+        PrimaryExpressionSyntax(SyntaxKind::EmptyQueueExpression), openBrace(openBrace), closeBrace(closeBrace) {
+    }
+
+    explicit EmptyQueueExpressionSyntax(const EmptyQueueExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EmptyQueueExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
+    Token openBrace;
+    SeparatedSyntaxList<ExpressionSyntax> expressions;
+    Token closeBrace;
+
+    ConcatenationExpressionSyntax(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token closeBrace) :
+        PrimaryExpressionSyntax(SyntaxKind::ConcatenationExpression), openBrace(openBrace), expressions(expressions), closeBrace(closeBrace) {
+        this->expressions.parent = this;
+        for (auto child : this->expressions)
+            child->parent = this;
+    }
+
+    explicit ConcatenationExpressionSyntax(const ConcatenationExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConcatenationExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MultipleConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
+    Token openBrace;
+    not_null<ExpressionSyntax*> expression;
+    not_null<ConcatenationExpressionSyntax*> concatenation;
+    Token closeBrace;
+
+    MultipleConcatenationExpressionSyntax(Token openBrace, ExpressionSyntax& expression, ConcatenationExpressionSyntax& concatenation, Token closeBrace) :
+        PrimaryExpressionSyntax(SyntaxKind::MultipleConcatenationExpression), openBrace(openBrace), expression(&expression), concatenation(&concatenation), closeBrace(closeBrace) {
+        this->expression->parent = this;
+        this->concatenation->parent = this;
+    }
+
+    explicit MultipleConcatenationExpressionSyntax(const MultipleConcatenationExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MultipleConcatenationExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct StreamExpressionWithRangeSyntax : public SyntaxNode {
+    Token withKeyword;
+    not_null<ElementSelectSyntax*> range;
+
+    StreamExpressionWithRangeSyntax(Token withKeyword, ElementSelectSyntax& range) :
+        SyntaxNode(SyntaxKind::StreamExpressionWithRange), withKeyword(withKeyword), range(&range) {
+        this->range->parent = this;
+    }
+
+    explicit StreamExpressionWithRangeSyntax(const StreamExpressionWithRangeSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    StreamExpressionWithRangeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct StreamExpressionSyntax : public SyntaxNode {
+    not_null<ExpressionSyntax*> expression;
+    StreamExpressionWithRangeSyntax* withRange;
+
+    StreamExpressionSyntax(ExpressionSyntax& expression, StreamExpressionWithRangeSyntax* withRange) :
+        SyntaxNode(SyntaxKind::StreamExpression), expression(&expression), withRange(withRange) {
+        this->expression->parent = this;
+        if (this->withRange) this->withRange->parent = this;
+    }
+
+    explicit StreamExpressionSyntax(const StreamExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    StreamExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct StreamingConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
+    Token openBrace;
+    Token operatorToken;
+    ExpressionSyntax* sliceSize;
+    Token innerOpenBrace;
+    SeparatedSyntaxList<StreamExpressionSyntax> expressions;
+    Token innerCloseBrace;
+    Token closeBrace;
+
+    StreamingConcatenationExpressionSyntax(Token openBrace, Token operatorToken, ExpressionSyntax* sliceSize, Token innerOpenBrace, const SeparatedSyntaxList<StreamExpressionSyntax>& expressions, Token innerCloseBrace, Token closeBrace) :
+        PrimaryExpressionSyntax(SyntaxKind::StreamingConcatenationExpression), openBrace(openBrace), operatorToken(operatorToken), sliceSize(sliceSize), innerOpenBrace(innerOpenBrace), expressions(expressions), innerCloseBrace(innerCloseBrace), closeBrace(closeBrace) {
+        if (this->sliceSize) this->sliceSize->parent = this;
+        this->expressions.parent = this;
+        for (auto child : this->expressions)
+            child->parent = this;
+    }
+
+    explicit StreamingConcatenationExpressionSyntax(const StreamingConcatenationExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    StreamingConcatenationExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ParenthesizedExpressionSyntax : public PrimaryExpressionSyntax {
+    Token openParen;
+    not_null<ExpressionSyntax*> expression;
+    Token closeParen;
+
+    ParenthesizedExpressionSyntax(Token openParen, ExpressionSyntax& expression, Token closeParen) :
+        PrimaryExpressionSyntax(SyntaxKind::ParenthesizedExpression), openParen(openParen), expression(&expression), closeParen(closeParen) {
+        this->expression->parent = this;
+    }
+
+    explicit ParenthesizedExpressionSyntax(const ParenthesizedExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ParenthesizedExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NewArrayExpressionSyntax : public ExpressionSyntax {
+    not_null<NameSyntax*> newKeyword;
+    Token openBracket;
+    not_null<ExpressionSyntax*> sizeExpr;
+    Token closeBracket;
+    ParenthesizedExpressionSyntax* initializer;
+
+    NewArrayExpressionSyntax(NameSyntax& newKeyword, Token openBracket, ExpressionSyntax& sizeExpr, Token closeBracket, ParenthesizedExpressionSyntax* initializer) :
+        ExpressionSyntax(SyntaxKind::NewArrayExpression), newKeyword(&newKeyword), openBracket(openBracket), sizeExpr(&sizeExpr), closeBracket(closeBracket), initializer(initializer) {
+        this->newKeyword->parent = this;
+        this->sizeExpr->parent = this;
+        if (this->initializer) this->initializer->parent = this;
+    }
+
+    explicit NewArrayExpressionSyntax(const NewArrayExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NewArrayExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NewClassExpressionSyntax : public ExpressionSyntax {
+    not_null<NameSyntax*> scopedNew;
+    ArgumentListSyntax* argList;
+
+    NewClassExpressionSyntax(NameSyntax& scopedNew, ArgumentListSyntax* argList) :
+        ExpressionSyntax(SyntaxKind::NewClassExpression), scopedNew(&scopedNew), argList(argList) {
+        this->scopedNew->parent = this;
+        if (this->argList) this->argList->parent = this;
+    }
+
+    explicit NewClassExpressionSyntax(const NewClassExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NewClassExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct CopyClassExpressionSyntax : public ExpressionSyntax {
+    not_null<NameSyntax*> scopedNew;
+    not_null<ExpressionSyntax*> expr;
+
+    CopyClassExpressionSyntax(NameSyntax& scopedNew, ExpressionSyntax& expr) :
+        ExpressionSyntax(SyntaxKind::CopyClassExpression), scopedNew(&scopedNew), expr(&expr) {
+        this->scopedNew->parent = this;
+        this->expr->parent = this;
+    }
+
+    explicit CopyClassExpressionSyntax(const CopyClassExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    CopyClassExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- POSTFIX EXPRESSIONS -----
+
+struct ElementSelectExpressionSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> left;
+    not_null<ElementSelectSyntax*> select;
+
+    ElementSelectExpressionSyntax(ExpressionSyntax& left, ElementSelectSyntax& select) :
+        ExpressionSyntax(SyntaxKind::ElementSelectExpression), left(&left), select(&select) {
+        this->left->parent = this;
+        this->select->parent = this;
+    }
+
+    explicit ElementSelectExpressionSyntax(const ElementSelectExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ElementSelectExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MemberAccessExpressionSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> left;
+    Token dot;
+    Token name;
+
+    MemberAccessExpressionSyntax(ExpressionSyntax& left, Token dot, Token name) :
+        ExpressionSyntax(SyntaxKind::MemberAccessExpression), left(&left), dot(dot), name(name) {
+        this->left->parent = this;
+    }
+
+    explicit MemberAccessExpressionSyntax(const MemberAccessExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MemberAccessExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct InvocationExpressionSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> left;
+    SyntaxList<AttributeInstanceSyntax> attributes;
+    ArgumentListSyntax* arguments;
+
+    InvocationExpressionSyntax(ExpressionSyntax& left, const SyntaxList<AttributeInstanceSyntax>& attributes, ArgumentListSyntax* arguments) :
+        ExpressionSyntax(SyntaxKind::InvocationExpression), left(&left), attributes(attributes), arguments(arguments) {
+        this->left->parent = this;
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+        if (this->arguments) this->arguments->parent = this;
+    }
+
+    explicit InvocationExpressionSyntax(const InvocationExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    InvocationExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct CastExpressionSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> left;
+    Token apostrophe;
+    not_null<ParenthesizedExpressionSyntax*> right;
+
+    CastExpressionSyntax(ExpressionSyntax& left, Token apostrophe, ParenthesizedExpressionSyntax& right) :
+        ExpressionSyntax(SyntaxKind::CastExpression), left(&left), apostrophe(apostrophe), right(&right) {
+        this->left->parent = this;
+        this->right->parent = this;
+    }
+
+    explicit CastExpressionSyntax(const CastExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    CastExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct SignedCastExpressionSyntax : public ExpressionSyntax {
+    Token signing;
+    Token apostrophe;
+    not_null<ParenthesizedExpressionSyntax*> inner;
+
+    SignedCastExpressionSyntax(Token signing, Token apostrophe, ParenthesizedExpressionSyntax& inner) :
+        ExpressionSyntax(SyntaxKind::SignedCastExpression), signing(signing), apostrophe(apostrophe), inner(&inner) {
+        this->inner->parent = this;
+    }
+
+    explicit SignedCastExpressionSyntax(const SignedCastExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SignedCastExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- TIMING CONTROL -----
+
+struct TimingControlSyntax : public SyntaxNode {
+
+    TimingControlSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit TimingControlSyntax(const TimingControlSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct DelaySyntax : public TimingControlSyntax {
+    Token hash;
+    not_null<ExpressionSyntax*> delayValue;
+
+    DelaySyntax(SyntaxKind kind, Token hash, ExpressionSyntax& delayValue) :
+        TimingControlSyntax(kind), hash(hash), delayValue(&delayValue) {
+        this->delayValue->parent = this;
+    }
+
+    explicit DelaySyntax(const DelaySyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DelaySyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct Delay3Syntax : public TimingControlSyntax {
+    Token hash;
+    Token openParen;
+    not_null<ExpressionSyntax*> delay1;
+    Token comma1;
+    ExpressionSyntax* delay2;
+    Token comma2;
+    ExpressionSyntax* delay3;
+    Token closeParen;
+
+    Delay3Syntax(Token hash, Token openParen, ExpressionSyntax& delay1, Token comma1, ExpressionSyntax* delay2, Token comma2, ExpressionSyntax* delay3, Token closeParen) :
+        TimingControlSyntax(SyntaxKind::Delay3), hash(hash), openParen(openParen), delay1(&delay1), comma1(comma1), delay2(delay2), comma2(comma2), delay3(delay3), closeParen(closeParen) {
+        this->delay1->parent = this;
+        if (this->delay2) this->delay2->parent = this;
+        if (this->delay3) this->delay3->parent = this;
+    }
+
+    explicit Delay3Syntax(const Delay3Syntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    Delay3Syntax* clone(BumpAllocator& alloc) const;
+};
+
+struct EventControlSyntax : public TimingControlSyntax {
+    Token at;
+    not_null<NameSyntax*> eventName;
+
+    EventControlSyntax(Token at, NameSyntax& eventName) :
+        TimingControlSyntax(SyntaxKind::EventControl), at(at), eventName(&eventName) {
+        this->eventName->parent = this;
+    }
+
+    explicit EventControlSyntax(const EventControlSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EventControlSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct IffEventClauseSyntax : public SyntaxNode {
+    Token iff;
+    not_null<ExpressionSyntax*> expr;
+
+    IffEventClauseSyntax(Token iff, ExpressionSyntax& expr) :
+        SyntaxNode(SyntaxKind::IffEventClause), iff(iff), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    explicit IffEventClauseSyntax(const IffEventClauseSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    IffEventClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct EventExpressionSyntax : public SyntaxNode {
+
+    EventExpressionSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit EventExpressionSyntax(const EventExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct SignalEventExpressionSyntax : public EventExpressionSyntax {
+    Token edge;
+    not_null<ExpressionSyntax*> expr;
+    IffEventClauseSyntax* iffClause;
+
+    SignalEventExpressionSyntax(Token edge, ExpressionSyntax& expr, IffEventClauseSyntax* iffClause) :
+        EventExpressionSyntax(SyntaxKind::SignalEventExpression), edge(edge), expr(&expr), iffClause(iffClause) {
+        this->expr->parent = this;
+        if (this->iffClause) this->iffClause->parent = this;
+    }
+
+    explicit SignalEventExpressionSyntax(const SignalEventExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SignalEventExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct BinaryEventExpressionSyntax : public EventExpressionSyntax {
+    not_null<EventExpressionSyntax*> left;
+    Token operatorToken;
+    not_null<EventExpressionSyntax*> right;
+
+    BinaryEventExpressionSyntax(EventExpressionSyntax& left, Token operatorToken, EventExpressionSyntax& right) :
+        EventExpressionSyntax(SyntaxKind::BinaryEventExpression), left(&left), operatorToken(operatorToken), right(&right) {
+        this->left->parent = this;
+        this->right->parent = this;
+    }
+
+    explicit BinaryEventExpressionSyntax(const BinaryEventExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    BinaryEventExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ParenthesizedEventExpressionSyntax : public EventExpressionSyntax {
+    Token openParen;
+    not_null<EventExpressionSyntax*> expr;
+    Token closeParen;
+
+    ParenthesizedEventExpressionSyntax(Token openParen, EventExpressionSyntax& expr, Token closeParen) :
+        EventExpressionSyntax(SyntaxKind::ParenthesizedEventExpression), openParen(openParen), expr(&expr), closeParen(closeParen) {
+        this->expr->parent = this;
+    }
+
+    explicit ParenthesizedEventExpressionSyntax(const ParenthesizedEventExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ParenthesizedEventExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ImplicitEventControlSyntax : public TimingControlSyntax {
+    Token at;
+    Token openParen;
+    Token star;
+    Token closeParen;
+
+    ImplicitEventControlSyntax(Token at, Token openParen, Token star, Token closeParen) :
+        TimingControlSyntax(SyntaxKind::ImplicitEventControl), at(at), openParen(openParen), star(star), closeParen(closeParen) {
+    }
+
+    explicit ImplicitEventControlSyntax(const ImplicitEventControlSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ImplicitEventControlSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct EventControlWithExpressionSyntax : public TimingControlSyntax {
+    Token at;
+    not_null<EventExpressionSyntax*> expr;
+
+    EventControlWithExpressionSyntax(Token at, EventExpressionSyntax& expr) :
+        TimingControlSyntax(SyntaxKind::EventControlWithExpression), at(at), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    explicit EventControlWithExpressionSyntax(const EventControlWithExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EventControlWithExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct RepeatedEventControlSyntax : public TimingControlSyntax {
+    Token repeat;
+    Token openParen;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+    TimingControlSyntax* eventControl;
+
+    RepeatedEventControlSyntax(Token repeat, Token openParen, ExpressionSyntax& expr, Token closeParen, TimingControlSyntax* eventControl) :
+        TimingControlSyntax(SyntaxKind::RepeatedEventControl), repeat(repeat), openParen(openParen), expr(&expr), closeParen(closeParen), eventControl(eventControl) {
+        this->expr->parent = this;
+        if (this->eventControl) this->eventControl->parent = this;
+    }
+
+    explicit RepeatedEventControlSyntax(const RepeatedEventControlSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    RepeatedEventControlSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TimingControlExpressionSyntax : public ExpressionSyntax {
+    not_null<TimingControlSyntax*> timing;
+    not_null<ExpressionSyntax*> expr;
+
+    TimingControlExpressionSyntax(TimingControlSyntax& timing, ExpressionSyntax& expr) :
+        ExpressionSyntax(SyntaxKind::TimingControlExpression), timing(&timing), expr(&expr) {
+        this->timing->parent = this;
+        this->expr->parent = this;
+    }
+
+    explicit TimingControlExpressionSyntax(const TimingControlExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TimingControlExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TimingControlExpressionConcatenationSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> left;
+    not_null<TimingControlSyntax*> timing;
+    not_null<ExpressionSyntax*> right;
+
+    TimingControlExpressionConcatenationSyntax(ExpressionSyntax& left, TimingControlSyntax& timing, ExpressionSyntax& right) :
+        ExpressionSyntax(SyntaxKind::TimingControlExpressionConcatenation), left(&left), timing(&timing), right(&right) {
+        this->left->parent = this;
+        this->timing->parent = this;
+        this->right->parent = this;
+    }
+
+    explicit TimingControlExpressionConcatenationSyntax(const TimingControlExpressionConcatenationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TimingControlExpressionConcatenationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ShortcutCycleDelayRangeSyntax : public TimingControlSyntax {
+    Token doubleHash;
+    Token openBracket;
+    Token op;
+    Token closeBracket;
+
+    ShortcutCycleDelayRangeSyntax(Token doubleHash, Token openBracket, Token op, Token closeBracket) :
+        TimingControlSyntax(SyntaxKind::ShortcutCycleDelayRange), doubleHash(doubleHash), openBracket(openBracket), op(op), closeBracket(closeBracket) {
+    }
+
+    explicit ShortcutCycleDelayRangeSyntax(const ShortcutCycleDelayRangeSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ShortcutCycleDelayRangeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- DECLARATIONS -----
+
+struct DimensionSpecifierSyntax : public SyntaxNode {
+
+    DimensionSpecifierSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit DimensionSpecifierSyntax(const DimensionSpecifierSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct RangeDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
+    not_null<SelectorSyntax*> selector;
+
+    RangeDimensionSpecifierSyntax(SelectorSyntax& selector) :
+        DimensionSpecifierSyntax(SyntaxKind::RangeDimensionSpecifier), selector(&selector) {
+        this->selector->parent = this;
+    }
+
+    explicit RangeDimensionSpecifierSyntax(const RangeDimensionSpecifierSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    RangeDimensionSpecifierSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct WildcardDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
+    Token star;
+
+    WildcardDimensionSpecifierSyntax(Token star) :
+        DimensionSpecifierSyntax(SyntaxKind::WildcardDimensionSpecifier), star(star) {
+    }
+
+    explicit WildcardDimensionSpecifierSyntax(const WildcardDimensionSpecifierSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WildcardDimensionSpecifierSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ColonExpressionClauseSyntax : public SyntaxNode {
+    Token colon;
+    not_null<ExpressionSyntax*> expr;
+
+    ColonExpressionClauseSyntax(Token colon, ExpressionSyntax& expr) :
+        SyntaxNode(SyntaxKind::ColonExpressionClause), colon(colon), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    explicit ColonExpressionClauseSyntax(const ColonExpressionClauseSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ColonExpressionClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct QueueDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
+    Token dollar;
+    ColonExpressionClauseSyntax* maxSizeClause;
+
+    QueueDimensionSpecifierSyntax(Token dollar, ColonExpressionClauseSyntax* maxSizeClause) :
+        DimensionSpecifierSyntax(SyntaxKind::QueueDimensionSpecifier), dollar(dollar), maxSizeClause(maxSizeClause) {
+        if (this->maxSizeClause) this->maxSizeClause->parent = this;
+    }
+
+    explicit QueueDimensionSpecifierSyntax(const QueueDimensionSpecifierSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    QueueDimensionSpecifierSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct VariableDimensionSyntax : public SyntaxNode {
+    Token openBracket;
+    DimensionSpecifierSyntax* specifier;
+    Token closeBracket;
+
+    VariableDimensionSyntax(Token openBracket, DimensionSpecifierSyntax* specifier, Token closeBracket) :
+        SyntaxNode(SyntaxKind::VariableDimension), openBracket(openBracket), specifier(specifier), closeBracket(closeBracket) {
+        if (this->specifier) this->specifier->parent = this;
+    }
+
+    explicit VariableDimensionSyntax(const VariableDimensionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    VariableDimensionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DeclaratorSyntax : public SyntaxNode {
+    Token name;
+    SyntaxList<VariableDimensionSyntax> dimensions;
+    EqualsValueClauseSyntax* initializer;
+
+    DeclaratorSyntax(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, EqualsValueClauseSyntax* initializer) :
+        SyntaxNode(SyntaxKind::Declarator), name(name), dimensions(dimensions), initializer(initializer) {
+        this->dimensions.parent = this;
+        for (auto child : this->dimensions)
+            child->parent = this;
+        if (this->initializer) this->initializer->parent = this;
+    }
+
+    explicit DeclaratorSyntax(const DeclaratorSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DeclaratorSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DataDeclarationSyntax : public MemberSyntax {
+    TokenList modifiers;
+    not_null<DataTypeSyntax*> type;
+    SeparatedSyntaxList<DeclaratorSyntax> declarators;
+    Token semi;
+
+    DataDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& modifiers, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) :
+        MemberSyntax(SyntaxKind::DataDeclaration, attributes), modifiers(modifiers), type(&type), declarators(declarators), semi(semi) {
+        this->modifiers.parent = this;
+        this->type->parent = this;
+        this->declarators.parent = this;
+        for (auto child : this->declarators)
+            child->parent = this;
+    }
+
+    explicit DataDeclarationSyntax(const DataDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DataDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TypedefDeclarationSyntax : public MemberSyntax {
+    Token typedefKeyword;
+    not_null<DataTypeSyntax*> type;
+    Token name;
+    SyntaxList<VariableDimensionSyntax> dimensions;
+    Token semi;
+
+    TypedefDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, DataTypeSyntax& type, Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, Token semi) :
+        MemberSyntax(SyntaxKind::TypedefDeclaration, attributes), typedefKeyword(typedefKeyword), type(&type), name(name), dimensions(dimensions), semi(semi) {
+        this->type->parent = this;
+        this->dimensions.parent = this;
+        for (auto child : this->dimensions)
+            child->parent = this;
+    }
+
+    explicit TypedefDeclarationSyntax(const TypedefDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TypedefDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ForwardTypedefDeclarationSyntax : public MemberSyntax {
+    Token typedefKeyword;
+    Token keyword;
+    Token name;
+    Token semi;
+
+    ForwardTypedefDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, Token keyword, Token name, Token semi) :
+        MemberSyntax(SyntaxKind::ForwardTypedefDeclaration, attributes), typedefKeyword(typedefKeyword), keyword(keyword), name(name), semi(semi) {
+    }
+
+    explicit ForwardTypedefDeclarationSyntax(const ForwardTypedefDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ForwardTypedefDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ForwardInterfaceClassTypedefDeclarationSyntax : public MemberSyntax {
+    Token typedefKeyword;
+    Token interfaceKeyword;
+    Token classKeyword;
+    Token name;
+    Token semi;
+
+    ForwardInterfaceClassTypedefDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, Token interfaceKeyword, Token classKeyword, Token name, Token semi) :
+        MemberSyntax(SyntaxKind::ForwardInterfaceClassTypedefDeclaration, attributes), typedefKeyword(typedefKeyword), interfaceKeyword(interfaceKeyword), classKeyword(classKeyword), name(name), semi(semi) {
+    }
+
+    explicit ForwardInterfaceClassTypedefDeclarationSyntax(const ForwardInterfaceClassTypedefDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ForwardInterfaceClassTypedefDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NetStrengthSyntax : public SyntaxNode {
+
+    NetStrengthSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit NetStrengthSyntax(const NetStrengthSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct ChargeStrengthSyntax : public NetStrengthSyntax {
+    Token openParen;
+    Token strength;
+    Token closeParen;
+
+    ChargeStrengthSyntax(Token openParen, Token strength, Token closeParen) :
+        NetStrengthSyntax(SyntaxKind::ChargeStrength), openParen(openParen), strength(strength), closeParen(closeParen) {
+    }
+
+    explicit ChargeStrengthSyntax(const ChargeStrengthSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ChargeStrengthSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DriveStrengthSyntax : public NetStrengthSyntax {
+    Token openParen;
+    Token strength0;
+    Token comma;
+    Token strength1;
+    Token closeParen;
+
+    DriveStrengthSyntax(Token openParen, Token strength0, Token comma, Token strength1, Token closeParen) :
+        NetStrengthSyntax(SyntaxKind::DriveStrength), openParen(openParen), strength0(strength0), comma(comma), strength1(strength1), closeParen(closeParen) {
+    }
+
+    explicit DriveStrengthSyntax(const DriveStrengthSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DriveStrengthSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NetDeclarationSyntax : public MemberSyntax {
+    Token netType;
+    NetStrengthSyntax* strength;
+    Token expansionHint;
+    not_null<DataTypeSyntax*> type;
+    TimingControlSyntax* delay;
+    SeparatedSyntaxList<DeclaratorSyntax> declarators;
+    Token semi;
+
+    NetDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token netType, NetStrengthSyntax* strength, Token expansionHint, DataTypeSyntax& type, TimingControlSyntax* delay, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) :
+        MemberSyntax(SyntaxKind::NetDeclaration, attributes), netType(netType), strength(strength), expansionHint(expansionHint), type(&type), delay(delay), declarators(declarators), semi(semi) {
+        if (this->strength) this->strength->parent = this;
+        this->type->parent = this;
+        if (this->delay) this->delay->parent = this;
+        this->declarators.parent = this;
+        for (auto child : this->declarators)
+            child->parent = this;
+    }
+
+    explicit NetDeclarationSyntax(const NetDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NetDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct UserDefinedNetDeclarationSyntax : public MemberSyntax {
+    Token netType;
+    not_null<TimingControlSyntax*> delay;
+    SeparatedSyntaxList<DeclaratorSyntax> declarators;
+    Token semi;
+
+    UserDefinedNetDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token netType, TimingControlSyntax& delay, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) :
+        MemberSyntax(SyntaxKind::UserDefinedNetDeclaration, attributes), netType(netType), delay(&delay), declarators(declarators), semi(semi) {
+        this->delay->parent = this;
+        this->declarators.parent = this;
+        for (auto child : this->declarators)
+            child->parent = this;
+    }
+
+    explicit UserDefinedNetDeclarationSyntax(const UserDefinedNetDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    UserDefinedNetDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct WithFunctionClauseSyntax : public SyntaxNode {
+    Token with;
+    not_null<NameSyntax*> name;
+
+    WithFunctionClauseSyntax(Token with, NameSyntax& name) :
+        SyntaxNode(SyntaxKind::WithFunctionClause), with(with), name(&name) {
+        this->name->parent = this;
+    }
+
+    explicit WithFunctionClauseSyntax(const WithFunctionClauseSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WithFunctionClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NetTypeDeclarationSyntax : public MemberSyntax {
+    Token keyword;
+    not_null<DataTypeSyntax*> type;
+    Token name;
+    WithFunctionClauseSyntax* withFunction;
+    Token semi;
+
+    NetTypeDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, DataTypeSyntax& type, Token name, WithFunctionClauseSyntax* withFunction, Token semi) :
+        MemberSyntax(SyntaxKind::NetTypeDeclaration, attributes), keyword(keyword), type(&type), name(name), withFunction(withFunction), semi(semi) {
+        this->type->parent = this;
+        if (this->withFunction) this->withFunction->parent = this;
+    }
+
+    explicit NetTypeDeclarationSyntax(const NetTypeDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NetTypeDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PackageImportItemSyntax : public SyntaxNode {
+    Token package;
+    Token doubleColon;
+    Token item;
+
+    PackageImportItemSyntax(Token package, Token doubleColon, Token item) :
+        SyntaxNode(SyntaxKind::PackageImportItem), package(package), doubleColon(doubleColon), item(item) {
+    }
+
+    explicit PackageImportItemSyntax(const PackageImportItemSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PackageImportItemSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PackageImportDeclarationSyntax : public MemberSyntax {
+    Token keyword;
+    SeparatedSyntaxList<PackageImportItemSyntax> items;
+    Token semi;
+
+    PackageImportDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<PackageImportItemSyntax>& items, Token semi) :
+        MemberSyntax(SyntaxKind::PackageImportDeclaration, attributes), keyword(keyword), items(items), semi(semi) {
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    explicit PackageImportDeclarationSyntax(const PackageImportDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PackageImportDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ParameterDeclarationBaseSyntax : public SyntaxNode {
+    Token keyword;
+
+    ParameterDeclarationBaseSyntax(SyntaxKind kind, Token keyword) :
+        SyntaxNode(kind), keyword(keyword) {
+    }
+
+    explicit ParameterDeclarationBaseSyntax(const ParameterDeclarationBaseSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ParameterDeclarationBaseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ParameterDeclarationSyntax : public ParameterDeclarationBaseSyntax {
+    not_null<DataTypeSyntax*> type;
+    SeparatedSyntaxList<DeclaratorSyntax> declarators;
+
+    ParameterDeclarationSyntax(Token keyword, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators) :
+        ParameterDeclarationBaseSyntax(SyntaxKind::ParameterDeclaration, keyword), type(&type), declarators(declarators) {
+        this->type->parent = this;
+        this->declarators.parent = this;
+        for (auto child : this->declarators)
+            child->parent = this;
+    }
+
+    explicit ParameterDeclarationSyntax(const ParameterDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ParameterDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct EqualsTypeClauseSyntax : public SyntaxNode {
+    Token equals;
+    not_null<DataTypeSyntax*> type;
+
+    EqualsTypeClauseSyntax(Token equals, DataTypeSyntax& type) :
+        SyntaxNode(SyntaxKind::EqualsTypeClause), equals(equals), type(&type) {
+        this->type->parent = this;
+    }
+
+    explicit EqualsTypeClauseSyntax(const EqualsTypeClauseSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EqualsTypeClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TypeAssignmentSyntax : public SyntaxNode {
+    Token name;
+    EqualsTypeClauseSyntax* assignment;
+
+    TypeAssignmentSyntax(Token name, EqualsTypeClauseSyntax* assignment) :
+        SyntaxNode(SyntaxKind::TypeAssignment), name(name), assignment(assignment) {
+        if (this->assignment) this->assignment->parent = this;
+    }
+
+    explicit TypeAssignmentSyntax(const TypeAssignmentSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TypeAssignmentSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TypeParameterDeclarationSyntax : public ParameterDeclarationBaseSyntax {
+    Token typeKeyword;
+    SeparatedSyntaxList<TypeAssignmentSyntax> declarators;
+
+    TypeParameterDeclarationSyntax(Token keyword, Token typeKeyword, const SeparatedSyntaxList<TypeAssignmentSyntax>& declarators) :
+        ParameterDeclarationBaseSyntax(SyntaxKind::TypeParameterDeclaration, keyword), typeKeyword(typeKeyword), declarators(declarators) {
+        this->declarators.parent = this;
+        for (auto child : this->declarators)
+            child->parent = this;
+    }
+
+    explicit TypeParameterDeclarationSyntax(const TypeParameterDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TypeParameterDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ParameterDeclarationStatementSyntax : public MemberSyntax {
+    not_null<ParameterDeclarationBaseSyntax*> parameter;
+    Token semi;
+
+    ParameterDeclarationStatementSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, ParameterDeclarationBaseSyntax& parameter, Token semi) :
+        MemberSyntax(SyntaxKind::ParameterDeclarationStatement, attributes), parameter(&parameter), semi(semi) {
+        this->parameter->parent = this;
+    }
+
+    explicit ParameterDeclarationStatementSyntax(const ParameterDeclarationStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ParameterDeclarationStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PortHeaderSyntax : public SyntaxNode {
+
+    PortHeaderSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit PortHeaderSyntax(const PortHeaderSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct PortDeclarationSyntax : public MemberSyntax {
+    not_null<PortHeaderSyntax*> header;
+    SeparatedSyntaxList<DeclaratorSyntax> declarators;
+    Token semi;
+
+    PortDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, PortHeaderSyntax& header, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) :
+        MemberSyntax(SyntaxKind::PortDeclaration, attributes), header(&header), declarators(declarators), semi(semi) {
+        this->header->parent = this;
+        this->declarators.parent = this;
+        for (auto child : this->declarators)
+            child->parent = this;
+    }
+
+    explicit PortDeclarationSyntax(const PortDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PortDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct GenvarDeclarationSyntax : public MemberSyntax {
+    Token keyword;
+    SeparatedSyntaxList<IdentifierNameSyntax> identifiers;
+    Token semi;
+
+    GenvarDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<IdentifierNameSyntax>& identifiers, Token semi) :
+        MemberSyntax(SyntaxKind::GenvarDeclaration, attributes), keyword(keyword), identifiers(identifiers), semi(semi) {
+        this->identifiers.parent = this;
+        for (auto child : this->identifiers)
+            child->parent = this;
+    }
+
+    explicit GenvarDeclarationSyntax(const GenvarDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    GenvarDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- TYPES -----
+
+struct IntegerTypeSyntax : public DataTypeSyntax {
+    Token keyword;
+    Token signing;
+    SyntaxList<VariableDimensionSyntax> dimensions;
+
+    IntegerTypeSyntax(SyntaxKind kind, Token keyword, Token signing, const SyntaxList<VariableDimensionSyntax>& dimensions) :
+        DataTypeSyntax(kind), keyword(keyword), signing(signing), dimensions(dimensions) {
+        this->dimensions.parent = this;
+        for (auto child : this->dimensions)
+            child->parent = this;
+    }
+
+    explicit IntegerTypeSyntax(const IntegerTypeSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    IntegerTypeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct KeywordTypeSyntax : public DataTypeSyntax {
+    Token keyword;
+
+    KeywordTypeSyntax(SyntaxKind kind, Token keyword) :
+        DataTypeSyntax(kind), keyword(keyword) {
+    }
+
+    explicit KeywordTypeSyntax(const KeywordTypeSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    KeywordTypeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NamedTypeSyntax : public DataTypeSyntax {
+    not_null<NameSyntax*> name;
+
+    NamedTypeSyntax(NameSyntax& name) :
+        DataTypeSyntax(SyntaxKind::NamedType), name(&name) {
+        this->name->parent = this;
+    }
+
+    explicit NamedTypeSyntax(const NamedTypeSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NamedTypeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct StructUnionMemberSyntax : public SyntaxNode {
+    SyntaxList<AttributeInstanceSyntax> attributes;
+    Token randomQualifier;
+    not_null<DataTypeSyntax*> type;
+    SeparatedSyntaxList<DeclaratorSyntax> declarators;
+    Token semi;
+
+    StructUnionMemberSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token randomQualifier, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) :
+        SyntaxNode(SyntaxKind::StructUnionMember), attributes(attributes), randomQualifier(randomQualifier), type(&type), declarators(declarators), semi(semi) {
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+        this->type->parent = this;
+        this->declarators.parent = this;
+        for (auto child : this->declarators)
+            child->parent = this;
+    }
+
+    explicit StructUnionMemberSyntax(const StructUnionMemberSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    StructUnionMemberSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct StructUnionTypeSyntax : public DataTypeSyntax {
+    Token keyword;
+    Token tagged;
+    Token packed;
+    Token signing;
+    Token openBrace;
+    SyntaxList<StructUnionMemberSyntax> members;
+    Token closeBrace;
+    SyntaxList<VariableDimensionSyntax> dimensions;
+
+    StructUnionTypeSyntax(SyntaxKind kind, Token keyword, Token tagged, Token packed, Token signing, Token openBrace, const SyntaxList<StructUnionMemberSyntax>& members, Token closeBrace, const SyntaxList<VariableDimensionSyntax>& dimensions) :
+        DataTypeSyntax(kind), keyword(keyword), tagged(tagged), packed(packed), signing(signing), openBrace(openBrace), members(members), closeBrace(closeBrace), dimensions(dimensions) {
+        this->members.parent = this;
+        for (auto child : this->members)
+            child->parent = this;
+        this->dimensions.parent = this;
+        for (auto child : this->dimensions)
+            child->parent = this;
+    }
+
+    explicit StructUnionTypeSyntax(const StructUnionTypeSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    StructUnionTypeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct EnumTypeSyntax : public DataTypeSyntax {
+    Token keyword;
+    DataTypeSyntax* baseType;
+    Token openBrace;
+    SeparatedSyntaxList<DeclaratorSyntax> members;
+    Token closeBrace;
+    SyntaxList<VariableDimensionSyntax> dimensions;
+
+    EnumTypeSyntax(Token keyword, DataTypeSyntax* baseType, Token openBrace, const SeparatedSyntaxList<DeclaratorSyntax>& members, Token closeBrace, const SyntaxList<VariableDimensionSyntax>& dimensions) :
+        DataTypeSyntax(SyntaxKind::EnumType), keyword(keyword), baseType(baseType), openBrace(openBrace), members(members), closeBrace(closeBrace), dimensions(dimensions) {
+        if (this->baseType) this->baseType->parent = this;
+        this->members.parent = this;
+        for (auto child : this->members)
+            child->parent = this;
+        this->dimensions.parent = this;
+        for (auto child : this->dimensions)
+            child->parent = this;
+    }
+
+    explicit EnumTypeSyntax(const EnumTypeSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EnumTypeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TypeReferenceSyntax : public DataTypeSyntax {
+    Token typeKeyword;
+    Token openParen;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+
+    TypeReferenceSyntax(Token typeKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen) :
+        DataTypeSyntax(SyntaxKind::TypeReference), typeKeyword(typeKeyword), openParen(openParen), expr(&expr), closeParen(closeParen) {
+        this->expr->parent = this;
+    }
+
+    explicit TypeReferenceSyntax(const TypeReferenceSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TypeReferenceSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DotMemberClauseSyntax : public SyntaxNode {
+    Token dot;
+    Token member;
+
+    DotMemberClauseSyntax(Token dot, Token member) :
+        SyntaxNode(SyntaxKind::DotMemberClause), dot(dot), member(member) {
+    }
+
+    explicit DotMemberClauseSyntax(const DotMemberClauseSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DotMemberClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct VirtualInterfaceTypeSyntax : public DataTypeSyntax {
+    Token virtualKeyword;
+    Token interfaceKeyword;
+    Token name;
+    ParameterValueAssignmentSyntax* parameters;
+    DotMemberClauseSyntax* modport;
+
+    VirtualInterfaceTypeSyntax(Token virtualKeyword, Token interfaceKeyword, Token name, ParameterValueAssignmentSyntax* parameters, DotMemberClauseSyntax* modport) :
+        DataTypeSyntax(SyntaxKind::VirtualInterfaceType), virtualKeyword(virtualKeyword), interfaceKeyword(interfaceKeyword), name(name), parameters(parameters), modport(modport) {
+        if (this->parameters) this->parameters->parent = this;
+        if (this->modport) this->modport->parent = this;
+    }
+
+    explicit VirtualInterfaceTypeSyntax(const VirtualInterfaceTypeSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    VirtualInterfaceTypeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ImplicitTypeSyntax : public DataTypeSyntax {
+    Token signing;
+    SyntaxList<VariableDimensionSyntax> dimensions;
+
+    ImplicitTypeSyntax(Token signing, const SyntaxList<VariableDimensionSyntax>& dimensions) :
+        DataTypeSyntax(SyntaxKind::ImplicitType), signing(signing), dimensions(dimensions) {
+        this->dimensions.parent = this;
+        for (auto child : this->dimensions)
+            child->parent = this;
+    }
+
+    explicit ImplicitTypeSyntax(const ImplicitTypeSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ImplicitTypeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- ASSERTIONS -----
+
+struct DeferredAssertionSyntax : public SyntaxNode {
+    Token hash;
+    Token zero;
+    Token finalKeyword;
+
+    DeferredAssertionSyntax(Token hash, Token zero, Token finalKeyword) :
+        SyntaxNode(SyntaxKind::DeferredAssertion), hash(hash), zero(zero), finalKeyword(finalKeyword) {
+    }
+
+    explicit DeferredAssertionSyntax(const DeferredAssertionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DeferredAssertionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ElseClauseSyntax : public SyntaxNode {
+    Token elseKeyword;
+    not_null<SyntaxNode*> clause;
+
+    ElseClauseSyntax(Token elseKeyword, SyntaxNode& clause) :
+        SyntaxNode(SyntaxKind::ElseClause), elseKeyword(elseKeyword), clause(&clause) {
+        this->clause->parent = this;
+    }
+
+    explicit ElseClauseSyntax(const ElseClauseSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ElseClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ActionBlockSyntax : public SyntaxNode {
+    StatementSyntax* statement;
+    ElseClauseSyntax* elseClause;
+
+    ActionBlockSyntax(StatementSyntax* statement, ElseClauseSyntax* elseClause) :
+        SyntaxNode(SyntaxKind::ActionBlock), statement(statement), elseClause(elseClause) {
+        if (this->statement) this->statement->parent = this;
+        if (this->elseClause) this->elseClause->parent = this;
+    }
+
+    explicit ActionBlockSyntax(const ActionBlockSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ActionBlockSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ImmediateAssertionStatementSyntax : public StatementSyntax {
+    Token keyword;
+    DeferredAssertionSyntax* delay;
+    not_null<ParenthesizedExpressionSyntax*> expr;
+    not_null<ActionBlockSyntax*> action;
+
+    ImmediateAssertionStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, DeferredAssertionSyntax* delay, ParenthesizedExpressionSyntax& expr, ActionBlockSyntax& action) :
+        StatementSyntax(kind, label, attributes), keyword(keyword), delay(delay), expr(&expr), action(&action) {
+        if (this->delay) this->delay->parent = this;
+        this->expr->parent = this;
+        this->action->parent = this;
+    }
+
+    explicit ImmediateAssertionStatementSyntax(const ImmediateAssertionStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ImmediateAssertionStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DisableIffSyntax : public SyntaxNode {
+    Token disable;
+    Token iff;
+    Token openParen;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+
+    DisableIffSyntax(Token disable, Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen) :
+        SyntaxNode(SyntaxKind::DisableIff), disable(disable), iff(iff), openParen(openParen), expr(&expr), closeParen(closeParen) {
+        this->expr->parent = this;
+    }
+
+    explicit DisableIffSyntax(const DisableIffSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DisableIffSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PropertySpecSyntax : public SyntaxNode {
+    TimingControlSyntax* clocking;
+    DisableIffSyntax* disable;
+    not_null<ExpressionSyntax*> expr;
+
+    PropertySpecSyntax(TimingControlSyntax* clocking, DisableIffSyntax* disable, ExpressionSyntax& expr) :
+        SyntaxNode(SyntaxKind::PropertySpec), clocking(clocking), disable(disable), expr(&expr) {
+        if (this->clocking) this->clocking->parent = this;
+        if (this->disable) this->disable->parent = this;
+        this->expr->parent = this;
+    }
+
+    explicit PropertySpecSyntax(const PropertySpecSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PropertySpecSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConcurrentAssertionStatementSyntax : public StatementSyntax {
+    Token keyword;
+    Token propertyOrSequence;
+    Token openParen;
+    not_null<PropertySpecSyntax*> propertySpec;
+    Token closeParen;
+    not_null<ActionBlockSyntax*> action;
+
+    ConcurrentAssertionStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token propertyOrSequence, Token openParen, PropertySpecSyntax& propertySpec, Token closeParen, ActionBlockSyntax& action) :
+        StatementSyntax(kind, label, attributes), keyword(keyword), propertyOrSequence(propertyOrSequence), openParen(openParen), propertySpec(&propertySpec), closeParen(closeParen), action(&action) {
+        this->propertySpec->parent = this;
+        this->action->parent = this;
+    }
+
+    explicit ConcurrentAssertionStatementSyntax(const ConcurrentAssertionStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConcurrentAssertionStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConcurrentAssertionMemberSyntax : public MemberSyntax {
+    not_null<ConcurrentAssertionStatementSyntax*> statement;
+
+    ConcurrentAssertionMemberSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, ConcurrentAssertionStatementSyntax& statement) :
+        MemberSyntax(SyntaxKind::ConcurrentAssertionMember, attributes), statement(&statement) {
+        this->statement->parent = this;
+    }
+
+    explicit ConcurrentAssertionMemberSyntax(const ConcurrentAssertionMemberSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConcurrentAssertionMemberSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ImmediateAssertionMemberSyntax : public MemberSyntax {
+    not_null<ImmediateAssertionStatementSyntax*> statement;
+
+    ImmediateAssertionMemberSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, ImmediateAssertionStatementSyntax& statement) :
+        MemberSyntax(SyntaxKind::ImmediateAssertionMember, attributes), statement(&statement) {
+        this->statement->parent = this;
+    }
+
+    explicit ImmediateAssertionMemberSyntax(const ImmediateAssertionMemberSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ImmediateAssertionMemberSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- STATEMENTS -----
+
+struct EmptyStatementSyntax : public StatementSyntax {
+    Token semicolon;
+
+    EmptyStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token semicolon) :
+        StatementSyntax(SyntaxKind::EmptyStatement, label, attributes), semicolon(semicolon) {
+    }
+
+    explicit EmptyStatementSyntax(const EmptyStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EmptyStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConditionalStatementSyntax : public StatementSyntax {
+    Token uniqueOrPriority;
+    Token ifKeyword;
+    Token openParen;
+    not_null<ConditionalPredicateSyntax*> predicate;
+    Token closeParen;
+    not_null<StatementSyntax*> statement;
+    ElseClauseSyntax* elseClause;
+
+    ConditionalStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token uniqueOrPriority, Token ifKeyword, Token openParen, ConditionalPredicateSyntax& predicate, Token closeParen, StatementSyntax& statement, ElseClauseSyntax* elseClause) :
+        StatementSyntax(SyntaxKind::ConditionalStatement, label, attributes), uniqueOrPriority(uniqueOrPriority), ifKeyword(ifKeyword), openParen(openParen), predicate(&predicate), closeParen(closeParen), statement(&statement), elseClause(elseClause) {
+        this->predicate->parent = this;
+        this->statement->parent = this;
+        if (this->elseClause) this->elseClause->parent = this;
+    }
+
+    explicit ConditionalStatementSyntax(const ConditionalStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConditionalStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct CaseItemSyntax : public SyntaxNode {
+
+    CaseItemSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit CaseItemSyntax(const CaseItemSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct DefaultCaseItemSyntax : public CaseItemSyntax {
+    Token defaultKeyword;
+    Token colon;
+    not_null<SyntaxNode*> clause;
+
+    DefaultCaseItemSyntax(Token defaultKeyword, Token colon, SyntaxNode& clause) :
+        CaseItemSyntax(SyntaxKind::DefaultCaseItem), defaultKeyword(defaultKeyword), colon(colon), clause(&clause) {
+        this->clause->parent = this;
+    }
+
+    explicit DefaultCaseItemSyntax(const DefaultCaseItemSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DefaultCaseItemSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PatternCaseItemSyntax : public CaseItemSyntax {
+    not_null<PatternSyntax*> pattern;
+    Token tripleAnd;
+    ExpressionSyntax* expr;
+    Token colon;
+    not_null<StatementSyntax*> statement;
+
+    PatternCaseItemSyntax(PatternSyntax& pattern, Token tripleAnd, ExpressionSyntax* expr, Token colon, StatementSyntax& statement) :
+        CaseItemSyntax(SyntaxKind::PatternCaseItem), pattern(&pattern), tripleAnd(tripleAnd), expr(expr), colon(colon), statement(&statement) {
+        this->pattern->parent = this;
+        if (this->expr) this->expr->parent = this;
+        this->statement->parent = this;
+    }
+
+    explicit PatternCaseItemSyntax(const PatternCaseItemSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PatternCaseItemSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct StandardCaseItemSyntax : public CaseItemSyntax {
+    SeparatedSyntaxList<ExpressionSyntax> expressions;
+    Token colon;
+    not_null<SyntaxNode*> clause;
+
+    StandardCaseItemSyntax(const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token colon, SyntaxNode& clause) :
+        CaseItemSyntax(SyntaxKind::StandardCaseItem), expressions(expressions), colon(colon), clause(&clause) {
+        this->expressions.parent = this;
+        for (auto child : this->expressions)
+            child->parent = this;
+        this->clause->parent = this;
+    }
+
+    explicit StandardCaseItemSyntax(const StandardCaseItemSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    StandardCaseItemSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct CaseStatementSyntax : public StatementSyntax {
+    Token uniqueOrPriority;
+    Token caseKeyword;
+    Token openParen;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+    Token matchesOrInside;
+    SyntaxList<CaseItemSyntax> items;
+    Token endcase;
+
+    CaseStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token uniqueOrPriority, Token caseKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token matchesOrInside, const SyntaxList<CaseItemSyntax>& items, Token endcase) :
+        StatementSyntax(SyntaxKind::CaseStatement, label, attributes), uniqueOrPriority(uniqueOrPriority), caseKeyword(caseKeyword), openParen(openParen), expr(&expr), closeParen(closeParen), matchesOrInside(matchesOrInside), items(items), endcase(endcase) {
+        this->expr->parent = this;
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    explicit CaseStatementSyntax(const CaseStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    CaseStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ForeverStatementSyntax : public StatementSyntax {
+    Token foreverKeyword;
+    not_null<StatementSyntax*> statement;
+
+    ForeverStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token foreverKeyword, StatementSyntax& statement) :
+        StatementSyntax(SyntaxKind::ForeverStatement, label, attributes), foreverKeyword(foreverKeyword), statement(&statement) {
+        this->statement->parent = this;
+    }
+
+    explicit ForeverStatementSyntax(const ForeverStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ForeverStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct LoopStatementSyntax : public StatementSyntax {
+    Token repeatOrWhile;
+    Token openParen;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+    not_null<StatementSyntax*> statement;
+
+    LoopStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token repeatOrWhile, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement) :
+        StatementSyntax(SyntaxKind::LoopStatement, label, attributes), repeatOrWhile(repeatOrWhile), openParen(openParen), expr(&expr), closeParen(closeParen), statement(&statement) {
+        this->expr->parent = this;
+        this->statement->parent = this;
+    }
+
+    explicit LoopStatementSyntax(const LoopStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    LoopStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DoWhileStatementSyntax : public StatementSyntax {
+    Token doKeyword;
+    not_null<StatementSyntax*> statement;
+    Token whileKeyword;
+    Token openParen;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+    Token semi;
+
+    DoWhileStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token doKeyword, StatementSyntax& statement, Token whileKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi) :
+        StatementSyntax(SyntaxKind::DoWhileStatement, label, attributes), doKeyword(doKeyword), statement(&statement), whileKeyword(whileKeyword), openParen(openParen), expr(&expr), closeParen(closeParen), semi(semi) {
+        this->statement->parent = this;
+        this->expr->parent = this;
+    }
+
+    explicit DoWhileStatementSyntax(const DoWhileStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DoWhileStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ForVariableDeclarationSyntax : public SyntaxNode {
+    Token varKeyword;
+    DataTypeSyntax* type;
+    not_null<DeclaratorSyntax*> declarator;
+
+    ForVariableDeclarationSyntax(Token varKeyword, DataTypeSyntax* type, DeclaratorSyntax& declarator) :
+        SyntaxNode(SyntaxKind::ForVariableDeclaration), varKeyword(varKeyword), type(type), declarator(&declarator) {
+        if (this->type) this->type->parent = this;
+        this->declarator->parent = this;
+    }
+
+    explicit ForVariableDeclarationSyntax(const ForVariableDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ForVariableDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ForLoopStatementSyntax : public StatementSyntax {
+    Token forKeyword;
+    Token openParen;
+    SeparatedSyntaxList<SyntaxNode> initializers;
+    Token semi1;
+    not_null<ExpressionSyntax*> stopExpr;
+    Token semi2;
+    SeparatedSyntaxList<ExpressionSyntax> steps;
+    Token closeParen;
+    not_null<StatementSyntax*> statement;
+
+    ForLoopStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token forKeyword, Token openParen, const SeparatedSyntaxList<SyntaxNode>& initializers, Token semi1, ExpressionSyntax& stopExpr, Token semi2, const SeparatedSyntaxList<ExpressionSyntax>& steps, Token closeParen, StatementSyntax& statement) :
+        StatementSyntax(SyntaxKind::ForLoopStatement, label, attributes), forKeyword(forKeyword), openParen(openParen), initializers(initializers), semi1(semi1), stopExpr(&stopExpr), semi2(semi2), steps(steps), closeParen(closeParen), statement(&statement) {
+        this->initializers.parent = this;
+        for (auto child : this->initializers)
+            child->parent = this;
+        this->stopExpr->parent = this;
+        this->steps.parent = this;
+        for (auto child : this->steps)
+            child->parent = this;
+        this->statement->parent = this;
+    }
+
+    explicit ForLoopStatementSyntax(const ForLoopStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ForLoopStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ForeachLoopListSyntax : public SyntaxNode {
+    Token openParen;
+    not_null<NameSyntax*> arrayName;
+    Token openBracket;
+    SeparatedSyntaxList<NameSyntax> loopVariables;
+    Token closeBracket;
+    Token closeParen;
+
+    ForeachLoopListSyntax(Token openParen, NameSyntax& arrayName, Token openBracket, const SeparatedSyntaxList<NameSyntax>& loopVariables, Token closeBracket, Token closeParen) :
+        SyntaxNode(SyntaxKind::ForeachLoopList), openParen(openParen), arrayName(&arrayName), openBracket(openBracket), loopVariables(loopVariables), closeBracket(closeBracket), closeParen(closeParen) {
+        this->arrayName->parent = this;
+        this->loopVariables.parent = this;
+        for (auto child : this->loopVariables)
+            child->parent = this;
+    }
+
+    explicit ForeachLoopListSyntax(const ForeachLoopListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ForeachLoopListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ForeachLoopStatementSyntax : public StatementSyntax {
+    Token keyword;
+    not_null<ForeachLoopListSyntax*> loopList;
+    not_null<StatementSyntax*> statement;
+
+    ForeachLoopStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ForeachLoopListSyntax& loopList, StatementSyntax& statement) :
+        StatementSyntax(SyntaxKind::ForeachLoopStatement, label, attributes), keyword(keyword), loopList(&loopList), statement(&statement) {
+        this->loopList->parent = this;
+        this->statement->parent = this;
+    }
+
+    explicit ForeachLoopStatementSyntax(const ForeachLoopStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ForeachLoopStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ReturnStatementSyntax : public StatementSyntax {
+    Token returnKeyword;
+    ExpressionSyntax* returnValue;
+    Token semi;
+
+    ReturnStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token returnKeyword, ExpressionSyntax* returnValue, Token semi) :
+        StatementSyntax(SyntaxKind::ReturnStatement, label, attributes), returnKeyword(returnKeyword), returnValue(returnValue), semi(semi) {
+        if (this->returnValue) this->returnValue->parent = this;
+    }
+
+    explicit ReturnStatementSyntax(const ReturnStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ReturnStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct JumpStatementSyntax : public StatementSyntax {
+    Token breakOrContinue;
+    Token semi;
+
+    JumpStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token breakOrContinue, Token semi) :
+        StatementSyntax(SyntaxKind::JumpStatement, label, attributes), breakOrContinue(breakOrContinue), semi(semi) {
+    }
+
+    explicit JumpStatementSyntax(const JumpStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    JumpStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TimingControlStatementSyntax : public StatementSyntax {
+    not_null<TimingControlSyntax*> timingControl;
+    not_null<StatementSyntax*> statement;
+
+    TimingControlStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, TimingControlSyntax& timingControl, StatementSyntax& statement) :
+        StatementSyntax(SyntaxKind::TimingControlStatement, label, attributes), timingControl(&timingControl), statement(&statement) {
+        this->timingControl->parent = this;
+        this->statement->parent = this;
+    }
+
+    explicit TimingControlStatementSyntax(const TimingControlStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TimingControlStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ExpressionStatementSyntax : public StatementSyntax {
+    not_null<ExpressionSyntax*> expr;
+    Token semi;
+
+    ExpressionStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& expr, Token semi) :
+        StatementSyntax(SyntaxKind::ExpressionStatement, label, attributes), expr(&expr), semi(semi) {
+        this->expr->parent = this;
+    }
+
+    explicit ExpressionStatementSyntax(const ExpressionStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ExpressionStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct VoidCastedCallStatementSyntax : public StatementSyntax {
+    Token voidKeyword;
+    Token apostrophe;
+    Token openParen;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+    Token semi;
+
+    VoidCastedCallStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token voidKeyword, Token apostrophe, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi) :
+        StatementSyntax(SyntaxKind::VoidCastedCallStatement, label, attributes), voidKeyword(voidKeyword), apostrophe(apostrophe), openParen(openParen), expr(&expr), closeParen(closeParen), semi(semi) {
+        this->expr->parent = this;
+    }
+
+    explicit VoidCastedCallStatementSyntax(const VoidCastedCallStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    VoidCastedCallStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ProceduralAssignStatementSyntax : public StatementSyntax {
+    Token keyword;
+    not_null<ExpressionSyntax*> expr;
+    Token semi;
+
+    ProceduralAssignStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ExpressionSyntax& expr, Token semi) :
+        StatementSyntax(kind, label, attributes), keyword(keyword), expr(&expr), semi(semi) {
+        this->expr->parent = this;
+    }
+
+    explicit ProceduralAssignStatementSyntax(const ProceduralAssignStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ProceduralAssignStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ProceduralDeassignStatementSyntax : public StatementSyntax {
+    Token keyword;
+    not_null<ExpressionSyntax*> variable;
+    Token semi;
+
+    ProceduralDeassignStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ExpressionSyntax& variable, Token semi) :
+        StatementSyntax(kind, label, attributes), keyword(keyword), variable(&variable), semi(semi) {
+        this->variable->parent = this;
+    }
+
+    explicit ProceduralDeassignStatementSyntax(const ProceduralDeassignStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ProceduralDeassignStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DisableStatementSyntax : public StatementSyntax {
+    Token disable;
+    not_null<NameSyntax*> name;
+    Token semi;
+
+    DisableStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token disable, NameSyntax& name, Token semi) :
+        StatementSyntax(SyntaxKind::DisableStatement, label, attributes), disable(disable), name(&name), semi(semi) {
+        this->name->parent = this;
+    }
+
+    explicit DisableStatementSyntax(const DisableStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DisableStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DisableForkStatementSyntax : public StatementSyntax {
+    Token disable;
+    Token fork;
+    Token semi;
+
+    DisableForkStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token disable, Token fork, Token semi) :
+        StatementSyntax(SyntaxKind::DisableForkStatement, label, attributes), disable(disable), fork(fork), semi(semi) {
+    }
+
+    explicit DisableForkStatementSyntax(const DisableForkStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DisableForkStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NamedBlockClauseSyntax : public SyntaxNode {
+    Token colon;
+    Token name;
+
+    NamedBlockClauseSyntax(Token colon, Token name) :
+        SyntaxNode(SyntaxKind::NamedBlockClause), colon(colon), name(name) {
+    }
+
+    explicit NamedBlockClauseSyntax(const NamedBlockClauseSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NamedBlockClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct BlockStatementSyntax : public StatementSyntax {
+    Token begin;
+    NamedBlockClauseSyntax* blockName;
+    SyntaxList<SyntaxNode> items;
+    Token end;
+    NamedBlockClauseSyntax* endBlockName;
+
+    BlockStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token begin, NamedBlockClauseSyntax* blockName, const SyntaxList<SyntaxNode>& items, Token end, NamedBlockClauseSyntax* endBlockName) :
+        StatementSyntax(kind, label, attributes), begin(begin), blockName(blockName), items(items), end(end), endBlockName(endBlockName) {
+        if (this->blockName) this->blockName->parent = this;
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+        if (this->endBlockName) this->endBlockName->parent = this;
+    }
+
+    explicit BlockStatementSyntax(const BlockStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    BlockStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct WaitStatementSyntax : public StatementSyntax {
+    Token wait;
+    Token openParen;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+    not_null<StatementSyntax*> statement;
+
+    WaitStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement) :
+        StatementSyntax(SyntaxKind::WaitStatement, label, attributes), wait(wait), openParen(openParen), expr(&expr), closeParen(closeParen), statement(&statement) {
+        this->expr->parent = this;
+        this->statement->parent = this;
+    }
+
+    explicit WaitStatementSyntax(const WaitStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WaitStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct WaitForkStatementSyntax : public StatementSyntax {
+    Token wait;
+    Token fork;
+    Token semi;
+
+    WaitForkStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait, Token fork, Token semi) :
+        StatementSyntax(SyntaxKind::WaitForkStatement, label, attributes), wait(wait), fork(fork), semi(semi) {
+    }
+
+    explicit WaitForkStatementSyntax(const WaitForkStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WaitForkStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct WaitOrderStatementSyntax : public StatementSyntax {
+    Token wait_order;
+    Token openParen;
+    SeparatedSyntaxList<NameSyntax> names;
+    Token closeParen;
+    not_null<ActionBlockSyntax*> action;
+
+    WaitOrderStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait_order, Token openParen, const SeparatedSyntaxList<NameSyntax>& names, Token closeParen, ActionBlockSyntax& action) :
+        StatementSyntax(SyntaxKind::WaitOrderStatement, label, attributes), wait_order(wait_order), openParen(openParen), names(names), closeParen(closeParen), action(&action) {
+        this->names.parent = this;
+        for (auto child : this->names)
+            child->parent = this;
+        this->action->parent = this;
+    }
+
+    explicit WaitOrderStatementSyntax(const WaitOrderStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WaitOrderStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct RandCaseItemSyntax : public SyntaxNode {
+    not_null<ExpressionSyntax*> expr;
+    Token colon;
+    not_null<StatementSyntax*> statement;
+
+    RandCaseItemSyntax(ExpressionSyntax& expr, Token colon, StatementSyntax& statement) :
+        SyntaxNode(SyntaxKind::RandCaseItem), expr(&expr), colon(colon), statement(&statement) {
+        this->expr->parent = this;
+        this->statement->parent = this;
+    }
+
+    explicit RandCaseItemSyntax(const RandCaseItemSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    RandCaseItemSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct RandCaseStatementSyntax : public StatementSyntax {
+    Token randCase;
+    SyntaxList<RandCaseItemSyntax> items;
+    Token endCase;
+
+    RandCaseStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token randCase, const SyntaxList<RandCaseItemSyntax>& items, Token endCase) :
+        StatementSyntax(SyntaxKind::RandCaseStatement, label, attributes), randCase(randCase), items(items), endCase(endCase) {
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    explicit RandCaseStatementSyntax(const RandCaseStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    RandCaseStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct EventTriggerStatementSyntax : public StatementSyntax {
+    Token trigger;
+    TimingControlSyntax* timing;
+    not_null<NameSyntax*> name;
+    Token semi;
+
+    EventTriggerStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token trigger, TimingControlSyntax* timing, NameSyntax& name, Token semi) :
+        StatementSyntax(kind, label, attributes), trigger(trigger), timing(timing), name(&name), semi(semi) {
+        if (this->timing) this->timing->parent = this;
+        this->name->parent = this;
+    }
+
+    explicit EventTriggerStatementSyntax(const EventTriggerStatementSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EventTriggerStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- MODULES -----
+
+struct PortListSyntax : public SyntaxNode {
+
+    PortListSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit PortListSyntax(const PortListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct NonAnsiPortSyntax : public SyntaxNode {
+
+    NonAnsiPortSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit NonAnsiPortSyntax(const NonAnsiPortSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct PortExpressionSyntax : public SyntaxNode {
+
+    PortExpressionSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit PortExpressionSyntax(const PortExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct PortReferenceSyntax : public PortExpressionSyntax {
+    Token name;
+    ElementSelectSyntax* select;
+
+    PortReferenceSyntax(Token name, ElementSelectSyntax* select) :
+        PortExpressionSyntax(SyntaxKind::PortReference), name(name), select(select) {
+        if (this->select) this->select->parent = this;
+    }
+
+    explicit PortReferenceSyntax(const PortReferenceSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PortReferenceSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PortConcatenationSyntax : public PortExpressionSyntax {
+    Token openBrace;
+    SeparatedSyntaxList<PortReferenceSyntax> references;
+    Token closeBrace;
+
+    PortConcatenationSyntax(Token openBrace, const SeparatedSyntaxList<PortReferenceSyntax>& references, Token closeBrace) :
+        PortExpressionSyntax(SyntaxKind::PortConcatenation), openBrace(openBrace), references(references), closeBrace(closeBrace) {
+        this->references.parent = this;
+        for (auto child : this->references)
+            child->parent = this;
+    }
+
+    explicit PortConcatenationSyntax(const PortConcatenationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PortConcatenationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ImplicitNonAnsiPortSyntax : public NonAnsiPortSyntax {
+    PortExpressionSyntax* expr;
+
+    ImplicitNonAnsiPortSyntax(PortExpressionSyntax* expr) :
+        NonAnsiPortSyntax(SyntaxKind::ImplicitNonAnsiPort), expr(expr) {
+        if (this->expr) this->expr->parent = this;
+    }
+
+    explicit ImplicitNonAnsiPortSyntax(const ImplicitNonAnsiPortSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ImplicitNonAnsiPortSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ExplicitNonAnsiPortSyntax : public NonAnsiPortSyntax {
+    Token dot;
+    Token name;
+    Token openParen;
+    PortExpressionSyntax* expr;
+    Token closeParen;
+
+    ExplicitNonAnsiPortSyntax(Token dot, Token name, Token openParen, PortExpressionSyntax* expr, Token closeParen) :
+        NonAnsiPortSyntax(SyntaxKind::ExplicitNonAnsiPort), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
+        if (this->expr) this->expr->parent = this;
+    }
+
+    explicit ExplicitNonAnsiPortSyntax(const ExplicitNonAnsiPortSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ExplicitNonAnsiPortSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NonAnsiPortListSyntax : public PortListSyntax {
+    Token openParen;
+    SeparatedSyntaxList<NonAnsiPortSyntax> ports;
+    Token closeParen;
+
+    NonAnsiPortListSyntax(Token openParen, const SeparatedSyntaxList<NonAnsiPortSyntax>& ports, Token closeParen) :
+        PortListSyntax(SyntaxKind::NonAnsiPortList), openParen(openParen), ports(ports), closeParen(closeParen) {
+        this->ports.parent = this;
+        for (auto child : this->ports)
+            child->parent = this;
+    }
+
+    explicit NonAnsiPortListSyntax(const NonAnsiPortListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NonAnsiPortListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct InterfacePortHeaderSyntax : public PortHeaderSyntax {
+    Token nameOrKeyword;
+    DotMemberClauseSyntax* modport;
+
+    InterfacePortHeaderSyntax(Token nameOrKeyword, DotMemberClauseSyntax* modport) :
+        PortHeaderSyntax(SyntaxKind::InterfacePortHeader), nameOrKeyword(nameOrKeyword), modport(modport) {
+        if (this->modport) this->modport->parent = this;
+    }
+
+    explicit InterfacePortHeaderSyntax(const InterfacePortHeaderSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    InterfacePortHeaderSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct VariablePortHeaderSyntax : public PortHeaderSyntax {
+    Token constKeyword;
+    Token direction;
+    Token varKeyword;
+    not_null<DataTypeSyntax*> dataType;
+
+    VariablePortHeaderSyntax(Token constKeyword, Token direction, Token varKeyword, DataTypeSyntax& dataType) :
+        PortHeaderSyntax(SyntaxKind::VariablePortHeader), constKeyword(constKeyword), direction(direction), varKeyword(varKeyword), dataType(&dataType) {
+        this->dataType->parent = this;
+    }
+
+    explicit VariablePortHeaderSyntax(const VariablePortHeaderSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    VariablePortHeaderSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct InterconnectPortHeaderSyntax : public PortHeaderSyntax {
+    Token direction;
+    Token interconnect;
+    not_null<ImplicitTypeSyntax*> type;
+
+    InterconnectPortHeaderSyntax(Token direction, Token interconnect, ImplicitTypeSyntax& type) :
+        PortHeaderSyntax(SyntaxKind::InterconnectPortHeader), direction(direction), interconnect(interconnect), type(&type) {
+        this->type->parent = this;
+    }
+
+    explicit InterconnectPortHeaderSyntax(const InterconnectPortHeaderSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    InterconnectPortHeaderSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NetPortHeaderSyntax : public PortHeaderSyntax {
+    Token direction;
+    Token netType;
+    not_null<DataTypeSyntax*> dataType;
+
+    NetPortHeaderSyntax(Token direction, Token netType, DataTypeSyntax& dataType) :
+        PortHeaderSyntax(SyntaxKind::NetPortHeader), direction(direction), netType(netType), dataType(&dataType) {
+        this->dataType->parent = this;
+    }
+
+    explicit NetPortHeaderSyntax(const NetPortHeaderSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NetPortHeaderSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ImplicitAnsiPortSyntax : public MemberSyntax {
+    not_null<PortHeaderSyntax*> header;
+    not_null<DeclaratorSyntax*> declarator;
+
+    ImplicitAnsiPortSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, PortHeaderSyntax& header, DeclaratorSyntax& declarator) :
+        MemberSyntax(SyntaxKind::ImplicitAnsiPort, attributes), header(&header), declarator(&declarator) {
+        this->header->parent = this;
+        this->declarator->parent = this;
+    }
+
+    explicit ImplicitAnsiPortSyntax(const ImplicitAnsiPortSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ImplicitAnsiPortSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ExplicitAnsiPortSyntax : public MemberSyntax {
+    Token direction;
+    Token dot;
+    Token name;
+    Token openParen;
+    ExpressionSyntax* expr;
+    Token closeParen;
+
+    ExplicitAnsiPortSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token direction, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
+        MemberSyntax(SyntaxKind::ExplicitAnsiPort, attributes), direction(direction), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
+        if (this->expr) this->expr->parent = this;
+    }
+
+    explicit ExplicitAnsiPortSyntax(const ExplicitAnsiPortSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ExplicitAnsiPortSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct AnsiPortListSyntax : public PortListSyntax {
+    Token openParen;
+    SeparatedSyntaxList<MemberSyntax> ports;
+    Token closeParen;
+
+    AnsiPortListSyntax(Token openParen, const SeparatedSyntaxList<MemberSyntax>& ports, Token closeParen) :
+        PortListSyntax(SyntaxKind::AnsiPortList), openParen(openParen), ports(ports), closeParen(closeParen) {
+        this->ports.parent = this;
+        for (auto child : this->ports)
+            child->parent = this;
+    }
+
+    explicit AnsiPortListSyntax(const AnsiPortListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    AnsiPortListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct WildcardPortListSyntax : public PortListSyntax {
+    Token openParen;
+    Token dotStar;
+    Token closeParen;
+
+    WildcardPortListSyntax(Token openParen, Token dotStar, Token closeParen) :
+        PortListSyntax(SyntaxKind::WildcardPortList), openParen(openParen), dotStar(dotStar), closeParen(closeParen) {
+    }
+
+    explicit WildcardPortListSyntax(const WildcardPortListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WildcardPortListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ParameterPortListSyntax : public SyntaxNode {
+    Token hash;
+    Token openParen;
+    SeparatedSyntaxList<ParameterDeclarationBaseSyntax> declarations;
+    Token closeParen;
+
+    ParameterPortListSyntax(Token hash, Token openParen, const SeparatedSyntaxList<ParameterDeclarationBaseSyntax>& declarations, Token closeParen) :
+        SyntaxNode(SyntaxKind::ParameterPortList), hash(hash), openParen(openParen), declarations(declarations), closeParen(closeParen) {
+        this->declarations.parent = this;
+        for (auto child : this->declarations)
+            child->parent = this;
+    }
+
+    explicit ParameterPortListSyntax(const ParameterPortListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ParameterPortListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ModuleHeaderSyntax : public SyntaxNode {
+    Token moduleKeyword;
+    Token lifetime;
+    Token name;
+    SyntaxList<PackageImportDeclarationSyntax> imports;
+    ParameterPortListSyntax* parameters;
+    PortListSyntax* ports;
+    Token semi;
+
+    ModuleHeaderSyntax(SyntaxKind kind, Token moduleKeyword, Token lifetime, Token name, const SyntaxList<PackageImportDeclarationSyntax>& imports, ParameterPortListSyntax* parameters, PortListSyntax* ports, Token semi) :
+        SyntaxNode(kind), moduleKeyword(moduleKeyword), lifetime(lifetime), name(name), imports(imports), parameters(parameters), ports(ports), semi(semi) {
+        this->imports.parent = this;
+        for (auto child : this->imports)
+            child->parent = this;
+        if (this->parameters) this->parameters->parent = this;
+        if (this->ports) this->ports->parent = this;
+    }
+
+    explicit ModuleHeaderSyntax(const ModuleHeaderSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ModuleHeaderSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ModuleDeclarationSyntax : public MemberSyntax {
+    not_null<ModuleHeaderSyntax*> header;
+    SyntaxList<MemberSyntax> members;
+    Token endmodule;
+    NamedBlockClauseSyntax* blockName;
+
+    ModuleDeclarationSyntax(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, ModuleHeaderSyntax& header, const SyntaxList<MemberSyntax>& members, Token endmodule, NamedBlockClauseSyntax* blockName) :
+        MemberSyntax(kind, attributes), header(&header), members(members), endmodule(endmodule), blockName(blockName) {
+        this->header->parent = this;
+        this->members.parent = this;
+        for (auto child : this->members)
+            child->parent = this;
+        if (this->blockName) this->blockName->parent = this;
+    }
+
+    explicit ModuleDeclarationSyntax(const ModuleDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ModuleDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ExternModuleSyntax : public SyntaxNode {
+    Token externKeyword;
+    not_null<ModuleHeaderSyntax*> header;
+
+    ExternModuleSyntax(Token externKeyword, ModuleHeaderSyntax& header) :
+        SyntaxNode(SyntaxKind::ExternModule), externKeyword(externKeyword), header(&header) {
+        this->header->parent = this;
+    }
+
+    explicit ExternModuleSyntax(const ExternModuleSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ExternModuleSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- MEMBERS -----
+
+struct EmptyMemberSyntax : public MemberSyntax {
+    TokenList qualifiers;
+    Token semi;
+
+    EmptyMemberSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token semi) :
+        MemberSyntax(SyntaxKind::EmptyMember, attributes), qualifiers(qualifiers), semi(semi) {
+        this->qualifiers.parent = this;
+    }
+
+    explicit EmptyMemberSyntax(const EmptyMemberSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EmptyMemberSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ProceduralBlockSyntax : public MemberSyntax {
+    Token keyword;
+    not_null<StatementSyntax*> statement;
+
+    ProceduralBlockSyntax(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, StatementSyntax& statement) :
+        MemberSyntax(kind, attributes), keyword(keyword), statement(&statement) {
+        this->statement->parent = this;
+    }
+
+    explicit ProceduralBlockSyntax(const ProceduralBlockSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ProceduralBlockSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct GenerateRegionSyntax : public MemberSyntax {
+    Token keyword;
+    SyntaxList<MemberSyntax> members;
+    Token endgenerate;
+
+    GenerateRegionSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SyntaxList<MemberSyntax>& members, Token endgenerate) :
+        MemberSyntax(SyntaxKind::GenerateRegion, attributes), keyword(keyword), members(members), endgenerate(endgenerate) {
+        this->members.parent = this;
+        for (auto child : this->members)
+            child->parent = this;
+    }
+
+    explicit GenerateRegionSyntax(const GenerateRegionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    GenerateRegionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct LoopGenerateSyntax : public MemberSyntax {
+    Token keyword;
+    Token openParen;
+    Token genvar;
+    Token identifier;
+    Token equals;
+    not_null<ExpressionSyntax*> initialExpr;
+    Token semi1;
+    not_null<ExpressionSyntax*> stopExpr;
+    Token semi2;
+    not_null<ExpressionSyntax*> iterationExpr;
+    Token closeParen;
+    not_null<MemberSyntax*> block;
+
+    LoopGenerateSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, Token genvar, Token identifier, Token equals, ExpressionSyntax& initialExpr, Token semi1, ExpressionSyntax& stopExpr, Token semi2, ExpressionSyntax& iterationExpr, Token closeParen, MemberSyntax& block) :
+        MemberSyntax(SyntaxKind::LoopGenerate, attributes), keyword(keyword), openParen(openParen), genvar(genvar), identifier(identifier), equals(equals), initialExpr(&initialExpr), semi1(semi1), stopExpr(&stopExpr), semi2(semi2), iterationExpr(&iterationExpr), closeParen(closeParen), block(&block) {
+        this->initialExpr->parent = this;
+        this->stopExpr->parent = this;
+        this->iterationExpr->parent = this;
+        this->block->parent = this;
+    }
+
+    explicit LoopGenerateSyntax(const LoopGenerateSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    LoopGenerateSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct IfGenerateSyntax : public MemberSyntax {
+    Token keyword;
+    Token openParen;
+    not_null<ExpressionSyntax*> condition;
+    Token closeParen;
+    not_null<MemberSyntax*> block;
+    ElseClauseSyntax* elseClause;
+
+    IfGenerateSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, MemberSyntax& block, ElseClauseSyntax* elseClause) :
+        MemberSyntax(SyntaxKind::IfGenerate, attributes), keyword(keyword), openParen(openParen), condition(&condition), closeParen(closeParen), block(&block), elseClause(elseClause) {
+        this->condition->parent = this;
+        this->block->parent = this;
+        if (this->elseClause) this->elseClause->parent = this;
+    }
+
+    explicit IfGenerateSyntax(const IfGenerateSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    IfGenerateSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct CaseGenerateSyntax : public MemberSyntax {
+    Token keyword;
+    Token openParen;
+    not_null<ExpressionSyntax*> condition;
+    Token closeParen;
+    SyntaxList<CaseItemSyntax> items;
+    Token endCase;
+
+    CaseGenerateSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, const SyntaxList<CaseItemSyntax>& items, Token endCase) :
+        MemberSyntax(SyntaxKind::CaseGenerate, attributes), keyword(keyword), openParen(openParen), condition(&condition), closeParen(closeParen), items(items), endCase(endCase) {
+        this->condition->parent = this;
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    explicit CaseGenerateSyntax(const CaseGenerateSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    CaseGenerateSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct GenerateBlockSyntax : public MemberSyntax {
+    NamedLabelSyntax* label;
+    Token begin;
+    NamedBlockClauseSyntax* beginName;
+    SyntaxList<MemberSyntax> members;
+    Token end;
+    NamedBlockClauseSyntax* endName;
+
+    GenerateBlockSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, NamedLabelSyntax* label, Token begin, NamedBlockClauseSyntax* beginName, const SyntaxList<MemberSyntax>& members, Token end, NamedBlockClauseSyntax* endName) :
+        MemberSyntax(SyntaxKind::GenerateBlock, attributes), label(label), begin(begin), beginName(beginName), members(members), end(end), endName(endName) {
+        if (this->label) this->label->parent = this;
+        if (this->beginName) this->beginName->parent = this;
+        this->members.parent = this;
+        for (auto child : this->members)
+            child->parent = this;
+        if (this->endName) this->endName->parent = this;
+    }
+
+    explicit GenerateBlockSyntax(const GenerateBlockSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    GenerateBlockSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DividerClauseSyntax : public SyntaxNode {
+    Token divide;
+    Token value;
+
+    DividerClauseSyntax(Token divide, Token value) :
+        SyntaxNode(SyntaxKind::DividerClause), divide(divide), value(value) {
+    }
+
+    explicit DividerClauseSyntax(const DividerClauseSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DividerClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TimeUnitsDeclarationSyntax : public MemberSyntax {
+    Token keyword;
+    Token time;
+    DividerClauseSyntax* divider;
+    Token semi;
+
+    TimeUnitsDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token time, DividerClauseSyntax* divider, Token semi) :
+        MemberSyntax(SyntaxKind::TimeUnitsDeclaration, attributes), keyword(keyword), time(time), divider(divider), semi(semi) {
+        if (this->divider) this->divider->parent = this;
+    }
+
+    explicit TimeUnitsDeclarationSyntax(const TimeUnitsDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TimeUnitsDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PortConnectionSyntax : public SyntaxNode {
+    SyntaxList<AttributeInstanceSyntax> attributes;
+
+    PortConnectionSyntax(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes) :
+        SyntaxNode(kind), attributes(attributes) {
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+    }
+
+    explicit PortConnectionSyntax(const PortConnectionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PortConnectionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct EmptyPortConnectionSyntax : public PortConnectionSyntax {
+    Token placeholder;
+
+    EmptyPortConnectionSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token placeholder) :
+        PortConnectionSyntax(SyntaxKind::EmptyPortConnection, attributes), placeholder(placeholder) {
+    }
+
+    explicit EmptyPortConnectionSyntax(const EmptyPortConnectionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EmptyPortConnectionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct OrderedPortConnectionSyntax : public PortConnectionSyntax {
+    not_null<ExpressionSyntax*> expr;
+
+    OrderedPortConnectionSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& expr) :
+        PortConnectionSyntax(SyntaxKind::OrderedPortConnection, attributes), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    explicit OrderedPortConnectionSyntax(const OrderedPortConnectionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    OrderedPortConnectionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NamedPortConnectionSyntax : public PortConnectionSyntax {
+    Token dot;
+    Token name;
+    Token openParen;
+    ExpressionSyntax* expr;
+    Token closeParen;
+
+    NamedPortConnectionSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
+        PortConnectionSyntax(SyntaxKind::NamedPortConnection, attributes), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
+        if (this->expr) this->expr->parent = this;
+    }
+
+    explicit NamedPortConnectionSyntax(const NamedPortConnectionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NamedPortConnectionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct WildcardPortConnectionSyntax : public PortConnectionSyntax {
+    Token dotStar;
+
+    WildcardPortConnectionSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token dotStar) :
+        PortConnectionSyntax(SyntaxKind::WildcardPortConnection, attributes), dotStar(dotStar) {
+    }
+
+    explicit WildcardPortConnectionSyntax(const WildcardPortConnectionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WildcardPortConnectionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct HierarchicalInstanceSyntax : public SyntaxNode {
+    Token name;
+    SyntaxList<VariableDimensionSyntax> dimensions;
+    Token openParen;
+    SeparatedSyntaxList<PortConnectionSyntax> connections;
+    Token closeParen;
+
+    HierarchicalInstanceSyntax(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, Token openParen, const SeparatedSyntaxList<PortConnectionSyntax>& connections, Token closeParen) :
+        SyntaxNode(SyntaxKind::HierarchicalInstance), name(name), dimensions(dimensions), openParen(openParen), connections(connections), closeParen(closeParen) {
+        this->dimensions.parent = this;
+        for (auto child : this->dimensions)
+            child->parent = this;
+        this->connections.parent = this;
+        for (auto child : this->connections)
+            child->parent = this;
+    }
+
+    explicit HierarchicalInstanceSyntax(const HierarchicalInstanceSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    HierarchicalInstanceSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct HierarchyInstantiationSyntax : public MemberSyntax {
+    Token type;
+    ParameterValueAssignmentSyntax* parameters;
+    SeparatedSyntaxList<HierarchicalInstanceSyntax> instances;
+    Token semi;
+
+    HierarchyInstantiationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token type, ParameterValueAssignmentSyntax* parameters, const SeparatedSyntaxList<HierarchicalInstanceSyntax>& instances, Token semi) :
+        MemberSyntax(SyntaxKind::HierarchyInstantiation, attributes), type(type), parameters(parameters), instances(instances), semi(semi) {
+        if (this->parameters) this->parameters->parent = this;
+        this->instances.parent = this;
+        for (auto child : this->instances)
+            child->parent = this;
+    }
+
+    explicit HierarchyInstantiationSyntax(const HierarchyInstantiationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    HierarchyInstantiationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct BindTargetListSyntax : public SyntaxNode {
+    Token colon;
+    SeparatedSyntaxList<NameSyntax> targets;
+
+    BindTargetListSyntax(Token colon, const SeparatedSyntaxList<NameSyntax>& targets) :
+        SyntaxNode(SyntaxKind::BindTargetList), colon(colon), targets(targets) {
+        this->targets.parent = this;
+        for (auto child : this->targets)
+            child->parent = this;
+    }
+
+    explicit BindTargetListSyntax(const BindTargetListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    BindTargetListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct BindDirectiveSyntax : public MemberSyntax {
+    Token bind;
+    not_null<NameSyntax*> target;
+    BindTargetListSyntax* targetInstances;
+    not_null<HierarchyInstantiationSyntax*> instantiation;
+
+    BindDirectiveSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token bind, NameSyntax& target, BindTargetListSyntax* targetInstances, HierarchyInstantiationSyntax& instantiation) :
+        MemberSyntax(SyntaxKind::BindDirective, attributes), bind(bind), target(&target), targetInstances(targetInstances), instantiation(&instantiation) {
+        this->target->parent = this;
+        if (this->targetInstances) this->targetInstances->parent = this;
+        this->instantiation->parent = this;
+    }
+
+    explicit BindDirectiveSyntax(const BindDirectiveSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    BindDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct GateInstanceNameSyntax : public SyntaxNode {
+    Token name;
+    SyntaxList<VariableDimensionSyntax> dimensions;
+
+    GateInstanceNameSyntax(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions) :
+        SyntaxNode(SyntaxKind::GateInstanceName), name(name), dimensions(dimensions) {
+        this->dimensions.parent = this;
+        for (auto child : this->dimensions)
+            child->parent = this;
+    }
+
+    explicit GateInstanceNameSyntax(const GateInstanceNameSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    GateInstanceNameSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct GateInstanceSyntax : public SyntaxNode {
+    GateInstanceNameSyntax* decl;
+    Token openParen;
+    SeparatedSyntaxList<ExpressionSyntax> connections;
+    Token closeParen;
+
+    GateInstanceSyntax(GateInstanceNameSyntax* decl, Token openParen, const SeparatedSyntaxList<ExpressionSyntax>& connections, Token closeParen) :
+        SyntaxNode(SyntaxKind::GateInstance), decl(decl), openParen(openParen), connections(connections), closeParen(closeParen) {
+        if (this->decl) this->decl->parent = this;
+        this->connections.parent = this;
+        for (auto child : this->connections)
+            child->parent = this;
+    }
+
+    explicit GateInstanceSyntax(const GateInstanceSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    GateInstanceSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct GateInstantiationSyntax : public MemberSyntax {
+    Token gateType;
+    DriveStrengthSyntax* strength;
+    TimingControlSyntax* delay;
+    SeparatedSyntaxList<GateInstanceSyntax> instances;
+    Token semi;
+
+    GateInstantiationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token gateType, DriveStrengthSyntax* strength, TimingControlSyntax* delay, const SeparatedSyntaxList<GateInstanceSyntax>& instances, Token semi) :
+        MemberSyntax(SyntaxKind::GateInstantiation, attributes), gateType(gateType), strength(strength), delay(delay), instances(instances), semi(semi) {
+        if (this->strength) this->strength->parent = this;
+        if (this->delay) this->delay->parent = this;
+        this->instances.parent = this;
+        for (auto child : this->instances)
+            child->parent = this;
+    }
+
+    explicit GateInstantiationSyntax(const GateInstantiationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    GateInstantiationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct FunctionPortSyntax : public SyntaxNode {
+    SyntaxList<AttributeInstanceSyntax> attributes;
+    Token constKeyword;
+    Token direction;
+    Token varKeyword;
+    DataTypeSyntax* dataType;
+    not_null<DeclaratorSyntax*> declarator;
+
+    FunctionPortSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token constKeyword, Token direction, Token varKeyword, DataTypeSyntax* dataType, DeclaratorSyntax& declarator) :
+        SyntaxNode(SyntaxKind::FunctionPort), attributes(attributes), constKeyword(constKeyword), direction(direction), varKeyword(varKeyword), dataType(dataType), declarator(&declarator) {
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+        if (this->dataType) this->dataType->parent = this;
+        this->declarator->parent = this;
+    }
+
+    explicit FunctionPortSyntax(const FunctionPortSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    FunctionPortSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct FunctionPortListSyntax : public SyntaxNode {
+    Token openParen;
+    SeparatedSyntaxList<FunctionPortSyntax> ports;
+    Token closeParen;
+
+    FunctionPortListSyntax(Token openParen, const SeparatedSyntaxList<FunctionPortSyntax>& ports, Token closeParen) :
+        SyntaxNode(SyntaxKind::FunctionPortList), openParen(openParen), ports(ports), closeParen(closeParen) {
+        this->ports.parent = this;
+        for (auto child : this->ports)
+            child->parent = this;
+    }
+
+    explicit FunctionPortListSyntax(const FunctionPortListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    FunctionPortListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct FunctionPrototypeSyntax : public SyntaxNode {
+    Token keyword;
+    Token lifetime;
+    not_null<DataTypeSyntax*> returnType;
+    not_null<NameSyntax*> name;
+    FunctionPortListSyntax* portList;
+
+    FunctionPrototypeSyntax(Token keyword, Token lifetime, DataTypeSyntax& returnType, NameSyntax& name, FunctionPortListSyntax* portList) :
+        SyntaxNode(SyntaxKind::FunctionPrototype), keyword(keyword), lifetime(lifetime), returnType(&returnType), name(&name), portList(portList) {
+        this->returnType->parent = this;
+        this->name->parent = this;
+        if (this->portList) this->portList->parent = this;
+    }
+
+    explicit FunctionPrototypeSyntax(const FunctionPrototypeSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    FunctionPrototypeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct FunctionDeclarationSyntax : public MemberSyntax {
+    not_null<FunctionPrototypeSyntax*> prototype;
+    Token semi;
+    SyntaxList<SyntaxNode> items;
+    Token end;
+    NamedBlockClauseSyntax* endBlockName;
+
+    FunctionDeclarationSyntax(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, FunctionPrototypeSyntax& prototype, Token semi, const SyntaxList<SyntaxNode>& items, Token end, NamedBlockClauseSyntax* endBlockName) :
+        MemberSyntax(kind, attributes), prototype(&prototype), semi(semi), items(items), end(end), endBlockName(endBlockName) {
+        this->prototype->parent = this;
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+        if (this->endBlockName) this->endBlockName->parent = this;
+    }
+
+    explicit FunctionDeclarationSyntax(const FunctionDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    FunctionDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct AssertionItemPortSyntax : public SyntaxNode {
+    SyntaxList<AttributeInstanceSyntax> attributes;
+    Token local;
+    Token direction;
+    not_null<DataTypeSyntax*> type;
+    not_null<DeclaratorSyntax*> declarator;
+
+    AssertionItemPortSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token local, Token direction, DataTypeSyntax& type, DeclaratorSyntax& declarator) :
+        SyntaxNode(SyntaxKind::AssertionItemPort), attributes(attributes), local(local), direction(direction), type(&type), declarator(&declarator) {
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+        this->type->parent = this;
+        this->declarator->parent = this;
+    }
+
+    explicit AssertionItemPortSyntax(const AssertionItemPortSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    AssertionItemPortSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct AssertionItemPortListSyntax : public SyntaxNode {
+    Token openParen;
+    SeparatedSyntaxList<AssertionItemPortSyntax> ports;
+    Token closeParen;
+
+    AssertionItemPortListSyntax(Token openParen, const SeparatedSyntaxList<AssertionItemPortSyntax>& ports, Token closeParen) :
+        SyntaxNode(SyntaxKind::AssertionItemPortList), openParen(openParen), ports(ports), closeParen(closeParen) {
+        this->ports.parent = this;
+        for (auto child : this->ports)
+            child->parent = this;
+    }
+
+    explicit AssertionItemPortListSyntax(const AssertionItemPortListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    AssertionItemPortListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct LetDeclarationSyntax : public MemberSyntax {
+    Token let;
+    Token identifier;
+    AssertionItemPortListSyntax* portList;
+    not_null<EqualsValueClauseSyntax*> initializer;
+    Token semi;
+
+    LetDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token let, Token identifier, AssertionItemPortListSyntax* portList, EqualsValueClauseSyntax& initializer, Token semi) :
+        MemberSyntax(SyntaxKind::LetDeclaration, attributes), let(let), identifier(identifier), portList(portList), initializer(&initializer), semi(semi) {
+        if (this->portList) this->portList->parent = this;
+        this->initializer->parent = this;
+    }
+
+    explicit LetDeclarationSyntax(const LetDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    LetDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PropertyDeclarationSyntax : public MemberSyntax {
+    Token keyword;
+    Token name;
+    AssertionItemPortListSyntax* portList;
+    Token semi;
+    SyntaxList<MemberSyntax> assertionVariables;
+    not_null<PropertySpecSyntax*> propertySpec;
+    Token optionalSemi;
+    Token end;
+    NamedBlockClauseSyntax* endBlockName;
+
+    PropertyDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, const SyntaxList<MemberSyntax>& assertionVariables, PropertySpecSyntax& propertySpec, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName) :
+        MemberSyntax(SyntaxKind::PropertyDeclaration, attributes), keyword(keyword), name(name), portList(portList), semi(semi), assertionVariables(assertionVariables), propertySpec(&propertySpec), optionalSemi(optionalSemi), end(end), endBlockName(endBlockName) {
+        if (this->portList) this->portList->parent = this;
+        this->assertionVariables.parent = this;
+        for (auto child : this->assertionVariables)
+            child->parent = this;
+        this->propertySpec->parent = this;
+        if (this->endBlockName) this->endBlockName->parent = this;
+    }
+
+    explicit PropertyDeclarationSyntax(const PropertyDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PropertyDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct SequenceDeclarationSyntax : public MemberSyntax {
+    Token keyword;
+    Token name;
+    AssertionItemPortListSyntax* portList;
+    Token semi;
+    SyntaxList<MemberSyntax> assertionVariables;
+    not_null<ExpressionSyntax*> seqExpr;
+    Token optionalSemi;
+    Token end;
+    NamedBlockClauseSyntax* endBlockName;
+
+    SequenceDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, const SyntaxList<MemberSyntax>& assertionVariables, ExpressionSyntax& seqExpr, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName) :
+        MemberSyntax(SyntaxKind::SequenceDeclaration, attributes), keyword(keyword), name(name), portList(portList), semi(semi), assertionVariables(assertionVariables), seqExpr(&seqExpr), optionalSemi(optionalSemi), end(end), endBlockName(endBlockName) {
+        if (this->portList) this->portList->parent = this;
+        this->assertionVariables.parent = this;
+        for (auto child : this->assertionVariables)
+            child->parent = this;
+        this->seqExpr->parent = this;
+        if (this->endBlockName) this->endBlockName->parent = this;
+    }
+
+    explicit SequenceDeclarationSyntax(const SequenceDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SequenceDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ExtendsClauseSyntax : public SyntaxNode {
+    Token keyword;
+    not_null<NameSyntax*> baseName;
+    ArgumentListSyntax* arguments;
+
+    ExtendsClauseSyntax(Token keyword, NameSyntax& baseName, ArgumentListSyntax* arguments) :
+        SyntaxNode(SyntaxKind::ExtendsClause), keyword(keyword), baseName(&baseName), arguments(arguments) {
+        this->baseName->parent = this;
+        if (this->arguments) this->arguments->parent = this;
+    }
+
+    explicit ExtendsClauseSyntax(const ExtendsClauseSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ExtendsClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ImplementsClauseSyntax : public SyntaxNode {
+    Token keyword;
+    SeparatedSyntaxList<NameSyntax> interfaces;
+
+    ImplementsClauseSyntax(Token keyword, const SeparatedSyntaxList<NameSyntax>& interfaces) :
+        SyntaxNode(SyntaxKind::ImplementsClause), keyword(keyword), interfaces(interfaces) {
+        this->interfaces.parent = this;
+        for (auto child : this->interfaces)
+            child->parent = this;
+    }
+
+    explicit ImplementsClauseSyntax(const ImplementsClauseSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ImplementsClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ClassDeclarationSyntax : public MemberSyntax {
+    Token virtualOrInterface;
+    Token classKeyword;
+    Token lifetime;
+    Token name;
+    ParameterPortListSyntax* parameters;
+    ExtendsClauseSyntax* extendsClause;
+    ImplementsClauseSyntax* implementsClause;
+    Token semi;
+    SyntaxList<MemberSyntax> items;
+    Token endClass;
+    NamedBlockClauseSyntax* endBlockName;
+
+    ClassDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token virtualOrInterface, Token classKeyword, Token lifetime, Token name, ParameterPortListSyntax* parameters, ExtendsClauseSyntax* extendsClause, ImplementsClauseSyntax* implementsClause, Token semi, const SyntaxList<MemberSyntax>& items, Token endClass, NamedBlockClauseSyntax* endBlockName) :
+        MemberSyntax(SyntaxKind::ClassDeclaration, attributes), virtualOrInterface(virtualOrInterface), classKeyword(classKeyword), lifetime(lifetime), name(name), parameters(parameters), extendsClause(extendsClause), implementsClause(implementsClause), semi(semi), items(items), endClass(endClass), endBlockName(endBlockName) {
+        if (this->parameters) this->parameters->parent = this;
+        if (this->extendsClause) this->extendsClause->parent = this;
+        if (this->implementsClause) this->implementsClause->parent = this;
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+        if (this->endBlockName) this->endBlockName->parent = this;
+    }
+
+    explicit ClassDeclarationSyntax(const ClassDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ClassDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ClassPropertyDeclarationSyntax : public MemberSyntax {
+    TokenList qualifiers;
+    not_null<MemberSyntax*> declaration;
+
+    ClassPropertyDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, MemberSyntax& declaration) :
+        MemberSyntax(SyntaxKind::ClassPropertyDeclaration, attributes), qualifiers(qualifiers), declaration(&declaration) {
+        this->qualifiers.parent = this;
+        this->declaration->parent = this;
+    }
+
+    explicit ClassPropertyDeclarationSyntax(const ClassPropertyDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ClassPropertyDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ClassMethodDeclarationSyntax : public MemberSyntax {
+    TokenList qualifiers;
+    not_null<FunctionDeclarationSyntax*> declaration;
+
+    ClassMethodDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, FunctionDeclarationSyntax& declaration) :
+        MemberSyntax(SyntaxKind::ClassMethodDeclaration, attributes), qualifiers(qualifiers), declaration(&declaration) {
+        this->qualifiers.parent = this;
+        this->declaration->parent = this;
+    }
+
+    explicit ClassMethodDeclarationSyntax(const ClassMethodDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ClassMethodDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ClassMethodPrototypeSyntax : public MemberSyntax {
+    TokenList qualifiers;
+    not_null<FunctionPrototypeSyntax*> prototype;
+    Token semi;
+
+    ClassMethodPrototypeSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, FunctionPrototypeSyntax& prototype, Token semi) :
+        MemberSyntax(SyntaxKind::ClassMethodPrototype, attributes), qualifiers(qualifiers), prototype(&prototype), semi(semi) {
+        this->qualifiers.parent = this;
+        this->prototype->parent = this;
+    }
+
+    explicit ClassMethodPrototypeSyntax(const ClassMethodPrototypeSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ClassMethodPrototypeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ContinuousAssignSyntax : public MemberSyntax {
+    Token assign;
+    DriveStrengthSyntax* strength;
+    TimingControlSyntax* delay;
+    SeparatedSyntaxList<ExpressionSyntax> assignments;
+    Token semi;
+
+    ContinuousAssignSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token assign, DriveStrengthSyntax* strength, TimingControlSyntax* delay, const SeparatedSyntaxList<ExpressionSyntax>& assignments, Token semi) :
+        MemberSyntax(SyntaxKind::ContinuousAssign, attributes), assign(assign), strength(strength), delay(delay), assignments(assignments), semi(semi) {
+        if (this->strength) this->strength->parent = this;
+        if (this->delay) this->delay->parent = this;
+        this->assignments.parent = this;
+        for (auto child : this->assignments)
+            child->parent = this;
+    }
+
+    explicit ContinuousAssignSyntax(const ContinuousAssignSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ContinuousAssignSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DefParamAssignmentSyntax : public SyntaxNode {
+    not_null<NameSyntax*> name;
+    not_null<EqualsValueClauseSyntax*> setter;
+
+    DefParamAssignmentSyntax(NameSyntax& name, EqualsValueClauseSyntax& setter) :
+        SyntaxNode(SyntaxKind::DefParamAssignment), name(&name), setter(&setter) {
+        this->name->parent = this;
+        this->setter->parent = this;
+    }
+
+    explicit DefParamAssignmentSyntax(const DefParamAssignmentSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DefParamAssignmentSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DefParamSyntax : public MemberSyntax {
+    Token defparam;
+    SeparatedSyntaxList<DefParamAssignmentSyntax> assignments;
+    Token semi;
+
+    DefParamSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token defparam, const SeparatedSyntaxList<DefParamAssignmentSyntax>& assignments, Token semi) :
+        MemberSyntax(SyntaxKind::DefParam, attributes), defparam(defparam), assignments(assignments), semi(semi) {
+        this->assignments.parent = this;
+        for (auto child : this->assignments)
+            child->parent = this;
+    }
+
+    explicit DefParamSyntax(const DefParamSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DefParamSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ModportClockingPortSyntax : public MemberSyntax {
+    Token clocking;
+    Token name;
+
+    ModportClockingPortSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token clocking, Token name) :
+        MemberSyntax(SyntaxKind::ModportClockingPort, attributes), clocking(clocking), name(name) {
+    }
+
+    explicit ModportClockingPortSyntax(const ModportClockingPortSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ModportClockingPortSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ModportPortSyntax : public SyntaxNode {
+
+    ModportPortSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit ModportPortSyntax(const ModportPortSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct ModportNamedPortSyntax : public ModportPortSyntax {
+    Token name;
+
+    ModportNamedPortSyntax(Token name) :
+        ModportPortSyntax(SyntaxKind::ModportNamedPort), name(name) {
+    }
+
+    explicit ModportNamedPortSyntax(const ModportNamedPortSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ModportNamedPortSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ModportExplicitPortSyntax : public ModportPortSyntax {
+    Token dot;
+    Token name;
+    Token openParen;
+    ExpressionSyntax* expr;
+    Token closeParen;
+
+    ModportExplicitPortSyntax(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
+        ModportPortSyntax(SyntaxKind::ModportExplicitPort), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
+        if (this->expr) this->expr->parent = this;
+    }
+
+    explicit ModportExplicitPortSyntax(const ModportExplicitPortSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ModportExplicitPortSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ModportSimplePortListSyntax : public MemberSyntax {
+    Token direction;
+    SeparatedSyntaxList<ModportPortSyntax> ports;
+
+    ModportSimplePortListSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token direction, const SeparatedSyntaxList<ModportPortSyntax>& ports) :
+        MemberSyntax(SyntaxKind::ModportSimplePortList, attributes), direction(direction), ports(ports) {
+        this->ports.parent = this;
+        for (auto child : this->ports)
+            child->parent = this;
+    }
+
+    explicit ModportSimplePortListSyntax(const ModportSimplePortListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ModportSimplePortListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ModportSubroutinePortSyntax : public ModportPortSyntax {
+    not_null<FunctionPrototypeSyntax*> prototype;
+
+    ModportSubroutinePortSyntax(FunctionPrototypeSyntax& prototype) :
+        ModportPortSyntax(SyntaxKind::ModportSubroutinePort), prototype(&prototype) {
+        this->prototype->parent = this;
+    }
+
+    explicit ModportSubroutinePortSyntax(const ModportSubroutinePortSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ModportSubroutinePortSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ModportSubroutinePortListSyntax : public MemberSyntax {
+    Token importExport;
+    SeparatedSyntaxList<ModportPortSyntax> ports;
+
+    ModportSubroutinePortListSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token importExport, const SeparatedSyntaxList<ModportPortSyntax>& ports) :
+        MemberSyntax(SyntaxKind::ModportSubroutinePortList, attributes), importExport(importExport), ports(ports) {
+        this->ports.parent = this;
+        for (auto child : this->ports)
+            child->parent = this;
+    }
+
+    explicit ModportSubroutinePortListSyntax(const ModportSubroutinePortListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ModportSubroutinePortListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ModportItemSyntax : public SyntaxNode {
+    Token name;
+    not_null<AnsiPortListSyntax*> ports;
+
+    ModportItemSyntax(Token name, AnsiPortListSyntax& ports) :
+        SyntaxNode(SyntaxKind::ModportItem), name(name), ports(&ports) {
+        this->ports->parent = this;
+    }
+
+    explicit ModportItemSyntax(const ModportItemSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ModportItemSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ModportDeclarationSyntax : public MemberSyntax {
+    Token keyword;
+    SeparatedSyntaxList<ModportItemSyntax> items;
+    Token semi;
+
+    ModportDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<ModportItemSyntax>& items, Token semi) :
+        MemberSyntax(SyntaxKind::ModportDeclaration, attributes), keyword(keyword), items(items), semi(semi) {
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    explicit ModportDeclarationSyntax(const ModportDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ModportDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ClockingSkewSyntax : public SyntaxNode {
+    Token edge;
+    DelaySyntax* delay;
+
+    ClockingSkewSyntax(Token edge, DelaySyntax* delay) :
+        SyntaxNode(SyntaxKind::ClockingSkew), edge(edge), delay(delay) {
+        if (this->delay) this->delay->parent = this;
+    }
+
+    explicit ClockingSkewSyntax(const ClockingSkewSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ClockingSkewSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ClockingDirectionSyntax : public SyntaxNode {
+    Token input;
+    ClockingSkewSyntax* inputSkew;
+    Token output;
+    ClockingSkewSyntax* ouputSkew;
+
+    ClockingDirectionSyntax(Token input, ClockingSkewSyntax* inputSkew, Token output, ClockingSkewSyntax* ouputSkew) :
+        SyntaxNode(SyntaxKind::ClockingDirection), input(input), inputSkew(inputSkew), output(output), ouputSkew(ouputSkew) {
+        if (this->inputSkew) this->inputSkew->parent = this;
+        if (this->ouputSkew) this->ouputSkew->parent = this;
+    }
+
+    explicit ClockingDirectionSyntax(const ClockingDirectionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ClockingDirectionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DefaultSkewItemSyntax : public MemberSyntax {
+    Token keyword;
+    not_null<ClockingDirectionSyntax*> direction;
+    Token semi;
+
+    DefaultSkewItemSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ClockingDirectionSyntax& direction, Token semi) :
+        MemberSyntax(SyntaxKind::DefaultSkewItem, attributes), keyword(keyword), direction(&direction), semi(semi) {
+        this->direction->parent = this;
+    }
+
+    explicit DefaultSkewItemSyntax(const DefaultSkewItemSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DefaultSkewItemSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ClockingItemSyntax : public MemberSyntax {
+    not_null<ClockingDirectionSyntax*> direction;
+    SeparatedSyntaxList<AttributeSpecSyntax> decls;
+    Token semi;
+
+    ClockingItemSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, ClockingDirectionSyntax& direction, const SeparatedSyntaxList<AttributeSpecSyntax>& decls, Token semi) :
+        MemberSyntax(SyntaxKind::ClockingItem, attributes), direction(&direction), decls(decls), semi(semi) {
+        this->direction->parent = this;
+        this->decls.parent = this;
+        for (auto child : this->decls)
+            child->parent = this;
+    }
+
+    explicit ClockingItemSyntax(const ClockingItemSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ClockingItemSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ClockingDeclarationSyntax : public MemberSyntax {
+    Token globalOrDefault;
+    Token clocking;
+    Token blockName;
+    Token at;
+    not_null<EventExpressionSyntax*> event;
+    Token semi;
+    SyntaxList<MemberSyntax> items;
+    Token endClocking;
+    NamedBlockClauseSyntax* endBlockName;
+
+    ClockingDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token globalOrDefault, Token clocking, Token blockName, Token at, EventExpressionSyntax& event, Token semi, const SyntaxList<MemberSyntax>& items, Token endClocking, NamedBlockClauseSyntax* endBlockName) :
+        MemberSyntax(SyntaxKind::ClockingDeclaration, attributes), globalOrDefault(globalOrDefault), clocking(clocking), blockName(blockName), at(at), event(&event), semi(semi), items(items), endClocking(endClocking), endBlockName(endBlockName) {
+        this->event->parent = this;
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+        if (this->endBlockName) this->endBlockName->parent = this;
+    }
+
+    explicit ClockingDeclarationSyntax(const ClockingDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ClockingDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DefaultClockingReferenceSyntax : public MemberSyntax {
+    Token defaultKeyword;
+    Token clocking;
+    Token name;
+    Token semi;
+
+    DefaultClockingReferenceSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token defaultKeyword, Token clocking, Token name, Token semi) :
+        MemberSyntax(SyntaxKind::DefaultClockingReference, attributes), defaultKeyword(defaultKeyword), clocking(clocking), name(name), semi(semi) {
+    }
+
+    explicit DefaultClockingReferenceSyntax(const DefaultClockingReferenceSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DefaultClockingReferenceSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DPIImportSyntax : public MemberSyntax {
+    Token keyword;
+    Token specString;
+    Token property;
+    Token c_identifier;
+    Token equals;
+    not_null<FunctionPrototypeSyntax*> method;
+    Token semi;
+
+    DPIImportSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token specString, Token property, Token c_identifier, Token equals, FunctionPrototypeSyntax& method, Token semi) :
+        MemberSyntax(SyntaxKind::DPIImport, attributes), keyword(keyword), specString(specString), property(property), c_identifier(c_identifier), equals(equals), method(&method), semi(semi) {
+        this->method->parent = this;
+    }
+
+    explicit DPIImportSyntax(const DPIImportSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DPIImportSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DPIExportSyntax : public MemberSyntax {
+    Token keyword;
+    Token specString;
+    Token c_identifier;
+    Token equals;
+    Token functionOrTask;
+    Token name;
+    Token semi;
+
+    DPIExportSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token specString, Token c_identifier, Token equals, Token functionOrTask, Token name, Token semi) :
+        MemberSyntax(SyntaxKind::DPIExport, attributes), keyword(keyword), specString(specString), c_identifier(c_identifier), equals(equals), functionOrTask(functionOrTask), name(name), semi(semi) {
+    }
+
+    explicit DPIExportSyntax(const DPIExportSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DPIExportSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ElabSystemTaskSyntax : public MemberSyntax {
+    Token name;
+    ArgumentListSyntax* arguments;
+    Token semi;
+
+    ElabSystemTaskSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token name, ArgumentListSyntax* arguments, Token semi) :
+        MemberSyntax(SyntaxKind::ElabSystemTask, attributes), name(name), arguments(arguments), semi(semi) {
+        if (this->arguments) this->arguments->parent = this;
+    }
+
+    explicit ElabSystemTaskSyntax(const ElabSystemTaskSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ElabSystemTaskSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct UdpPortDeclSyntax : public SyntaxNode {
+    SyntaxList<AttributeInstanceSyntax> attributes;
+
+    UdpPortDeclSyntax(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes) :
+        SyntaxNode(kind), attributes(attributes) {
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+    }
+
+    explicit UdpPortDeclSyntax(const UdpPortDeclSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    UdpPortDeclSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct UdpOutputPortDeclSyntax : public UdpPortDeclSyntax {
+    Token keyword;
+    Token reg;
+    Token name;
+    EqualsValueClauseSyntax* initializer;
+
+    UdpOutputPortDeclSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token reg, Token name, EqualsValueClauseSyntax* initializer) :
+        UdpPortDeclSyntax(SyntaxKind::UdpOutputPortDecl, attributes), keyword(keyword), reg(reg), name(name), initializer(initializer) {
+        if (this->initializer) this->initializer->parent = this;
+    }
+
+    explicit UdpOutputPortDeclSyntax(const UdpOutputPortDeclSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    UdpOutputPortDeclSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct UdpInputPortDeclSyntax : public UdpPortDeclSyntax {
+    Token keyword;
+    SeparatedSyntaxList<IdentifierNameSyntax> names;
+
+    UdpInputPortDeclSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<IdentifierNameSyntax>& names) :
+        UdpPortDeclSyntax(SyntaxKind::UdpInputPortDecl, attributes), keyword(keyword), names(names) {
+        this->names.parent = this;
+        for (auto child : this->names)
+            child->parent = this;
+    }
+
+    explicit UdpInputPortDeclSyntax(const UdpInputPortDeclSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    UdpInputPortDeclSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct UdpPortListSyntax : public SyntaxNode {
+
+    UdpPortListSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit UdpPortListSyntax(const UdpPortListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct AnsiUdpPortListSyntax : public UdpPortListSyntax {
+    Token openParen;
+    SeparatedSyntaxList<UdpPortDeclSyntax> ports;
+    Token closeParen;
+    Token semi;
+
+    AnsiUdpPortListSyntax(Token openParen, const SeparatedSyntaxList<UdpPortDeclSyntax>& ports, Token closeParen, Token semi) :
+        UdpPortListSyntax(SyntaxKind::AnsiUdpPortList), openParen(openParen), ports(ports), closeParen(closeParen), semi(semi) {
+        this->ports.parent = this;
+        for (auto child : this->ports)
+            child->parent = this;
+    }
+
+    explicit AnsiUdpPortListSyntax(const AnsiUdpPortListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    AnsiUdpPortListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NonAnsiUdpPortListSyntax : public UdpPortListSyntax {
+    Token openParen;
+    SeparatedSyntaxList<IdentifierNameSyntax> ports;
+    Token closeParen;
+    Token semi;
+
+    NonAnsiUdpPortListSyntax(Token openParen, const SeparatedSyntaxList<IdentifierNameSyntax>& ports, Token closeParen, Token semi) :
+        UdpPortListSyntax(SyntaxKind::NonAnsiUdpPortList), openParen(openParen), ports(ports), closeParen(closeParen), semi(semi) {
+        this->ports.parent = this;
+        for (auto child : this->ports)
+            child->parent = this;
+    }
+
+    explicit NonAnsiUdpPortListSyntax(const NonAnsiUdpPortListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NonAnsiUdpPortListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct WildcardUdpPortListSyntax : public UdpPortListSyntax {
+    Token openParen;
+    Token dotStar;
+    Token closeParen;
+    Token semi;
+
+    WildcardUdpPortListSyntax(Token openParen, Token dotStar, Token closeParen, Token semi) :
+        UdpPortListSyntax(SyntaxKind::WildcardUdpPortList), openParen(openParen), dotStar(dotStar), closeParen(closeParen), semi(semi) {
+    }
+
+    explicit WildcardUdpPortListSyntax(const WildcardUdpPortListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WildcardUdpPortListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct UdpInitialStmtSyntax : public SyntaxNode {
+    Token initial;
+    Token name;
+    Token equals;
+    not_null<ExpressionSyntax*> value;
+    Token semi;
+
+    UdpInitialStmtSyntax(Token initial, Token name, Token equals, ExpressionSyntax& value, Token semi) :
+        SyntaxNode(SyntaxKind::UdpInitialStmt), initial(initial), name(name), equals(equals), value(&value), semi(semi) {
+        this->value->parent = this;
+    }
+
+    explicit UdpInitialStmtSyntax(const UdpInitialStmtSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    UdpInitialStmtSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct UdpEdgeIndicatorSyntax : public SyntaxNode {
+    Token openParen;
+    Token first;
+    Token second;
+    Token closeParen;
+
+    UdpEdgeIndicatorSyntax(Token openParen, Token first, Token second, Token closeParen) :
+        SyntaxNode(SyntaxKind::UdpEdgeIndicator), openParen(openParen), first(first), second(second), closeParen(closeParen) {
+    }
+
+    explicit UdpEdgeIndicatorSyntax(const UdpEdgeIndicatorSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    UdpEdgeIndicatorSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct UdpEntrySyntax : public SyntaxNode {
+    TokenList preInputs;
+    UdpEdgeIndicatorSyntax* edgeIndicator;
+    TokenList postInputs;
+    Token colon1;
+    Token current;
+    Token colon2;
+    Token next;
+    Token semi;
+
+    UdpEntrySyntax(const TokenList& preInputs, UdpEdgeIndicatorSyntax* edgeIndicator, const TokenList& postInputs, Token colon1, Token current, Token colon2, Token next, Token semi) :
+        SyntaxNode(SyntaxKind::UdpEntry), preInputs(preInputs), edgeIndicator(edgeIndicator), postInputs(postInputs), colon1(colon1), current(current), colon2(colon2), next(next), semi(semi) {
+        this->preInputs.parent = this;
+        if (this->edgeIndicator) this->edgeIndicator->parent = this;
+        this->postInputs.parent = this;
+    }
+
+    explicit UdpEntrySyntax(const UdpEntrySyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    UdpEntrySyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct UdpBodySyntax : public SyntaxNode {
+    SeparatedSyntaxList<UdpPortDeclSyntax> portDecls;
+    UdpInitialStmtSyntax* initialStmt;
+    Token table;
+    SyntaxList<UdpEntrySyntax> entries;
+    Token endtable;
+
+    UdpBodySyntax(const SeparatedSyntaxList<UdpPortDeclSyntax>& portDecls, UdpInitialStmtSyntax* initialStmt, Token table, const SyntaxList<UdpEntrySyntax>& entries, Token endtable) :
+        SyntaxNode(SyntaxKind::UdpBody), portDecls(portDecls), initialStmt(initialStmt), table(table), entries(entries), endtable(endtable) {
+        this->portDecls.parent = this;
+        for (auto child : this->portDecls)
+            child->parent = this;
+        if (this->initialStmt) this->initialStmt->parent = this;
+        this->entries.parent = this;
+        for (auto child : this->entries)
+            child->parent = this;
+    }
+
+    explicit UdpBodySyntax(const UdpBodySyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    UdpBodySyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct UdpDeclarationSyntax : public MemberSyntax {
+    Token primitive;
+    Token name;
+    not_null<UdpPortListSyntax*> portList;
+    not_null<UdpBodySyntax*> body;
+    Token endprimitive;
+    NamedBlockClauseSyntax* endBlockName;
+
+    UdpDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token primitive, Token name, UdpPortListSyntax& portList, UdpBodySyntax& body, Token endprimitive, NamedBlockClauseSyntax* endBlockName) :
+        MemberSyntax(SyntaxKind::UdpDeclaration, attributes), primitive(primitive), name(name), portList(&portList), body(&body), endprimitive(endprimitive), endBlockName(endBlockName) {
+        this->portList->parent = this;
+        this->body->parent = this;
+        if (this->endBlockName) this->endBlockName->parent = this;
+    }
+
+    explicit UdpDeclarationSyntax(const UdpDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    UdpDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct SpecparamDeclaratorSyntax : public SyntaxNode {
+    Token name;
+    Token equals;
+    not_null<ExpressionSyntax*> value;
+
+    SpecparamDeclaratorSyntax(Token name, Token equals, ExpressionSyntax& value) :
+        SyntaxNode(SyntaxKind::SpecparamDeclarator), name(name), equals(equals), value(&value) {
+        this->value->parent = this;
+    }
+
+    explicit SpecparamDeclaratorSyntax(const SpecparamDeclaratorSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SpecparamDeclaratorSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct SpecparamDeclarationSyntax : public MemberSyntax {
+    Token keyword;
+    not_null<ImplicitTypeSyntax*> type;
+    SeparatedSyntaxList<SpecparamDeclaratorSyntax> declarators;
+    Token semi;
+
+    SpecparamDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ImplicitTypeSyntax& type, const SeparatedSyntaxList<SpecparamDeclaratorSyntax>& declarators, Token semi) :
+        MemberSyntax(SyntaxKind::SpecparamDeclaration, attributes), keyword(keyword), type(&type), declarators(declarators), semi(semi) {
+        this->type->parent = this;
+        this->declarators.parent = this;
+        for (auto child : this->declarators)
+            child->parent = this;
+    }
+
+    explicit SpecparamDeclarationSyntax(const SpecparamDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SpecparamDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PathSuffixSyntax : public SyntaxNode {
+
+    PathSuffixSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit PathSuffixSyntax(const PathSuffixSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct SimplePathSuffixSyntax : public PathSuffixSyntax {
+    SeparatedSyntaxList<NameSyntax> outputs;
+
+    SimplePathSuffixSyntax(const SeparatedSyntaxList<NameSyntax>& outputs) :
+        PathSuffixSyntax(SyntaxKind::SimplePathSuffix), outputs(outputs) {
+        this->outputs.parent = this;
+        for (auto child : this->outputs)
+            child->parent = this;
+    }
+
+    explicit SimplePathSuffixSyntax(const SimplePathSuffixSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SimplePathSuffixSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct EdgeSensitivePathSuffixSyntax : public PathSuffixSyntax {
+    Token openParen;
+    SeparatedSyntaxList<NameSyntax> outputs;
+    Token polarityOperator;
+    Token colon;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+
+    EdgeSensitivePathSuffixSyntax(Token openParen, const SeparatedSyntaxList<NameSyntax>& outputs, Token polarityOperator, Token colon, ExpressionSyntax& expr, Token closeParen) :
+        PathSuffixSyntax(SyntaxKind::EdgeSensitivePathSuffix), openParen(openParen), outputs(outputs), polarityOperator(polarityOperator), colon(colon), expr(&expr), closeParen(closeParen) {
+        this->outputs.parent = this;
+        for (auto child : this->outputs)
+            child->parent = this;
+        this->expr->parent = this;
+    }
+
+    explicit EdgeSensitivePathSuffixSyntax(const EdgeSensitivePathSuffixSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EdgeSensitivePathSuffixSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PathDescriptionSyntax : public SyntaxNode {
+    Token openParen;
+    Token edgeIdentifier;
+    SeparatedSyntaxList<NameSyntax> inputs;
+    Token polarityOperator;
+    Token pathOperator;
+    not_null<PathSuffixSyntax*> suffix;
+    Token closeParen;
+
+    PathDescriptionSyntax(Token openParen, Token edgeIdentifier, const SeparatedSyntaxList<NameSyntax>& inputs, Token polarityOperator, Token pathOperator, PathSuffixSyntax& suffix, Token closeParen) :
+        SyntaxNode(SyntaxKind::PathDescription), openParen(openParen), edgeIdentifier(edgeIdentifier), inputs(inputs), polarityOperator(polarityOperator), pathOperator(pathOperator), suffix(&suffix), closeParen(closeParen) {
+        this->inputs.parent = this;
+        for (auto child : this->inputs)
+            child->parent = this;
+        this->suffix->parent = this;
+    }
+
+    explicit PathDescriptionSyntax(const PathDescriptionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PathDescriptionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PathDeclarationSyntax : public MemberSyntax {
+    not_null<PathDescriptionSyntax*> desc;
+    Token equals;
+    Token openParen;
+    SeparatedSyntaxList<ExpressionSyntax> delays;
+    Token closeParen;
+    Token semi;
+
+    PathDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, PathDescriptionSyntax& desc, Token equals, Token openParen, const SeparatedSyntaxList<ExpressionSyntax>& delays, Token closeParen, Token semi) :
+        MemberSyntax(SyntaxKind::PathDeclaration, attributes), desc(&desc), equals(equals), openParen(openParen), delays(delays), closeParen(closeParen), semi(semi) {
+        this->desc->parent = this;
+        this->delays.parent = this;
+        for (auto child : this->delays)
+            child->parent = this;
+    }
+
+    explicit PathDeclarationSyntax(const PathDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PathDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConditionalPathDeclarationSyntax : public MemberSyntax {
+    Token keyword;
+    Token openParen;
+    not_null<ExpressionSyntax*> predicate;
+    Token closeParen;
+    not_null<PathDeclarationSyntax*> path;
+
+    ConditionalPathDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& predicate, Token closeParen, PathDeclarationSyntax& path) :
+        MemberSyntax(SyntaxKind::ConditionalPathDeclaration, attributes), keyword(keyword), openParen(openParen), predicate(&predicate), closeParen(closeParen), path(&path) {
+        this->predicate->parent = this;
+        this->path->parent = this;
+    }
+
+    explicit ConditionalPathDeclarationSyntax(const ConditionalPathDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConditionalPathDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct IfNonePathDeclarationSyntax : public MemberSyntax {
+    Token keyword;
+    not_null<PathDeclarationSyntax*> path;
+
+    IfNonePathDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, PathDeclarationSyntax& path) :
+        MemberSyntax(SyntaxKind::IfNonePathDeclaration, attributes), keyword(keyword), path(&path) {
+        this->path->parent = this;
+    }
+
+    explicit IfNonePathDeclarationSyntax(const IfNonePathDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    IfNonePathDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PulseStyleDeclarationSyntax : public MemberSyntax {
+    Token keyword;
+    SeparatedSyntaxList<NameSyntax> inputs;
+    Token semi;
+
+    PulseStyleDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<NameSyntax>& inputs, Token semi) :
+        MemberSyntax(SyntaxKind::PulseStyleDeclaration, attributes), keyword(keyword), inputs(inputs), semi(semi) {
+        this->inputs.parent = this;
+        for (auto child : this->inputs)
+            child->parent = this;
+    }
+
+    explicit PulseStyleDeclarationSyntax(const PulseStyleDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PulseStyleDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TimingCheckArgSyntax : public SyntaxNode {
+
+    TimingCheckArgSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit TimingCheckArgSyntax(const TimingCheckArgSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct EmptyTimingCheckArgSyntax : public TimingCheckArgSyntax {
+    Token placeholder;
+
+    EmptyTimingCheckArgSyntax(Token placeholder) :
+        TimingCheckArgSyntax(SyntaxKind::EmptyTimingCheckArg), placeholder(placeholder) {
+    }
+
+    explicit EmptyTimingCheckArgSyntax(const EmptyTimingCheckArgSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EmptyTimingCheckArgSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct EdgeDescriptorSyntax : public SyntaxNode {
+    Token t1;
+    Token t2;
+
+    EdgeDescriptorSyntax(Token t1, Token t2) :
+        SyntaxNode(SyntaxKind::EdgeDescriptor), t1(t1), t2(t2) {
+    }
+
+    explicit EdgeDescriptorSyntax(const EdgeDescriptorSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EdgeDescriptorSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct EdgeControlSpecifierSyntax : public SyntaxNode {
+    Token openBracket;
+    SeparatedSyntaxList<EdgeDescriptorSyntax> descriptors;
+    Token closeBracket;
+
+    EdgeControlSpecifierSyntax(Token openBracket, const SeparatedSyntaxList<EdgeDescriptorSyntax>& descriptors, Token closeBracket) :
+        SyntaxNode(SyntaxKind::EdgeControlSpecifier), openBracket(openBracket), descriptors(descriptors), closeBracket(closeBracket) {
+        this->descriptors.parent = this;
+        for (auto child : this->descriptors)
+            child->parent = this;
+    }
+
+    explicit EdgeControlSpecifierSyntax(const EdgeControlSpecifierSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EdgeControlSpecifierSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TimingCheckConditionSyntax : public SyntaxNode {
+    Token tripleAnd;
+    not_null<ExpressionSyntax*> expr;
+
+    TimingCheckConditionSyntax(Token tripleAnd, ExpressionSyntax& expr) :
+        SyntaxNode(SyntaxKind::TimingCheckCondition), tripleAnd(tripleAnd), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    explicit TimingCheckConditionSyntax(const TimingCheckConditionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TimingCheckConditionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TimingCheckEventSyntax : public TimingCheckArgSyntax {
+    Token edge;
+    EdgeControlSpecifierSyntax* controlSpecifier;
+    not_null<NameSyntax*> terminal;
+    TimingCheckConditionSyntax* condition;
+
+    TimingCheckEventSyntax(Token edge, EdgeControlSpecifierSyntax* controlSpecifier, NameSyntax& terminal, TimingCheckConditionSyntax* condition) :
+        TimingCheckArgSyntax(SyntaxKind::TimingCheckEvent), edge(edge), controlSpecifier(controlSpecifier), terminal(&terminal), condition(condition) {
+        if (this->controlSpecifier) this->controlSpecifier->parent = this;
+        this->terminal->parent = this;
+        if (this->condition) this->condition->parent = this;
+    }
+
+    explicit TimingCheckEventSyntax(const TimingCheckEventSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TimingCheckEventSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DelayedTerminalArgSyntax : public TimingCheckArgSyntax {
+    Token terminal;
+    Token openBracket;
+    not_null<ExpressionSyntax*> expr;
+    Token closeBracket;
+
+    DelayedTerminalArgSyntax(Token terminal, Token openBracket, ExpressionSyntax& expr, Token closeBracket) :
+        TimingCheckArgSyntax(SyntaxKind::DelayedTerminalArg), terminal(terminal), openBracket(openBracket), expr(&expr), closeBracket(closeBracket) {
+        this->expr->parent = this;
+    }
+
+    explicit DelayedTerminalArgSyntax(const DelayedTerminalArgSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DelayedTerminalArgSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ExpressionTimingCheckArgSyntax : public TimingCheckArgSyntax {
+    not_null<ExpressionSyntax*> expr;
+    TimingCheckConditionSyntax* condition;
+
+    ExpressionTimingCheckArgSyntax(ExpressionSyntax& expr, TimingCheckConditionSyntax* condition) :
+        TimingCheckArgSyntax(SyntaxKind::ExpressionTimingCheckArg), expr(&expr), condition(condition) {
+        this->expr->parent = this;
+        if (this->condition) this->condition->parent = this;
+    }
+
+    explicit ExpressionTimingCheckArgSyntax(const ExpressionTimingCheckArgSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ExpressionTimingCheckArgSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct SystemTimingCheckSyntax : public MemberSyntax {
+    Token name;
+    Token openParen;
+    SeparatedSyntaxList<TimingCheckArgSyntax> args;
+    Token closeParen;
+    Token semi;
+
+    SystemTimingCheckSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token name, Token openParen, const SeparatedSyntaxList<TimingCheckArgSyntax>& args, Token closeParen, Token semi) :
+        MemberSyntax(SyntaxKind::SystemTimingCheck, attributes), name(name), openParen(openParen), args(args), closeParen(closeParen), semi(semi) {
+        this->args.parent = this;
+        for (auto child : this->args)
+            child->parent = this;
+    }
+
+    explicit SystemTimingCheckSyntax(const SystemTimingCheckSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SystemTimingCheckSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct SpecifyBlockSyntax : public MemberSyntax {
+    Token specify;
+    SyntaxList<MemberSyntax> items;
+    Token endspecify;
+
+    SpecifyBlockSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token specify, const SyntaxList<MemberSyntax>& items, Token endspecify) :
+        MemberSyntax(SyntaxKind::SpecifyBlock, attributes), specify(specify), items(items), endspecify(endspecify) {
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    explicit SpecifyBlockSyntax(const SpecifyBlockSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SpecifyBlockSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- CONSTRAINTS -----
+
+struct ConstraintItemSyntax : public SyntaxNode {
+
+    ConstraintItemSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit ConstraintItemSyntax(const ConstraintItemSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct DistWeightSyntax : public SyntaxNode {
+    Token op;
+    not_null<ExpressionSyntax*> expr;
+
+    DistWeightSyntax(Token op, ExpressionSyntax& expr) :
+        SyntaxNode(SyntaxKind::DistWeight), op(op), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    explicit DistWeightSyntax(const DistWeightSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DistWeightSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DistItemSyntax : public SyntaxNode {
+    not_null<ExpressionSyntax*> range;
+    DistWeightSyntax* weight;
+
+    DistItemSyntax(ExpressionSyntax& range, DistWeightSyntax* weight) :
+        SyntaxNode(SyntaxKind::DistItem), range(&range), weight(weight) {
+        this->range->parent = this;
+        if (this->weight) this->weight->parent = this;
+    }
+
+    explicit DistItemSyntax(const DistItemSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DistItemSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DistConstraintListSyntax : public SyntaxNode {
+    Token dist;
+    Token openBrace;
+    SeparatedSyntaxList<DistItemSyntax> items;
+    Token closeBrace;
+
+    DistConstraintListSyntax(Token dist, Token openBrace, const SeparatedSyntaxList<DistItemSyntax>& items, Token closeBrace) :
+        SyntaxNode(SyntaxKind::DistConstraintList), dist(dist), openBrace(openBrace), items(items), closeBrace(closeBrace) {
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    explicit DistConstraintListSyntax(const DistConstraintListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DistConstraintListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ExpressionOrDistSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> expr;
+    not_null<DistConstraintListSyntax*> distribution;
+
+    ExpressionOrDistSyntax(ExpressionSyntax& expr, DistConstraintListSyntax& distribution) :
+        ExpressionSyntax(SyntaxKind::ExpressionOrDist), expr(&expr), distribution(&distribution) {
+        this->expr->parent = this;
+        this->distribution->parent = this;
+    }
+
+    explicit ExpressionOrDistSyntax(const ExpressionOrDistSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ExpressionOrDistSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ExpressionConstraintSyntax : public ConstraintItemSyntax {
+    Token soft;
+    not_null<ExpressionSyntax*> expr;
+    Token semi;
+
+    ExpressionConstraintSyntax(Token soft, ExpressionSyntax& expr, Token semi) :
+        ConstraintItemSyntax(SyntaxKind::ExpressionConstraint), soft(soft), expr(&expr), semi(semi) {
+        this->expr->parent = this;
+    }
+
+    explicit ExpressionConstraintSyntax(const ExpressionConstraintSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ExpressionConstraintSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct UniquenessConstraintSyntax : public ConstraintItemSyntax {
+    Token unique;
+    not_null<OpenRangeListSyntax*> ranges;
+    Token semi;
+
+    UniquenessConstraintSyntax(Token unique, OpenRangeListSyntax& ranges, Token semi) :
+        ConstraintItemSyntax(SyntaxKind::UniquenessConstraint), unique(unique), ranges(&ranges), semi(semi) {
+        this->ranges->parent = this;
+    }
+
+    explicit UniquenessConstraintSyntax(const UniquenessConstraintSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    UniquenessConstraintSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ImplicationConstraintSyntax : public ConstraintItemSyntax {
+    not_null<ExpressionSyntax*> left;
+    Token arrow;
+    not_null<ConstraintItemSyntax*> constraints;
+
+    ImplicationConstraintSyntax(ExpressionSyntax& left, Token arrow, ConstraintItemSyntax& constraints) :
+        ConstraintItemSyntax(SyntaxKind::ImplicationConstraint), left(&left), arrow(arrow), constraints(&constraints) {
+        this->left->parent = this;
+        this->constraints->parent = this;
+    }
+
+    explicit ImplicationConstraintSyntax(const ImplicationConstraintSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ImplicationConstraintSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ElseConstraintClauseSyntax : public SyntaxNode {
+    Token elseKeyword;
+    not_null<ConstraintItemSyntax*> constraints;
+
+    ElseConstraintClauseSyntax(Token elseKeyword, ConstraintItemSyntax& constraints) :
+        SyntaxNode(SyntaxKind::ElseConstraintClause), elseKeyword(elseKeyword), constraints(&constraints) {
+        this->constraints->parent = this;
+    }
+
+    explicit ElseConstraintClauseSyntax(const ElseConstraintClauseSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ElseConstraintClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConditionalConstraintSyntax : public ConstraintItemSyntax {
+    Token ifKeyword;
+    Token openParen;
+    not_null<ExpressionSyntax*> condition;
+    Token closeParen;
+    not_null<ConstraintItemSyntax*> constraints;
+    ElseConstraintClauseSyntax* elseClause;
+
+    ConditionalConstraintSyntax(Token ifKeyword, Token openParen, ExpressionSyntax& condition, Token closeParen, ConstraintItemSyntax& constraints, ElseConstraintClauseSyntax* elseClause) :
+        ConstraintItemSyntax(SyntaxKind::ConditionalConstraint), ifKeyword(ifKeyword), openParen(openParen), condition(&condition), closeParen(closeParen), constraints(&constraints), elseClause(elseClause) {
+        this->condition->parent = this;
+        this->constraints->parent = this;
+        if (this->elseClause) this->elseClause->parent = this;
+    }
+
+    explicit ConditionalConstraintSyntax(const ConditionalConstraintSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConditionalConstraintSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct LoopConstraintSyntax : public ConstraintItemSyntax {
+    Token foreachKeyword;
+    not_null<ForeachLoopListSyntax*> loopList;
+    not_null<ConstraintItemSyntax*> constraints;
+
+    LoopConstraintSyntax(Token foreachKeyword, ForeachLoopListSyntax& loopList, ConstraintItemSyntax& constraints) :
+        ConstraintItemSyntax(SyntaxKind::LoopConstraint), foreachKeyword(foreachKeyword), loopList(&loopList), constraints(&constraints) {
+        this->loopList->parent = this;
+        this->constraints->parent = this;
+    }
+
+    explicit LoopConstraintSyntax(const LoopConstraintSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    LoopConstraintSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DisableConstraintSyntax : public ConstraintItemSyntax {
+    Token disable;
+    Token soft;
+    not_null<NameSyntax*> name;
+    Token semi;
+
+    DisableConstraintSyntax(Token disable, Token soft, NameSyntax& name, Token semi) :
+        ConstraintItemSyntax(SyntaxKind::DisableConstraint), disable(disable), soft(soft), name(&name), semi(semi) {
+        this->name->parent = this;
+    }
+
+    explicit DisableConstraintSyntax(const DisableConstraintSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DisableConstraintSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct SolveBeforeConstraintSyntax : public ConstraintItemSyntax {
+    Token solve;
+    SeparatedSyntaxList<ExpressionSyntax> beforeExpr;
+    Token before;
+    SeparatedSyntaxList<ExpressionSyntax> afterExpr;
+    Token semi;
+
+    SolveBeforeConstraintSyntax(Token solve, const SeparatedSyntaxList<ExpressionSyntax>& beforeExpr, Token before, const SeparatedSyntaxList<ExpressionSyntax>& afterExpr, Token semi) :
+        ConstraintItemSyntax(SyntaxKind::SolveBeforeConstraint), solve(solve), beforeExpr(beforeExpr), before(before), afterExpr(afterExpr), semi(semi) {
+        this->beforeExpr.parent = this;
+        for (auto child : this->beforeExpr)
+            child->parent = this;
+        this->afterExpr.parent = this;
+        for (auto child : this->afterExpr)
+            child->parent = this;
+    }
+
+    explicit SolveBeforeConstraintSyntax(const SolveBeforeConstraintSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SolveBeforeConstraintSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConstraintBlockSyntax : public ConstraintItemSyntax {
+    Token openBrace;
+    SyntaxList<ConstraintItemSyntax> items;
+    Token closeBrace;
+
+    ConstraintBlockSyntax(Token openBrace, const SyntaxList<ConstraintItemSyntax>& items, Token closeBrace) :
+        ConstraintItemSyntax(SyntaxKind::ConstraintBlock), openBrace(openBrace), items(items), closeBrace(closeBrace) {
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    explicit ConstraintBlockSyntax(const ConstraintBlockSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConstraintBlockSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConstraintPrototypeSyntax : public MemberSyntax {
+    TokenList qualifiers;
+    Token keyword;
+    not_null<NameSyntax*> name;
+    Token semi;
+
+    ConstraintPrototypeSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token keyword, NameSyntax& name, Token semi) :
+        MemberSyntax(SyntaxKind::ConstraintPrototype, attributes), qualifiers(qualifiers), keyword(keyword), name(&name), semi(semi) {
+        this->qualifiers.parent = this;
+        this->name->parent = this;
+    }
+
+    explicit ConstraintPrototypeSyntax(const ConstraintPrototypeSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConstraintPrototypeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConstraintDeclarationSyntax : public MemberSyntax {
+    TokenList qualifiers;
+    Token keyword;
+    not_null<NameSyntax*> name;
+    not_null<ConstraintBlockSyntax*> block;
+
+    ConstraintDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token keyword, NameSyntax& name, ConstraintBlockSyntax& block) :
+        MemberSyntax(SyntaxKind::ConstraintDeclaration, attributes), qualifiers(qualifiers), keyword(keyword), name(&name), block(&block) {
+        this->qualifiers.parent = this;
+        this->name->parent = this;
+        this->block->parent = this;
+    }
+
+    explicit ConstraintDeclarationSyntax(const ConstraintDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConstraintDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ParenExpressionListSyntax : public SyntaxNode {
+    Token openParen;
+    SeparatedSyntaxList<ExpressionSyntax> expressions;
+    Token closeParen;
+
+    ParenExpressionListSyntax(Token openParen, const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token closeParen) :
+        SyntaxNode(SyntaxKind::ParenExpressionList), openParen(openParen), expressions(expressions), closeParen(closeParen) {
+        this->expressions.parent = this;
+        for (auto child : this->expressions)
+            child->parent = this;
+    }
+
+    explicit ParenExpressionListSyntax(const ParenExpressionListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ParenExpressionListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ArrayOrRandomizeMethodExpressionSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> method;
+    Token with;
+    ParenExpressionListSyntax* args;
+    ConstraintBlockSyntax* constraints;
+
+    ArrayOrRandomizeMethodExpressionSyntax(ExpressionSyntax& method, Token with, ParenExpressionListSyntax* args, ConstraintBlockSyntax* constraints) :
+        ExpressionSyntax(SyntaxKind::ArrayOrRandomizeMethodExpression), method(&method), with(with), args(args), constraints(constraints) {
+        this->method->parent = this;
+        if (this->args) this->args->parent = this;
+        if (this->constraints) this->constraints->parent = this;
+    }
+
+    explicit ArrayOrRandomizeMethodExpressionSyntax(const ArrayOrRandomizeMethodExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ArrayOrRandomizeMethodExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- COVER GROUPS -----
+
+struct WithFunctionSampleSyntax : public SyntaxNode {
+    Token with;
+    Token function;
+    Token sample;
+    not_null<AnsiPortListSyntax*> portList;
+
+    WithFunctionSampleSyntax(Token with, Token function, Token sample, AnsiPortListSyntax& portList) :
+        SyntaxNode(SyntaxKind::WithFunctionSample), with(with), function(function), sample(sample), portList(&portList) {
+        this->portList->parent = this;
+    }
+
+    explicit WithFunctionSampleSyntax(const WithFunctionSampleSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WithFunctionSampleSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct BlockEventExpressionSyntax : public SyntaxNode {
+
+    BlockEventExpressionSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit BlockEventExpressionSyntax(const BlockEventExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct BinaryBlockEventExpressionSyntax : public BlockEventExpressionSyntax {
+    not_null<BlockEventExpressionSyntax*> left;
+    Token orKeyword;
+    not_null<BlockEventExpressionSyntax*> right;
+
+    BinaryBlockEventExpressionSyntax(BlockEventExpressionSyntax& left, Token orKeyword, BlockEventExpressionSyntax& right) :
+        BlockEventExpressionSyntax(SyntaxKind::BinaryBlockEventExpression), left(&left), orKeyword(orKeyword), right(&right) {
+        this->left->parent = this;
+        this->right->parent = this;
+    }
+
+    explicit BinaryBlockEventExpressionSyntax(const BinaryBlockEventExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    BinaryBlockEventExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PrimaryBlockEventExpressionSyntax : public BlockEventExpressionSyntax {
+    Token keyword;
+    not_null<NameSyntax*> name;
+
+    PrimaryBlockEventExpressionSyntax(Token keyword, NameSyntax& name) :
+        BlockEventExpressionSyntax(SyntaxKind::PrimaryBlockEventExpression), keyword(keyword), name(&name) {
+        this->name->parent = this;
+    }
+
+    explicit PrimaryBlockEventExpressionSyntax(const PrimaryBlockEventExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PrimaryBlockEventExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct BlockCoverageEventSyntax : public SyntaxNode {
+    Token atat;
+    Token openParen;
+    not_null<BlockEventExpressionSyntax*> expr;
+    Token closeParen;
+
+    BlockCoverageEventSyntax(Token atat, Token openParen, BlockEventExpressionSyntax& expr, Token closeParen) :
+        SyntaxNode(SyntaxKind::BlockCoverageEvent), atat(atat), openParen(openParen), expr(&expr), closeParen(closeParen) {
+        this->expr->parent = this;
+    }
+
+    explicit BlockCoverageEventSyntax(const BlockCoverageEventSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    BlockCoverageEventSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct CovergroupDeclarationSyntax : public MemberSyntax {
+    Token covergroup;
+    Token name;
+    AnsiPortListSyntax* portList;
+    SyntaxNode* event;
+    Token semi;
+    SyntaxList<MemberSyntax> members;
+    Token endgroup;
+    NamedBlockClauseSyntax* endBlockName;
+
+    CovergroupDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token covergroup, Token name, AnsiPortListSyntax* portList, SyntaxNode* event, Token semi, const SyntaxList<MemberSyntax>& members, Token endgroup, NamedBlockClauseSyntax* endBlockName) :
+        MemberSyntax(SyntaxKind::CovergroupDeclaration, attributes), covergroup(covergroup), name(name), portList(portList), event(event), semi(semi), members(members), endgroup(endgroup), endBlockName(endBlockName) {
+        if (this->portList) this->portList->parent = this;
+        if (this->event) this->event->parent = this;
+        this->members.parent = this;
+        for (auto child : this->members)
+            child->parent = this;
+        if (this->endBlockName) this->endBlockName->parent = this;
+    }
+
+    explicit CovergroupDeclarationSyntax(const CovergroupDeclarationSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    CovergroupDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct CoverageOptionSyntax : public MemberSyntax {
+    Token option;
+    Token dot;
+    Token name;
+    Token equals;
+    not_null<ExpressionSyntax*> expr;
+    Token semi;
+
+    CoverageOptionSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token option, Token dot, Token name, Token equals, ExpressionSyntax& expr, Token semi) :
+        MemberSyntax(SyntaxKind::CoverageOption, attributes), option(option), dot(dot), name(name), equals(equals), expr(&expr), semi(semi) {
+        this->expr->parent = this;
+    }
+
+    explicit CoverageOptionSyntax(const CoverageOptionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    CoverageOptionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct CoverpointSyntax : public MemberSyntax {
+    DataTypeSyntax* type;
+    NamedLabelSyntax* label;
+    Token coverpoint;
+    not_null<ExpressionSyntax*> expr;
+    Token openBrace;
+    SyntaxList<MemberSyntax> members;
+    Token closeBrace;
+    Token emptySemi;
+
+    CoverpointSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, DataTypeSyntax* type, NamedLabelSyntax* label, Token coverpoint, ExpressionSyntax& expr, Token openBrace, const SyntaxList<MemberSyntax>& members, Token closeBrace, Token emptySemi) :
+        MemberSyntax(SyntaxKind::Coverpoint, attributes), type(type), label(label), coverpoint(coverpoint), expr(&expr), openBrace(openBrace), members(members), closeBrace(closeBrace), emptySemi(emptySemi) {
+        if (this->type) this->type->parent = this;
+        if (this->label) this->label->parent = this;
+        this->expr->parent = this;
+        this->members.parent = this;
+        for (auto child : this->members)
+            child->parent = this;
+    }
+
+    explicit CoverpointSyntax(const CoverpointSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    CoverpointSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct CoverageBinInitializerSyntax : public SyntaxNode {
+
+    CoverageBinInitializerSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit CoverageBinInitializerSyntax(const CoverageBinInitializerSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct DefaultCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
+    Token defaultKeyword;
+    Token sequenceKeyword;
+
+    DefaultCoverageBinInitializerSyntax(Token defaultKeyword, Token sequenceKeyword) :
+        CoverageBinInitializerSyntax(SyntaxKind::DefaultCoverageBinInitializer), defaultKeyword(defaultKeyword), sequenceKeyword(sequenceKeyword) {
+    }
+
+    explicit DefaultCoverageBinInitializerSyntax(const DefaultCoverageBinInitializerSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DefaultCoverageBinInitializerSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct WithClauseSyntax : public SyntaxNode {
+    Token with;
+    Token openParen;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+
+    WithClauseSyntax(Token with, Token openParen, ExpressionSyntax& expr, Token closeParen) :
+        SyntaxNode(SyntaxKind::WithClause), with(with), openParen(openParen), expr(&expr), closeParen(closeParen) {
+        this->expr->parent = this;
+    }
+
+    explicit WithClauseSyntax(const WithClauseSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WithClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ExpressionCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
+    not_null<ExpressionSyntax*> expr;
+    WithClauseSyntax* withClause;
+
+    ExpressionCoverageBinInitializerSyntax(ExpressionSyntax& expr, WithClauseSyntax* withClause) :
+        CoverageBinInitializerSyntax(SyntaxKind::ExpressionCoverageBinInitializer), expr(&expr), withClause(withClause) {
+        this->expr->parent = this;
+        if (this->withClause) this->withClause->parent = this;
+    }
+
+    explicit ExpressionCoverageBinInitializerSyntax(const ExpressionCoverageBinInitializerSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ExpressionCoverageBinInitializerSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct RangeCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
+    not_null<OpenRangeListSyntax*> ranges;
+    WithClauseSyntax* withClause;
+
+    RangeCoverageBinInitializerSyntax(OpenRangeListSyntax& ranges, WithClauseSyntax* withClause) :
+        CoverageBinInitializerSyntax(SyntaxKind::RangeCoverageBinInitializer), ranges(&ranges), withClause(withClause) {
+        this->ranges->parent = this;
+        if (this->withClause) this->withClause->parent = this;
+    }
+
+    explicit RangeCoverageBinInitializerSyntax(const RangeCoverageBinInitializerSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    RangeCoverageBinInitializerSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TransRepeatRangeSyntax : public SyntaxNode {
+    Token openBracket;
+    Token specifier;
+    SelectorSyntax* selector;
+    Token closeBracket;
+
+    TransRepeatRangeSyntax(Token openBracket, Token specifier, SelectorSyntax* selector, Token closeBracket) :
+        SyntaxNode(SyntaxKind::TransRepeatRange), openBracket(openBracket), specifier(specifier), selector(selector), closeBracket(closeBracket) {
+        if (this->selector) this->selector->parent = this;
+    }
+
+    explicit TransRepeatRangeSyntax(const TransRepeatRangeSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TransRepeatRangeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TransRangeSyntax : public SyntaxNode {
+    SeparatedSyntaxList<ExpressionSyntax> items;
+    TransRepeatRangeSyntax* repeat;
+
+    TransRangeSyntax(const SeparatedSyntaxList<ExpressionSyntax>& items, TransRepeatRangeSyntax* repeat) :
+        SyntaxNode(SyntaxKind::TransRange), items(items), repeat(repeat) {
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+        if (this->repeat) this->repeat->parent = this;
+    }
+
+    explicit TransRangeSyntax(const TransRangeSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TransRangeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TransSetSyntax : public SyntaxNode {
+    Token openParen;
+    SeparatedSyntaxList<TransRangeSyntax> ranges;
+    Token closeParen;
+
+    TransSetSyntax(Token openParen, const SeparatedSyntaxList<TransRangeSyntax>& ranges, Token closeParen) :
+        SyntaxNode(SyntaxKind::TransSet), openParen(openParen), ranges(ranges), closeParen(closeParen) {
+        this->ranges.parent = this;
+        for (auto child : this->ranges)
+            child->parent = this;
+    }
+
+    explicit TransSetSyntax(const TransSetSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TransSetSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TransListCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
+    SeparatedSyntaxList<TransSetSyntax> sets;
+    WithClauseSyntax* withClause;
+
+    TransListCoverageBinInitializerSyntax(const SeparatedSyntaxList<TransSetSyntax>& sets, WithClauseSyntax* withClause) :
+        CoverageBinInitializerSyntax(SyntaxKind::TransListCoverageBinInitializer), sets(sets), withClause(withClause) {
+        this->sets.parent = this;
+        for (auto child : this->sets)
+            child->parent = this;
+        if (this->withClause) this->withClause->parent = this;
+    }
+
+    explicit TransListCoverageBinInitializerSyntax(const TransListCoverageBinInitializerSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TransListCoverageBinInitializerSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct CoverageIffClauseSyntax : public SyntaxNode {
+    Token iff;
+    Token openParen;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+
+    CoverageIffClauseSyntax(Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen) :
+        SyntaxNode(SyntaxKind::CoverageIffClause), iff(iff), openParen(openParen), expr(&expr), closeParen(closeParen) {
+        this->expr->parent = this;
+    }
+
+    explicit CoverageIffClauseSyntax(const CoverageIffClauseSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    CoverageIffClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct CoverageBinsSyntax : public MemberSyntax {
+    Token wildcard;
+    Token keyword;
+    Token name;
+    ElementSelectSyntax* selector;
+    Token equals;
+    not_null<CoverageBinInitializerSyntax*> initializer;
+    CoverageIffClauseSyntax* iff;
+    Token semi;
+
+    CoverageBinsSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token wildcard, Token keyword, Token name, ElementSelectSyntax* selector, Token equals, CoverageBinInitializerSyntax& initializer, CoverageIffClauseSyntax* iff, Token semi) :
+        MemberSyntax(SyntaxKind::CoverageBins, attributes), wildcard(wildcard), keyword(keyword), name(name), selector(selector), equals(equals), initializer(&initializer), iff(iff), semi(semi) {
+        if (this->selector) this->selector->parent = this;
+        this->initializer->parent = this;
+        if (this->iff) this->iff->parent = this;
+    }
+
+    explicit CoverageBinsSyntax(const CoverageBinsSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    CoverageBinsSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- TOP LEVEL -----
+
+struct CompilationUnitSyntax : public SyntaxNode {
+    SyntaxList<MemberSyntax> members;
+    Token endOfFile;
+
+    CompilationUnitSyntax(const SyntaxList<MemberSyntax>& members, Token endOfFile) :
+        SyntaxNode(SyntaxKind::CompilationUnit), members(members), endOfFile(endOfFile) {
+        this->members.parent = this;
+        for (auto child : this->members)
+            child->parent = this;
+    }
+
+    explicit CompilationUnitSyntax(const CompilationUnitSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    CompilationUnitSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- DIRECTIVES -----
+
+struct DirectiveSyntax : public SyntaxNode {
+    Token directive;
+
+    DirectiveSyntax(SyntaxKind kind, Token directive) :
+        SyntaxNode(kind), directive(directive) {
+    }
+
+    explicit DirectiveSyntax(const DirectiveSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct SimpleDirectiveSyntax : public DirectiveSyntax {
+
+    SimpleDirectiveSyntax(SyntaxKind kind, Token directive) :
+        DirectiveSyntax(kind, directive) {
+    }
+
+    explicit SimpleDirectiveSyntax(const SimpleDirectiveSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SimpleDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct IncludeDirectiveSyntax : public DirectiveSyntax {
+    Token fileName;
+
+    IncludeDirectiveSyntax(Token directive, Token fileName) :
+        DirectiveSyntax(SyntaxKind::IncludeDirective, directive), fileName(fileName) {
+    }
+
+    explicit IncludeDirectiveSyntax(const IncludeDirectiveSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    IncludeDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConditionalBranchDirectiveSyntax : public DirectiveSyntax {
+    Token name;
+    TokenList disabledTokens;
+
+    ConditionalBranchDirectiveSyntax(SyntaxKind kind, Token directive, Token name, const TokenList& disabledTokens) :
+        DirectiveSyntax(kind, directive), name(name), disabledTokens(disabledTokens) {
+        this->disabledTokens.parent = this;
+    }
+
+    explicit ConditionalBranchDirectiveSyntax(const ConditionalBranchDirectiveSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConditionalBranchDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct UnconditionalBranchDirectiveSyntax : public DirectiveSyntax {
+    TokenList disabledTokens;
+
+    UnconditionalBranchDirectiveSyntax(SyntaxKind kind, Token directive, const TokenList& disabledTokens) :
+        DirectiveSyntax(kind, directive), disabledTokens(disabledTokens) {
+        this->disabledTokens.parent = this;
+    }
+
+    explicit UnconditionalBranchDirectiveSyntax(const UnconditionalBranchDirectiveSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    UnconditionalBranchDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MacroArgumentDefaultSyntax : public SyntaxNode {
+    Token equals;
+    TokenList tokens;
+
+    MacroArgumentDefaultSyntax(Token equals, const TokenList& tokens) :
+        SyntaxNode(SyntaxKind::MacroArgumentDefault), equals(equals), tokens(tokens) {
+        this->tokens.parent = this;
+    }
+
+    explicit MacroArgumentDefaultSyntax(const MacroArgumentDefaultSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MacroArgumentDefaultSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MacroFormalArgumentSyntax : public SyntaxNode {
+    Token name;
+    MacroArgumentDefaultSyntax* defaultValue;
+
+    MacroFormalArgumentSyntax(Token name, MacroArgumentDefaultSyntax* defaultValue) :
+        SyntaxNode(SyntaxKind::MacroFormalArgument), name(name), defaultValue(defaultValue) {
+        if (this->defaultValue) this->defaultValue->parent = this;
+    }
+
+    explicit MacroFormalArgumentSyntax(const MacroFormalArgumentSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MacroFormalArgumentSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MacroFormalArgumentListSyntax : public SyntaxNode {
+    Token openParen;
+    SeparatedSyntaxList<MacroFormalArgumentSyntax> args;
+    Token closeParen;
+
+    MacroFormalArgumentListSyntax(Token openParen, const SeparatedSyntaxList<MacroFormalArgumentSyntax>& args, Token closeParen) :
+        SyntaxNode(SyntaxKind::MacroFormalArgumentList), openParen(openParen), args(args), closeParen(closeParen) {
+        this->args.parent = this;
+        for (auto child : this->args)
+            child->parent = this;
+    }
+
+    explicit MacroFormalArgumentListSyntax(const MacroFormalArgumentListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MacroFormalArgumentListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DefineDirectiveSyntax : public DirectiveSyntax {
+    Token name;
+    MacroFormalArgumentListSyntax* formalArguments;
+    TokenList body;
+
+    DefineDirectiveSyntax(Token directive, Token name, MacroFormalArgumentListSyntax* formalArguments, const TokenList& body) :
+        DirectiveSyntax(SyntaxKind::DefineDirective, directive), name(name), formalArguments(formalArguments), body(body) {
+        if (this->formalArguments) this->formalArguments->parent = this;
+        this->body.parent = this;
+    }
+
+    explicit DefineDirectiveSyntax(const DefineDirectiveSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DefineDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MacroActualArgumentSyntax : public SyntaxNode {
+    TokenList tokens;
+
+    MacroActualArgumentSyntax(const TokenList& tokens) :
+        SyntaxNode(SyntaxKind::MacroActualArgument), tokens(tokens) {
+        this->tokens.parent = this;
+    }
+
+    explicit MacroActualArgumentSyntax(const MacroActualArgumentSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MacroActualArgumentSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MacroActualArgumentListSyntax : public SyntaxNode {
+    Token openParen;
+    SeparatedSyntaxList<MacroActualArgumentSyntax> args;
+    Token closeParen;
+
+    MacroActualArgumentListSyntax(Token openParen, const SeparatedSyntaxList<MacroActualArgumentSyntax>& args, Token closeParen) :
+        SyntaxNode(SyntaxKind::MacroActualArgumentList), openParen(openParen), args(args), closeParen(closeParen) {
+        this->args.parent = this;
+        for (auto child : this->args)
+            child->parent = this;
+    }
+
+    explicit MacroActualArgumentListSyntax(const MacroActualArgumentListSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MacroActualArgumentListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MacroUsageSyntax : public DirectiveSyntax {
+    MacroActualArgumentListSyntax* args;
+
+    MacroUsageSyntax(Token directive, MacroActualArgumentListSyntax* args) :
+        DirectiveSyntax(SyntaxKind::MacroUsage, directive), args(args) {
+        if (this->args) this->args->parent = this;
+    }
+
+    explicit MacroUsageSyntax(const MacroUsageSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MacroUsageSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TimeScaleDirectiveSyntax : public DirectiveSyntax {
+    Token timeUnit;
+    Token slash;
+    Token timePrecision;
+
+    TimeScaleDirectiveSyntax(Token directive, Token timeUnit, Token slash, Token timePrecision) :
+        DirectiveSyntax(SyntaxKind::TimeScaleDirective, directive), timeUnit(timeUnit), slash(slash), timePrecision(timePrecision) {
+    }
+
+    explicit TimeScaleDirectiveSyntax(const TimeScaleDirectiveSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TimeScaleDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DefaultNetTypeDirectiveSyntax : public DirectiveSyntax {
+    Token netType;
+
+    DefaultNetTypeDirectiveSyntax(Token directive, Token netType) :
+        DirectiveSyntax(SyntaxKind::DefaultNetTypeDirective, directive), netType(netType) {
+    }
+
+    explicit DefaultNetTypeDirectiveSyntax(const DefaultNetTypeDirectiveSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DefaultNetTypeDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct UnconnectedDriveDirectiveSyntax : public DirectiveSyntax {
+    Token strength;
+
+    UnconnectedDriveDirectiveSyntax(Token directive, Token strength) :
+        DirectiveSyntax(SyntaxKind::UnconnectedDriveDirective, directive), strength(strength) {
+    }
+
+    explicit UnconnectedDriveDirectiveSyntax(const UnconnectedDriveDirectiveSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    UnconnectedDriveDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct LineDirectiveSyntax : public DirectiveSyntax {
+    Token lineNumber;
+    Token fileName;
+    Token level;
+
+    LineDirectiveSyntax(Token directive, Token lineNumber, Token fileName, Token level) :
+        DirectiveSyntax(SyntaxKind::LineDirective, directive), lineNumber(lineNumber), fileName(fileName), level(level) {
+    }
+
+    explicit LineDirectiveSyntax(const LineDirectiveSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    LineDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct UndefDirectiveSyntax : public DirectiveSyntax {
+    Token name;
+
+    UndefDirectiveSyntax(Token directive, Token name) :
+        DirectiveSyntax(SyntaxKind::UndefDirective, directive), name(name) {
+    }
+
+    explicit UndefDirectiveSyntax(const UndefDirectiveSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    UndefDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct BeginKeywordsDirectiveSyntax : public DirectiveSyntax {
+    Token versionSpecifier;
+
+    BeginKeywordsDirectiveSyntax(Token directive, Token versionSpecifier) :
+        DirectiveSyntax(SyntaxKind::BeginKeywordsDirective, directive), versionSpecifier(versionSpecifier) {
+    }
+
+    explicit BeginKeywordsDirectiveSyntax(const BeginKeywordsDirectiveSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    BeginKeywordsDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PragmaExpressionSyntax : public SyntaxNode {
+
+    PragmaExpressionSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    explicit PragmaExpressionSyntax(const PragmaExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct SimplePragmaExpressionSyntax : public PragmaExpressionSyntax {
+    Token value;
+
+    SimplePragmaExpressionSyntax(Token value) :
+        PragmaExpressionSyntax(SyntaxKind::SimplePragmaExpression), value(value) {
+    }
+
+    explicit SimplePragmaExpressionSyntax(const SimplePragmaExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SimplePragmaExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NameValuePragmaExpressionSyntax : public PragmaExpressionSyntax {
+    Token name;
+    Token equals;
+    not_null<PragmaExpressionSyntax*> value;
+
+    NameValuePragmaExpressionSyntax(Token name, Token equals, PragmaExpressionSyntax& value) :
+        PragmaExpressionSyntax(SyntaxKind::NameValuePragmaExpression), name(name), equals(equals), value(&value) {
+        this->value->parent = this;
+    }
+
+    explicit NameValuePragmaExpressionSyntax(const NameValuePragmaExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NameValuePragmaExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NumberPragmaExpressionSyntax : public PragmaExpressionSyntax {
+    Token size;
+    Token base;
+    Token value;
+
+    NumberPragmaExpressionSyntax(Token size, Token base, Token value) :
+        PragmaExpressionSyntax(SyntaxKind::NumberPragmaExpression), size(size), base(base), value(value) {
+    }
+
+    explicit NumberPragmaExpressionSyntax(const NumberPragmaExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NumberPragmaExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ParenPragmaExpressionSyntax : public PragmaExpressionSyntax {
+    Token openParen;
+    SeparatedSyntaxList<PragmaExpressionSyntax> values;
+    Token closeParen;
+
+    ParenPragmaExpressionSyntax(Token openParen, const SeparatedSyntaxList<PragmaExpressionSyntax>& values, Token closeParen) :
+        PragmaExpressionSyntax(SyntaxKind::ParenPragmaExpression), openParen(openParen), values(values), closeParen(closeParen) {
+        this->values.parent = this;
+        for (auto child : this->values)
+            child->parent = this;
+    }
+
+    explicit ParenPragmaExpressionSyntax(const ParenPragmaExpressionSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ParenPragmaExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PragmaDirectiveSyntax : public DirectiveSyntax {
+    Token name;
+    SeparatedSyntaxList<PragmaExpressionSyntax> args;
+
+    PragmaDirectiveSyntax(Token directive, Token name, const SeparatedSyntaxList<PragmaExpressionSyntax>& args) :
+        DirectiveSyntax(SyntaxKind::PragmaDirective, directive), name(name), args(args) {
+        this->args.parent = this;
+        for (auto child : this->args)
+            child->parent = this;
+    }
+
+    explicit PragmaDirectiveSyntax(const PragmaDirectiveSyntax&) = default;
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PragmaDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+class SyntaxFactory {
+public:
+    explicit SyntaxFactory(BumpAllocator& alloc) : alloc(alloc) {}
+
+    ActionBlockSyntax& actionBlock(StatementSyntax* statement, ElseClauseSyntax* elseClause);
+    AnsiPortListSyntax& ansiPortList(Token openParen, const SeparatedSyntaxList<MemberSyntax>& ports, Token closeParen);
+    AnsiUdpPortListSyntax& ansiUdpPortList(Token openParen, const SeparatedSyntaxList<UdpPortDeclSyntax>& ports, Token closeParen, Token semi);
+    ArgumentListSyntax& argumentList(Token openParen, const SeparatedSyntaxList<ArgumentSyntax>& parameters, Token closeParen);
+    ArrayOrRandomizeMethodExpressionSyntax& arrayOrRandomizeMethodExpression(ExpressionSyntax& method, Token with, ParenExpressionListSyntax* args, ConstraintBlockSyntax* constraints);
+    AssertionItemPortListSyntax& assertionItemPortList(Token openParen, const SeparatedSyntaxList<AssertionItemPortSyntax>& ports, Token closeParen);
+    AssertionItemPortSyntax& assertionItemPort(const SyntaxList<AttributeInstanceSyntax>& attributes, Token local, Token direction, DataTypeSyntax& type, DeclaratorSyntax& declarator);
+    AssignmentPatternExpressionSyntax& assignmentPatternExpression(DataTypeSyntax* type, AssignmentPatternSyntax& pattern);
+    AssignmentPatternItemSyntax& assignmentPatternItem(ExpressionSyntax& key, Token colon, ExpressionSyntax& expr);
+    AttributeInstanceSyntax& attributeInstance(Token openParen, const SeparatedSyntaxList<AttributeSpecSyntax>& specs, Token closeParen);
+    AttributeSpecSyntax& attributeSpec(Token name, EqualsValueClauseSyntax* value);
+    BadExpressionSyntax& badExpression(ExpressionSyntax& expr);
+    BeginKeywordsDirectiveSyntax& beginKeywordsDirective(Token directive, Token versionSpecifier);
+    BinaryBlockEventExpressionSyntax& binaryBlockEventExpression(BlockEventExpressionSyntax& left, Token orKeyword, BlockEventExpressionSyntax& right);
+    BinaryEventExpressionSyntax& binaryEventExpression(EventExpressionSyntax& left, Token operatorToken, EventExpressionSyntax& right);
+    BinaryExpressionSyntax& binaryExpression(SyntaxKind kind, ExpressionSyntax& left, Token operatorToken, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& right);
+    BindDirectiveSyntax& bindDirective(const SyntaxList<AttributeInstanceSyntax>& attributes, Token bind, NameSyntax& target, BindTargetListSyntax* targetInstances, HierarchyInstantiationSyntax& instantiation);
+    BindTargetListSyntax& bindTargetList(Token colon, const SeparatedSyntaxList<NameSyntax>& targets);
+    BitSelectSyntax& bitSelect(ExpressionSyntax& expr);
+    BlockCoverageEventSyntax& blockCoverageEvent(Token atat, Token openParen, BlockEventExpressionSyntax& expr, Token closeParen);
+    BlockStatementSyntax& blockStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token begin, NamedBlockClauseSyntax* blockName, const SyntaxList<SyntaxNode>& items, Token end, NamedBlockClauseSyntax* endBlockName);
+    CaseGenerateSyntax& caseGenerate(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, const SyntaxList<CaseItemSyntax>& items, Token endCase);
+    CaseStatementSyntax& caseStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token uniqueOrPriority, Token caseKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token matchesOrInside, const SyntaxList<CaseItemSyntax>& items, Token endcase);
+    CastExpressionSyntax& castExpression(ExpressionSyntax& left, Token apostrophe, ParenthesizedExpressionSyntax& right);
+    ChargeStrengthSyntax& chargeStrength(Token openParen, Token strength, Token closeParen);
+    ClassDeclarationSyntax& classDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token virtualOrInterface, Token classKeyword, Token lifetime, Token name, ParameterPortListSyntax* parameters, ExtendsClauseSyntax* extendsClause, ImplementsClauseSyntax* implementsClause, Token semi, const SyntaxList<MemberSyntax>& items, Token endClass, NamedBlockClauseSyntax* endBlockName);
+    ClassMethodDeclarationSyntax& classMethodDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, FunctionDeclarationSyntax& declaration);
+    ClassMethodPrototypeSyntax& classMethodPrototype(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, FunctionPrototypeSyntax& prototype, Token semi);
+    ClassNameSyntax& className(Token identifier, ParameterValueAssignmentSyntax& parameters);
+    ClassPropertyDeclarationSyntax& classPropertyDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, MemberSyntax& declaration);
+    ClockingDeclarationSyntax& clockingDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token globalOrDefault, Token clocking, Token blockName, Token at, EventExpressionSyntax& event, Token semi, const SyntaxList<MemberSyntax>& items, Token endClocking, NamedBlockClauseSyntax* endBlockName);
+    ClockingDirectionSyntax& clockingDirection(Token input, ClockingSkewSyntax* inputSkew, Token output, ClockingSkewSyntax* ouputSkew);
+    ClockingItemSyntax& clockingItem(const SyntaxList<AttributeInstanceSyntax>& attributes, ClockingDirectionSyntax& direction, const SeparatedSyntaxList<AttributeSpecSyntax>& decls, Token semi);
+    ClockingSkewSyntax& clockingSkew(Token edge, DelaySyntax* delay);
+    ColonExpressionClauseSyntax& colonExpressionClause(Token colon, ExpressionSyntax& expr);
+    CompilationUnitSyntax& compilationUnit(const SyntaxList<MemberSyntax>& members, Token endOfFile);
+    ConcatenationExpressionSyntax& concatenationExpression(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token closeBrace);
+    ConcurrentAssertionMemberSyntax& concurrentAssertionMember(const SyntaxList<AttributeInstanceSyntax>& attributes, ConcurrentAssertionStatementSyntax& statement);
+    ConcurrentAssertionStatementSyntax& concurrentAssertionStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token propertyOrSequence, Token openParen, PropertySpecSyntax& propertySpec, Token closeParen, ActionBlockSyntax& action);
+    ConditionalBranchDirectiveSyntax& conditionalBranchDirective(SyntaxKind kind, Token directive, Token name, const TokenList& disabledTokens);
+    ConditionalConstraintSyntax& conditionalConstraint(Token ifKeyword, Token openParen, ExpressionSyntax& condition, Token closeParen, ConstraintItemSyntax& constraints, ElseConstraintClauseSyntax* elseClause);
+    ConditionalExpressionSyntax& conditionalExpression(ConditionalPredicateSyntax& predicate, Token question, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& left, Token colon, ExpressionSyntax& right);
+    ConditionalPathDeclarationSyntax& conditionalPathDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& predicate, Token closeParen, PathDeclarationSyntax& path);
+    ConditionalPatternSyntax& conditionalPattern(ExpressionSyntax& expr, MatchesClauseSyntax* matchesClause);
+    ConditionalPredicateSyntax& conditionalPredicate(const SeparatedSyntaxList<ConditionalPatternSyntax>& conditions);
+    ConditionalStatementSyntax& conditionalStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token uniqueOrPriority, Token ifKeyword, Token openParen, ConditionalPredicateSyntax& predicate, Token closeParen, StatementSyntax& statement, ElseClauseSyntax* elseClause);
+    ConstraintBlockSyntax& constraintBlock(Token openBrace, const SyntaxList<ConstraintItemSyntax>& items, Token closeBrace);
+    ConstraintDeclarationSyntax& constraintDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token keyword, NameSyntax& name, ConstraintBlockSyntax& block);
+    ConstraintPrototypeSyntax& constraintPrototype(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token keyword, NameSyntax& name, Token semi);
+    ContinuousAssignSyntax& continuousAssign(const SyntaxList<AttributeInstanceSyntax>& attributes, Token assign, DriveStrengthSyntax* strength, TimingControlSyntax* delay, const SeparatedSyntaxList<ExpressionSyntax>& assignments, Token semi);
+    CopyClassExpressionSyntax& copyClassExpression(NameSyntax& scopedNew, ExpressionSyntax& expr);
+    CoverageBinsSyntax& coverageBins(const SyntaxList<AttributeInstanceSyntax>& attributes, Token wildcard, Token keyword, Token name, ElementSelectSyntax* selector, Token equals, CoverageBinInitializerSyntax& initializer, CoverageIffClauseSyntax* iff, Token semi);
+    CoverageIffClauseSyntax& coverageIffClause(Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen);
+    CoverageOptionSyntax& coverageOption(const SyntaxList<AttributeInstanceSyntax>& attributes, Token option, Token dot, Token name, Token equals, ExpressionSyntax& expr, Token semi);
+    CovergroupDeclarationSyntax& covergroupDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token covergroup, Token name, AnsiPortListSyntax* portList, SyntaxNode* event, Token semi, const SyntaxList<MemberSyntax>& members, Token endgroup, NamedBlockClauseSyntax* endBlockName);
+    CoverpointSyntax& coverpoint(const SyntaxList<AttributeInstanceSyntax>& attributes, DataTypeSyntax* type, NamedLabelSyntax* label, Token coverpoint, ExpressionSyntax& expr, Token openBrace, const SyntaxList<MemberSyntax>& members, Token closeBrace, Token emptySemi);
+    DPIExportSyntax& dPIExport(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token specString, Token c_identifier, Token equals, Token functionOrTask, Token name, Token semi);
+    DPIImportSyntax& dPIImport(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token specString, Token property, Token c_identifier, Token equals, FunctionPrototypeSyntax& method, Token semi);
+    DataDeclarationSyntax& dataDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& modifiers, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi);
+    DeclaratorSyntax& declarator(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, EqualsValueClauseSyntax* initializer);
+    DefParamAssignmentSyntax& defParamAssignment(NameSyntax& name, EqualsValueClauseSyntax& setter);
+    DefParamSyntax& defParam(const SyntaxList<AttributeInstanceSyntax>& attributes, Token defparam, const SeparatedSyntaxList<DefParamAssignmentSyntax>& assignments, Token semi);
+    DefaultCaseItemSyntax& defaultCaseItem(Token defaultKeyword, Token colon, SyntaxNode& clause);
+    DefaultClockingReferenceSyntax& defaultClockingReference(const SyntaxList<AttributeInstanceSyntax>& attributes, Token defaultKeyword, Token clocking, Token name, Token semi);
+    DefaultCoverageBinInitializerSyntax& defaultCoverageBinInitializer(Token defaultKeyword, Token sequenceKeyword);
+    DefaultNetTypeDirectiveSyntax& defaultNetTypeDirective(Token directive, Token netType);
+    DefaultSkewItemSyntax& defaultSkewItem(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ClockingDirectionSyntax& direction, Token semi);
+    DeferredAssertionSyntax& deferredAssertion(Token hash, Token zero, Token finalKeyword);
+    DefineDirectiveSyntax& defineDirective(Token directive, Token name, MacroFormalArgumentListSyntax* formalArguments, const TokenList& body);
+    Delay3Syntax& delay3(Token hash, Token openParen, ExpressionSyntax& delay1, Token comma1, ExpressionSyntax* delay2, Token comma2, ExpressionSyntax* delay3, Token closeParen);
+    DelaySyntax& delay(SyntaxKind kind, Token hash, ExpressionSyntax& delayValue);
+    DelayedTerminalArgSyntax& delayedTerminalArg(Token terminal, Token openBracket, ExpressionSyntax& expr, Token closeBracket);
+    DisableConstraintSyntax& disableConstraint(Token disable, Token soft, NameSyntax& name, Token semi);
+    DisableForkStatementSyntax& disableForkStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token disable, Token fork, Token semi);
+    DisableIffSyntax& disableIff(Token disable, Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen);
+    DisableStatementSyntax& disableStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token disable, NameSyntax& name, Token semi);
+    DistConstraintListSyntax& distConstraintList(Token dist, Token openBrace, const SeparatedSyntaxList<DistItemSyntax>& items, Token closeBrace);
+    DistItemSyntax& distItem(ExpressionSyntax& range, DistWeightSyntax* weight);
+    DistWeightSyntax& distWeight(Token op, ExpressionSyntax& expr);
+    DividerClauseSyntax& dividerClause(Token divide, Token value);
+    DoWhileStatementSyntax& doWhileStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token doKeyword, StatementSyntax& statement, Token whileKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi);
+    DotMemberClauseSyntax& dotMemberClause(Token dot, Token member);
+    DriveStrengthSyntax& driveStrength(Token openParen, Token strength0, Token comma, Token strength1, Token closeParen);
+    EdgeControlSpecifierSyntax& edgeControlSpecifier(Token openBracket, const SeparatedSyntaxList<EdgeDescriptorSyntax>& descriptors, Token closeBracket);
+    EdgeDescriptorSyntax& edgeDescriptor(Token t1, Token t2);
+    EdgeSensitivePathSuffixSyntax& edgeSensitivePathSuffix(Token openParen, const SeparatedSyntaxList<NameSyntax>& outputs, Token polarityOperator, Token colon, ExpressionSyntax& expr, Token closeParen);
+    ElabSystemTaskSyntax& elabSystemTask(const SyntaxList<AttributeInstanceSyntax>& attributes, Token name, ArgumentListSyntax* arguments, Token semi);
+    ElementSelectExpressionSyntax& elementSelectExpression(ExpressionSyntax& left, ElementSelectSyntax& select);
+    ElementSelectSyntax& elementSelect(Token openBracket, SelectorSyntax* selector, Token closeBracket);
+    ElseClauseSyntax& elseClause(Token elseKeyword, SyntaxNode& clause);
+    ElseConstraintClauseSyntax& elseConstraintClause(Token elseKeyword, ConstraintItemSyntax& constraints);
+    EmptyArgumentSyntax& emptyArgument(Token placeholder);
+    EmptyIdentifierNameSyntax& emptyIdentifierName(Token placeholder);
+    EmptyMemberSyntax& emptyMember(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token semi);
+    EmptyPortConnectionSyntax& emptyPortConnection(const SyntaxList<AttributeInstanceSyntax>& attributes, Token placeholder);
+    EmptyQueueExpressionSyntax& emptyQueueExpression(Token openBrace, Token closeBrace);
+    EmptyStatementSyntax& emptyStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token semicolon);
+    EmptyTimingCheckArgSyntax& emptyTimingCheckArg(Token placeholder);
+    EnumTypeSyntax& enumType(Token keyword, DataTypeSyntax* baseType, Token openBrace, const SeparatedSyntaxList<DeclaratorSyntax>& members, Token closeBrace, const SyntaxList<VariableDimensionSyntax>& dimensions);
+    EqualsTypeClauseSyntax& equalsTypeClause(Token equals, DataTypeSyntax& type);
+    EqualsValueClauseSyntax& equalsValueClause(Token equals, ExpressionSyntax& expr);
+    EventControlSyntax& eventControl(Token at, NameSyntax& eventName);
+    EventControlWithExpressionSyntax& eventControlWithExpression(Token at, EventExpressionSyntax& expr);
+    EventTriggerStatementSyntax& eventTriggerStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token trigger, TimingControlSyntax* timing, NameSyntax& name, Token semi);
+    ExplicitAnsiPortSyntax& explicitAnsiPort(const SyntaxList<AttributeInstanceSyntax>& attributes, Token direction, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen);
+    ExplicitNonAnsiPortSyntax& explicitNonAnsiPort(Token dot, Token name, Token openParen, PortExpressionSyntax* expr, Token closeParen);
+    ExpressionConstraintSyntax& expressionConstraint(Token soft, ExpressionSyntax& expr, Token semi);
+    ExpressionCoverageBinInitializerSyntax& expressionCoverageBinInitializer(ExpressionSyntax& expr, WithClauseSyntax* withClause);
+    ExpressionOrDistSyntax& expressionOrDist(ExpressionSyntax& expr, DistConstraintListSyntax& distribution);
+    ExpressionPatternSyntax& expressionPattern(ExpressionSyntax& expr);
+    ExpressionStatementSyntax& expressionStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& expr, Token semi);
+    ExpressionTimingCheckArgSyntax& expressionTimingCheckArg(ExpressionSyntax& expr, TimingCheckConditionSyntax* condition);
+    ExtendsClauseSyntax& extendsClause(Token keyword, NameSyntax& baseName, ArgumentListSyntax* arguments);
+    ExternModuleSyntax& externModule(Token externKeyword, ModuleHeaderSyntax& header);
+    ForLoopStatementSyntax& forLoopStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token forKeyword, Token openParen, const SeparatedSyntaxList<SyntaxNode>& initializers, Token semi1, ExpressionSyntax& stopExpr, Token semi2, const SeparatedSyntaxList<ExpressionSyntax>& steps, Token closeParen, StatementSyntax& statement);
+    ForVariableDeclarationSyntax& forVariableDeclaration(Token varKeyword, DataTypeSyntax* type, DeclaratorSyntax& declarator);
+    ForeachLoopListSyntax& foreachLoopList(Token openParen, NameSyntax& arrayName, Token openBracket, const SeparatedSyntaxList<NameSyntax>& loopVariables, Token closeBracket, Token closeParen);
+    ForeachLoopStatementSyntax& foreachLoopStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ForeachLoopListSyntax& loopList, StatementSyntax& statement);
+    ForeverStatementSyntax& foreverStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token foreverKeyword, StatementSyntax& statement);
+    ForwardInterfaceClassTypedefDeclarationSyntax& forwardInterfaceClassTypedefDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, Token interfaceKeyword, Token classKeyword, Token name, Token semi);
+    ForwardTypedefDeclarationSyntax& forwardTypedefDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, Token keyword, Token name, Token semi);
+    FunctionDeclarationSyntax& functionDeclaration(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, FunctionPrototypeSyntax& prototype, Token semi, const SyntaxList<SyntaxNode>& items, Token end, NamedBlockClauseSyntax* endBlockName);
+    FunctionPortListSyntax& functionPortList(Token openParen, const SeparatedSyntaxList<FunctionPortSyntax>& ports, Token closeParen);
+    FunctionPortSyntax& functionPort(const SyntaxList<AttributeInstanceSyntax>& attributes, Token constKeyword, Token direction, Token varKeyword, DataTypeSyntax* dataType, DeclaratorSyntax& declarator);
+    FunctionPrototypeSyntax& functionPrototype(Token keyword, Token lifetime, DataTypeSyntax& returnType, NameSyntax& name, FunctionPortListSyntax* portList);
+    GateInstanceNameSyntax& gateInstanceName(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions);
+    GateInstanceSyntax& gateInstance(GateInstanceNameSyntax* decl, Token openParen, const SeparatedSyntaxList<ExpressionSyntax>& connections, Token closeParen);
+    GateInstantiationSyntax& gateInstantiation(const SyntaxList<AttributeInstanceSyntax>& attributes, Token gateType, DriveStrengthSyntax* strength, TimingControlSyntax* delay, const SeparatedSyntaxList<GateInstanceSyntax>& instances, Token semi);
+    GenerateBlockSyntax& generateBlock(const SyntaxList<AttributeInstanceSyntax>& attributes, NamedLabelSyntax* label, Token begin, NamedBlockClauseSyntax* beginName, const SyntaxList<MemberSyntax>& members, Token end, NamedBlockClauseSyntax* endName);
+    GenerateRegionSyntax& generateRegion(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SyntaxList<MemberSyntax>& members, Token endgenerate);
+    GenvarDeclarationSyntax& genvarDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<IdentifierNameSyntax>& identifiers, Token semi);
+    HierarchicalInstanceSyntax& hierarchicalInstance(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, Token openParen, const SeparatedSyntaxList<PortConnectionSyntax>& connections, Token closeParen);
+    HierarchyInstantiationSyntax& hierarchyInstantiation(const SyntaxList<AttributeInstanceSyntax>& attributes, Token type, ParameterValueAssignmentSyntax* parameters, const SeparatedSyntaxList<HierarchicalInstanceSyntax>& instances, Token semi);
+    IdentifierNameSyntax& identifierName(Token identifier);
+    IdentifierSelectNameSyntax& identifierSelectName(Token identifier, const SyntaxList<ElementSelectSyntax>& selectors);
+    IfGenerateSyntax& ifGenerate(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, MemberSyntax& block, ElseClauseSyntax* elseClause);
+    IfNonePathDeclarationSyntax& ifNonePathDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, PathDeclarationSyntax& path);
+    IffEventClauseSyntax& iffEventClause(Token iff, ExpressionSyntax& expr);
+    ImmediateAssertionMemberSyntax& immediateAssertionMember(const SyntaxList<AttributeInstanceSyntax>& attributes, ImmediateAssertionStatementSyntax& statement);
+    ImmediateAssertionStatementSyntax& immediateAssertionStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, DeferredAssertionSyntax* delay, ParenthesizedExpressionSyntax& expr, ActionBlockSyntax& action);
+    ImplementsClauseSyntax& implementsClause(Token keyword, const SeparatedSyntaxList<NameSyntax>& interfaces);
+    ImplicationConstraintSyntax& implicationConstraint(ExpressionSyntax& left, Token arrow, ConstraintItemSyntax& constraints);
+    ImplicitAnsiPortSyntax& implicitAnsiPort(const SyntaxList<AttributeInstanceSyntax>& attributes, PortHeaderSyntax& header, DeclaratorSyntax& declarator);
+    ImplicitEventControlSyntax& implicitEventControl(Token at, Token openParen, Token star, Token closeParen);
+    ImplicitNonAnsiPortSyntax& implicitNonAnsiPort(PortExpressionSyntax* expr);
+    ImplicitTypeSyntax& implicitType(Token signing, const SyntaxList<VariableDimensionSyntax>& dimensions);
+    IncludeDirectiveSyntax& includeDirective(Token directive, Token fileName);
+    InsideExpressionSyntax& insideExpression(ExpressionSyntax& expr, Token inside, OpenRangeListSyntax& ranges);
+    IntegerTypeSyntax& integerType(SyntaxKind kind, Token keyword, Token signing, const SyntaxList<VariableDimensionSyntax>& dimensions);
+    IntegerVectorExpressionSyntax& integerVectorExpression(Token size, Token base, Token value);
+    InterconnectPortHeaderSyntax& interconnectPortHeader(Token direction, Token interconnect, ImplicitTypeSyntax& type);
+    InterfacePortHeaderSyntax& interfacePortHeader(Token nameOrKeyword, DotMemberClauseSyntax* modport);
+    InvocationExpressionSyntax& invocationExpression(ExpressionSyntax& left, const SyntaxList<AttributeInstanceSyntax>& attributes, ArgumentListSyntax* arguments);
+    JumpStatementSyntax& jumpStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token breakOrContinue, Token semi);
+    KeywordNameSyntax& keywordName(SyntaxKind kind, Token keyword);
+    KeywordTypeSyntax& keywordType(SyntaxKind kind, Token keyword);
+    LetDeclarationSyntax& letDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token let, Token identifier, AssertionItemPortListSyntax* portList, EqualsValueClauseSyntax& initializer, Token semi);
+    LineDirectiveSyntax& lineDirective(Token directive, Token lineNumber, Token fileName, Token level);
+    LiteralExpressionSyntax& literalExpression(SyntaxKind kind, Token literal);
+    LoopConstraintSyntax& loopConstraint(Token foreachKeyword, ForeachLoopListSyntax& loopList, ConstraintItemSyntax& constraints);
+    LoopGenerateSyntax& loopGenerate(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, Token genvar, Token identifier, Token equals, ExpressionSyntax& initialExpr, Token semi1, ExpressionSyntax& stopExpr, Token semi2, ExpressionSyntax& iterationExpr, Token closeParen, MemberSyntax& block);
+    LoopStatementSyntax& loopStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token repeatOrWhile, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement);
+    MacroActualArgumentListSyntax& macroActualArgumentList(Token openParen, const SeparatedSyntaxList<MacroActualArgumentSyntax>& args, Token closeParen);
+    MacroActualArgumentSyntax& macroActualArgument(const TokenList& tokens);
+    MacroArgumentDefaultSyntax& macroArgumentDefault(Token equals, const TokenList& tokens);
+    MacroFormalArgumentListSyntax& macroFormalArgumentList(Token openParen, const SeparatedSyntaxList<MacroFormalArgumentSyntax>& args, Token closeParen);
+    MacroFormalArgumentSyntax& macroFormalArgument(Token name, MacroArgumentDefaultSyntax* defaultValue);
+    MacroUsageSyntax& macroUsage(Token directive, MacroActualArgumentListSyntax* args);
+    MatchesClauseSyntax& matchesClause(Token matchesKeyword, PatternSyntax& pattern);
+    MemberAccessExpressionSyntax& memberAccessExpression(ExpressionSyntax& left, Token dot, Token name);
+    MinTypMaxExpressionSyntax& minTypMaxExpression(ExpressionSyntax& min, Token colon1, ExpressionSyntax& typ, Token colon2, ExpressionSyntax& max);
+    ModportClockingPortSyntax& modportClockingPort(const SyntaxList<AttributeInstanceSyntax>& attributes, Token clocking, Token name);
+    ModportDeclarationSyntax& modportDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<ModportItemSyntax>& items, Token semi);
+    ModportExplicitPortSyntax& modportExplicitPort(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen);
+    ModportItemSyntax& modportItem(Token name, AnsiPortListSyntax& ports);
+    ModportNamedPortSyntax& modportNamedPort(Token name);
+    ModportSimplePortListSyntax& modportSimplePortList(const SyntaxList<AttributeInstanceSyntax>& attributes, Token direction, const SeparatedSyntaxList<ModportPortSyntax>& ports);
+    ModportSubroutinePortListSyntax& modportSubroutinePortList(const SyntaxList<AttributeInstanceSyntax>& attributes, Token importExport, const SeparatedSyntaxList<ModportPortSyntax>& ports);
+    ModportSubroutinePortSyntax& modportSubroutinePort(FunctionPrototypeSyntax& prototype);
+    ModuleDeclarationSyntax& moduleDeclaration(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, ModuleHeaderSyntax& header, const SyntaxList<MemberSyntax>& members, Token endmodule, NamedBlockClauseSyntax* blockName);
+    ModuleHeaderSyntax& moduleHeader(SyntaxKind kind, Token moduleKeyword, Token lifetime, Token name, const SyntaxList<PackageImportDeclarationSyntax>& imports, ParameterPortListSyntax* parameters, PortListSyntax* ports, Token semi);
+    MultipleConcatenationExpressionSyntax& multipleConcatenationExpression(Token openBrace, ExpressionSyntax& expression, ConcatenationExpressionSyntax& concatenation, Token closeBrace);
+    NameValuePragmaExpressionSyntax& nameValuePragmaExpression(Token name, Token equals, PragmaExpressionSyntax& value);
+    NamedArgumentSyntax& namedArgument(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen);
+    NamedBlockClauseSyntax& namedBlockClause(Token colon, Token name);
+    NamedLabelSyntax& namedLabel(Token name, Token colon);
+    NamedPortConnectionSyntax& namedPortConnection(const SyntaxList<AttributeInstanceSyntax>& attributes, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen);
+    NamedStructurePatternMemberSyntax& namedStructurePatternMember(Token name, Token colon, PatternSyntax& pattern);
+    NamedTypeSyntax& namedType(NameSyntax& name);
+    NetDeclarationSyntax& netDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token netType, NetStrengthSyntax* strength, Token expansionHint, DataTypeSyntax& type, TimingControlSyntax* delay, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi);
+    NetPortHeaderSyntax& netPortHeader(Token direction, Token netType, DataTypeSyntax& dataType);
+    NetTypeDeclarationSyntax& netTypeDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, DataTypeSyntax& type, Token name, WithFunctionClauseSyntax* withFunction, Token semi);
+    NewArrayExpressionSyntax& newArrayExpression(NameSyntax& newKeyword, Token openBracket, ExpressionSyntax& sizeExpr, Token closeBracket, ParenthesizedExpressionSyntax* initializer);
+    NewClassExpressionSyntax& newClassExpression(NameSyntax& scopedNew, ArgumentListSyntax* argList);
+    NonAnsiPortListSyntax& nonAnsiPortList(Token openParen, const SeparatedSyntaxList<NonAnsiPortSyntax>& ports, Token closeParen);
+    NonAnsiUdpPortListSyntax& nonAnsiUdpPortList(Token openParen, const SeparatedSyntaxList<IdentifierNameSyntax>& ports, Token closeParen, Token semi);
+    NumberPragmaExpressionSyntax& numberPragmaExpression(Token size, Token base, Token value);
+    OpenRangeExpressionSyntax& openRangeExpression(Token openBracket, ExpressionSyntax& left, Token colon, ExpressionSyntax& right, Token closeBracket);
+    OpenRangeListSyntax& openRangeList(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& valueRanges, Token closeBrace);
+    OrderedArgumentSyntax& orderedArgument(ExpressionSyntax& expr);
+    OrderedPortConnectionSyntax& orderedPortConnection(const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& expr);
+    OrderedStructurePatternMemberSyntax& orderedStructurePatternMember(PatternSyntax& pattern);
+    PackageImportDeclarationSyntax& packageImportDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<PackageImportItemSyntax>& items, Token semi);
+    PackageImportItemSyntax& packageImportItem(Token package, Token doubleColon, Token item);
+    ParameterDeclarationStatementSyntax& parameterDeclarationStatement(const SyntaxList<AttributeInstanceSyntax>& attributes, ParameterDeclarationBaseSyntax& parameter, Token semi);
+    ParameterDeclarationSyntax& parameterDeclaration(Token keyword, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators);
+    ParameterPortListSyntax& parameterPortList(Token hash, Token openParen, const SeparatedSyntaxList<ParameterDeclarationBaseSyntax>& declarations, Token closeParen);
+    ParameterValueAssignmentSyntax& parameterValueAssignment(Token hash, ArgumentListSyntax& assignments);
+    ParenExpressionListSyntax& parenExpressionList(Token openParen, const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token closeParen);
+    ParenPragmaExpressionSyntax& parenPragmaExpression(Token openParen, const SeparatedSyntaxList<PragmaExpressionSyntax>& values, Token closeParen);
+    ParenthesizedEventExpressionSyntax& parenthesizedEventExpression(Token openParen, EventExpressionSyntax& expr, Token closeParen);
+    ParenthesizedExpressionSyntax& parenthesizedExpression(Token openParen, ExpressionSyntax& expression, Token closeParen);
+    PathDeclarationSyntax& pathDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, PathDescriptionSyntax& desc, Token equals, Token openParen, const SeparatedSyntaxList<ExpressionSyntax>& delays, Token closeParen, Token semi);
+    PathDescriptionSyntax& pathDescription(Token openParen, Token edgeIdentifier, const SeparatedSyntaxList<NameSyntax>& inputs, Token polarityOperator, Token pathOperator, PathSuffixSyntax& suffix, Token closeParen);
+    PatternCaseItemSyntax& patternCaseItem(PatternSyntax& pattern, Token tripleAnd, ExpressionSyntax* expr, Token colon, StatementSyntax& statement);
+    PortConcatenationSyntax& portConcatenation(Token openBrace, const SeparatedSyntaxList<PortReferenceSyntax>& references, Token closeBrace);
+    PortDeclarationSyntax& portDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, PortHeaderSyntax& header, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi);
+    PortReferenceSyntax& portReference(Token name, ElementSelectSyntax* select);
+    PostfixUnaryExpressionSyntax& postfixUnaryExpression(SyntaxKind kind, ExpressionSyntax& operand, const SyntaxList<AttributeInstanceSyntax>& attributes, Token operatorToken);
+    PragmaDirectiveSyntax& pragmaDirective(Token directive, Token name, const SeparatedSyntaxList<PragmaExpressionSyntax>& args);
+    PrefixUnaryExpressionSyntax& prefixUnaryExpression(SyntaxKind kind, Token operatorToken, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& operand);
+    PrimaryBlockEventExpressionSyntax& primaryBlockEventExpression(Token keyword, NameSyntax& name);
+    ProceduralAssignStatementSyntax& proceduralAssignStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ExpressionSyntax& expr, Token semi);
+    ProceduralBlockSyntax& proceduralBlock(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, StatementSyntax& statement);
+    ProceduralDeassignStatementSyntax& proceduralDeassignStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ExpressionSyntax& variable, Token semi);
+    PropertyDeclarationSyntax& propertyDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, const SyntaxList<MemberSyntax>& assertionVariables, PropertySpecSyntax& propertySpec, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName);
+    PropertySpecSyntax& propertySpec(TimingControlSyntax* clocking, DisableIffSyntax* disable, ExpressionSyntax& expr);
+    PulseStyleDeclarationSyntax& pulseStyleDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<NameSyntax>& inputs, Token semi);
+    QueueDimensionSpecifierSyntax& queueDimensionSpecifier(Token dollar, ColonExpressionClauseSyntax* maxSizeClause);
+    RandCaseItemSyntax& randCaseItem(ExpressionSyntax& expr, Token colon, StatementSyntax& statement);
+    RandCaseStatementSyntax& randCaseStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token randCase, const SyntaxList<RandCaseItemSyntax>& items, Token endCase);
+    RangeCoverageBinInitializerSyntax& rangeCoverageBinInitializer(OpenRangeListSyntax& ranges, WithClauseSyntax* withClause);
+    RangeDimensionSpecifierSyntax& rangeDimensionSpecifier(SelectorSyntax& selector);
+    RangeSelectSyntax& rangeSelect(SyntaxKind kind, ExpressionSyntax& left, Token range, ExpressionSyntax& right);
+    RepeatedEventControlSyntax& repeatedEventControl(Token repeat, Token openParen, ExpressionSyntax& expr, Token closeParen, TimingControlSyntax* eventControl);
+    ReplicatedAssignmentPatternSyntax& replicatedAssignmentPattern(Token openBrace, ExpressionSyntax& countExpr, Token innerOpenBrace, const SeparatedSyntaxList<ExpressionSyntax>& items, Token innerCloseBrace, Token closeBrace);
+    ReturnStatementSyntax& returnStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token returnKeyword, ExpressionSyntax* returnValue, Token semi);
+    ScopedNameSyntax& scopedName(NameSyntax& left, Token separator, NameSyntax& right);
+    SequenceDeclarationSyntax& sequenceDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, const SyntaxList<MemberSyntax>& assertionVariables, ExpressionSyntax& seqExpr, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName);
+    ShortcutCycleDelayRangeSyntax& shortcutCycleDelayRange(Token doubleHash, Token openBracket, Token op, Token closeBracket);
+    SignalEventExpressionSyntax& signalEventExpression(Token edge, ExpressionSyntax& expr, IffEventClauseSyntax* iffClause);
+    SignedCastExpressionSyntax& signedCastExpression(Token signing, Token apostrophe, ParenthesizedExpressionSyntax& inner);
+    SimpleAssignmentPatternSyntax& simpleAssignmentPattern(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& items, Token closeBrace);
+    SimpleDirectiveSyntax& simpleDirective(SyntaxKind kind, Token directive);
+    SimplePathSuffixSyntax& simplePathSuffix(const SeparatedSyntaxList<NameSyntax>& outputs);
+    SimplePragmaExpressionSyntax& simplePragmaExpression(Token value);
+    SolveBeforeConstraintSyntax& solveBeforeConstraint(Token solve, const SeparatedSyntaxList<ExpressionSyntax>& beforeExpr, Token before, const SeparatedSyntaxList<ExpressionSyntax>& afterExpr, Token semi);
+    SpecifyBlockSyntax& specifyBlock(const SyntaxList<AttributeInstanceSyntax>& attributes, Token specify, const SyntaxList<MemberSyntax>& items, Token endspecify);
+    SpecparamDeclarationSyntax& specparamDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ImplicitTypeSyntax& type, const SeparatedSyntaxList<SpecparamDeclaratorSyntax>& declarators, Token semi);
+    SpecparamDeclaratorSyntax& specparamDeclarator(Token name, Token equals, ExpressionSyntax& value);
+    StandardCaseItemSyntax& standardCaseItem(const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token colon, SyntaxNode& clause);
+    StreamExpressionSyntax& streamExpression(ExpressionSyntax& expression, StreamExpressionWithRangeSyntax* withRange);
+    StreamExpressionWithRangeSyntax& streamExpressionWithRange(Token withKeyword, ElementSelectSyntax& range);
+    StreamingConcatenationExpressionSyntax& streamingConcatenationExpression(Token openBrace, Token operatorToken, ExpressionSyntax* sliceSize, Token innerOpenBrace, const SeparatedSyntaxList<StreamExpressionSyntax>& expressions, Token innerCloseBrace, Token closeBrace);
+    StructUnionMemberSyntax& structUnionMember(const SyntaxList<AttributeInstanceSyntax>& attributes, Token randomQualifier, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi);
+    StructUnionTypeSyntax& structUnionType(SyntaxKind kind, Token keyword, Token tagged, Token packed, Token signing, Token openBrace, const SyntaxList<StructUnionMemberSyntax>& members, Token closeBrace, const SyntaxList<VariableDimensionSyntax>& dimensions);
+    StructurePatternSyntax& structurePattern(Token openBrace, const SeparatedSyntaxList<StructurePatternMemberSyntax>& members, Token closeBrace);
+    StructuredAssignmentPatternSyntax& structuredAssignmentPattern(Token openBrace, const SeparatedSyntaxList<AssignmentPatternItemSyntax>& items, Token closeBrace);
+    SystemNameSyntax& systemName(Token systemIdentifier);
+    SystemTimingCheckSyntax& systemTimingCheck(const SyntaxList<AttributeInstanceSyntax>& attributes, Token name, Token openParen, const SeparatedSyntaxList<TimingCheckArgSyntax>& args, Token closeParen, Token semi);
+    TaggedPatternSyntax& taggedPattern(Token tagged, Token memberName, PatternSyntax* pattern);
+    TaggedUnionExpressionSyntax& taggedUnionExpression(Token tagged, Token member, ExpressionSyntax* expr);
+    TimeScaleDirectiveSyntax& timeScaleDirective(Token directive, Token timeUnit, Token slash, Token timePrecision);
+    TimeUnitsDeclarationSyntax& timeUnitsDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token time, DividerClauseSyntax* divider, Token semi);
+    TimingCheckConditionSyntax& timingCheckCondition(Token tripleAnd, ExpressionSyntax& expr);
+    TimingCheckEventSyntax& timingCheckEvent(Token edge, EdgeControlSpecifierSyntax* controlSpecifier, NameSyntax& terminal, TimingCheckConditionSyntax* condition);
+    TimingControlExpressionConcatenationSyntax& timingControlExpressionConcatenation(ExpressionSyntax& left, TimingControlSyntax& timing, ExpressionSyntax& right);
+    TimingControlExpressionSyntax& timingControlExpression(TimingControlSyntax& timing, ExpressionSyntax& expr);
+    TimingControlStatementSyntax& timingControlStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, TimingControlSyntax& timingControl, StatementSyntax& statement);
+    TransListCoverageBinInitializerSyntax& transListCoverageBinInitializer(const SeparatedSyntaxList<TransSetSyntax>& sets, WithClauseSyntax* withClause);
+    TransRangeSyntax& transRange(const SeparatedSyntaxList<ExpressionSyntax>& items, TransRepeatRangeSyntax* repeat);
+    TransRepeatRangeSyntax& transRepeatRange(Token openBracket, Token specifier, SelectorSyntax* selector, Token closeBracket);
+    TransSetSyntax& transSet(Token openParen, const SeparatedSyntaxList<TransRangeSyntax>& ranges, Token closeParen);
+    TypeAssignmentSyntax& typeAssignment(Token name, EqualsTypeClauseSyntax* assignment);
+    TypeParameterDeclarationSyntax& typeParameterDeclaration(Token keyword, Token typeKeyword, const SeparatedSyntaxList<TypeAssignmentSyntax>& declarators);
+    TypeReferenceSyntax& typeReference(Token typeKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen);
+    TypedefDeclarationSyntax& typedefDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, DataTypeSyntax& type, Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, Token semi);
+    UdpBodySyntax& udpBody(const SeparatedSyntaxList<UdpPortDeclSyntax>& portDecls, UdpInitialStmtSyntax* initialStmt, Token table, const SyntaxList<UdpEntrySyntax>& entries, Token endtable);
+    UdpDeclarationSyntax& udpDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token primitive, Token name, UdpPortListSyntax& portList, UdpBodySyntax& body, Token endprimitive, NamedBlockClauseSyntax* endBlockName);
+    UdpEdgeIndicatorSyntax& udpEdgeIndicator(Token openParen, Token first, Token second, Token closeParen);
+    UdpEntrySyntax& udpEntry(const TokenList& preInputs, UdpEdgeIndicatorSyntax* edgeIndicator, const TokenList& postInputs, Token colon1, Token current, Token colon2, Token next, Token semi);
+    UdpInitialStmtSyntax& udpInitialStmt(Token initial, Token name, Token equals, ExpressionSyntax& value, Token semi);
+    UdpInputPortDeclSyntax& udpInputPortDecl(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<IdentifierNameSyntax>& names);
+    UdpOutputPortDeclSyntax& udpOutputPortDecl(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token reg, Token name, EqualsValueClauseSyntax* initializer);
+    UnconditionalBranchDirectiveSyntax& unconditionalBranchDirective(SyntaxKind kind, Token directive, const TokenList& disabledTokens);
+    UnconnectedDriveDirectiveSyntax& unconnectedDriveDirective(Token directive, Token strength);
+    UndefDirectiveSyntax& undefDirective(Token directive, Token name);
+    UniquenessConstraintSyntax& uniquenessConstraint(Token unique, OpenRangeListSyntax& ranges, Token semi);
+    UserDefinedNetDeclarationSyntax& userDefinedNetDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token netType, TimingControlSyntax& delay, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi);
+    VariableDimensionSyntax& variableDimension(Token openBracket, DimensionSpecifierSyntax* specifier, Token closeBracket);
+    VariablePatternSyntax& variablePattern(Token dot, Token variableName);
+    VariablePortHeaderSyntax& variablePortHeader(Token constKeyword, Token direction, Token varKeyword, DataTypeSyntax& dataType);
+    VirtualInterfaceTypeSyntax& virtualInterfaceType(Token virtualKeyword, Token interfaceKeyword, Token name, ParameterValueAssignmentSyntax* parameters, DotMemberClauseSyntax* modport);
+    VoidCastedCallStatementSyntax& voidCastedCallStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token voidKeyword, Token apostrophe, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi);
+    WaitForkStatementSyntax& waitForkStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait, Token fork, Token semi);
+    WaitOrderStatementSyntax& waitOrderStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait_order, Token openParen, const SeparatedSyntaxList<NameSyntax>& names, Token closeParen, ActionBlockSyntax& action);
+    WaitStatementSyntax& waitStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement);
+    WildcardDimensionSpecifierSyntax& wildcardDimensionSpecifier(Token star);
+    WildcardPatternSyntax& wildcardPattern(Token dotStar);
+    WildcardPortConnectionSyntax& wildcardPortConnection(const SyntaxList<AttributeInstanceSyntax>& attributes, Token dotStar);
+    WildcardPortListSyntax& wildcardPortList(Token openParen, Token dotStar, Token closeParen);
+    WildcardUdpPortListSyntax& wildcardUdpPortList(Token openParen, Token dotStar, Token closeParen, Token semi);
+    WithClauseSyntax& withClause(Token with, Token openParen, ExpressionSyntax& expr, Token closeParen);
+    WithFunctionClauseSyntax& withFunctionClause(Token with, NameSyntax& name);
+    WithFunctionSampleSyntax& withFunctionSample(Token with, Token function, Token sample, AnsiPortListSyntax& portList);
+
+private:
+    BumpAllocator& alloc;
+};
+
+namespace detail {
+
+template<typename TNode, typename TVisitor, typename... Args>
+decltype(auto) visitSyntaxNode(TNode* node, TVisitor& visitor, Args&&... args) {
+    static constexpr bool isConst = std::is_const_v<TNode>;    switch (node->kind) {
+        case SyntaxKind::Unknown: return visitor.visitInvalid(*node, std::forward<Args>(args)...);
+        case SyntaxKind::SyntaxList:
+        case SyntaxKind::TokenList:
+        case SyntaxKind::SeparatedList:
+            return visitor.visit(*static_cast<std::conditional_t<isConst, const SyntaxListBase*, SyntaxListBase*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AcceptOnPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ActionBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ActionBlockSyntax*, ActionBlockSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AddAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AddExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AlwaysBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AlwaysCombBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AlwaysFFBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AlwaysLatchBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AlwaysPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AndAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AndSequenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AnsiPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const AnsiPortListSyntax*, AnsiPortListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AnsiUdpPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const AnsiUdpPortListSyntax*, AnsiUdpPortListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ArgumentList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ArgumentListSyntax*, ArgumentListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ArithmeticLeftShiftAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ArithmeticRightShiftAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ArithmeticShiftLeftExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ArithmeticShiftRightExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ArrayAndMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ArrayOrMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ArrayOrRandomizeMethodExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ArrayOrRandomizeMethodExpressionSyntax*, ArrayOrRandomizeMethodExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ArrayUniqueMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ArrayXorMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AscendingRangeSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeSelectSyntax*, RangeSelectSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AssertPropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AssertionItemPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const AssertionItemPortSyntax*, AssertionItemPortSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AssertionItemPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const AssertionItemPortListSyntax*, AssertionItemPortListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AssignmentPatternExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const AssignmentPatternExpressionSyntax*, AssignmentPatternExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AssignmentPatternItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const AssignmentPatternItemSyntax*, AssignmentPatternItemSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AssumePropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AttributeInstance: return visitor.visit(*static_cast<std::conditional_t<isConst, const AttributeInstanceSyntax*, AttributeInstanceSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AttributeSpec: return visitor.visit(*static_cast<std::conditional_t<isConst, const AttributeSpecSyntax*, AttributeSpecSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BadExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BadExpressionSyntax*, BadExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BeginKeywordsDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const BeginKeywordsDirectiveSyntax*, BeginKeywordsDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BinaryAndExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BinaryBlockEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryBlockEventExpressionSyntax*, BinaryBlockEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BinaryEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryEventExpressionSyntax*, BinaryEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BinaryOrExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BinarySequenceDelayExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BinaryXnorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BinaryXorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BindDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const BindDirectiveSyntax*, BindDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BindTargetList: return visitor.visit(*static_cast<std::conditional_t<isConst, const BindTargetListSyntax*, BindTargetListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BitSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const BitSelectSyntax*, BitSelectSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BitType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BlockCoverageEvent: return visitor.visit(*static_cast<std::conditional_t<isConst, const BlockCoverageEventSyntax*, BlockCoverageEventSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BlockingEventTriggerStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const EventTriggerStatementSyntax*, EventTriggerStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ByteType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CHandleType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CaseEqualityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CaseGenerate: return visitor.visit(*static_cast<std::conditional_t<isConst, const CaseGenerateSyntax*, CaseGenerateSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CaseInequalityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CaseStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const CaseStatementSyntax*, CaseStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CastExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const CastExpressionSyntax*, CastExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CellDefineDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ChargeStrength: return visitor.visit(*static_cast<std::conditional_t<isConst, const ChargeStrengthSyntax*, ChargeStrengthSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ClassDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassDeclarationSyntax*, ClassDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ClassMethodDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassMethodDeclarationSyntax*, ClassMethodDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ClassMethodPrototype: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassMethodPrototypeSyntax*, ClassMethodPrototypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ClassName: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassNameSyntax*, ClassNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ClassPropertyDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassPropertyDeclarationSyntax*, ClassPropertyDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ClockingDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingDeclarationSyntax*, ClockingDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ClockingDirection: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingDirectionSyntax*, ClockingDirectionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ClockingItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingItemSyntax*, ClockingItemSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ClockingSkew: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingSkewSyntax*, ClockingSkewSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ColonExpressionClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ColonExpressionClauseSyntax*, ColonExpressionClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CompilationUnit: return visitor.visit(*static_cast<std::conditional_t<isConst, const CompilationUnitSyntax*, CompilationUnitSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConcatenationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcatenationExpressionSyntax*, ConcatenationExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConcurrentAssertionMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionMemberSyntax*, ConcurrentAssertionMemberSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConditionalConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalConstraintSyntax*, ConditionalConstraintSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConditionalExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalExpressionSyntax*, ConditionalExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConditionalPathDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalPathDeclarationSyntax*, ConditionalPathDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConditionalPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalPatternSyntax*, ConditionalPatternSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConditionalPredicate: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalPredicateSyntax*, ConditionalPredicateSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConditionalStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalStatementSyntax*, ConditionalStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConstraintBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConstraintBlockSyntax*, ConstraintBlockSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConstraintDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConstraintDeclarationSyntax*, ConstraintDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConstraintPrototype: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConstraintPrototypeSyntax*, ConstraintPrototypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConstructorName: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ContinuousAssign: return visitor.visit(*static_cast<std::conditional_t<isConst, const ContinuousAssignSyntax*, ContinuousAssignSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CopyClassExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const CopyClassExpressionSyntax*, CopyClassExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CoverPropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CoverSequenceStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CoverageBins: return visitor.visit(*static_cast<std::conditional_t<isConst, const CoverageBinsSyntax*, CoverageBinsSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CoverageIffClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const CoverageIffClauseSyntax*, CoverageIffClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CoverageOption: return visitor.visit(*static_cast<std::conditional_t<isConst, const CoverageOptionSyntax*, CoverageOptionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CovergroupDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const CovergroupDeclarationSyntax*, CovergroupDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::Coverpoint: return visitor.visit(*static_cast<std::conditional_t<isConst, const CoverpointSyntax*, CoverpointSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CycleDelay: return visitor.visit(*static_cast<std::conditional_t<isConst, const DelaySyntax*, DelaySyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DPIExport: return visitor.visit(*static_cast<std::conditional_t<isConst, const DPIExportSyntax*, DPIExportSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DPIImport: return visitor.visit(*static_cast<std::conditional_t<isConst, const DPIImportSyntax*, DPIImportSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DataDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const DataDeclarationSyntax*, DataDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::Declarator: return visitor.visit(*static_cast<std::conditional_t<isConst, const DeclaratorSyntax*, DeclaratorSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DefParam: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefParamSyntax*, DefParamSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DefParamAssignment: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefParamAssignmentSyntax*, DefParamAssignmentSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DefaultCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultCaseItemSyntax*, DefaultCaseItemSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DefaultClockingReference: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultClockingReferenceSyntax*, DefaultClockingReferenceSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DefaultCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultCoverageBinInitializerSyntax*, DefaultCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DefaultNetTypeDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultNetTypeDirectiveSyntax*, DefaultNetTypeDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DefaultPatternKeyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DefaultSkewItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultSkewItemSyntax*, DefaultSkewItemSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DeferredAssertion: return visitor.visit(*static_cast<std::conditional_t<isConst, const DeferredAssertionSyntax*, DeferredAssertionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DefineDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefineDirectiveSyntax*, DefineDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::Delay3: return visitor.visit(*static_cast<std::conditional_t<isConst, const Delay3Syntax*, Delay3Syntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DelayControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const DelaySyntax*, DelaySyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DelayedTerminalArg: return visitor.visit(*static_cast<std::conditional_t<isConst, const DelayedTerminalArgSyntax*, DelayedTerminalArgSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DescendingRangeSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeSelectSyntax*, RangeSelectSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DisableConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const DisableConstraintSyntax*, DisableConstraintSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DisableForkStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const DisableForkStatementSyntax*, DisableForkStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DisableIff: return visitor.visit(*static_cast<std::conditional_t<isConst, const DisableIffSyntax*, DisableIffSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DisableStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const DisableStatementSyntax*, DisableStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DistConstraintList: return visitor.visit(*static_cast<std::conditional_t<isConst, const DistConstraintListSyntax*, DistConstraintListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DistItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const DistItemSyntax*, DistItemSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DistWeight: return visitor.visit(*static_cast<std::conditional_t<isConst, const DistWeightSyntax*, DistWeightSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DivideAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DivideExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DividerClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const DividerClauseSyntax*, DividerClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DoWhileStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const DoWhileStatementSyntax*, DoWhileStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DotMemberClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const DotMemberClauseSyntax*, DotMemberClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DriveStrength: return visitor.visit(*static_cast<std::conditional_t<isConst, const DriveStrengthSyntax*, DriveStrengthSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EdgeControlSpecifier: return visitor.visit(*static_cast<std::conditional_t<isConst, const EdgeControlSpecifierSyntax*, EdgeControlSpecifierSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EdgeDescriptor: return visitor.visit(*static_cast<std::conditional_t<isConst, const EdgeDescriptorSyntax*, EdgeDescriptorSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EdgeSensitivePathSuffix: return visitor.visit(*static_cast<std::conditional_t<isConst, const EdgeSensitivePathSuffixSyntax*, EdgeSensitivePathSuffixSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ElabSystemTask: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElabSystemTaskSyntax*, ElabSystemTaskSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ElementSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElementSelectSyntax*, ElementSelectSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ElementSelectExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElementSelectExpressionSyntax*, ElementSelectExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ElsIfDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalBranchDirectiveSyntax*, ConditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ElseClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElseClauseSyntax*, ElseClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ElseConstraintClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElseConstraintClauseSyntax*, ElseConstraintClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ElseDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const UnconditionalBranchDirectiveSyntax*, UnconditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EmptyArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyArgumentSyntax*, EmptyArgumentSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EmptyIdentifierName: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyIdentifierNameSyntax*, EmptyIdentifierNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EmptyMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyMemberSyntax*, EmptyMemberSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EmptyPortConnection: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyPortConnectionSyntax*, EmptyPortConnectionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EmptyQueueExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyQueueExpressionSyntax*, EmptyQueueExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EmptyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyStatementSyntax*, EmptyStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EmptyTimingCheckArg: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyTimingCheckArgSyntax*, EmptyTimingCheckArgSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EndCellDefineDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EndIfDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const UnconditionalBranchDirectiveSyntax*, UnconditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EndKeywordsDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EnumType: return visitor.visit(*static_cast<std::conditional_t<isConst, const EnumTypeSyntax*, EnumTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EqualityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EqualsTypeClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const EqualsTypeClauseSyntax*, EqualsTypeClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EqualsValueClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const EqualsValueClauseSyntax*, EqualsValueClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EventControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const EventControlSyntax*, EventControlSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EventControlWithExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const EventControlWithExpressionSyntax*, EventControlWithExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EventType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EventuallyPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExpectPropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExplicitAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExplicitAnsiPortSyntax*, ExplicitAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExplicitNonAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExplicitNonAnsiPortSyntax*, ExplicitNonAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExpressionConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionConstraintSyntax*, ExpressionConstraintSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExpressionCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionCoverageBinInitializerSyntax*, ExpressionCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExpressionOrDist: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionOrDistSyntax*, ExpressionOrDistSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExpressionPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionPatternSyntax*, ExpressionPatternSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExpressionStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionStatementSyntax*, ExpressionStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExpressionTimingCheckArg: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionTimingCheckArgSyntax*, ExpressionTimingCheckArgSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExtendsClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExtendsClauseSyntax*, ExtendsClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExternModule: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExternModuleSyntax*, ExternModuleSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::FinalBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ForLoopStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForLoopStatementSyntax*, ForLoopStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ForVariableDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForVariableDeclarationSyntax*, ForVariableDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ForeachLoopList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForeachLoopListSyntax*, ForeachLoopListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ForeachLoopStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForeachLoopStatementSyntax*, ForeachLoopStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ForeverStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForeverStatementSyntax*, ForeverStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ForwardInterfaceClassTypedefDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForwardInterfaceClassTypedefDeclarationSyntax*, ForwardInterfaceClassTypedefDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ForwardTypedefDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForwardTypedefDeclarationSyntax*, ForwardTypedefDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::FunctionDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionDeclarationSyntax*, FunctionDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::FunctionPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionPortSyntax*, FunctionPortSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::FunctionPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionPortListSyntax*, FunctionPortListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::FunctionPrototype: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionPrototypeSyntax*, FunctionPrototypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::GateInstance: return visitor.visit(*static_cast<std::conditional_t<isConst, const GateInstanceSyntax*, GateInstanceSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::GateInstanceName: return visitor.visit(*static_cast<std::conditional_t<isConst, const GateInstanceNameSyntax*, GateInstanceNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::GateInstantiation: return visitor.visit(*static_cast<std::conditional_t<isConst, const GateInstantiationSyntax*, GateInstantiationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::GenerateBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const GenerateBlockSyntax*, GenerateBlockSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::GenerateRegion: return visitor.visit(*static_cast<std::conditional_t<isConst, const GenerateRegionSyntax*, GenerateRegionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::GenvarDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const GenvarDeclarationSyntax*, GenvarDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::GreaterThanEqualExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::GreaterThanExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::HierarchicalInstance: return visitor.visit(*static_cast<std::conditional_t<isConst, const HierarchicalInstanceSyntax*, HierarchicalInstanceSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::HierarchyInstantiation: return visitor.visit(*static_cast<std::conditional_t<isConst, const HierarchyInstantiationSyntax*, HierarchyInstantiationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IdentifierName: return visitor.visit(*static_cast<std::conditional_t<isConst, const IdentifierNameSyntax*, IdentifierNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IdentifierSelectName: return visitor.visit(*static_cast<std::conditional_t<isConst, const IdentifierSelectNameSyntax*, IdentifierSelectNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IfDefDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalBranchDirectiveSyntax*, ConditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IfGenerate: return visitor.visit(*static_cast<std::conditional_t<isConst, const IfGenerateSyntax*, IfGenerateSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IfNDefDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalBranchDirectiveSyntax*, ConditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IfNonePathDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const IfNonePathDeclarationSyntax*, IfNonePathDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IffEventClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const IffEventClauseSyntax*, IffEventClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IffPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImmediateAssertStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImmediateAssertionStatementSyntax*, ImmediateAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImmediateAssertionMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImmediateAssertionMemberSyntax*, ImmediateAssertionMemberSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImmediateAssumeStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImmediateAssertionStatementSyntax*, ImmediateAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImmediateCoverStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImmediateAssertionStatementSyntax*, ImmediateAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImplementsClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplementsClauseSyntax*, ImplementsClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImplicationConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicationConstraintSyntax*, ImplicationConstraintSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImplicitAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicitAnsiPortSyntax*, ImplicitAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImplicitEventControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicitEventControlSyntax*, ImplicitEventControlSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImplicitNonAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicitNonAnsiPortSyntax*, ImplicitNonAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImplicitType: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicitTypeSyntax*, ImplicitTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImpliesPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IncludeDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const IncludeDirectiveSyntax*, IncludeDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::InequalityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::InitialBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::InsideExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const InsideExpressionSyntax*, InsideExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IntType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IntegerLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IntegerType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IntegerVectorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerVectorExpressionSyntax*, IntegerVectorExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::InterconnectPortHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const InterconnectPortHeaderSyntax*, InterconnectPortHeaderSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::InterfaceDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleDeclarationSyntax*, ModuleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::InterfaceHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleHeaderSyntax*, ModuleHeaderSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::InterfacePortHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const InterfacePortHeaderSyntax*, InterfacePortHeaderSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IntersectSequenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::InvocationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const InvocationExpressionSyntax*, InvocationExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::JumpStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const JumpStatementSyntax*, JumpStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LessThanEqualExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LessThanExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LetDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const LetDeclarationSyntax*, LetDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LineDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const LineDirectiveSyntax*, LineDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LocalScope: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LogicType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LogicalAndExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LogicalEquivalenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LogicalImplicationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LogicalLeftShiftAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LogicalOrExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LogicalRightShiftAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LogicalShiftLeftExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LogicalShiftRightExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LongIntType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LoopConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const LoopConstraintSyntax*, LoopConstraintSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LoopGenerate: return visitor.visit(*static_cast<std::conditional_t<isConst, const LoopGenerateSyntax*, LoopGenerateSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LoopStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const LoopStatementSyntax*, LoopStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MacroActualArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroActualArgumentSyntax*, MacroActualArgumentSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MacroActualArgumentList: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroActualArgumentListSyntax*, MacroActualArgumentListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MacroArgumentDefault: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroArgumentDefaultSyntax*, MacroArgumentDefaultSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MacroFormalArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroFormalArgumentSyntax*, MacroFormalArgumentSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MacroFormalArgumentList: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroFormalArgumentListSyntax*, MacroFormalArgumentListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MacroUsage: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroUsageSyntax*, MacroUsageSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MatchesClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const MatchesClauseSyntax*, MatchesClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MemberAccessExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const MemberAccessExpressionSyntax*, MemberAccessExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MinTypMaxExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const MinTypMaxExpressionSyntax*, MinTypMaxExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModportClockingPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportClockingPortSyntax*, ModportClockingPortSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModportDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportDeclarationSyntax*, ModportDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModportExplicitPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportExplicitPortSyntax*, ModportExplicitPortSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModportItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportItemSyntax*, ModportItemSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModportNamedPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportNamedPortSyntax*, ModportNamedPortSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModportSimplePortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportSimplePortListSyntax*, ModportSimplePortListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModportSubroutinePort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportSubroutinePortSyntax*, ModportSubroutinePortSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModportSubroutinePortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportSubroutinePortListSyntax*, ModportSubroutinePortListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModuleDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleDeclarationSyntax*, ModuleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModuleHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleHeaderSyntax*, ModuleHeaderSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MultipleConcatenationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const MultipleConcatenationExpressionSyntax*, MultipleConcatenationExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MultiplyAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MultiplyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NameValuePragmaExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const NameValuePragmaExpressionSyntax*, NameValuePragmaExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NamedArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedArgumentSyntax*, NamedArgumentSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NamedBlockClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedBlockClauseSyntax*, NamedBlockClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NamedLabel: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedLabelSyntax*, NamedLabelSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NamedPortConnection: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedPortConnectionSyntax*, NamedPortConnectionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NamedStructurePatternMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedStructurePatternMemberSyntax*, NamedStructurePatternMemberSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NamedType: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedTypeSyntax*, NamedTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NetDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const NetDeclarationSyntax*, NetDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NetPortHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const NetPortHeaderSyntax*, NetPortHeaderSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NetTypeDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const NetTypeDeclarationSyntax*, NetTypeDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NewArrayExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const NewArrayExpressionSyntax*, NewArrayExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NewClassExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const NewClassExpressionSyntax*, NewClassExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NextTimePropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NoUnconnectedDriveDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NonAnsiPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const NonAnsiPortListSyntax*, NonAnsiPortListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NonAnsiUdpPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const NonAnsiUdpPortListSyntax*, NonAnsiUdpPortListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NonOverlappedFollowedByPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NonOverlappedImplicationPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NonblockingAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NonblockingEventTriggerStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const EventTriggerStatementSyntax*, EventTriggerStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NullLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NumberPragmaExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const NumberPragmaExpressionSyntax*, NumberPragmaExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::OneStepLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::OpenRangeExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const OpenRangeExpressionSyntax*, OpenRangeExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::OpenRangeList: return visitor.visit(*static_cast<std::conditional_t<isConst, const OpenRangeListSyntax*, OpenRangeListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::OrAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::OrSequenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::OrderedArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const OrderedArgumentSyntax*, OrderedArgumentSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::OrderedPortConnection: return visitor.visit(*static_cast<std::conditional_t<isConst, const OrderedPortConnectionSyntax*, OrderedPortConnectionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::OrderedStructurePatternMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const OrderedStructurePatternMemberSyntax*, OrderedStructurePatternMemberSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::OverlappedFollowedByPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::OverlappedImplicationPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PackageDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleDeclarationSyntax*, ModuleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PackageHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleHeaderSyntax*, ModuleHeaderSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PackageImportDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PackageImportDeclarationSyntax*, PackageImportDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PackageImportItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const PackageImportItemSyntax*, PackageImportItemSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ParallelBlockStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const BlockStatementSyntax*, BlockStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ParameterDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParameterDeclarationSyntax*, ParameterDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ParameterDeclarationStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParameterDeclarationStatementSyntax*, ParameterDeclarationStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ParameterPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParameterPortListSyntax*, ParameterPortListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ParameterValueAssignment: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParameterValueAssignmentSyntax*, ParameterValueAssignmentSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ParenExpressionList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenExpressionListSyntax*, ParenExpressionListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ParenPragmaExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenPragmaExpressionSyntax*, ParenPragmaExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ParenthesizedEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenthesizedEventExpressionSyntax*, ParenthesizedEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ParenthesizedExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenthesizedExpressionSyntax*, ParenthesizedExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PathDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PathDeclarationSyntax*, PathDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PathDescription: return visitor.visit(*static_cast<std::conditional_t<isConst, const PathDescriptionSyntax*, PathDescriptionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PatternCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const PatternCaseItemSyntax*, PatternCaseItemSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PortConcatenation: return visitor.visit(*static_cast<std::conditional_t<isConst, const PortConcatenationSyntax*, PortConcatenationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PortDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PortDeclarationSyntax*, PortDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PortReference: return visitor.visit(*static_cast<std::conditional_t<isConst, const PortReferenceSyntax*, PortReferenceSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PostdecrementExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PostfixUnaryExpressionSyntax*, PostfixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PostincrementExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PostfixUnaryExpressionSyntax*, PostfixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PowerExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PragmaDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const PragmaDirectiveSyntax*, PragmaDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PrimaryBlockEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrimaryBlockEventExpressionSyntax*, PrimaryBlockEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ProceduralAssignStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralAssignStatementSyntax*, ProceduralAssignStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ProceduralDeassignStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralDeassignStatementSyntax*, ProceduralDeassignStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ProceduralForceStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralAssignStatementSyntax*, ProceduralAssignStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ProceduralReleaseStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralDeassignStatementSyntax*, ProceduralDeassignStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ProgramDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleDeclarationSyntax*, ModuleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ProgramHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleHeaderSyntax*, ModuleHeaderSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PropertyDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PropertyDeclarationSyntax*, PropertyDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PropertySpec: return visitor.visit(*static_cast<std::conditional_t<isConst, const PropertySpecSyntax*, PropertySpecSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PropertyType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PulseStyleDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PulseStyleDeclarationSyntax*, PulseStyleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::QueueDimensionSpecifier: return visitor.visit(*static_cast<std::conditional_t<isConst, const QueueDimensionSpecifierSyntax*, QueueDimensionSpecifierSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RandCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const RandCaseItemSyntax*, RandCaseItemSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RandCaseStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const RandCaseStatementSyntax*, RandCaseStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RangeCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeCoverageBinInitializerSyntax*, RangeCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RangeDimensionSpecifier: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeDimensionSpecifierSyntax*, RangeDimensionSpecifierSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RealLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RealTimeType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RealType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RegType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RejectOnPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RepeatedEventControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const RepeatedEventControlSyntax*, RepeatedEventControlSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ReplicatedAssignmentPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const ReplicatedAssignmentPatternSyntax*, ReplicatedAssignmentPatternSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ResetAllDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RestrictPropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ReturnStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ReturnStatementSyntax*, ReturnStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RootScope: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SAlwaysPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SEventuallyPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SNextTimePropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SUntilPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SUntilWithPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ScopedName: return visitor.visit(*static_cast<std::conditional_t<isConst, const ScopedNameSyntax*, ScopedNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SequenceDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const SequenceDeclarationSyntax*, SequenceDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SequenceType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SequentialBlockStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const BlockStatementSyntax*, BlockStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ShortIntType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ShortRealType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ShortcutCycleDelayRange: return visitor.visit(*static_cast<std::conditional_t<isConst, const ShortcutCycleDelayRangeSyntax*, ShortcutCycleDelayRangeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SignalEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const SignalEventExpressionSyntax*, SignalEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SignedCastExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const SignedCastExpressionSyntax*, SignedCastExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SimpleAssignmentPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleAssignmentPatternSyntax*, SimpleAssignmentPatternSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SimplePathSuffix: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimplePathSuffixSyntax*, SimplePathSuffixSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SimplePragmaExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimplePragmaExpressionSyntax*, SimplePragmaExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SimpleRangeSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeSelectSyntax*, RangeSelectSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SolveBeforeConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const SolveBeforeConstraintSyntax*, SolveBeforeConstraintSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SpecifyBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const SpecifyBlockSyntax*, SpecifyBlockSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SpecparamDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const SpecparamDeclarationSyntax*, SpecparamDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SpecparamDeclarator: return visitor.visit(*static_cast<std::conditional_t<isConst, const SpecparamDeclaratorSyntax*, SpecparamDeclaratorSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::StandardCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const StandardCaseItemSyntax*, StandardCaseItemSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::StreamExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const StreamExpressionSyntax*, StreamExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::StreamExpressionWithRange: return visitor.visit(*static_cast<std::conditional_t<isConst, const StreamExpressionWithRangeSyntax*, StreamExpressionWithRangeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::StreamingConcatenationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const StreamingConcatenationExpressionSyntax*, StreamingConcatenationExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::StringLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::StringType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::StructType: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructUnionTypeSyntax*, StructUnionTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::StructUnionMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructUnionMemberSyntax*, StructUnionMemberSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::StructurePattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructurePatternSyntax*, StructurePatternSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::StructuredAssignmentPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructuredAssignmentPatternSyntax*, StructuredAssignmentPatternSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SubtractAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SubtractExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SuperHandle: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SyncAcceptOnPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SyncRejectOnPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SystemName: return visitor.visit(*static_cast<std::conditional_t<isConst, const SystemNameSyntax*, SystemNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SystemTimingCheck: return visitor.visit(*static_cast<std::conditional_t<isConst, const SystemTimingCheckSyntax*, SystemTimingCheckSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TaggedPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const TaggedPatternSyntax*, TaggedPatternSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TaggedUnionExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const TaggedUnionExpressionSyntax*, TaggedUnionExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TaskDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionDeclarationSyntax*, FunctionDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ThisHandle: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ThroughoutSequenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TimeLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TimeScaleDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimeScaleDirectiveSyntax*, TimeScaleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TimeType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TimeUnitsDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimeUnitsDeclarationSyntax*, TimeUnitsDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TimingCheckCondition: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimingCheckConditionSyntax*, TimingCheckConditionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TimingCheckEvent: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimingCheckEventSyntax*, TimingCheckEventSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TimingControlExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimingControlExpressionSyntax*, TimingControlExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TimingControlExpressionConcatenation: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimingControlExpressionConcatenationSyntax*, TimingControlExpressionConcatenationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TimingControlStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimingControlStatementSyntax*, TimingControlStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TransListCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const TransListCoverageBinInitializerSyntax*, TransListCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TransRange: return visitor.visit(*static_cast<std::conditional_t<isConst, const TransRangeSyntax*, TransRangeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TransRepeatRange: return visitor.visit(*static_cast<std::conditional_t<isConst, const TransRepeatRangeSyntax*, TransRepeatRangeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TransSet: return visitor.visit(*static_cast<std::conditional_t<isConst, const TransSetSyntax*, TransSetSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TypeAssignment: return visitor.visit(*static_cast<std::conditional_t<isConst, const TypeAssignmentSyntax*, TypeAssignmentSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TypeParameterDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const TypeParameterDeclarationSyntax*, TypeParameterDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TypeReference: return visitor.visit(*static_cast<std::conditional_t<isConst, const TypeReferenceSyntax*, TypeReferenceSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TypedefDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const TypedefDeclarationSyntax*, TypedefDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UdpBody: return visitor.visit(*static_cast<std::conditional_t<isConst, const UdpBodySyntax*, UdpBodySyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UdpDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const UdpDeclarationSyntax*, UdpDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UdpEdgeIndicator: return visitor.visit(*static_cast<std::conditional_t<isConst, const UdpEdgeIndicatorSyntax*, UdpEdgeIndicatorSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UdpEntry: return visitor.visit(*static_cast<std::conditional_t<isConst, const UdpEntrySyntax*, UdpEntrySyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UdpInitialStmt: return visitor.visit(*static_cast<std::conditional_t<isConst, const UdpInitialStmtSyntax*, UdpInitialStmtSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UdpInputPortDecl: return visitor.visit(*static_cast<std::conditional_t<isConst, const UdpInputPortDeclSyntax*, UdpInputPortDeclSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UdpOutputPortDecl: return visitor.visit(*static_cast<std::conditional_t<isConst, const UdpOutputPortDeclSyntax*, UdpOutputPortDeclSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryBitwiseAndExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryBitwiseNandExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryBitwiseNorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryBitwiseNotExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryBitwiseOrExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryBitwiseXnorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryBitwiseXorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryLogicalNotExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryMinusExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryNotPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryPlusExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryPredecrementExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryPreincrementExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnarySequenceDelayExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnarySequenceEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnbasedUnsizedLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnconnectedDriveDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const UnconnectedDriveDirectiveSyntax*, UnconnectedDriveDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UndefDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const UndefDirectiveSyntax*, UndefDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UndefineAllDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnionType: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructUnionTypeSyntax*, StructUnionTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UniquenessConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const UniquenessConstraintSyntax*, UniquenessConstraintSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnitScope: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UntilPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UntilWithPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::Untyped: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UserDefinedNetDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const UserDefinedNetDeclarationSyntax*, UserDefinedNetDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::VariableDimension: return visitor.visit(*static_cast<std::conditional_t<isConst, const VariableDimensionSyntax*, VariableDimensionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::VariablePattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const VariablePatternSyntax*, VariablePatternSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::VariablePortHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const VariablePortHeaderSyntax*, VariablePortHeaderSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::VirtualInterfaceType: return visitor.visit(*static_cast<std::conditional_t<isConst, const VirtualInterfaceTypeSyntax*, VirtualInterfaceTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::VoidCastedCallStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const VoidCastedCallStatementSyntax*, VoidCastedCallStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::VoidType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WaitForkStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const WaitForkStatementSyntax*, WaitForkStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WaitOrderStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const WaitOrderStatementSyntax*, WaitOrderStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WaitStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const WaitStatementSyntax*, WaitStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WildcardDimensionSpecifier: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardDimensionSpecifierSyntax*, WildcardDimensionSpecifierSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WildcardEqualityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WildcardInequalityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WildcardLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WildcardPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardPatternSyntax*, WildcardPatternSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WildcardPortConnection: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardPortConnectionSyntax*, WildcardPortConnectionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WildcardPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardPortListSyntax*, WildcardPortListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WildcardUdpPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardUdpPortListSyntax*, WildcardUdpPortListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WithClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const WithClauseSyntax*, WithClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WithFunctionClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const WithFunctionClauseSyntax*, WithFunctionClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WithFunctionSample: return visitor.visit(*static_cast<std::conditional_t<isConst, const WithFunctionSampleSyntax*, WithFunctionSampleSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WithinSequenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::XorAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+    }
+    THROW_UNREACHABLE;
+}
+
+}
+
+template<typename TVisitor, typename... Args>
+decltype(auto) SyntaxNode::visit(TVisitor& visitor, Args&&... args) {
+    return detail::visitSyntaxNode(this, visitor, std::forward<Args>(args)...);
+}
+
+template<typename TVisitor, typename... Args>
+decltype(auto) SyntaxNode::visit(TVisitor& visitor, Args&&... args) const {
+    return detail::visitSyntaxNode(this, visitor, std::forward<Args>(args)...);
+}
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./generated/slang/syntax/SyntaxKind.h ./generated/slang/syntax/SyntaxKind.h
--- ./generated/slang/syntax/SyntaxKind.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/syntax/SyntaxKind.h	2021-03-02 17:51:09.141286189 -0800
@@ -0,0 +1,477 @@
+//------------------------------------------------------------------------------
+//! @file SyntaxKind.h
+//! @brief Generated SyntaxKind enum
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+namespace slang {
+
+enum class SyntaxKind {
+    Unknown,
+    SyntaxList,
+    TokenList,
+    SeparatedList,
+    AcceptOnPropertyExpression,
+    ActionBlock,
+    AddAssignmentExpression,
+    AddExpression,
+    AlwaysBlock,
+    AlwaysCombBlock,
+    AlwaysFFBlock,
+    AlwaysLatchBlock,
+    AlwaysPropertyExpression,
+    AndAssignmentExpression,
+    AndSequenceExpression,
+    AnsiPortList,
+    AnsiUdpPortList,
+    ArgumentList,
+    ArithmeticLeftShiftAssignmentExpression,
+    ArithmeticRightShiftAssignmentExpression,
+    ArithmeticShiftLeftExpression,
+    ArithmeticShiftRightExpression,
+    ArrayAndMethod,
+    ArrayOrMethod,
+    ArrayOrRandomizeMethodExpression,
+    ArrayUniqueMethod,
+    ArrayXorMethod,
+    AscendingRangeSelect,
+    AssertPropertyStatement,
+    AssertionItemPort,
+    AssertionItemPortList,
+    AssignmentExpression,
+    AssignmentPatternExpression,
+    AssignmentPatternItem,
+    AssumePropertyStatement,
+    AttributeInstance,
+    AttributeSpec,
+    BadExpression,
+    BeginKeywordsDirective,
+    BinaryAndExpression,
+    BinaryBlockEventExpression,
+    BinaryEventExpression,
+    BinaryOrExpression,
+    BinarySequenceDelayExpression,
+    BinaryXnorExpression,
+    BinaryXorExpression,
+    BindDirective,
+    BindTargetList,
+    BitSelect,
+    BitType,
+    BlockCoverageEvent,
+    BlockingEventTriggerStatement,
+    ByteType,
+    CHandleType,
+    CaseEqualityExpression,
+    CaseGenerate,
+    CaseInequalityExpression,
+    CaseStatement,
+    CastExpression,
+    CellDefineDirective,
+    ChargeStrength,
+    ClassDeclaration,
+    ClassMethodDeclaration,
+    ClassMethodPrototype,
+    ClassName,
+    ClassPropertyDeclaration,
+    ClockingDeclaration,
+    ClockingDirection,
+    ClockingItem,
+    ClockingSkew,
+    ColonExpressionClause,
+    CompilationUnit,
+    ConcatenationExpression,
+    ConcurrentAssertionMember,
+    ConditionalConstraint,
+    ConditionalExpression,
+    ConditionalPathDeclaration,
+    ConditionalPattern,
+    ConditionalPredicate,
+    ConditionalStatement,
+    ConstraintBlock,
+    ConstraintDeclaration,
+    ConstraintPrototype,
+    ConstructorName,
+    ContinuousAssign,
+    CopyClassExpression,
+    CoverPropertyStatement,
+    CoverSequenceStatement,
+    CoverageBins,
+    CoverageIffClause,
+    CoverageOption,
+    CovergroupDeclaration,
+    Coverpoint,
+    CycleDelay,
+    DPIExport,
+    DPIImport,
+    DataDeclaration,
+    Declarator,
+    DefParam,
+    DefParamAssignment,
+    DefaultCaseItem,
+    DefaultClockingReference,
+    DefaultCoverageBinInitializer,
+    DefaultNetTypeDirective,
+    DefaultPatternKeyExpression,
+    DefaultSkewItem,
+    DeferredAssertion,
+    DefineDirective,
+    Delay3,
+    DelayControl,
+    DelayedTerminalArg,
+    DescendingRangeSelect,
+    DisableConstraint,
+    DisableForkStatement,
+    DisableIff,
+    DisableStatement,
+    DistConstraintList,
+    DistItem,
+    DistWeight,
+    DivideAssignmentExpression,
+    DivideExpression,
+    DividerClause,
+    DoWhileStatement,
+    DotMemberClause,
+    DriveStrength,
+    EdgeControlSpecifier,
+    EdgeDescriptor,
+    EdgeSensitivePathSuffix,
+    ElabSystemTask,
+    ElementSelect,
+    ElementSelectExpression,
+    ElsIfDirective,
+    ElseClause,
+    ElseConstraintClause,
+    ElseDirective,
+    EmptyArgument,
+    EmptyIdentifierName,
+    EmptyMember,
+    EmptyPortConnection,
+    EmptyQueueExpression,
+    EmptyStatement,
+    EmptyTimingCheckArg,
+    EndCellDefineDirective,
+    EndIfDirective,
+    EndKeywordsDirective,
+    EnumType,
+    EqualityExpression,
+    EqualsTypeClause,
+    EqualsValueClause,
+    EventControl,
+    EventControlWithExpression,
+    EventType,
+    EventuallyPropertyExpression,
+    ExpectPropertyStatement,
+    ExplicitAnsiPort,
+    ExplicitNonAnsiPort,
+    ExpressionConstraint,
+    ExpressionCoverageBinInitializer,
+    ExpressionOrDist,
+    ExpressionPattern,
+    ExpressionStatement,
+    ExpressionTimingCheckArg,
+    ExtendsClause,
+    ExternModule,
+    FinalBlock,
+    ForLoopStatement,
+    ForVariableDeclaration,
+    ForeachLoopList,
+    ForeachLoopStatement,
+    ForeverStatement,
+    ForwardInterfaceClassTypedefDeclaration,
+    ForwardTypedefDeclaration,
+    FunctionDeclaration,
+    FunctionPort,
+    FunctionPortList,
+    FunctionPrototype,
+    GateInstance,
+    GateInstanceName,
+    GateInstantiation,
+    GenerateBlock,
+    GenerateRegion,
+    GenvarDeclaration,
+    GreaterThanEqualExpression,
+    GreaterThanExpression,
+    HierarchicalInstance,
+    HierarchyInstantiation,
+    IdentifierName,
+    IdentifierSelectName,
+    IfDefDirective,
+    IfGenerate,
+    IfNDefDirective,
+    IfNonePathDeclaration,
+    IffEventClause,
+    IffPropertyExpression,
+    ImmediateAssertStatement,
+    ImmediateAssertionMember,
+    ImmediateAssumeStatement,
+    ImmediateCoverStatement,
+    ImplementsClause,
+    ImplicationConstraint,
+    ImplicitAnsiPort,
+    ImplicitEventControl,
+    ImplicitNonAnsiPort,
+    ImplicitType,
+    ImpliesPropertyExpression,
+    IncludeDirective,
+    InequalityExpression,
+    InitialBlock,
+    InsideExpression,
+    IntType,
+    IntegerLiteralExpression,
+    IntegerType,
+    IntegerVectorExpression,
+    InterconnectPortHeader,
+    InterfaceDeclaration,
+    InterfaceHeader,
+    InterfacePortHeader,
+    IntersectSequenceExpression,
+    InvocationExpression,
+    JumpStatement,
+    LessThanEqualExpression,
+    LessThanExpression,
+    LetDeclaration,
+    LineDirective,
+    LocalScope,
+    LogicType,
+    LogicalAndExpression,
+    LogicalEquivalenceExpression,
+    LogicalImplicationExpression,
+    LogicalLeftShiftAssignmentExpression,
+    LogicalOrExpression,
+    LogicalRightShiftAssignmentExpression,
+    LogicalShiftLeftExpression,
+    LogicalShiftRightExpression,
+    LongIntType,
+    LoopConstraint,
+    LoopGenerate,
+    LoopStatement,
+    MacroActualArgument,
+    MacroActualArgumentList,
+    MacroArgumentDefault,
+    MacroFormalArgument,
+    MacroFormalArgumentList,
+    MacroUsage,
+    MatchesClause,
+    MemberAccessExpression,
+    MinTypMaxExpression,
+    ModAssignmentExpression,
+    ModExpression,
+    ModportClockingPort,
+    ModportDeclaration,
+    ModportExplicitPort,
+    ModportItem,
+    ModportNamedPort,
+    ModportSimplePortList,
+    ModportSubroutinePort,
+    ModportSubroutinePortList,
+    ModuleDeclaration,
+    ModuleHeader,
+    MultipleConcatenationExpression,
+    MultiplyAssignmentExpression,
+    MultiplyExpression,
+    NameValuePragmaExpression,
+    NamedArgument,
+    NamedBlockClause,
+    NamedLabel,
+    NamedPortConnection,
+    NamedStructurePatternMember,
+    NamedType,
+    NetDeclaration,
+    NetPortHeader,
+    NetTypeDeclaration,
+    NewArrayExpression,
+    NewClassExpression,
+    NextTimePropertyExpression,
+    NoUnconnectedDriveDirective,
+    NonAnsiPortList,
+    NonAnsiUdpPortList,
+    NonOverlappedFollowedByPropertyExpression,
+    NonOverlappedImplicationPropertyExpression,
+    NonblockingAssignmentExpression,
+    NonblockingEventTriggerStatement,
+    NullLiteralExpression,
+    NumberPragmaExpression,
+    OneStepLiteralExpression,
+    OpenRangeExpression,
+    OpenRangeList,
+    OrAssignmentExpression,
+    OrSequenceExpression,
+    OrderedArgument,
+    OrderedPortConnection,
+    OrderedStructurePatternMember,
+    OverlappedFollowedByPropertyExpression,
+    OverlappedImplicationPropertyExpression,
+    PackageDeclaration,
+    PackageHeader,
+    PackageImportDeclaration,
+    PackageImportItem,
+    ParallelBlockStatement,
+    ParameterDeclaration,
+    ParameterDeclarationStatement,
+    ParameterPortList,
+    ParameterValueAssignment,
+    ParenExpressionList,
+    ParenPragmaExpression,
+    ParenthesizedEventExpression,
+    ParenthesizedExpression,
+    PathDeclaration,
+    PathDescription,
+    PatternCaseItem,
+    PortConcatenation,
+    PortDeclaration,
+    PortReference,
+    PostdecrementExpression,
+    PostincrementExpression,
+    PowerExpression,
+    PragmaDirective,
+    PrimaryBlockEventExpression,
+    ProceduralAssignStatement,
+    ProceduralDeassignStatement,
+    ProceduralForceStatement,
+    ProceduralReleaseStatement,
+    ProgramDeclaration,
+    ProgramHeader,
+    PropertyDeclaration,
+    PropertySpec,
+    PropertyType,
+    PulseStyleDeclaration,
+    QueueDimensionSpecifier,
+    RandCaseItem,
+    RandCaseStatement,
+    RangeCoverageBinInitializer,
+    RangeDimensionSpecifier,
+    RealLiteralExpression,
+    RealTimeType,
+    RealType,
+    RegType,
+    RejectOnPropertyExpression,
+    RepeatedEventControl,
+    ReplicatedAssignmentPattern,
+    ResetAllDirective,
+    RestrictPropertyStatement,
+    ReturnStatement,
+    RootScope,
+    SAlwaysPropertyExpression,
+    SEventuallyPropertyExpression,
+    SNextTimePropertyExpression,
+    SUntilPropertyExpression,
+    SUntilWithPropertyExpression,
+    ScopedName,
+    SequenceDeclaration,
+    SequenceType,
+    SequentialBlockStatement,
+    ShortIntType,
+    ShortRealType,
+    ShortcutCycleDelayRange,
+    SignalEventExpression,
+    SignedCastExpression,
+    SimpleAssignmentPattern,
+    SimplePathSuffix,
+    SimplePragmaExpression,
+    SimpleRangeSelect,
+    SolveBeforeConstraint,
+    SpecifyBlock,
+    SpecparamDeclaration,
+    SpecparamDeclarator,
+    StandardCaseItem,
+    StreamExpression,
+    StreamExpressionWithRange,
+    StreamingConcatenationExpression,
+    StringLiteralExpression,
+    StringType,
+    StructType,
+    StructUnionMember,
+    StructurePattern,
+    StructuredAssignmentPattern,
+    SubtractAssignmentExpression,
+    SubtractExpression,
+    SuperHandle,
+    SyncAcceptOnPropertyExpression,
+    SyncRejectOnPropertyExpression,
+    SystemName,
+    SystemTimingCheck,
+    TaggedPattern,
+    TaggedUnionExpression,
+    TaskDeclaration,
+    ThisHandle,
+    ThroughoutSequenceExpression,
+    TimeLiteralExpression,
+    TimeScaleDirective,
+    TimeType,
+    TimeUnitsDeclaration,
+    TimingCheckCondition,
+    TimingCheckEvent,
+    TimingControlExpression,
+    TimingControlExpressionConcatenation,
+    TimingControlStatement,
+    TransListCoverageBinInitializer,
+    TransRange,
+    TransRepeatRange,
+    TransSet,
+    TypeAssignment,
+    TypeParameterDeclaration,
+    TypeReference,
+    TypedefDeclaration,
+    UdpBody,
+    UdpDeclaration,
+    UdpEdgeIndicator,
+    UdpEntry,
+    UdpInitialStmt,
+    UdpInputPortDecl,
+    UdpOutputPortDecl,
+    UnaryBitwiseAndExpression,
+    UnaryBitwiseNandExpression,
+    UnaryBitwiseNorExpression,
+    UnaryBitwiseNotExpression,
+    UnaryBitwiseOrExpression,
+    UnaryBitwiseXnorExpression,
+    UnaryBitwiseXorExpression,
+    UnaryLogicalNotExpression,
+    UnaryMinusExpression,
+    UnaryNotPropertyExpression,
+    UnaryPlusExpression,
+    UnaryPredecrementExpression,
+    UnaryPreincrementExpression,
+    UnarySequenceDelayExpression,
+    UnarySequenceEventExpression,
+    UnbasedUnsizedLiteralExpression,
+    UnconnectedDriveDirective,
+    UndefDirective,
+    UndefineAllDirective,
+    UnionType,
+    UniquenessConstraint,
+    UnitScope,
+    UntilPropertyExpression,
+    UntilWithPropertyExpression,
+    Untyped,
+    UserDefinedNetDeclaration,
+    VariableDimension,
+    VariablePattern,
+    VariablePortHeader,
+    VirtualInterfaceType,
+    VoidCastedCallStatement,
+    VoidType,
+    WaitForkStatement,
+    WaitOrderStatement,
+    WaitStatement,
+    WildcardDimensionSpecifier,
+    WildcardEqualityExpression,
+    WildcardInequalityExpression,
+    WildcardLiteralExpression,
+    WildcardPattern,
+    WildcardPortConnection,
+    WildcardPortList,
+    WildcardUdpPortList,
+    WithClause,
+    WithFunctionClause,
+    WithFunctionSample,
+    WithinSequenceExpression,
+    XorAssignmentExpression,
+};
+
+std::ostream& operator<<(std::ostream& os, SyntaxKind kind);
+string_view toString(SyntaxKind kind);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./generated/Version.cpp ./generated/Version.cpp
--- ./generated/Version.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/Version.cpp	2021-03-02 17:50:53.851604954 -0800
@@ -0,0 +1,26 @@
+//------------------------------------------------------------------------------
+// Version.cpp
+// Input file for build-time version source generation
+//
+// File is under the MIT license; see LICENSE for details.
+//------------------------------------------------------------------------------
+#include "slang/util/Version.h"
+
+using std::string_view;
+using namespace std::literals;
+
+namespace slang {
+
+int VersionInfo::getMajor() {
+    return 0;
+}
+
+int VersionInfo::getMinor() {
+    return 7;
+}
+
+string_view VersionInfo::getRevision() {
+    return "5fd85b76"sv;
+}
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' ./include/slang/util/OS.h ./include/slang/util/OS.h
--- ./include/slang/util/OS.h	2021-03-02 16:27:19.475579506 -0800
+++ ./include/slang/util/OS.h	2021-03-02 17:58:05.412608286 -0800
@@ -75,11 +75,11 @@
 
     /// Prints colored formatted text to stdout, handling Unicode conversions where necessary.
     template<typename... Args>
     static void print(const fmt::text_style& style, string_view format, const Args&... args) {
         if (showColorsStdout) {
-            fmt::vprint(stdout, style, format, fmt::make_format_args(args...));
+            fmt::print(format, args...);
         }
         else {
             fmt::vprint(stdout, format, fmt::make_format_args(args...));
         }
     }
