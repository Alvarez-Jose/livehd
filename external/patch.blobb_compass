diff -druN BloBB_CompaSS_050315/BloBB/bound.cxx blob_compass/BloBB/bound.cxx
--- BloBB_CompaSS_050315/BloBB/bound.cxx	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/BloBB/bound.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,561 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "bound.h"
-#include "parameters.h"
-
-#include <float.h>
-#include <algorithm>
-using namespace std;
-
-// ========================================================
-bool BranchBoundCompare(const double area,
-                        const double bestArea)
-{
-   return area < bestArea;
-}
-// --------------------------------------------------------
-bool BacktrackCompare(const double area,
-                      const double bestArea)
-{
-   return area < bestArea;
-}
-// --------------------------------------------------------
-bool EnumerateCompare(const double area,
-                      const double bestArea)
-{
-   return area <= bestArea;
-}
-// ========================================================
-bool BranchBoundProceed(const double minEdge[],
-                        const bool same[][MAX_BLOCK_NUM],
-                        const int blkBefore[],
-                        const OwnQueue<int>& bCont,
-                        const FloorPlan& best,
-                        Dimension block[][ORIENT_NUM],
-                        OTree& ot)
-{
-    if (ot.TOTAL_AREA + ot.deadspace >= best.area)
-       return false;
-    if (ot.width() * ot.height() >= best.area)
-       return false;
-    if (!LBCompact(ot)) 
-       return false;
-    if (!sameBlockBound(same, ot, blkBefore))
-       return false;
-    if (!sameEdgeBound(ot))
-       return false;    
-    if (!notRedundant(ot, bCont))
-       return false;
-    if (ot.TOTAL_AREA + ot.deadspace + extDspace(ot, bCont, minEdge)
-        >= best.area)
-       return false;
-    if (ot.orient[0] != 0)
-       return false;
-    if (maxMinBound(block, minEdge, bCont, ot, best) >= best.area)
-       return false;
-    if (minMinBound(minEdge, bCont, best, block, ot) >= best.area)
-       return false;    
-    return true;
-}                                       
-// --------------------------------------------------------
-bool BacktrackProceed(const double minEdge[],
-                      const bool same[][MAX_BLOCK_NUM],
-                      const int blkBefore[],
-                      const OwnQueue<int>& bCont,
-                      const FloorPlan& best,
-                      Dimension block[][ORIENT_NUM],
-                      OTree& ot)
-{
-    if (max(ot.TOTAL_AREA + ot.deadspace, BT_MIN_TOTAL) >= best.area)
-       return false;
-    if (max(ot.width() * ot.height(), BT_MIN_TOTAL) >= best.area)
-       return false;
-    if (!LBCompact(ot)) 
-       return false;
-    if (!sameBlockBound(same, ot, blkBefore))
-       return false;
-    if (!sameEdgeBound(ot))
-       return false;    
-    if (!notRedundant(ot, bCont))
-       return false;
-    if (max(ot.TOTAL_AREA + ot.deadspace + extDspace(ot, bCont, minEdge),
-            BT_MIN_TOTAL) >= best.area)
-       return false;
-    if (ot.orient[0] != 0)
-       return false;
-    if (max(maxMinBound(block, minEdge, bCont, ot, best), BT_MIN_TOTAL)
-        >= best.area)
-       return false;
-    if (max(minMinBound(minEdge, bCont, best, block, ot), BT_MIN_TOTAL)
-        >= best.area)
-       return false;    
-    return true;
-}                                       
-// --------------------------------------------------------
-bool EnumerateProceed(const double minEdge[],
-                      const bool same[][MAX_BLOCK_NUM],
-                      const int blkBefore[],
-                      const OwnQueue<int>& bCont,
-                      const FloorPlan& best,
-                      Dimension block[][ORIENT_NUM],
-                      OTree& ot)
-{
-    if (ot.TOTAL_AREA + ot.deadspace > best.area)
-       return false;
-    if (ot.width() * ot.height() > best.area)
-       return false;
-    if (!LBCompact(ot)) 
-       return false;
-    if (!sameBlockBound(same, ot, blkBefore))
-       return false;
-    if (!sameEdgeBound(ot))
-       return false;    
-    if (!notRedundant(ot, bCont))
-       return false;
-    if (ot.TOTAL_AREA + ot.deadspace + extDspace(ot, bCont, minEdge)
-        > best.area)
-       return false;
-    if (ot.orient[0] != 0)
-       return false;
-    if (maxMinBound(block, minEdge, bCont, ot, best) > best.area)
-       return false;
-    if (minMinBound(minEdge, bCont, best, block, ot) > best.area)
-       return false;    
-    return true;
-}                                       
-// ========================================================
-double extDspace(const OTree& ot, 
-                 const OwnQueue<int>& queue,
-                 const double minEdge[])
-{
-   int size = queue.size();
-   double minMinEdge = DBL_MAX;
-   double edspace = 0;
-
-   for (int i = 0; i < size; i++)
-      if (minEdge[queue[i]] < minMinEdge)
-         minMinEdge = minEdge[queue[i]];
-      
-   int ptr = ot.contour[ot.BLOCK_NUM].next;
-   while (ptr != ot.BLOCK_NUM+1)
-   {
-      double begin = ot.contour[ptr].begin;
-      double end = ot.contour[ptr].end;
-      double LCTL = ot.contour[ot.contour[ptr].prev].CTL;
-      double RCTL = ot.contour[ot.contour[ptr].next].CTL;
-      double CTL = min(LCTL, RCTL);
-
-      if ((end-begin < minMinEdge) &&
-          (CTL > ot.contour[ptr].CTL))
-         edspace += (CTL-ot.contour[ptr].CTL) * (end-begin);
-      ptr = ot.contour[ptr].next;
-   }
-   return edspace;
-}
-// --------------------------------------------------------
-double minMinBound(const double minEdge[],
-                   const OwnQueue<int>& bCont,
-                   const FloorPlan& best,
-                   Dimension block[][ORIENT_NUM],
-                   OTree& ot)
-{
-   static const int FIRST_IND = ot.BLOCK_NUM+2;
-   int qSize = bCont.size();
-   int extbNum = ot.numZero - ot.perSize;
-   double minMinEdge = DBL_MAX;
-   
-   if (extbNum < 1)
-      return 0;   
-   
-   for (int i = 0; i < qSize; i++)
-      if (minEdge[bCont[i]] < minMinEdge)      
-         minMinEdge = minEdge[bCont[i]];              
-
-   for (int j = 0; j < extbNum; j++)
-   {
-      block[FIRST_IND+j][0].width = minMinEdge;
-      block[FIRST_IND+j][0].height = minMinEdge;
-
-      ot.push_perm(FIRST_IND+j);
-      ot.push_orient(0);
-      ot.setpos_update(block, FIRST_IND+j);
-   }
-   
-   double width = ot.width();
-   double height = ot.height();
-   double minArea = width * height;
-   
-   for (int k = extbNum-1; k >= 0; k--)
-   {
-      ot.remove_block(FIRST_IND+k);
-      ot.pop_orient();
-      ot.pop_perm();
-   }
-
-   return minArea;
-}
-// --------------------------------------------------------
-double maxMinBound(const Dimension block[][ORIENT_NUM],
-                   const double minEdge[],
-                   const OwnQueue<int>& bCont,
-                   const OTree& ot,
-                   const FloorPlan& best)
-{
-   double maxMinEdge = 0;
-   double maxWidth = 0;
-   double maxHeight = 0;
-   double minArea = DBL_MAX;
-   double otWidth = ot.width();
-   double otHeight = ot.height();
-   
-   int qSize = bCont.size();
-
-   if (qSize < 2)
-      return 0;
-
-   for (int i = 0; i < qSize; i++)
-      if (minEdge[bCont[i]] > maxMinEdge)
-      {
-         maxMinEdge = minEdge[bCont[i]];
-         maxWidth = block[bCont[i]][0].width;
-         maxHeight = block[bCont[i]][0].height;
-      }
-
-   int currBlk = ot.contour[ot.BLOCK_NUM].next;
-   int prevBlk = ot.BLOCK_NUM;
-   while (currBlk != -1)
-   {
-      if (ot.contour[currBlk].CTL < ot.contour[prevBlk].CTL)
-      {
-         double begin = ot.contour[currBlk].begin;
-         double end = begin + maxWidth;
-         double maxY = 0;
-         int ptr = currBlk;
-         while (ot.contour[ptr].end <= end)
-         {
-            if (ot.contour[ptr].CTL > maxY)
-               maxY = ot.contour[ptr].CTL;
-            ptr = ot.contour[ptr].next;
-         }
-
-         if (ot.contour[ptr].begin < end)
-            if (ot.contour[ptr].CTL > maxY)
-               maxY = ot.contour[ptr].CTL;
-
-         double height = max(maxY+maxHeight, otHeight);
-         double width = max(end, otWidth);
-      
-         if (height*width < minArea)
-            minArea = height * width;
-      }
-      prevBlk = currBlk;
-      currBlk = ot.contour[currBlk].next;
-   }
-
-   prevBlk = ot.BLOCK_NUM;
-   currBlk = ot.contour[ot.BLOCK_NUM].next;
-   while (currBlk != -1)
-   {
-      if (ot.contour[currBlk].CTL < ot.contour[prevBlk].CTL)
-      {
-         double begin = ot.contour[currBlk].begin;
-         double end = begin + maxHeight;
-         double maxY = 0;
-         int ptr = currBlk;
-         while (ot.contour[ptr].end <= end)
-         {
-            if (ot.contour[ptr].CTL > maxY)
-               maxY = ot.contour[ptr].CTL;
-            ptr = ot.contour[ptr].next;
-         }
-
-         if (ot.contour[ptr].begin < end)
-            if (ot.contour[ptr].CTL > maxY)
-               maxY = ot.contour[ptr].CTL;
-
-         double height = max(maxY+maxWidth, otHeight);
-         double width = max(end, otWidth);
-      
-         if (height*width < minArea)
-            minArea = height * width;
-      }
-      prevBlk = currBlk;
-      currBlk = ot.contour[currBlk].next;
-   }
-
-   return minArea;
-}
-// --------------------------------------------------------
-bool LBCompact(const OTree& ot)
-{
-   int rect = ot.perm.top();
-   int Lrect = ot.prev[rect];
-
-   return (ot.yloc[rect] < ot.contour[Lrect].CTL) &&
-          (ot.contour[rect].CTL > ot.yloc[Lrect]);
-}
-// --------------------------------------------------------
-bool notRedundant(const OTree& ot,
-                  const OwnQueue<int>& bCont)
-{
-   int rect = ot.perm.top();
-   int LRect = ot.prev[rect];
-   
-   if (ot.contour[LRect].blockBelow.size() != 0)
-   {
-      int BRect = ot.contour[LRect].blockBelow.back();
-      if ((ot.contour[BRect].end == ot.xloc[rect]) &&
-          (ot.contour[BRect].CTL > ot.yloc[rect]))
-         return false;
-   }
-
-   int ptr = ot.contour[ot.BLOCK_NUM+1].prev;
-   while (ot.contour[ptr].begin > ot.xloc[ptr])
-      ptr = ot.contour[ptr].prev;
-
-   int TRRect = ptr;
-   int TLRect = ot.contour[ot.BLOCK_NUM].next;
-   int BRRect;
-   int BLRect = ot.perm[0];
-
-   ptr = ot.contour[ot.BLOCK_NUM+1].prev;
-   while (ot.yloc[ptr] != 0)
-      ptr = ot.contour[ptr].blockBelow.back();
-   BRRect = ptr;
-
-   if (flatBottom(ot))
-      if (!FlatBottomBound(ot))
-         return false;
-
-   if (flatTop(ot))
-      return (FlatTopBound(ot, BLRect, BRRect, TLRect, TRRect));
-
-   int count = 0; 
-   if (BLRect > BRRect)
-      count++;
-
-   if (BLRect > TLRect)
-      count++;
-
-   if ((count == 0) && BLRect <= TRRect)
-      return true;
-
-   if (count < 2)
-      return (BLRect < maxOneAbsent(bCont));
-   else
-      return (BLRect < maxTwoAbsent(bCont));   
-}
-// --------------------------------------------------------
-int maxOneAbsent(const OwnQueue<int>& queue)
-{
-   int maxAbs = 0;
-   int size = queue.size();
-
-   if (size == 0)
-      return -1;
-
-   for (int i = 0; i < size; i++)
-      if (queue[i] > maxAbs)
-         maxAbs = queue[i];
-
-   return maxAbs;
-}
-// --------------------------------------------------------
-int maxTwoAbsent(const OwnQueue<int>& queue)
-{
-   int size = queue.size();
-   int maxOne = 0;
-   int maxTwo = 0;
-
-   if (size == 0)
-      return -1;
-
-   for (int i = 0; i < size; i++)
-      if (queue[i] > maxOne)
-      {
-         maxOne = queue[i];
-         maxTwo = maxOne;
-      }
-      else if (queue[i] > maxTwo)
-         maxTwo = queue[i];
-   return maxTwo;
-}
-// --------------------------------------------------------
-bool FlatBottomBound(const OTree& ot)
-{
-   int rect = ot.perm.top();
-   int blrect = ot.perm[0];
-   int brrect, tlrect, trrect;
-
-   if (ot.contour[rect].blockBelow.size() == 0)
-      return true;
-
-   int ptr = ot.contour[rect].blockBelow.back();
-   while (ot.contour[ptr].begin != ot.xloc[ptr])
-      ptr = ot.contour[ptr].prev;
-   trrect = ptr;
-
-   while (ot.contour[ptr].prev != ot.BLOCK_NUM)
-      ptr = ot.contour[ptr].prev;
-   tlrect = ptr;
-
-   ptr = ot.contour[ot.BLOCK_NUM+1].prev;
-   while (ot.yloc[ptr] != 0)
-      ptr = ot.contour[ptr].blockBelow.back();
-   brrect = ptr;
-
-   return ((blrect <= brrect) && (blrect <= tlrect) && 
-           (blrect <= trrect));
-}
-// --------------------------------------------------------
-bool flatBottom(const OTree& ot)
-{
-   int ptr = ot.contour[ot.BLOCK_NUM].next;
-   double yloc = ot.yloc[ptr];
-
-   while (ptr != ot.BLOCK_NUM+1)
-   {
-      if (ot.yloc[ptr] != yloc)
-         return false;
-      ptr = ot.contour[ptr].next;
-   }
-   return true;
-}
-// --------------------------------------------------------
-bool FlatTopBound(const OTree& ot,
-                  int BLRect,
-                  int BRRect,
-                  int TLRect,
-                  int TRRect)
-{
-   return ((BLRect <= TLRect) && (BLRect <= TRRect) &&
-           (BLRect <= BRRect));
-}
-// --------------------------------------------------------
-bool flatTop(const OTree& ot)
-{
-   int ptr = ot.contour[ot.BLOCK_NUM].next;
-   double CTL = ot.contour[ptr].CTL;
-
-   while (ptr != ot.BLOCK_NUM+1)
-   {
-      if (ot.contour[ptr].CTL != CTL)
-         return false;
-      ptr = ot.contour[ptr].next;
-   }
-   return true;
-}
-// --------------------------------------------------------
-bool sameEdgeBound(const OTree& ot)
-{
-   int rect = ot.perm.top();
-   int Lrect = ot.prev[rect];
-   if ((ot.yloc[Lrect] == ot.yloc[rect]) &&
-       (ot.contour[Lrect].CTL == ot.contour[rect].CTL) &&
-       (Lrect > rect))
-       return false;
-
-   if (ot.contour[rect].blockBelow.size() == 0)
-      return true;
-
-   int Brect = ot.contour[rect].blockBelow.back();      
-   if ((ot.xloc[Brect] == ot.xloc[rect]) &&
-       (ot.contour[Brect].end == ot.contour[rect].end) &&
-       (Brect > rect))
-       return false;
-   return true;
-}
-// --------------------------------------------------------
-bool sameBlockBound(const bool same[][MAX_BLOCK_NUM],
-                    const OTree& ot,
-                    const int blkBefore[])
-{
-   int rect = ot.perm.top();
-   int pSize = ot.permpos[rect];
-   int blkCount = blkBefore[rect];
-
-   for (int i = 0; i < pSize; i++)
-      if (blkCount == 0)
-         return true;
-      else if (same[rect][ot.perm[i]])
-         blkCount--;         
-   return (blkCount == 0);   
-}
-// --------------------------------------------------------
-void InitializeBound(const Dimension block[][ORIENT_NUM],
-                     const OTree& ot,
-                     double minEdge[],
-                     bool same[][MAX_BLOCK_NUM],
-                     int blkBefore[])
-{
-   for (int q = 0; q < ot.BLOCK_NUM; q++)
-      minEdge[q] = min(block[q][0].width, block[q][0].height);      
-
-   for (int t = 0; t < ot.BLOCK_NUM; t++)
-   {
-      blkBefore[t] = 0;
-      for (int s = 0; s < t; s++)
-      {
-         if ((block[s][0].width == block[t][0].width) &&
-             (block[s][0].height == block[t][0].height))
-         {
-            same[s][t] = true;
-            same[t][s] = true;
-            blkBefore[t]++;
-         }
-         else if ((block[s][1].width == block[t][0].width) &&
-                  (block[s][1].height == block[t][0].height))
-         {
-            same[s][t] = true;
-            same[t][s] = true;
-            blkBefore[t]++;
-         }
-         else
-         {
-            same[s][t] = false;
-            same[t][s] = false;
-         }
-      }
-      same[t][t] = true;
-   }
-
-   for (int t = 0; t < ot.BLOCK_NUM; t++)
-   {
-      same[ot.BLOCK_NUM][t] = false;
-      for (int s = 0; s < t; s++)
-         same[ot.BLOCK_NUM][t] = same[s][t] || same[ot.BLOCK_NUM][t];
-
-      for (int s = t+1; s < ot.BLOCK_NUM; s++)
-         same[ot.BLOCK_NUM][t] = same[s][t] || same[ot.BLOCK_NUM][t];
-   }
-}
-// --------------------------------------------------------
diff -druN BloBB_CompaSS_050315/BloBB/boundfixed.cxx blob_compass/BloBB/boundfixed.cxx
--- BloBB_CompaSS_050315/BloBB/boundfixed.cxx	2003-11-26 17:33:42.000000000 -0800
+++ blob_compass/BloBB/boundfixed.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,271 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "boundfixed.h"
-#include "bound.h"
-#include "parameters.h"
-
-#include <float.h>
-#include <algorithm>
-using namespace std;
-
-// ========================================================
-bool fixed_BranchBoundProceed(const double minEdge[],
-                              const bool same[][MAX_BLOCK_NUM],
-                              const int blkBefore[],
-                              const OwnQueue<int>& bCont,
-                              const FloorPlan& best,
-                              Dimension block[][ORIENT_NUM],
-                              OTree& ot)
-{
-    if (ot.TOTAL_AREA + ot.deadspace >= best.area)
-       return false;
-    if (ot.width() * ot.height() >= best.area)
-       return false;
-    if (!LBCompact(ot)) 
-       return false;
-    if (!sameBlockBound(same, ot, blkBefore))
-       return false;
-    if (!sameEdgeBound(ot))
-       return false;    
-    if (!notRedundant(ot, bCont))
-       return false;
-    if (ot.TOTAL_AREA + ot.deadspace + fixed_extDspace(ot, bCont, block)
-        >= best.area)
-       return false;
-    if (fixed_maxMinBound(block, minEdge, bCont, ot, best) >= best.area)
-       return false;
-    if (fixed_minMinBound(bCont, best, block, ot) >= best.area)
-       return false;    
-    return true;
-}                                       
-// --------------------------------------------------------
-bool fixed_BacktrackProceed(const double minEdge[],
-                            const bool same[][MAX_BLOCK_NUM],
-                            const int blkBefore[],
-                            const OwnQueue<int>& bCont,
-                            const FloorPlan& best,
-                            Dimension block[][ORIENT_NUM],
-                            OTree& ot)
-{
-    if (max(ot.TOTAL_AREA + ot.deadspace, BT_MIN_TOTAL) >= best.area)
-       return false;
-    if (max(ot.width() * ot.height(), BT_MIN_TOTAL) >= best.area)
-       return false;
-    if (!LBCompact(ot)) 
-       return false;
-    if (!sameBlockBound(same, ot, blkBefore))
-       return false;
-    if (!sameEdgeBound(ot))
-       return false;    
-    if (!notRedundant(ot, bCont))
-       return false;
-    if (max(ot.TOTAL_AREA + ot.deadspace + fixed_extDspace(ot, bCont, block),
-            BT_MIN_TOTAL) >= best.area)
-       return false;
-    if (max(fixed_maxMinBound(block, minEdge, bCont, ot, best), BT_MIN_TOTAL)
-        >= best.area)
-       return false;
-    if (max(fixed_minMinBound(bCont, best, block, ot), BT_MIN_TOTAL)
-        >= best.area)
-       return false;    
-    return true;
-}                                       
-// --------------------------------------------------------
-bool fixed_EnumerateProceed(const double minEdge[],
-                            const bool same[][MAX_BLOCK_NUM],
-                            const int blkBefore[],
-                            const OwnQueue<int>& bCont,
-                            const FloorPlan& best,
-                            Dimension block[][ORIENT_NUM],
-                            OTree& ot)
-{
-    if (ot.TOTAL_AREA + ot.deadspace > best.area)
-       return false;
-    if (ot.width() * ot.height() > best.area)
-       return false;
-    if (!LBCompact(ot)) 
-       return false;
-    if (!sameBlockBound(same, ot, blkBefore))
-       return false;
-    if (!sameEdgeBound(ot))
-       return false;    
-    if (!notRedundant(ot, bCont))
-       return false;
-    if (ot.TOTAL_AREA + ot.deadspace + fixed_extDspace(ot, bCont, block)
-        > best.area)
-       return false;
-    if (fixed_maxMinBound(block, minEdge, bCont, ot, best) > best.area)
-       return false;
-    if (fixed_minMinBound(bCont, best, block, ot) > best.area)
-       return false;    
-    return true;
-}                                       
-// ========================================================
-double fixed_extDspace(const OTree& ot, 
-                       const OwnQueue<int>& queue,
-		       const Dimension block[][ORIENT_NUM])
-{
-   int size = queue.size();
-   double minMinEdge = DBL_MAX;
-   double edspace = 0;
-
-   for (int i = 0; i < size; i++)
-      if (block[queue[i]][0].width < minMinEdge)
-         minMinEdge = block[queue[i]][0].width;
-
-   int ptr = ot.contour[ot.BLOCK_NUM].next;
-   while (ptr != ot.BLOCK_NUM+1)
-   {
-      double begin = ot.contour[ptr].begin;
-      double end = ot.contour[ptr].end;
-      double LCTL = ot.contour[ot.contour[ptr].prev].CTL;
-      double RCTL = ot.contour[ot.contour[ptr].next].CTL;
-      double CTL = min(LCTL, RCTL);
-      
-      if ((end-begin < minMinEdge) &&
-          (CTL > ot.contour[ptr].CTL))
-         edspace += (CTL-ot.contour[ptr].CTL) * (end-begin);
-      ptr = ot.contour[ptr].next;
-   }
-   return edspace;
-}
-// --------------------------------------------------------
-double fixed_minMinBound(const OwnQueue<int>& bCont,
-                         const FloorPlan& best,
-                         Dimension block[][ORIENT_NUM], // scratch board
-                         OTree& ot)
-{
-   static const int FIRST_IND = ot.BLOCK_NUM+2;
-   int qSize = bCont.size();
-   int extbNum = ot.numZero - ot.perSize;
-   double minWidth = DBL_MAX;
-   double minHeight = DBL_MAX;
-      
-   if (extbNum < 1)
-      return 0;   
-
-   // find minWidth and minHeight
-   for (int i = 0; i < qSize; i++)
-   {
-      if (block[bCont[i]][0].width < minWidth)      
-	 minWidth = block[bCont[i]][0].width;
-
-      if (block[bCont[i]][0].height < minHeight)
-	 minHeight = block[bCont[i]][0].height;
-   }
-
-   // push extbNum minimum squares
-   for (int j = 0; j < extbNum; j++)
-   {
-      block[FIRST_IND+j][0].width = minWidth;
-      block[FIRST_IND+j][0].height = minHeight;
-
-      ot.push_perm(FIRST_IND+j);
-      ot.push_orient(0);
-      ot.setpos_update(block, FIRST_IND+j);
-   }
-   
-   double width = ot.width();
-   double height = ot.height();
-   double minArea = width * height;
-
-   // restore ot
-   for (int k = extbNum-1; k >= 0; k--)
-   {
-      ot.remove_block(FIRST_IND+k);
-      ot.pop_orient();
-      ot.pop_perm();
-   }
-   return minArea;
-}
-// --------------------------------------------------------
-double fixed_maxMinBound(const Dimension block[][ORIENT_NUM],
-			 const double minEdge[],
-                         const OwnQueue<int>& bCont,
-                         const OTree& ot,
-                         const FloorPlan& best)
-{
-   double maxMinEdge = 0;
-   double maxWidth = 0;
-   double maxHeight = 0;
-   double minArea = DBL_MAX;
-   double otWidth = ot.width();
-   double otHeight = ot.height();
-   
-   int qSize = bCont.size();
-
-   if (qSize < 2)
-      return 0;
-
-   // find an appropriate block
-   for (int i = 0; i < qSize; i++)
-      if (minEdge[bCont[i]] > maxMinEdge)
-      {
-         maxMinEdge = minEdge[bCont[i]];
-         maxWidth = block[bCont[i]][0].width;
-         maxHeight = block[bCont[i]][0].height;
-      }
-
-   int currBlk = ot.contour[ot.BLOCK_NUM].next;
-   int prevBlk = ot.BLOCK_NUM;
-   while (currBlk != -1)
-   {
-      if (ot.contour[currBlk].CTL < ot.contour[prevBlk].CTL)
-      {
-         double begin = ot.contour[currBlk].begin;
-         double end = begin + maxWidth;
-         double maxY = 0;
-         int ptr = currBlk;
-
-	 // get y-coordinate of that block
-         while (ot.contour[ptr].end <= end)
-         {
-            if (ot.contour[ptr].CTL > maxY)
-               maxY = ot.contour[ptr].CTL;
-            ptr = ot.contour[ptr].next;
-         }
-
-         if (ot.contour[ptr].begin < end)
-            if (ot.contour[ptr].CTL > maxY)
-               maxY = ot.contour[ptr].CTL;
-
-         double height = max(maxY+maxHeight, otHeight);
-         double width = max(end, otWidth);
-      
-	 minArea = min(minArea, height * width);
-      }
-      prevBlk = currBlk;
-      currBlk = ot.contour[currBlk].next;
-   }
-   return minArea;
-}
-// ========================================================
diff -druN BloBB_CompaSS_050315/BloBB/boundfixed.h blob_compass/BloBB/boundfixed.h
--- BloBB_CompaSS_050315/BloBB/boundfixed.h	2003-11-26 17:33:42.000000000 -0800
+++ blob_compass/BloBB/boundfixed.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,82 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef BOUNDFIXED_H
-#define BOUNDFIXED_H
-
-// optimized version for free orientation non-slicing block-packing
-// extra package in addition to bound.h
-
-#include "datastr.h"
-#include "stackqueue.h"
-
-// ========================================================
-bool fixed_BranchBoundProceed(const double minEdge[],
-			      const bool same[][MAX_BLOCK_NUM],
-			      const int blkBefore[],
-			      const OwnQueue<int>& bCont,
-			      const FloorPlan& best,
-			      Dimension block[][ORIENT_NUM],
-			      OTree& ot);
-// --------------------------------------------------------
-bool fixed_BacktrackProceed(const double minEdge[],
-			    const bool same[][MAX_BLOCK_NUM],
-			    const int blkBefore[],
-			    const OwnQueue<int>& bCont,
-			    const FloorPlan& best,
-			    Dimension block[][ORIENT_NUM],
-			    OTree& ot);
-// --------------------------------------------------------
-bool fixed_EnumerateProceed(const double minEdge[],
-			    const bool same[][MAX_BLOCK_NUM],
-			    const int blkBefore[],
-			    const OwnQueue<int>& bCont,
-			    const FloorPlan& best,
-			    Dimension block[][ORIENT_NUM],
-			    OTree& ot);
-// ========================================================
-double fixed_extDspace(const OTree& ot, 
-		       const OwnQueue<int>& queue,
-		       const Dimension block[][ORIENT_NUM]);
-
-double fixed_minMinBound(const OwnQueue<int>& bCont,
-			 const FloorPlan& best, 
-			 Dimension block[][ORIENT_NUM],
-			 OTree& ot);
-
-double fixed_maxMinBound(const Dimension block[][ORIENT_NUM],
-			 const double minEdge[],
-			 const OwnQueue<int>& bCont, 
-			 const OTree& ot, 
-			 const FloorPlan& best);
-// ========================================================
-
-#endif
diff -druN BloBB_CompaSS_050315/BloBB/bound.h blob_compass/BloBB/bound.h
--- BloBB_CompaSS_050315/BloBB/bound.h	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/BloBB/bound.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,115 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef BOUND_H
-#define BOUND_H
-
-#include "datastr.h"
-
-typedef bool (*CompareType)(const double, const double);
-typedef bool (*ProceedType)(const double[],
-                            const bool[][MAX_BLOCK_NUM],
-                            const int blkBefore[],
-                            const OwnQueue<int>& bCont,
-                            const FloorPlan& best,
-                            Dimension block[][ORIENT_NUM],
-                            OTree& ot);
-
-// ========================================================
-bool BranchBoundCompare(const double area, const double bestArea);
-bool BacktrackCompare(const double area, const double bestArea);
-bool EnumerateCompare(const double area, const double bestArea);
-// ========================================================
-bool BranchBoundProceed(const double minEdge[],
-                        const bool same[][MAX_BLOCK_NUM],
-                        const int blkBefore[],
-                        const OwnQueue<int>& bCont,
-                        const FloorPlan& best,
-                        Dimension block[][ORIENT_NUM],
-                        OTree& ot);
-// --------------------------------------------------------
-bool BacktrackProceed(const double minEdge[],
-                      const bool same[][MAX_BLOCK_NUM],
-                      const int blkBefore[],
-                      const OwnQueue<int>& bCont,
-                      const FloorPlan& best,
-                      Dimension block[][ORIENT_NUM],
-                      OTree& ot);
-// --------------------------------------------------------
-bool EnumerateProceed(const double minEdge[],
-                      const bool same[][MAX_BLOCK_NUM],
-                      const int blkBefore[],
-                      const OwnQueue<int>& bCont,
-                      const FloorPlan& best,
-                      Dimension block[][ORIENT_NUM],
-                      OTree& ot);
-// ========================================================
-double extDspace(const OTree& ot, 
-                 const OwnQueue<int>& queue,
-                 const double minEdge[]);
-
-double minMinBound(const double minEdge[], 
-                   const OwnQueue<int>& bCont,
-                   const FloorPlan& best, 
-                   Dimension block[][ORIENT_NUM],
-                   OTree& ot);
-
-double maxMinBound(const Dimension block[][ORIENT_NUM], 
-                   const double minEdge[],
-                   const OwnQueue<int>& bCont, 
-                   const OTree& ot, 
-                   const FloorPlan& best);
-// --------------------------------------------------------
-bool LBCompact(const OTree& ot);
-bool notRedundant(const OTree& ot, const OwnQueue<int>& bCont);
-int maxOneAbsent(const OwnQueue<int>& queue);
-int maxTwoAbsent(const OwnQueue<int>& queue);
-// --------------------------------------------------------
-bool FlatBottomBound(const OTree& ot);
-bool FlatTopBound(const OTree& ot,
-                  int BLRect,
-                  int BRRect,
-                  int TLRect,
-                  int TRRect);
-bool flatBottom(const OTree& ot);
-bool flatTop(const OTree& ot);
-// --------------------------------------------------------
-bool sameEdgeBound(const OTree& ot);
-bool sameBlockBound(const bool same[][MAX_BLOCK_NUM], 
-                    const OTree& ot,
-                    const int blkBefore[]);
-// --------------------------------------------------------
-void InitializeBound(const Dimension block[][ORIENT_NUM],
-                     const OTree& ot,
-                     double minEdge[],
-                     bool same[][MAX_BLOCK_NUM],
-                     int blkBefore[]);
-#endif
diff -druN BloBB_CompaSS_050315/BloBB/boundst.cxx blob_compass/BloBB/boundst.cxx
--- BloBB_CompaSS_050315/BloBB/boundst.cxx	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/BloBB/boundst.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,149 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "boundst.h"
-
-#include <algorithm>
-using namespace std;
-
-double extDeadspace(const STree& st)
-{
-   int bSize = st.buffer.size();
-   if (bSize < 2)
-      return 0;
-
-   double deadspace = 0;
-   double maxWidth = st.buffer.top().width;
-   double maxHeight = st.buffer.top().height;
-
-   for (int i = bSize-2; i >= 0; i--)
-   {
-      Node currRect = st.buffer[i];
-      double currWidth = currRect.width;
-      double currHeight = currRect.height;
-
-      if ((currWidth >= maxWidth) ||
-          (currHeight >= maxHeight))
-      {
-         if (currWidth > maxWidth)
-            maxWidth = currWidth;
-
-         if (currHeight > maxHeight)
-            maxHeight = currHeight;
-      }
-      else
-      {
-         deadspace += min(currWidth * (maxHeight - currHeight),
-                          (maxWidth - currWidth) * currHeight);
-      }
-   }
-   return deadspace;
-}
-// --------------------------------------------------------
-bool blockSym(const STree& st)
-{
-   int sSize = st.buffer.size();
-   if (sSize < 2)
-      return true;
-
-   int LBBlock = st.buffer[sSize-2].BLBlock;
-   int RTBlock = st.buffer[sSize-1].BLBlock;
-
-   return (LBBlock < RTBlock);
-}
-// --------------------------------------------------------
-bool abutSym(const STree& st)
-{
-   int sign = st.expression.top();
-
-   if (sign == st.storage.top().sign)
-   {
-      int sSize = st.storage.size();
-      int BLcluster = st.storage[sSize-1].TRblblock;
-      int TRcluster = st.storage[sSize-2].BLBlock;
-
-      return (BLcluster < TRcluster);
-   }
-   else
-      return true;
-}
-// --------------------------------------------------------
-bool sameBlockBound(const bool same[][MAX_BLOCK_NUM],
-                    const int blkBefore[],
-                    const STree& st)
-{
-   int rect = st.expression.top();
-   int rectpos = st.expression.size()-1;
-   int blkCount = blkBefore[rect];
-
-   for (int i = 0; i < rectpos; i++)
-      if (blkCount == 0)
-         return true;
-      else if ((st.expression[i] < st.BLOCK_NUM) &&
-               same[rect][st.expression[i]])
-         blkCount--;         
-   return (blkCount == 0);   
-}
-// --------------------------------------------------------
-void InitializeBound(const Dimension block[][ORIENT_NUM],
-                     const STree& st,
-                     bool same[][MAX_BLOCK_NUM],
-                     int blkBefore[])
-{
-   for (int t = 0; t < st.BLOCK_NUM; t++)
-   {
-      blkBefore[t] = 0;
-      for (int s = 0; s < t; s++)
-      {
-         if ((block[s][0].width == block[t][0].width) &&
-             (block[s][0].height == block[t][0].height))
-         {
-            same[s][t] = true;
-            same[t][s] = true;
-            blkBefore[t]++;
-         }
-         else if ((block[s][1].width == block[t][0].width) &&
-                  (block[s][1].height == block[t][0].height))
-         {
-            same[s][t] = true;
-            same[t][s] = true;
-            blkBefore[t]++;
-         }
-         else
-         {
-            same[s][t] = false;
-            same[t][s] = false;
-         }
-      }
-      same[t][t] = true;
-   }   
-}
-// --------------------------------------------------------
diff -druN BloBB_CompaSS_050315/BloBB/boundst.h blob_compass/BloBB/boundst.h
--- BloBB_CompaSS_050315/BloBB/boundst.h	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/BloBB/boundst.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,50 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef BOUNDST_H
-#define BOUNDST_H
-
-#include "datastrst.h"
-
-double extDeadspace(const STree& st);
-double twoMinArea(const STree& st);
-bool blockSym(const STree& st);
-bool abutSym(const STree& st);
-bool sameBlockBound(const bool same[][MAX_BLOCK_NUM],
-                    const int blkBefore[],
-                    const STree& st);
-// --------------------------------------------------------
-void InitializeBound(const Dimension block[][ORIENT_NUM], 
-                     const STree& st, 
-                     bool same[][MAX_BLOCK_NUM], 
-                     int blkBefore[]);
-#endif
-
diff -druN BloBB_CompaSS_050315/BloBB/btreefromblobb.cxx blob_compass/BloBB/btreefromblobb.cxx
--- BloBB_CompaSS_050315/BloBB/btreefromblobb.cxx	2004-05-10 13:46:26.000000000 -0700
+++ blob_compass/BloBB/btreefromblobb.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,82 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "btreefromblobb.h"
-
-#include "datastr.h"
-#include "datastrfrontsoftst.h"
-
-#include <vector>
-using namespace std;
-
-// --------------------------------------------------------
-SoftPackingFromBloBB::SoftPackingFromBloBB(
-   const vector< vector<Dimension> >& block,
-   const Cluster& cluster,
-   const FloorPlanVec& fp)
-   : SoftPacking()
-{
-   xloc.resize(cluster.BLOCK_NUM);
-   yloc.resize(cluster.BLOCK_NUM);
-   width.resize(cluster.BLOCK_NUM);
-   height.resize(cluster.BLOCK_NUM);
-   expression.resize(cluster.expression.size());
-
-   int orient_ptr = 0;
-   for (unsigned int i = 0; i < expression.size(); i++)
-   {
-      int sign = cluster.expression[i];
-      if (sign == cluster.PLUS)
-         expression[i] = SoftSTree::PLUS;
-      else if (sign == cluster.STAR)
-         expression[i] = SoftSTree::STAR;
-      else
-      {
-         int theta = cluster.orient[orient_ptr];
-         expression[i] = sign;
-         width[sign] = block[sign][theta].width;
-         height[sign] = block[sign][theta].height;
-         orient_ptr++;
-      }
-   }
-
-   for (int i = 0; i < cluster.BLOCK_NUM; i++)
-   {
-      xloc[i] = fp.xLoc[i];
-      yloc[i] = fp.yLoc[i];
-   }
-
-   deadspace = cluster.deadspace;
-   blockArea = cluster.area;
-   totalWidth = cluster.width;
-   totalHeight = cluster.height;
-}
-// --------------------------------------------------------   
diff -druN BloBB_CompaSS_050315/BloBB/btreefromblobb.h blob_compass/BloBB/btreefromblobb.h
--- BloBB_CompaSS_050315/BloBB/btreefromblobb.h	2004-05-10 13:45:57.000000000 -0700
+++ blob_compass/BloBB/btreefromblobb.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,53 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef BTREEFROMBLOBB_H
-#define BTREEFROMBLOBB_H
-
-#include "datastr.h"
-#include "datastrhierst.h"
-#include "datastrfrontsoftst.h"
-#include "vectorize.h"
-
-#include <vector>
-using namespace std;
-
-// --------------------------------------------------------
-class SoftPackingFromBloBB : public SoftPacking
-{
-public:
-   SoftPackingFromBloBB(const vector< vector<Dimension> >& block,
-                        const Cluster& cluster,
-                        const FloorPlanVec& fp);
-};
-// --------------------------------------------------------
-
-#endif
diff -druN BloBB_CompaSS_050315/BloBB/datastr.cxx blob_compass/BloBB/datastr.cxx
--- BloBB_CompaSS_050315/BloBB/datastr.cxx	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/BloBB/datastr.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,375 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "datastr.h"
-#include "parameters.h"
-
-#include <float.h>
-#include <algorithm>
-using namespace std;
-
-// --------------------------------------------------------
-OTree::OTree(const int blockNum,
-             const double totalArea)
-   :  deadspace(0),
-      BLOCK_NUM(blockNum),
-      TOTAL_AREA(totalArea),
-      balance(0),
-      numZero(0),
-      last(0),      
-      curr_contour(blockNum),
-      perSize(0)
-{
-   for (int k = 0; k < MAX_SIZE; k++)
-   {
-      permpos[k] = -1;
-      treepos[k] = -1;
-      prev[k] = -1;
-      pdspace[k] = 0;
-      xloc[k] = 0;
-      yloc[k] = 0;
-   }
-
-   contour[blockNum].next = blockNum+1;
-   contour[blockNum].prev = -1;
-   contour[blockNum].begin = 0;
-   contour[blockNum].end = 0;
-   contour[blockNum].CTL = DBL_MAX;
-
-   contour[blockNum+1].next = -1;
-   contour[blockNum+1].prev = blockNum;
-   contour[blockNum+1].begin = 0;
-   contour[blockNum+1].end = DBL_MAX;
-   contour[blockNum+1].CTL= 0;
-}
-// --------------------------------------------------------
-bool OTree::push_tree(int action)
-{
-   bool accept;
-   int act1 = action / 2;
-   int act2 = action % 2;
-
-   tree.push(act1);
-   tree.push(act2);
-
-   if (act1 == 0)
-   {
-      balance++;
-      numZero++;
-   }
-   else
-      balance--;
-
-   accept = (balance >= 0);
-   if (act2 == 0)
-   {
-      balance++;
-      numZero++;
-   }
-   else
-      balance--;
-
-   accept = accept && (balance >= 0)
-                   && (numZero <= BLOCK_NUM);
-   return accept;
-}
-// --------------------------------------------------------
-void OTree::push_perm(int b)
-{
-   perm.push(b);
-   permpos[b] = perSize;
-   perSize++;
-}
-// --------------------------------------------------------
-void OTree::push_orient(int theta)
-{
-   orient.push(theta);
-}
-// --------------------------------------------------------
-void OTree::pop_orient()
-{
-   orient.pop();
-}
-// --------------------------------------------------------
-int OTree::pop_perm()
-{
-   int b = perm.pop();
-   perSize--;
-   permpos[b] = -1;
-   return b;
-}
-// --------------------------------------------------------
-void OTree::pop_tree()
-{
-   int act2 = tree.pop();
-   int act1 = tree.pop();
-
-   if (act2 == 0)
-   {
-      balance--;
-      numZero--;
-   }
-   else
-      balance++;
-
-   if (act1 == 0)
-   {
-      balance--;
-      numZero--;
-   }
-   else
-      balance++;
-}
-// --------------------------------------------------------
-void OTree::setpos_update(const Dimension block[][ORIENT_NUM],
-                          int rect)
-{
-   int action = last;
-   int theta = orient[permpos[rect]];
-
-   while (tree[action] == 1)
-   {
-      curr_contour = prev[curr_contour];
-      action++;
-   }
-   treepos[rect] = action;
-   last = action+1;
-
-   if (curr_contour == BLOCK_NUM)
-      xloc[rect] = 0;
-   else
-      xloc[rect] = xloc[curr_contour] + 
-         block[curr_contour][orient[permpos[curr_contour]]].width;
-   prev[rect] = curr_contour;
-
-   contour[rect].end = xloc[rect] + block[rect][theta].width;
-   update_contour(rect);
-   contour[rect].CTL = yloc[rect] + block[rect][theta].height;
-
-   curr_contour = rect;
-   add_deadspace(rect);   
-}
-// --------------------------------------------------------
-void OTree::update_contour(int rect)
-{
-   int Lrect = prev[rect];
-   int ptr = contour[Lrect].next;
-   double maxCTL = contour[ptr].CTL;
-
-   while (contour[ptr].end <= contour[rect].end)
-   {
-      if (contour[ptr].CTL > maxCTL)
-         maxCTL = contour[ptr].CTL;
-      contour[rect].blockBelow.enqueue(ptr);
-      ptr = contour[ptr].next;
-   }
-
-   if ((contour[ptr].CTL > maxCTL) &&
-       (contour[ptr].begin < contour[rect].end))
-       maxCTL = contour[ptr].CTL;
-   yloc[rect] = maxCTL;
-
-   contour[rect].next = ptr;
-   contour[ptr].prev = rect;
-   contour[ptr].begin = contour[rect].end;
-
-   contour[rect].prev = Lrect;
-   contour[Lrect].next = rect;
-   contour[rect].begin = contour[Lrect].end;
-};
-// --------------------------------------------------------
-void OTree::add_deadspace(int rect)
-{
-   int size = contour[rect].blockBelow.size();
-   int ptr, last;
-   
-   if (size == 0)
-      return;
-
-   for (int i = 0; i < size; i++)
-   {
-      ptr = contour[rect].blockBelow[i];
-      double begin = max(contour[ptr].begin, contour[rect].begin);
-      double end = contour[ptr].end;
-      double CTL = contour[ptr].CTL;
-
-      pdspace[rect] += (yloc[rect] - CTL) * (end-begin);
-   }
-
-   ptr = contour[rect].next;
-   last = contour[rect].blockBelow.back();
-   if (contour[last].end < contour[rect].end)
-   {
-      double begin = contour[last].end;
-      double end = contour[rect].end;
-      double CTL = contour[ptr].CTL;
-
-      pdspace[rect] += (yloc[rect] - CTL) * (end-begin);
-   }
-   deadspace += pdspace[rect];
-}
-// --------------------------------------------------------
-void OTree::remove_block(int rect)
-{
-   int Lrect = contour[rect].prev;
-   int Rrect = contour[rect].next;
-   int ptr = Lrect;
-   int size = contour[rect].blockBelow.size();
-   
-   deadspace -= pdspace[rect];
-   pdspace[rect] = 0;
-
-   if (size != 0)
-   {
-      ptr = contour[rect].blockBelow.front();
-      contour[Lrect].next = ptr;
-      
-      for (int i = 0; i < size; i++)
-         ptr = contour[rect].blockBelow.dequeue();
-   }
-   else
-      contour[Lrect].next = Rrect;
-
-   contour[Rrect].prev = ptr;
-   contour[Rrect].begin = contour[ptr].end;
-
-   size = perm.size();
-   if (size >= 2)
-      curr_contour = perm[size-2];
-   else
-      curr_contour = BLOCK_NUM;
-   last = treepos[curr_contour]+1;
-   treepos[rect] = -1;
-   prev[rect] = -1;
-}
-// --------------------------------------------------------
-double OTree::width() const
-{
-   return contour[BLOCK_NUM+1].begin;
-}
-// --------------------------------------------------------
-double OTree::height() const
-{
-   int ptr = contour[BLOCK_NUM].next;
-   double maxCTL = 0;
-   
-   while (ptr != -1)
-   {
-      if (contour[ptr].CTL > maxCTL)
-         maxCTL = contour[ptr].CTL;
-      ptr = contour[ptr].next;
-   }
-   return maxCTL;
-}
-// -------------------------------------------------------
-void FloorPlan::operator =(const OTree& ot)
-{
-   blockNum = ot.perSize;
-   for (int i = 0; i < blockNum; i++)
-   {
-      int b = ot.perm[i];
-      int theta = ot.orient[i];
-
-      xLoc[b] = ot.xloc[b];
-      yLoc[b] = ot.yloc[b];
-      orient[b] = theta;      
-   }
-   
-   width = ot.width();
-   height = ot.height();
-   area = width * height;
-}
-// --------------------------------------------------------
-void outputfp(const Dimension block[][ORIENT_NUM],
-              const FloorPlan& fp,
-              ostream& outs)
-{
-   outs.setf(ios::fixed);
-   outs.precision(3);
-   outs << fp.width << endl;
-   outs << fp.height << endl;
-   outs << fp.blockNum << endl;
-   for (int i = 0; i < fp.blockNum; i++)
-   {
-      double width = block[i][fp.orient[i]].width;
-      double height = block[i][fp.orient[i]].height;
-      outs << width << " " << height << endl;
-   }
-   outs << endl;
-   for (int i = 0; i < fp.blockNum; i++)
-   {
-      outs << fp.xLoc[i] << " " << fp.yLoc[i] << endl;
-   }
-   outs << endl;
-}
-// --------------------------------------------------------
-void Initialize(Dimension block[][ORIENT_NUM],
-                OTreePtr& ot_ptr,
-                istream& ins)
-{
-   int blockNum;
-   double area = 0;
-   ins >> blockNum;
-
-   if (blockNum > MAX_BLOCK_NUM)
-   {
-      cout << "ERROR: The number of blocks (" << blockNum
-           << ") exceeds maximum allowed (" << MAX_BLOCK_NUM << ")." << endl;
-      exit(1);
-   }
-   
-   for (int i = 0; i < blockNum; i++)
-   {
-      double width, height;
-      ins >> width >> height;
-      for (int j = 0; j < ORIENT_NUM; j++)
-         if (j % ENG_ORIENT_CONSIDERED == 0)
-         {
-            block[i][j].width = width;
-            block[i][j].height = height;
-         }
-         else if (j % ENG_ORIENT_CONSIDERED == 1)
-         {
-            block[i][j].width = height;
-            block[i][j].height = width;
-         }
-	 else
-	 {
-	    cout << "ERROR: invalid value of \"ENG_ORIENT_CONSIDERED\" ("
-		 << ENG_ORIENT_CONSIDERED << ")." << endl;
-	    exit(1);
-	 }
-
-      area += width * height;
-   }
-   ot_ptr = new OTree(blockNum, area);   
-}
-// --------------------------------------------------------
diff -druN BloBB_CompaSS_050315/BloBB/datastr.h blob_compass/BloBB/datastr.h
--- BloBB_CompaSS_050315/BloBB/datastr.h	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/BloBB/datastr.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,139 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef DATASTR_H
-#define DATASTR_H
-
-#include "stackqueue.h"
-
-#include <iostream>
-using namespace std;
-
-class OTree;
-typedef OTree* OTreePtr;
-
-const int ORIENT_NUM = 8;
-const int MAX_BLOCK_NUM = 100;
-
-// --------------------------------------------------------
-struct Dimension
-{
-   double width;
-   double height;
-};
-// --------------------------------------------------------
-struct CTRecord
-{
-   int next;
-   int prev;
-
-   double begin;
-   double end;
-   double CTL;
-
-   OwnQueue<int> blockBelow;
-};
-// --------------------------------------------------------
-class OTree
-{
-public:
-   OTree(const int blockNum, const double totalArea);
-
-   OwnStack<int> tree;
-   OwnStack<int> perm;
-   OwnStack<int> orient;
-
-   double xloc[MAX_SIZE];
-   double yloc[MAX_SIZE];
-
-   int permpos[MAX_SIZE];
-   int treepos[MAX_SIZE];
-   int prev[MAX_SIZE];
-
-   double deadspace;
-   double pdspace[MAX_SIZE];
-
-   const int BLOCK_NUM;
-   const double TOTAL_AREA;
-
-   int balance;
-   int numZero;
-
-   int last;
-   int curr_contour;
-   int perSize;
-
-   CTRecord contour[MAX_SIZE];
-
-   bool push_tree(int action);
-   void push_perm(int b);
-   void push_orient(int theta);
-
-   void pop_orient();
-   int pop_perm();
-   void pop_tree();
-
-   void setpos_update(const Dimension block[][ORIENT_NUM], int rect);
-   void update_contour(int rect);
-   void add_deadspace(int rect);
-   
-   void remove_block(int rect);
-   
-   double width() const;
-   double height() const;
-
-private:
-   OTree();
-   OTree(const OTree&);
-};
-// --------------------------------------------------------
-struct FloorPlan
-{
-   double xLoc[MAX_SIZE];
-   double yLoc[MAX_SIZE];
-   int orient[MAX_SIZE];   
-   int blockNum;
-
-   double width;
-   double height;
-   double area;
-
-   void operator =(const OTree& ot);
-};
-// --------------------------------------------------------
-void outputfp(const Dimension block[][ORIENT_NUM], 
-              const FloorPlan& fp,
-              ostream& outs);
-// --------------------------------------------------------
-void Initialize(Dimension block[][ORIENT_NUM],
-                OTreePtr& ot_ptr, istream& ins);
-   
-#endif
diff -druN BloBB_CompaSS_050315/BloBB/datastrhierst.cxx blob_compass/BloBB/datastrhierst.cxx
--- BloBB_CompaSS_050315/BloBB/datastrhierst.cxx	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/BloBB/datastrhierst.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,201 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "datastrhierst.h"
-#include "datastrst.h"
-// #include "debug.h" //---
-
-#include <vector>
-using namespace std;
-
-DistanceInfo::DistanceInfo()
-   : dist(0),
-     blockOne(-1),
-     blockTwo(-1)
-{}
-// --------------------------------------------------------
-DistanceInfo::DistanceInfo(const DistanceInfo& d2)
-   : dist(d2.dist),
-     blockOne(d2.blockOne),
-     blockTwo(d2.blockTwo)
-{}
-// --------------------------------------------------------
-void DistanceInfo::operator =(const DistanceInfo& d2)
-{
-   dist = d2.dist;
-   blockOne = d2.blockOne;
-   blockTwo = d2.blockTwo;
-}
-// --------------------------------------------------------
-Cluster::Cluster(int blockNum)
-   : BLOCK_NUM(blockNum),
-     PLUS(blockNum),
-     STAR(blockNum+1),
-     BLBlock(-1),
-     width(0),
-     height(0),
-     area(0),
-     deadspace(0)
-{}
-// --------------------------------------------------------
-Cluster::Cluster(const Cluster& c2)
-   : expression(c2.expression),
-     orient(c2.orient),
-     BLOCK_NUM(c2.BLOCK_NUM),
-     PLUS(c2.PLUS),
-     STAR(c2.STAR),
-     BLBlock(c2.BLBlock),
-     width(c2.width),
-     height(c2.height),
-     area(c2.area),
-     deadspace(c2.deadspace)     
-{}
-// --------------------------------------------------------
-void Cluster::operator =(const Cluster& c2)
-{
-   expression = c2.expression;
-   orient = c2.orient;
-   BLBlock = c2.BLBlock;
-   width = c2.width;
-   height = c2.height;
-   area = c2.area;
-   deadspace = c2.deadspace;
-}
-// --------------------------------------------------------
-void Cluster::initialize(const Dimension block[][ORIENT_NUM],
-                         int blk)
-{
-   BLBlock = blk;
-   width = block[blk][0].width;
-   height = block[blk][0].height;
-   area = width * height;
-   deadspace = 0;
-   
-   expression.push_back(blk);
-   orient.push_back(0);
-}
-// --------------------------------------------------------
-void Cluster::initialize(const SliceRecord& best,
-                         ClusterSet& clusterSet)
-{
-   int orient_size = best.blockNum;
-   int expr_size = 2 * orient_size - 1;
-   int next_orient = 0;
-
-   // assume this ->expression, orient empty;
-   // each supermodule is identified by its index in 
-   // its cluster set
-   BLBlock = best.expression[0];
-   width = best.width;
-   height = best.height;
-   area = 0;
-   deadspace = best.deadspace;
-   for (int i = 0; i < expr_size; i++)
-   {
-      int sign = best.expression[i];
-      if (sign < BLOCK_NUM)
-      {
-         int index = sign;
-         
-         if (best.orient[next_orient] == 1)
-            clusterSet[index].complement();
-         next_orient++;
-
-         int p_expr_size = clusterSet[index].expression.size();
-         for (int j = 0; j < p_expr_size; j++)
-            expression.push_back(clusterSet[index].expression[j]);
-
-         int p_orient_size = clusterSet[index].orient.size();
-         for (int k = 0; k < p_orient_size; k++)
-            orient.push_back(clusterSet[index].orient[k]);
-
-         area += clusterSet[index].area;
-         deadspace += clusterSet[index].deadspace;         
-      }
-      else
-         expression.push_back(sign);
-   }
-}
-// --------------------------------------------------------
-void Cluster::complement()
-{
-   double tempWidth = width;
-   double tempHeight = height;
-
-   width = tempHeight;
-   height = tempWidth;
-
-   int exprSize = expression.size();
-   for (int i = 0; i < exprSize; i++)
-      if (expression[i] == PLUS)
-         expression[i] = STAR;
-      else if (expression[i] == STAR)
-         expression[i] = PLUS;
-
-   int orientSize = orient.size();
-   for (int j = 0; j < orientSize; j++)
-      if (orient[j] == 0)
-         orient[j] = 1;
-      else 
-         orient[j] = 0;
-}
-// --------------------------------------------------------
-void setSliceRecord(SliceRecord& sRecord, 
-                    const Cluster& cluster)
-{
-   sRecord.blockNum = cluster.BLOCK_NUM;
-   sRecord.area = cluster.area + cluster.deadspace;
-   sRecord.deadspace = cluster.deadspace;
-   sRecord.width = cluster.width;
-   sRecord.height = cluster.height;
-
-   int exprSize = cluster.expression.size();
-   int orientSize = cluster.orient.size();
-
-   for (int i = 0; i < exprSize; i++)
-      sRecord.expression[i] = cluster.expression[i];
-
-   for (int i = 0; i < orientSize; i++)
-      sRecord.orient[i] = cluster.orient[i];
-}
-// --------------------------------------------------------
-void InitializeCluster(const Dimension block[][ORIENT_NUM],
-                       int blockNum,
-                       vector<Cluster>& clusters)
-{
-   for (int i = 0; i < blockNum; i++)
-   {
-      Cluster c(blockNum);
-      c.initialize(block, i);
-      clusters.push_back(c);
-   }
-}
-// --------------------------------------------------------
diff -druN BloBB_CompaSS_050315/BloBB/datastrhierst.h blob_compass/BloBB/datastrhierst.h
--- BloBB_CompaSS_050315/BloBB/datastrhierst.h	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/BloBB/datastrhierst.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,93 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef DATASTRHIERST_H
-#define DATASTRHIERST_H
-
-#include "datastrst.h"
-
-#include <iostream>
-#include <vector>
-using namespace std;
-
-class Cluster;
-typedef vector<Cluster> ClusterSet;
-// --------------------------------------------------------
-class DistanceInfo
-{
-public:
-   DistanceInfo();
-
-   DistanceInfo(const DistanceInfo& d2);
-   void operator =(const DistanceInfo& d2);
-
-   double dist;
-   int blockOne;
-   int blockTwo;
-};
-// --------------------------------------------------------
-inline bool operator <(const DistanceInfo& d1,
-                       const DistanceInfo& d2)
-{  return d1.dist < d2.dist; }
-// --------------------------------------------------------
-class Cluster
-{
-public:
-   Cluster(int blockNum);
-   Cluster(const Cluster& c2);
-   void operator =(const Cluster& c2);
-
-   vector<int> expression;
-   vector<int> orient;
-
-   const int BLOCK_NUM;
-   const int PLUS;
-   const int STAR;
-
-   int BLBlock;
-   double width;
-   double height;
-   double area;
-   double deadspace;
-
-   void initialize(const Dimension block[][ORIENT_NUM],
-                   int blk);
-   void initialize(const SliceRecord& best,
-                   ClusterSet& clusterSet);
-   void complement();
-};
-// --------------------------------------------------------
-void setSliceRecord(SliceRecord& sRecord, const Cluster& cluster);
-// --------------------------------------------------------
-void InitializeCluster(const Dimension block[][ORIENT_NUM],
-                       int blockNum,
-                       vector<Cluster>& clusters); // assumed empty
-#endif
diff -druN BloBB_CompaSS_050315/BloBB/datastromergest.h blob_compass/BloBB/datastromergest.h
--- BloBB_CompaSS_050315/BloBB/datastromergest.h	2005-03-14 21:29:22.000000000 -0800
+++ blob_compass/BloBB/datastromergest.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,86 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef DATASTROMERGEST_H
-#define DATASTROMERGEST_H
-
-#include "datastr.h"
-#include "datastrst.h"
-
-// --------------------------------------------------------
-class HardClusterRecord
-{
-public:
-   HardClusterRecord(const double width_,
-                     const double height_,
-                     const vector<int>& expression_,
-                     const vector<int>& orient_)
-      : width(width_),
-        height(height_),
-        expression(expression_),
-        orient(orient_)
-      {}
-
-   const double width;
-   const double height;
-   const vector<int> expression;
-   const vector<int> orient;
-
-   inline static bool maxSideLessThan(const HardClusterRecord& cr1,
-                                      const HardClusterRecord& cr2);
-   inline static bool areaLessThan(const HardClusterRecord& cr1,
-                                   const HardClusterRecord& cr2);
-};
-// --------------------------------------------------------
-// used to store temp results, indices in _clusters[i]
-// refer to a cluster, not necessary a signle block
-class ClusterSetRecord
-{
-public:
-   ClusterSetRecord();
-
-   void opertor =(const STree& stree);
-
-   inline double blockArea() const;
-   inline double totalArea() const;
-   inline double deadspace() const;
-   inline const HardClusterRecord& clusters(int index) const;
-   
-protected:
-   double _blockArea;
-   double _totalArea;
-   double _deadspace;
-
-   vector<HardClusterRecord> _clusters; 
-};
-// --------------------------------------------------------
-
-#endif
diff -druN BloBB_CompaSS_050315/BloBB/datastrst.cxx blob_compass/BloBB/datastrst.cxx
--- BloBB_CompaSS_050315/BloBB/datastrst.cxx	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/BloBB/datastrst.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,427 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "datastrst.h"
-#include "stackqueue.h"
-#include "parameters.h"
-
-#include <algorithm>
-#include <float.h>
-#include <iomanip>
-using namespace std;
-
-TreeNode::TreeNode() 
-   : x(0),
-     y(0),
-     width(0),
-     height(0),
-     sign(-1),
-     left(-1),
-     right(-1),
-     parent(-1)
-{}
-// --------------------------------------------------------
-Node::Node()
-   : sign(-1),
-     BLBlock(-1),
-     TRblblock(-1),
-     width(0),
-     height(0),
-     area(0),
-     deadspace(0)
-{}
-// --------------------------------------------------------
-Node::Node(int nSign,
-           int nBLBlock,
-           int nTRblblock,
-           double nWidth,
-           double nHeight,
-           double nArea,
-           double nDeadspace)
-           : sign(nSign),
-             BLBlock(nBLBlock),
-             TRblblock(nTRblblock),
-             width(nWidth),
-             height(nHeight),
-             area(nArea),
-             deadspace(nDeadspace)
-{}
-// --------------------------------------------------------
-Node::Node(const Node& node)
-   : sign(node.sign),
-     BLBlock(node.BLBlock),
-     TRblblock(node.TRblblock),
-     width(node.width),
-     height(node.height),
-     area(node.area),
-     deadspace(node.deadspace)
-{}
-// --------------------------------------------------------
-void Node::operator =(const Node& node)
-{
-   sign = node.sign;
-   BLBlock = node.BLBlock;
-   TRblblock = node.TRblblock;
-   width = node.width;
-   height = node.height;
-   area = node.area;
-   deadspace = node.deadspace;
-}
-// --------------------------------------------------------
-STree::STree(int blockNum,
-             double totalArea)
-   : BLOCK_NUM(blockNum),
-     TOTAL_AREA(totalArea),
-     PLUS(blockNum),
-     STAR(blockNum+1),
-     balance(0),
-     perSize(0),
-     deadspace(0)
-{}
-// --------------------------------------------------------
-void STree::push_operand(int rect,
-                         const Dimension block[][ORIENT_NUM])
-{
-   int theta = orient.top();
-   double nWidth = block[rect][theta].width;
-   double nHeight = block[rect][theta].height;
-   Node newNode(rect, rect, rect,
-                nWidth, nHeight,
-                nWidth * nHeight, 0);
-
-   expression.push(rect);
-   buffer.push(newNode);
-   balance++;
-   perSize++;                
-}
-// --------------------------------------------------------
-int STree::pop_operand()
-{
-   perSize--;
-   balance--;
-   buffer.pop();
-   return expression.pop();
-}
-// --------------------------------------------------------
-void STree::push_operator(int sign)
-{
-   expression.push(sign);
-   Node RightTop(buffer.pop());
-   Node LeftBottom(buffer.pop());
-
-   storage.push(RightTop);
-   storage.push(LeftBottom);
-
-   int newSign, newBLBlock, newTRblblock;
-   double newWidth, newHeight, newArea;
-   double addDeadspace, newDeadspace;
-   if (sign == PLUS)
-   {
-      newSign = PLUS;
-      newWidth = max(RightTop.width, LeftBottom.width);
-      newHeight = RightTop.height + LeftBottom.height;
-   }
-   else
-   {
-      newSign = STAR;
-      newWidth = RightTop.width + LeftBottom.width;
-      newHeight = max(RightTop.height, LeftBottom.height);
-   }
-   newBLBlock = LeftBottom.BLBlock;
-   newTRblblock = RightTop.BLBlock;
-   newArea = newWidth * newHeight;
-
-   addDeadspace = newArea - RightTop.area - LeftBottom.area;
-   newDeadspace = RightTop.deadspace + LeftBottom.deadspace
-                  + addDeadspace;
-
-   Node newNode(newSign, newBLBlock, newTRblblock,
-                newWidth, newHeight, newArea, newDeadspace);
-   buffer.push(newNode);
-   balance--;
-   deadspace += addDeadspace;
-}
-// --------------------------------------------------------
-void STree::pop_operator()
-{
-   Node oNode = buffer.pop();
-   Node nNode1 = storage.pop();
-   Node nNode2 = storage.pop();
-
-   balance++;
-   deadspace -= oNode.area - nNode1.area - nNode2.area;
-
-   buffer.push(nNode1);
-   buffer.push(nNode2);
-
-   expression.pop();
-}
-// --------------------------------------------------------
-SliceRecord::SliceRecord()
-   : blockNum(0),
-     area(DBL_MAX),
-     deadspace(DBL_MAX),
-     width(DBL_MAX),
-     height(DBL_MAX)
-{}
-// --------------------------------------------------------
-void SliceRecord::operator =(const STree& st)
-{
-   blockNum = st.BLOCK_NUM;
-   area = st.TOTAL_AREA + st.deadspace;
-   deadspace = st.deadspace;
-   width = st.buffer[0].width;
-   height = st.buffer[0].height;
-
-   int exprSize = st.expression.size();
-   int orientSize = st.orient.size();
-
-   for (int i = 0; i < exprSize; i++)
-      expression[i] = st.expression[i];
-
-   for (int i = 0; i < orientSize; i++)
-      orient[i] = st.orient[i];
-}
-// --------------------------------------------------------
-void outputSRecord(const SliceRecord& slice, ostream& outs)
-{
-   outs << "area: " << slice.area << endl;
-   outs << "dspace: " << slice.deadspace << endl;
-   outs << "width: " << slice.width << endl;
-   outs << "height: " << slice.height << endl;
-
-   for (int i = 0; i < 2*slice.blockNum - 1; i++)
-      if (slice.expression[i] == slice.blockNum)
-         outs << "  +";
-      else if (slice.expression[i] == slice.blockNum+1)
-         outs << "  *";
-      else
-         outs << setw(3) << slice.expression[i];
-   outs << endl;
-
-   for (int i = 0; i < slice.blockNum; i++)
-      outs << setw(3) << slice.orient[i];
-   outs << endl;
-}
-// --------------------------------------------------------
-void outputNPE(const SliceRecord& slice, ostream& outs)
-{
-   outs << "expression: ";
-   for (int i = 0; i < 2*slice.blockNum - 1; i++)
-      if (slice.expression[i] == slice.blockNum)
-         outs << "  +";
-      else if (slice.expression[i] == slice.blockNum+1)
-         outs << "  *";
-      else
-         outs << setw(3) << slice.expression[i];
-   outs << endl;
-
-   outs << "orientatn:  ";
-   int blockCount = 0;
-   for (int i = 0; i < 2*slice.blockNum - 1; i++)
-      if (slice.expression[i] < slice.blockNum) // if is a block
-	 outs << setw(3) << slice.orient[blockCount++];
-      else  // if not
-	 outs << "   "; 
-   outs << endl;
-}
-// --------------------------------------------------------
-void InitializeSlice(Dimension block[][ORIENT_NUM],
-                   STreePtr& st_ptr,
-                   int& blockNum,
-                   istream& ins)
-{
-   double area = 0;
-   ins >> blockNum;
-   if (blockNum > MAX_BLOCK_NUM)
-   {
-      cout << "ERROR: The number of blocks (" << blockNum << ") "
-	   << "exceeds maximum allowed (" << MAX_BLOCK_NUM << ")." << endl;
-      exit(1);
-   }
-
-   for (int i = 0; i < blockNum; i++)
-   {
-      double width, height;
-      ins >> width >> height;
-      for (int j = 0; j < ORIENT_NUM; j++)
-         if (j % ENG_ORIENT_CONSIDERED == 0)
-         {
-            block[i][j].width = width;
-            block[i][j].height = height;
-         }
-         else if (j % ENG_ORIENT_CONSIDERED == 1)
-         {
-            block[i][j].width = height;
-            block[i][j].height = width;
-         }
-	 else
-	 {
-	    cout << "ERROR: invalid value of \"ENG_ORIENT_CONSIDERED\" ("
-		 << ENG_ORIENT_CONSIDERED << ")." << endl;
-	    exit(1);
-	 }
-
-      area += width * height;
-   }
-   st_ptr = new STree(blockNum, area);
-}
-// --------------------------------------------------------
-void Evaluate(const Dimension block[][ORIENT_NUM],
-              const SliceRecord& sRecord,
-              FloorPlan& fp)
-{
-   const int EXPR_SIZE = 2*sRecord.blockNum - 1;
-   const int BLOCK_NUM = sRecord.blockNum;
-
-   OwnStack<int> temp_expr;
-   OwnStack<int> temp_orient;
-   TreeNode tree[MAX_SIZE];
-   int next = 0;
-
-   for (int i = 0; i < EXPR_SIZE; i++)
-      temp_expr.push(sRecord.expression[i]);
-
-   for (int i = 0; i < BLOCK_NUM; i++)
-      temp_orient.push(sRecord.orient[i]);
-
-   ConstructTree(block, BLOCK_NUM, temp_expr, temp_orient, tree, next, fp);
-   EvaluateTree(BLOCK_NUM, tree, 0, fp);
-   fp.blockNum = BLOCK_NUM;
-   fp.width = tree[0].width;
-   fp.height = tree[0].height;
-   fp.area = fp.width * fp.height;   
-}
-// --------------------------------------------------------
-int ConstructTree(const Dimension block[][ORIENT_NUM],
-                  const int BLOCK_NUM,
-                  OwnStack<int>& expression,
-                  OwnStack<int>& orient,
-                  TreeNode tree[],
-                  int& next,
-                  FloorPlan& fp)
-{
-   int sign = expression.pop();
-   int here = next;
-
-   next++;
-   tree[here].sign = sign;
-
-   if (sign >= BLOCK_NUM)
-   {
-      tree[here].right = ConstructTree(block, BLOCK_NUM, expression, 
-                                       orient, tree, next, fp);
-      tree[here].left = ConstructTree(block, BLOCK_NUM, expression,
-                                      orient, tree, next, fp);
-      tree[tree[here].right].parent = here;
-      tree[tree[here].left].parent = here;
-   }
-   else
-   {
-      tree[here].right = -1;
-      tree[here].left = -1;
-
-      int theta = orient.pop();
-      tree[here].width = block[sign][theta].width;
-      tree[here].height = block[sign][theta].height;
-
-      fp.orient[sign] = theta;
-   }
-   return here;
-}
-// --------------------------------------------------------
-void EvaluateTree(const int BLOCK_NUM,
-                  TreeNode tree[],
-                  int ptr,
-                  FloorPlan& fp)
-{
-   static const int PLUS = BLOCK_NUM;
-   static const int STAR = BLOCK_NUM+1;
-   static const int ROOT = -1;
-
-   int parent = tree[ptr].parent;
-   int parMode = (parent == -1)? ROOT : tree[parent].sign;
-   int hereMode = tree[ptr].sign;
-
-   if (parMode == PLUS)
-   {
-      tree[ptr].x = tree[parent].x;
-      tree[ptr].y = tree[parent].y + tree[parent].height;      
-   }
-   else if (parMode == STAR)
-   {
-      tree[ptr].x = tree[parent].x + tree[parent].width;
-      tree[ptr].y = tree[parent].y;      
-   }
-   else if (parMode == ROOT)
-   {
-      tree[ptr].x = 0;
-      tree[ptr].y = 0;
-   }   
-   
-   if (tree[ptr].left == -1)
-   {
-      int rect = tree[ptr].sign;
-      fp.xLoc[rect] = tree[ptr].x;
-      fp.yLoc[rect] = tree[ptr].y;      
-      return;
-   }
-
-   tree[ptr].width = 0;
-   tree[ptr].height = 0;
-
-   EvaluateTree(BLOCK_NUM, tree, tree[ptr].left, fp);
-   if (hereMode == PLUS)
-      tree[ptr].height += tree[tree[ptr].left].height;
-   else if (hereMode == STAR)
-      tree[ptr].width += tree[tree[ptr].left].width;
-
-
-   EvaluateTree(BLOCK_NUM, tree, tree[ptr].right, fp);
-   if (hereMode == PLUS)
-   {
-      tree[ptr].height += tree[tree[ptr].right].height;
-      tree[ptr].width = max(tree[tree[ptr].left].width,
-                            tree[tree[ptr].right].width);
-   }
-   else if (hereMode == STAR)
-   {
-      tree[ptr].width += tree[tree[ptr].right].width;
-      tree[ptr].height = max(tree[tree[ptr].left].height,
-                             tree[tree[ptr].right].height);
-   }   
-}
-// --------------------------------------------------------
-
-
-
-   
-
diff -druN BloBB_CompaSS_050315/BloBB/datastrst.h blob_compass/BloBB/datastrst.h
--- BloBB_CompaSS_050315/BloBB/datastrst.h	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/BloBB/datastrst.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,156 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef DATASTRST_H
-#define DATASTRST_H
-
-#include "stackqueue.h"
-#include "datastr.h"
-
-class STree;
-typedef STree* STreePtr;
-
-// --------------------------------------------------------
-class TreeNode
-{
-public:
-   TreeNode();
-
-   double x;
-   double y;
-   double width;
-   double height;
-
-   int sign;
-   int left;
-   int right;
-   int parent;
-};
-// --------------------------------------------------------
-class Node
-{
-public:
-   Node();
-   Node(int nSize, int nBLBlock, int nTRblblock,
-        double nWidth, double nHeight, double nArea,
-        double nDeadspace);
-   Node(const Node& node);
-   void operator =(const Node& node);
-
-   int sign;
-   int BLBlock;
-   int TRblblock;
-   double width;
-   double height;
-   double area;
-   double deadspace;
-};
-// --------------------------------------------------------
-class STree
-{
-public:
-   STree(int blockNum, double totalArea);
-
-   OwnStack<int> expression;
-   OwnStack<int> orient;
-
-   OwnStack<Node> buffer;
-   OwnStack<Node> storage;
-
-   const int BLOCK_NUM;
-   const double TOTAL_AREA;
-   const int PLUS;
-   const int STAR;
-   int balance;
-   int perSize;
-   double deadspace;
-
-   void push_orient(int theta)
-   {  orient.push(theta);  }
-
-   void pop_orient()
-   {  orient.pop();  }
-
-   void push_operand(int rect, const Dimension block[][ORIENT_NUM]);
-   int pop_operand();
-
-   void push_operator(int sign);
-   inline bool can_push_operator(int sign)
-   {  return ((balance > 1) && (sign != expression.top())); }
-
-   void pop_operator();
-
-private: 
-   STree(const STree&);
-   STree();
-};                              
-// --------------------------------------------------------
-class SliceRecord
-{
-public: 
-   SliceRecord();
-
-   int blockNum;
-   double area;
-   double deadspace;
-   double width;
-   double height;
-
-   int expression[MAX_SIZE];
-   int orient[MAX_SIZE];
-
-   void operator =(const STree& st);
-
-private:
-   SliceRecord(const SliceRecord&);
-};
-void outputSRecord(const SliceRecord& slice, ostream& outs);
-void outputNPE(const SliceRecord& slice, ostream& outs);
-// --------------------------------------------------------
-void InitializeSlice(Dimension block[][ORIENT_NUM],
-                     STreePtr& st_ptr,
-                     int& blockNum,
-                     istream& ins);
-                     
-void Evaluate(const Dimension block[][ORIENT_NUM],
-              const SliceRecord& sRecord,
-              FloorPlan& fp);
-
-int ConstructTree(const Dimension block[][ORIENT_NUM],
-                  const int BLOCK_NUM,
-                  OwnStack<int>& expression,
-                  OwnStack<int>& orient,
-                  TreeNode tree[],
-                  int& next,
-                  FloorPlan& fp);
-void EvaluateTree(const int BLOCK_NUM, TreeNode tree[],
-                  int ptr, FloorPlan& fp);
-#endif
diff -druN BloBB_CompaSS_050315/BloBB/dummy blob_compass/BloBB/dummy
--- BloBB_CompaSS_050315/BloBB/dummy	2005-03-14 22:12:34.000000000 -0800
+++ blob_compass/BloBB/dummy	1969-12-31 16:00:00.000000000 -0800
@@ -1,74 +0,0 @@
-1183.000
-1057.000
-33
-336.000 133.000
-119.000 378.000
-161.000 140.000
-119.000 49.000
-175.000 119.000
-406.000 140.000
-497.000 140.000
-196.000 119.000
-119.000 294.000
-161.000 119.000
-119.000 266.000
-119.000 336.000
-119.000 126.000
-182.000 371.000
-182.000 203.000
-182.000 203.000
-119.000 84.000
-133.000 294.000
-350.000 182.000
-140.000 315.000
-133.000 315.000
-560.000 133.000
-140.000 133.000
-175.000 133.000
-231.000 133.000
-133.000 315.000
-182.000 98.000
-210.000 210.000
-126.000 378.000
-182.000 119.000
-119.000 119.000
-357.000 119.000
-119.000 84.000
-
-0.000 0.000
-0.000 133.000
-637.000 0.000
-0.000 763.000
-819.000 0.000
-238.000 763.000
-238.000 903.000
-819.000 119.000
-735.000 763.000
-1015.000 119.000
-854.000 763.000
-119.000 133.000
-119.000 763.000
-637.000 371.000
-819.000 371.000
-1001.000 371.000
-0.000 812.000
-364.000 0.000
-819.000 574.000
-364.000 294.000
-504.000 0.000
-0.000 630.000
-637.000 238.000
-777.000 238.000
-952.000 238.000
-504.000 315.000
-637.000 140.000
-973.000 763.000
-238.000 133.000
-994.000 0.000
-119.000 889.000
-0.000 511.000
-0.000 896.000
-
-
-
-0 1 11 * 28 * + 31 + 17 19 + * 20 25 + * 21 + 2 26 + 4 29 * 7 9 * + * 22 23 * 24 * + 13 14 15 * 18 + * + * 3 16 + 32 + 12 30 + * 5 6 + * 8 10 * * 27 * + 
diff -druN BloBB_CompaSS_050315/BloBB/enginehierst.cxx blob_compass/BloBB/enginehierst.cxx
--- BloBB_CompaSS_050315/BloBB/enginehierst.cxx	2005-03-14 22:08:49.000000000 -0800
+++ blob_compass/BloBB/enginehierst.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,416 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "enginehierst.h"
-#include "datastrst.h"
-#include "boundst.h"
-#include "stackqueue.h"
-#include "datastrhierst.h"
-#include "parameters.h"
-
-#include <iomanip>
-#include <cmath>
-#include <queue>
-#include <algorithm>
-#include <float.h>
-using namespace std;
-
-// ========================================================
-int HIER_CLUSTER_BASE = HIER_UNDEFINED_SENTINEL;
-bool HIER_USE_AR = true;
-double HIER_AR = HIER_UNDEFINED_SENTINEL;
-double HIER_AR_INCRE = HIER_UNDEFINED_SENTINEL;
-double HIER_BEST_AREA_INCRE = HIER_UNDEFINED_SENTINEL;
-double HIER_CLUSTER_AREA_DEV = HIER_UNDEFINED_SENTINEL;
-double HIER_SIDE_RESOLUTION = HIER_UNDEFINED_SENTINEL;
-bool HIER_COMPACT = true;
-bool HIER_OPTOPR = true;
-// ========================================================
-void FindSlice(const Dimension block[][ORIENT_NUM],
-               const bool same[][MAX_BLOCK_NUM],
-               const int blkBefore[],
-               STree& st,
-               OwnQueue<int>& bContainer,
-               SliceRecord& best)
-{
-   static const int PLUS = st.BLOCK_NUM;
-   static const int STAR = st.BLOCK_NUM + 1;
-
-   const double MAX_LENGTH = (HIER_USE_AR)? 
-      sqrt(best.area * HIER_AR) : DBL_MAX; 
-   
-   int qSize = bContainer.size();
-   if ((qSize == 0) && (st.balance == 1))
-   {
-      if (st.deadspace < best.deadspace)
-         best = st;
-      return;
-   }
-
-   for (int i = 0; i < qSize; i++)
-   {
-      int rect = bContainer.dequeue();
-      for (int k = 0; k < ENG_ORIENT_CONSIDERED; k++)
-      {
-         st.push_orient(k);
-         st.push_operand(rect, block);
-         
-         if (blockSym(st))
-            if (sameBlockBound(same, blkBefore, st))
-               if (st.deadspace + extDeadspace(st) < best.deadspace)
-                  FindSlice(block, same, blkBefore, 
-                            st, bContainer, best); 
-         st.pop_operand();
-         st.pop_orient();
-      }
-      bContainer.enqueue(rect);
-   }
-
-   for (int j = PLUS; j <= STAR; j++)
-      if (st.can_push_operator(j))
-      {
-         st.push_operator(j);
-
-         if (st.deadspace < best.deadspace)
-            if (abutSym(st))
-               if (st.deadspace + extDeadspace(st) < best.deadspace)
-                  if (st.buffer.top().width < MAX_LENGTH &&
-                      st.buffer.top().height < MAX_LENGTH) 
-                     FindSlice(block, same, blkBefore, 
-                               st, bContainer, best); 
-
-         st.pop_operator();
-      }
-}
-// ========================================================
-void CoreEngine(int blockNum,
-                vector<ClusterSet>& clusterSets,   // full --> empty
-                vector<Cluster>& clusters)         // empty --> full
-{
-   static const int BLOCK_NUM = blockNum; // TOTAL number of blks
-   static const double ORIG_HIER_AR = HIER_AR;
-
-   int clusterSetNum = clusterSets.size();
-   Dimension block[MAX_SIZE][ORIENT_NUM];    // <-|
-   bool same[MAX_BLOCK_NUM][MAX_BLOCK_NUM];  //   |-global info
-   int blkBefore[MAX_SIZE];                  // <-| for FindSlice
-
-   for (int i = 0; i < clusterSetNum; i++)
-   {
-      int clusterNum = clusterSets[i].size();
-      double grandArea = 0;
-      OwnQueue<int> bContainer;
-
-      // each supermodule is identified by its index
-      // in its cluster set
-      SetGlobalInfo(clusterSets[i], block, same, blkBefore, 
-                    grandArea, bContainer);      
-      
-      STree st(BLOCK_NUM, grandArea);
-      SliceRecord best;      
-      
-      int firstBlock = bContainer.dequeue();
-      best.area = st.TOTAL_AREA;
-      best.deadspace = 0;
-      HIER_AR = ORIG_HIER_AR;
-      while (best.blockNum == 0)
-      {
-         best.area *= HIER_BEST_AREA_INCRE;
-         best.deadspace = best.area - st.TOTAL_AREA;
-
-         st.push_orient(0);
-         st.push_operand(firstBlock, block);
-
-         FindSlice(block, same, blkBefore, st, bContainer, best);
-
-         st.pop_operand();
-         st.pop_orient();
-         HIER_AR *= HIER_AR_INCRE; 
-      }
-      
-      Cluster merged(BLOCK_NUM);
-      best.blockNum = clusterNum;   // <--"correct" best.blockNum
-      merged.initialize(best, clusterSets[i]);
-
-      clusters.push_back(merged);
-   }
-
-   for (int i = 0; i < clusterSetNum; i++)
-      clusterSets.pop_back();
-}
-// --------------------------------------------------------
-void SetGlobalInfo(const ClusterSet& clusterSet,
-                   Dimension block[][ORIENT_NUM],
-                   bool same[][MAX_BLOCK_NUM],
-                   int blkBefore[],
-                   double& grandArea,
-                   OwnQueue<int>& bContainer)
-{
-   CompareSidesType CompareSides = (ENG_ORIENT_CONSIDERED == 1)?
-      fixed_CompareSides : free_CompareSides;
-   
-   int clusterNum = clusterSet.size();   
-   for (int j = 0; j < clusterNum; j++)
-   {
-      int currBlk = j;
-      double width = clusterSet[j].width;
-      double height = clusterSet[j].height;
-
-      // set block[][ORIENT_NUM]
-      for (int k = 0; k < ORIENT_NUM; k++)
-         if (k % ENG_ORIENT_CONSIDERED == 0)
-         {
-            block[currBlk][k].width = width;
-            block[currBlk][k].height = height;
-         }
-         else if (k % ENG_ORIENT_CONSIDERED == 1)
-         {
-            block[currBlk][k].width = height;
-            block[currBlk][k].height = width;
-         }
-	 else
-	 {
-	    cout << "ERROR: invalid value for \"ENG_ORIENT_CONSIDERED\" ("
-		 << ENG_ORIENT_CONSIDERED << ")." << endl;
-	    exit(1);
-	 }
-
-      // set blkBefore[] and same[][MAX_BLOCK_NUM]
-      blkBefore[currBlk] = 0;
-      for (int k = 0; k < j; k++)
-      {
-         int compBlk = k;
-         if (CompareSides(block, currBlk, compBlk))
-         {
-            same[compBlk][currBlk] = true;
-            same[currBlk][compBlk] = true;
-            blkBefore[currBlk]++;
-         }
-         else
-         {
-            same[compBlk][currBlk] = false;
-            same[currBlk][compBlk] = false;
-         }        
-      }
-      same[currBlk][currBlk] = true;
-      grandArea += width * height;
-      bContainer.enqueue(currBlk);
-   }  
-}
-// --------------------------------------------------------
-bool free_CompareSides(const Dimension block[][ORIENT_NUM],
-		       int currBlk,
-		       int compBlk)
-{
-   double min1 = min(block[currBlk][0].width, block[currBlk][0].height);
-   double max1 = max(block[currBlk][0].width, block[currBlk][0].height);
-
-   double min2 = min(block[compBlk][0].width, block[compBlk][0].height);
-   double max2 = max(block[compBlk][0].width, block[compBlk][0].height);
-
-   return (pow(min(min1, min2) / max(min1, min2), 2) 
-         + pow(min(max1, max2) / max(max1, max2), 2)) 
-         >= HIER_SIDE_RESOLUTION; // play with this figure
-}
-// --------------------------------------------------------
-bool fixed_CompareSides(const Dimension block[][ORIENT_NUM],
-			int currBlk,
-			int compBlk)
-{
-   double min1 = block[currBlk][0].width;
-   double max1 = block[currBlk][0].height;
-
-   double min2 = block[compBlk][0].width;
-   double max2 = block[compBlk][0].height;
-
-   return (pow(min(min1, min2) / max(min1, min2), 2) 
-         + pow(min(max1, max2) / max(max1, max2), 2)) 
-         >= HIER_SIDE_RESOLUTION; // play with this figure
-}
-// ========================================================
-void GroupClusterSets(vector<Cluster>& clusters,       // full -> empty
-                      vector<ClusterSet>& clusterSets) // empty -> full  
-{
-   // priority_queue<DistanceInfo> distInfoPQ;
-   // BuildPriorityQueue(clusters, distInfoPQ);
-   vector<DistanceInfo> distInfoVec;
-   BuildSortedVector(clusters, distInfoVec);
-
-   const int clusterNum = clusters.size();
-   int clusterSetNum = getClusterSetNum(clusterNum);   // <-- may be imposs   
-   const int maxClusterSize = HIER_CLUSTER_BASE + 1;
-   const double maxClusterArea = (clusterSetNum <= HIER_CLUSTER_BASE)?
-      DBL_MAX : getMaxArea(clusters);
-   
-   // ----- initialize tools -----
-   vector<int> identifier;
-   vector<int> setSize;
-   vector<double> setArea;
-   for (int i = 0; i < clusterNum; i++)
-   {
-      identifier.push_back(i);
-      setSize.push_back(1);
-      setArea.push_back(clusters[i].width * clusters[i].height);
-   }
-
-   // ----- assign sets -----
-   int clusterSetCount = clusterNum;
-   while ((clusterSetCount > clusterSetNum) &&
-          !distInfoVec.empty()) // !distInfoPQ.empty())
-   {
-      // DistanceInfo closest(distInfoPQ.top());
-      DistanceInfo closest(distInfoVec.back());
-      int block1 = closest.blockOne;
-      int block2 = closest.blockTwo;
-      int blockOneID = min(identifier[block1], identifier[block2]);
-      int blockTwoID = max(identifier[block1], identifier[block2]);
-      double setOneBLBlockArea = 
-         clusters[blockOneID].width * clusters[blockOneID].height;
-
-      if ((blockOneID != blockTwoID) &&
-          (setSize[blockOneID] + setSize[blockTwoID] <= maxClusterSize) &&
-          (setArea[blockOneID] + setArea[blockTwoID] <= maxClusterArea))
-      {
-         for (int i = 0; i < clusterNum; i++)         
-            if (identifier[i] == blockTwoID)
-               identifier[i] = blockOneID;                                 
-               
-         setSize[blockOneID] += setSize[blockTwoID];
-         setArea[blockOneID] += setSize[blockTwoID] * setOneBLBlockArea;
-         clusterSetCount--;
-      }    
-      // distInfoPQ.pop();
-      distInfoVec.pop_back();
-   }
-   clusterSetNum = clusterSetCount; // clusterSetNum >= intended
-
-   // ----- in case if clusterSetNum == clusterNum -----
-   if (clusterSetNum == clusterNum)
-   {
-      identifier[1] = 0;
-      setSize[0] = 2;
-      setArea[0] += setArea[1];
-      clusterSetNum--;
-   }
-
-   // ----- gather sets -----
-   for (int i = 0; i < clusterSetNum; i++)
-   {
-      int ptr = 0;
-      while (identifier[ptr] == -1)
-         ptr++;
-      
-      int setIndex = ptr;
-      ClusterSet temp;
-      clusterSets.push_back(temp);
-
-      for (int j = ptr; j < clusterNum; j++)
-         if (identifier[j] == setIndex)
-         {
-            identifier[j] = -1;
-            clusterSets[i].push_back(clusters[j]);
-         }     
-   }
-
-   // ----- empty clusters -----
-   for (int i = 0; i < clusterNum; i++)
-      clusters.pop_back();
-}
-// --------------------------------------------------------
-void BuildSortedVector(const vector<Cluster>& clusters,
-                       vector<DistanceInfo>& distInfoVec)
-{
-   getPointsType getPoints = (ENG_ORIENT_CONSIDERED == 1)?
-      fixed_getPoints : free_getPoints;
-   
-   int clusterNum = clusters.size();
-   for (int i = 1; i < clusterNum; i++)
-      for (int j = 0; j+i < clusterNum; j++)
-      {
-         if (distInfoVec.size() >= HIER_SORT_VEC_MAX_SIZE) 
-            break;
-
-         DistanceInfo dInfo;
-         dInfo.dist = getPoints(clusters[j], clusters[j+i]);
-         dInfo.blockOne = j;
-         dInfo.blockTwo = j+i;
-
-         distInfoVec.push_back(dInfo);
-      }
-   sort(distInfoVec.begin(), distInfoVec.end());
-}
-// --------------------------------------------------------
-double getMaxArea(const vector<Cluster>& clusters)
-{
-   double totalArea = 0;
-   int clusterNum = clusters.size();
-   for (int i = 0; i < clusterNum; i++)
-      totalArea += clusters[i].width * clusters[i].height;
-
-   return (totalArea / clusterNum) * HIER_CLUSTER_AREA_DEV;   
-}
-// --------------------------------------------------------
-double free_getPoints(const Cluster& c1,
-		      const Cluster& c2)
-{
-   double min1 = min(c1.width, c1.height);
-   double max1 = max(c1.width, c1.height);
-   double min2 = min(c2.width, c2.height);
-   double max2 = max(c2.width, c2.height);
-
-   return pow(min(min1, min2) / max(min1, min2), 10) +
-          pow(min(max1, max2) / max(max1, max2), 10);   
-}
-// --------------------------------------------------------
-double fixed_getPoints(const Cluster& c1,
-		       const Cluster& c2)
-{
-   double min1 = c1.width;
-   double max1 = c1.height;
-   double min2 = c2.width;
-   double max2 = c2.height;
-
-   return pow(min(min1, min2) / max(min1, min2), 10) +
-          pow(min(max1, max2) / max(max1, max2), 10);   
-}
-// --------------------------------------------------------
-int getClusterSetNum(int clusterNum)
-{
-   double cSetNum = clusterNum;
-   int index = 0;
-   while (cSetNum > HIER_CLUSTER_BASE)
-   {
-      index++;
-      cSetNum = cSetNum / HIER_CLUSTER_BASE;
-   }
-   return int(pow(double(HIER_CLUSTER_BASE), double(index)));
-}
-// --------------------------------------------------------
diff -druN BloBB_CompaSS_050315/BloBB/enginehierst.h blob_compass/BloBB/enginehierst.h
--- BloBB_CompaSS_050315/BloBB/enginehierst.h	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/BloBB/enginehierst.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,85 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef ENGINEHIERST_H
-#define ENGINEHIERST_H
-
-#include "datastrst.h"
-#include "boundst.h"
-#include "stackqueue.h"
-#include "datastrhierst.h"
-
-#include <vector>
-#include <queue>
-using namespace std;
-
-typedef bool (*CompareSidesType)(const Dimension[][ORIENT_NUM],
-				 int, int);
-typedef double (*getPointsType)(const Cluster&, const Cluster&);
-
-// ---------------------------------------------------------
-void FindSlice(const Dimension block[][ORIENT_NUM],
-               const bool same[][MAX_BLOCK_NUM],
-               const int blkBefore[],
-               STree& st,
-               OwnQueue<int>& bContainer,
-               SliceRecord& best);
-// ========================================================
-void CoreEngine(int blockNum,
-                vector<ClusterSet>& clusterSets,
-                vector<Cluster>& clusters);  // assumed empty
-// --------------------------------------------------------
-void SetGlobalInfo(const ClusterSet& clusterSet,
-                   Dimension block[][ORIENT_NUM],
-                   bool same[][MAX_BLOCK_NUM],
-                   int blkBefore[],
-                   double& grandArea,
-                   OwnQueue<int>& bContainer);
-// --------------------------------------------------------
-bool free_CompareSides(const Dimension block[][ORIENT_NUM],
-		       int currBlk, int compBlk);
-bool fixed_CompareSides(const Dimension block[][ORIENT_NUM],
-			int currBlk, int compBlk);
-// ========================================================
-void GroupClusterSets(vector<Cluster>& clusters,
-                      vector<ClusterSet>& clusterSets);
-// --------------------------------------------------------
-void BuildSortedVector(const vector<Cluster>& clusters, 
-                       vector<DistanceInfo>& distInfoVec);
-// --------------------------------------------------------
-double getMaxArea(const vector<Cluster>& clusters);
-// --------------------------------------------------------
-double fixed_getPoints(const Cluster& c1, const Cluster& c2);
-double free_getPoints(const Cluster& cl, const Cluster& c2);
-// --------------------------------------------------------
-int getClusterSetNum(int clusterNum);
-// ========================================================
-#endif 
diff -druN BloBB_CompaSS_050315/BloBB/enginest.cxx blob_compass/BloBB/enginest.cxx
--- BloBB_CompaSS_050315/BloBB/enginest.cxx	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/BloBB/enginest.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,237 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "enginest.h"
-#include "stackqueue.h"
-#include "datastrst.h"
-#include "boundst.h"
-
-#include "parameters.h"
-#include "utilities.h"
-
-#include <iostream>
-#include <fstream>
-#include <sstream>
-#include <iomanip>
-#include <cmath>
-#include <queue>
-#include <algorithm>
-#include <float.h>
-using namespace std;
-
-// ========================================================
-void FindSlice(const OperandBoundType operandBound,
-               const OperatorBoundType operatorBound,
-               const OperatorBoundType compare,
-               const Dimension block[][ORIENT_NUM],
-               const bool same[][MAX_BLOCK_NUM],
-               const int blkBefore[],
-               STree& st,
-               OwnQueue<int>& bContainer,
-               SliceRecord& best)
-{
-   static const int PLUS = st.BLOCK_NUM;
-   static const int STAR = st.BLOCK_NUM + 1;
-
-   int qSize = bContainer.size();
-   if ((qSize == 0) && (st.balance == 1))
-   {
-      if (compare(st, best))
-      {
-	 if (st.deadspace < best.deadspace)
-	    counter[0][1] = counter[0][0];
-	 
-         best = st;
-	 if (INF_FN_PREFIX != "")
-	 {
-	    ofstream outs;
-	    stringstream filename;
-	    FloorPlan fp;
-	    filename << INF_FN_PREFIX << counter[0][0] << INF_FN_SUFFIX;
-	    
-	    outs.open(filename.str().c_str());
-	    Evaluate(block, best, fp);
-	    outputfp(block, fp, outs);
-	    outs.close();
-	 }
-	 
-	 if (INF_SHOW_INTERMEDIATES)
-	 {
-	    cout.setf(ios::fixed);
-	    cout.precision(2);
-	    cout << "[" << counter[0][0] << "] "  
-		 << "area: " << setw(15) << best.area << " (" 
-		 << ((best.deadspace / st.TOTAL_AREA) * 100) << "%) "
-		 << setw(10) << getTotalTime() << "s" << endl;
-	 }
-	 counter[0][0]++;
-      }
-      return;
-   }
-
-   for (int i = 0; i < qSize; i++)
-   {
-      int rect = bContainer.dequeue();
-      for (int k = 0; k < ENG_ORIENT_CONSIDERED; k++)
-      {
-         st.push_orient(k);
-         st.push_operand(rect, block);
-
-         counter[st.expression.size()][0]++;
-	 counter[st.expression.size()][1]++;
-         if (operandBound(same, blkBefore, st, best))
-         {
-            counter[st.expression.size()][2]++;
-            FindSlice(operandBound, operatorBound, compare,
-                      block, same, blkBefore, 
-                      st, bContainer, best); 
-         }
-         st.pop_operand();
-         st.pop_orient();
-      }
-      bContainer.enqueue(rect);
-   }
-
-   for (int j = PLUS; j <= STAR; j++)
-      if (st.can_push_operator(j))
-      {
-         st.push_operator(j);
-
-	 counter[st.expression.size()][0]++;
-         counter[st.expression.size()][3]++;
-         if (operatorBound(st, best))
-         {
-            counter[st.expression.size()][4]++;
-            FindSlice(operandBound, operatorBound, compare,
-                      block, same, blkBefore, 
-                      st, bContainer, best); 
-         }
-         st.pop_operator();
-      }
-}
-// ========================================================
-bool BranchBoundOperandBound(const bool same[][MAX_BLOCK_NUM],
-                             const int blkBefore[],
-                             const STree& st,
-                             const SliceRecord& best)
-{
-   if (!blockSym(st))
-      return false;
-   if (!sameBlockBound(same, blkBefore, st))
-      return false;
-   if (st.deadspace + extDeadspace(st) >= best.deadspace)
-      return false;
-   return true;
-}
-// --------------------------------------------------------
-bool BacktrackOperandBound(const bool same[][MAX_BLOCK_NUM],
-                           const int blkBefore[],
-                           const STree& st,
-                           const SliceRecord& best)
-{
-   if (!blockSym(st))
-      return false;
-   if (!sameBlockBound(same, blkBefore, st))
-      return false;
-   if (max(st.deadspace + extDeadspace(st), BT_MIN_DEADSPACE) >= best.deadspace)
-      return false;
-   return true;
-}
-// --------------------------------------------------------
-bool EnumerateOperandBound(const bool same[][MAX_BLOCK_NUM],
-                           const int blkBefore[],
-                           const STree& st,
-                           const SliceRecord& best)
-{
-   if (!blockSym(st))
-      return false;
-   if (!sameBlockBound(same, blkBefore, st))
-      return false;
-   if (st.deadspace + extDeadspace(st) > best.deadspace)
-      return false;
-   return true;
-}
-// ========================================================
-bool BranchBoundOperatorBound(const STree& st,
-                              const SliceRecord& best)
-{
-   if (st.deadspace >= best.deadspace)
-      return false;
-   if (!abutSym(st))
-      return false;
-   if (st.deadspace + extDeadspace(st) >= best.deadspace)
-      return false;
-   return true;
-}
-// --------------------------------------------------------
-bool BacktrackOperatorBound(const STree& st,
-                            const SliceRecord& best)
-{
-   if (max(st.deadspace, BT_MIN_DEADSPACE) >= best.deadspace)
-      return false;
-   if (!abutSym(st))
-      return false;
-   if (max(st.deadspace + extDeadspace(st), BT_MIN_DEADSPACE)
-       >= best.deadspace)
-      return false;
-   return true;
-}
-// --------------------------------------------------------
-bool EnumerateOperatorBound(const STree& st,
-                            const SliceRecord& best)
-{
-   if (st.deadspace > best.deadspace)
-      return false;
-   if (!abutSym(st))
-      return false;
-   if (st.deadspace + extDeadspace(st) > best.deadspace)
-      return false;
-   return true;
-}
-// ========================================================
-bool BranchBoundCompare(const STree& st,
-                        const SliceRecord& best)
-{
-   return (st.deadspace < best.deadspace);
-}
-// --------------------------------------------------------
-bool BacktrackCompare(const STree& st,
-                      const SliceRecord& best)
-{
-   return (st.deadspace < best.deadspace);
-}
-// --------------------------------------------------------
-bool EnumerateCompare(const STree& st,
-                      const SliceRecord& best)
-{
-   return (st.deadspace <= best.deadspace);
-}
-// ========================================================
diff -druN BloBB_CompaSS_050315/BloBB/enginest.h blob_compass/BloBB/enginest.h
--- BloBB_CompaSS_050315/BloBB/enginest.h	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/BloBB/enginest.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,88 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef ENGINEST_H
-#define ENGINEST_H
-
-#include "datastrst.h"
-#include "boundst.h"
-#include "stackqueue.h"
-
-#include <vector>
-#include <queue>
-using namespace std;
-
-#define STATISTICS
-
-typedef bool (*OperandBoundType)(const bool[][MAX_BLOCK_NUM], const int[],
-				 const STree&, const SliceRecord&);
-typedef bool (*OperatorBoundType)(const STree&, const SliceRecord&);
-
-// ========================================================
-void FindSlice(const OperandBoundType operandBound,
-	       const OperatorBoundType operatorBound,
-	       const OperatorBoundType compare,
-	       const Dimension block[][ORIENT_NUM],
-               const bool same[][MAX_BLOCK_NUM],
-               const int blkBefore[],
-               STree& st,
-               OwnQueue<int>& bContainer,
-               SliceRecord& best);
-// ========================================================
-bool BranchBoundOperandBound(const bool same[][MAX_BLOCK_NUM],
-			     const int blkBefore[],
-			     const STree& st,
-			     const SliceRecord& best);
-bool BacktrackOperandBound(const bool same[][MAX_BLOCK_NUM],
-			   const int blkBefore[],
-			   const STree& st,
-			   const SliceRecord& best);
-bool EnumerateOperandBound(const bool same[][MAX_BLOCK_NUM],
-			   const int blkBefore[],
-			   const STree& st,
-			   const SliceRecord& best);
-// ========================================================
-bool BranchBoundOperatorBound(const STree& st,
-			      const SliceRecord& best);
-bool BacktrackOperatorBound(const STree& st,
-			    const SliceRecord& best);
-bool EnumerateOperatorBound(const STree& st,
-			    const SliceRecord& best);
-// ========================================================
-bool BranchBoundCompare(const STree& st,
-			const SliceRecord& best);
-bool BacktrackCompare(const STree& st,
-		      const SliceRecord& best);
-bool EnumerateCompare(const STree& st,
-		      const SliceRecord& best);
-// ========================================================
-
-#endif // end ENGINEST_H
diff -druN BloBB_CompaSS_050315/BloBB/expected_040512.out blob_compass/BloBB/expected_040512.out
--- BloBB_CompaSS_050315/BloBB/expected_040512.out	2004-07-04 23:00:42.000000000 -0700
+++ blob_compass/BloBB/expected_040512.out	1969-12-31 16:00:00.000000000 -0800
@@ -1,384 +0,0 @@
------ Running source/TESTS/MCNCami33.txt ...
-WARNING: The type of floorplan is not specified, 
-         default option "--slicing" is used.
-WARNING: The type of algorithm is not specified, 
-         default option "--hierarchical" is used.
-===== BloBB (Block-packing with Branch-and-bound) =====
-floorplanType: --slicing
-algorithmType: --hierarchical
-block orientn: --free-orient
-EXTRA: cluster base=4
-EXTRA: aspect ratio tolerance=1.50
-EXTRA: asepct ratio increment=1.50
-EXTRA: dead space increment=1.05
-EXTRA: cluster area deviation=2.00
-EXTRA: side resolution=1.90
-EXTRA: optimize operators in the Polish expression? Yes
-EXTRA: compact? No
-=======================================================
-===== after InitializeCluster =====
-===== Grouping 33 clusters... 
-===== Packing into 22 clusters... 
-
-totalArea:  1156449.00 deadspace:    25725.00 (2.22%) time:  0.01
-
-===== Grouping 22 clusters... 
-===== Packing into 16 clusters... 
-
-totalArea:  1156449.00 deadspace:    34496.00 (2.98%) time:  0.01
-
-===== Grouping 16 clusters... 
-===== Packing into 4 clusters... 
-
-totalArea:  1156449.00 deadspace:   142345.00 (12.31%) time:  0.02
-
-===== Grouping 4 clusters... 
-===== Packing into 1 clusters... 
-
-totalArea:  1156449.00 deadspace:   277291.00 (23.98%) time:  0.02
-
-width:  1463.00
-height: 980.00
-total area:  1433740.00
-block area:  1156449.00
-dead space:   277291.00 (23.98%)
-
-area usage   (wrt. total area): 80.66%
-dead space % (wrt. total area): 19.34%
----------------------------
-
-Optimizing operators in the Polish expression...
-After operator optimization,
-width:  1463.00
-height: 980.00
-total area:  1433740.00
-block area:  1156449.00
-dead space:   277291.00 (23.98%)
-
-area usage   (wrt. total area): 80.66%
-dead space % (wrt. total area): 19.34%
----------------------------
-
-Output successfully written to dummy_output
-
-===== Thanks for using BloBB =====
------ Running source/TESTS/MCNCami49_10.txt ...
-WARNING: The type of floorplan is not specified, 
-         default option "--slicing" is used.
-WARNING: The type of algorithm is not specified, 
-         default option "--hierarchical" is used.
-===== BloBB (Block-packing with Branch-and-bound) =====
-floorplanType: --slicing
-algorithmType: --hierarchical
-block orientn: --free-orient
-EXTRA: cluster base=4
-EXTRA: aspect ratio tolerance=1.50
-EXTRA: asepct ratio increment=1.50
-EXTRA: dead space increment=1.05
-EXTRA: cluster area deviation=2.00
-EXTRA: side resolution=1.90
-EXTRA: optimize operators in the Polish expression? Yes
-EXTRA: compact? No
-=======================================================
-===== after InitializeCluster =====
-===== Grouping 490 clusters... 
-===== Packing into 256 clusters... 
-
-totalArea:  3544542.40 deadspace:      335.16 (0.01%) time:  0.12
-
-===== Grouping 256 clusters... 
-===== Packing into 140 clusters... 
-
-totalArea:  3544542.40 deadspace:    17171.56 (0.48%) time:  0.16
-
-===== Grouping 140 clusters... 
-===== Packing into 84 clusters... 
-
-totalArea:  3544542.40 deadspace:    31473.68 (0.89%) time:  0.18
-
-===== Grouping 84 clusters... 
-===== Packing into 64 clusters... 
-
-totalArea:  3544542.40 deadspace:    39245.08 (1.11%) time:  0.19
-
-===== Grouping 64 clusters... 
-===== Packing into 40 clusters... 
-
-totalArea:  3544542.40 deadspace:    57806.28 (1.63%) time:  0.19
-
-===== Grouping 40 clusters... 
-===== Packing into 29 clusters... 
-
-totalArea:  3544542.40 deadspace:    96139.96 (2.71%) time:  0.20
-
-===== Grouping 29 clusters... 
-===== Packing into 20 clusters... 
-
-totalArea:  3544542.40 deadspace:   102982.32 (2.91%) time:  0.20
-
-===== Grouping 20 clusters... 
-===== Packing into 16 clusters... 
-
-totalArea:  3544542.40 deadspace:   117854.80 (3.32%) time:  0.20
-
-===== Grouping 16 clusters... 
-===== Packing into 4 clusters... 
-
-totalArea:  3544542.40 deadspace:   327821.76 (9.25%) time:  0.21
-
-===== Grouping 4 clusters... 
-===== Packing into 1 clusters... 
-
-totalArea:  3544542.40 deadspace:   927374.00 (26.16%) time:  0.21
-
-width:  848.40
-height: 5271.00
-total area:  4471916.40
-block area:  3544542.40
-dead space:   927374.00 (26.16%)
-
-area usage   (wrt. total area): 79.26%
-dead space % (wrt. total area): 20.74%
----------------------------
-
-Optimizing operators in the Polish expression...
-After operator optimization,
-width:  848.40
-height: 5258.40
-total area:  4461226.56
-block area:  3544542.40
-dead space:   916684.16 (25.86%)
-
-area usage   (wrt. total area): 79.45%
-dead space % (wrt. total area): 20.55%
----------------------------
-
-Output successfully written to dummy_output
-
-===== Thanks for using BloBB =====
------ Running source/TESTS/MCNCami49.txt ...
-WARNING: The type of floorplan is not specified, 
-         default option "--slicing" is used.
-WARNING: The type of algorithm is not specified, 
-         default option "--hierarchical" is used.
-===== BloBB (Block-packing with Branch-and-bound) =====
-floorplanType: --slicing
-algorithmType: --hierarchical
-block orientn: --free-orient
-EXTRA: cluster base=4
-EXTRA: aspect ratio tolerance=1.50
-EXTRA: asepct ratio increment=1.50
-EXTRA: dead space increment=1.05
-EXTRA: cluster area deviation=2.00
-EXTRA: side resolution=1.90
-EXTRA: optimize operators in the Polish expression? Yes
-EXTRA: compact? No
-=======================================================
-===== after InitializeCluster =====
-===== Grouping 49 clusters... 
-===== Packing into 22 clusters... 
-
-totalArea: 35445424.00 deadspace:   450212.00 (1.27%) time:  0.01
-
-===== Grouping 22 clusters... 
-===== Packing into 16 clusters... 
-
-totalArea: 35445424.00 deadspace:   863576.00 (2.44%) time:  0.01
-
-===== Grouping 16 clusters... 
-===== Packing into 4 clusters... 
-
-totalArea: 35445424.00 deadspace:  3870804.00 (10.92%) time:  0.03
-
-===== Grouping 4 clusters... 
-===== Packing into 1 clusters... 
-
-totalArea: 35445424.00 deadspace:  6222608.00 (17.56%) time:  0.03
-
-width:  3612.00
-height: 11536.00
-total area: 41668032.00
-block area: 35445424.00
-dead space:  6222608.00 (17.56%)
-
-area usage   (wrt. total area): 85.07%
-dead space % (wrt. total area): 14.93%
----------------------------
-
-Optimizing operators in the Polish expression...
-After operator optimization,
-width:  3612.00
-height: 11536.00
-total area: 41668032.00
-block area: 35445424.00
-dead space:  6222608.00 (17.56%)
-
-area usage   (wrt. total area): 85.07%
-dead space % (wrt. total area): 14.93%
----------------------------
-
-Output successfully written to dummy_output
-
-===== Thanks for using BloBB =====
------ Running source/TESTS/MCNCapte.txt ...
-WARNING: The type of floorplan is not specified, 
-         default option "--slicing" is used.
-WARNING: The type of algorithm is not specified, 
-         default option "--hierarchical" is used.
-===== BloBB (Block-packing with Branch-and-bound) =====
-floorplanType: --slicing
-algorithmType: --hierarchical
-block orientn: --free-orient
-EXTRA: cluster base=4
-EXTRA: aspect ratio tolerance=1.50
-EXTRA: asepct ratio increment=1.50
-EXTRA: dead space increment=1.05
-EXTRA: cluster area deviation=2.00
-EXTRA: side resolution=1.90
-EXTRA: optimize operators in the Polish expression? Yes
-EXTRA: compact? No
-=======================================================
-===== after InitializeCluster =====
-===== Grouping 9 clusters... 
-===== Packing into 4 clusters... 
-
-totalArea: 46561628.00 deadspace:        0.00 (0.00%) time:  0.01
-
-===== Grouping 4 clusters... 
-===== Packing into 1 clusters... 
-
-totalArea: 46561628.00 deadspace:  3178612.00 (6.83%) time:  0.01
-
-width:  6810.00
-height: 7304.00
-total area: 49740240.00
-block area: 46561628.00
-dead space:  3178612.00 (6.83%)
-
-area usage   (wrt. total area): 93.61%
-dead space % (wrt. total area): 6.39%
----------------------------
-
-Optimizing operators in the Polish expression...
-After operator optimization,
-width:  6810.00
-height: 7304.00
-total area: 49740240.00
-block area: 46561628.00
-dead space:  3178612.00 (6.83%)
-
-area usage   (wrt. total area): 93.61%
-dead space % (wrt. total area): 6.39%
----------------------------
-
-Output successfully written to dummy_output
-
-===== Thanks for using BloBB =====
------ Running source/TESTS/MCNChp.txt ...
-WARNING: The type of floorplan is not specified, 
-         default option "--slicing" is used.
-WARNING: The type of algorithm is not specified, 
-         default option "--hierarchical" is used.
-===== BloBB (Block-packing with Branch-and-bound) =====
-floorplanType: --slicing
-algorithmType: --hierarchical
-block orientn: --free-orient
-EXTRA: cluster base=4
-EXTRA: aspect ratio tolerance=1.50
-EXTRA: asepct ratio increment=1.50
-EXTRA: dead space increment=1.05
-EXTRA: cluster area deviation=2.00
-EXTRA: side resolution=1.90
-EXTRA: optimize operators in the Polish expression? Yes
-EXTRA: compact? No
-=======================================================
-===== after InitializeCluster =====
-===== Grouping 11 clusters... 
-===== Packing into 4 clusters... 
-
-totalArea:  8830584.00 deadspace:   604856.00 (6.85%) time:  0.01
-
-===== Grouping 4 clusters... 
-===== Packing into 1 clusters... 
-
-totalArea:  8830584.00 deadspace:  1119944.00 (12.68%) time:  0.01
-
-width:  2128.00
-height: 4676.00
-total area:  9950528.00
-block area:  8830584.00
-dead space:  1119944.00 (12.68%)
-
-area usage   (wrt. total area): 88.74%
-dead space % (wrt. total area): 11.26%
----------------------------
-
-Optimizing operators in the Polish expression...
-After operator optimization,
-width:  2128.00
-height: 4676.00
-total area:  9950528.00
-block area:  8830584.00
-dead space:  1119944.00 (12.68%)
-
-area usage   (wrt. total area): 88.74%
-dead space % (wrt. total area): 11.26%
----------------------------
-
-Output successfully written to dummy_output
-
-===== Thanks for using BloBB =====
------ Running source/TESTS/MCNCxerox.txt ...
-WARNING: The type of floorplan is not specified, 
-         default option "--slicing" is used.
-WARNING: The type of algorithm is not specified, 
-         default option "--hierarchical" is used.
-===== BloBB (Block-packing with Branch-and-bound) =====
-floorplanType: --slicing
-algorithmType: --hierarchical
-block orientn: --free-orient
-EXTRA: cluster base=4
-EXTRA: aspect ratio tolerance=1.50
-EXTRA: asepct ratio increment=1.50
-EXTRA: dead space increment=1.05
-EXTRA: cluster area deviation=2.00
-EXTRA: side resolution=1.90
-EXTRA: optimize operators in the Polish expression? Yes
-EXTRA: compact? No
-=======================================================
-===== after InitializeCluster =====
-===== Grouping 10 clusters... 
-===== Packing into 4 clusters... 
-
-totalArea: 19350296.00 deadspace:   852208.00 (4.40%) time:  0.00
-
-===== Grouping 4 clusters... 
-===== Packing into 1 clusters... 
-
-totalArea: 19350296.00 deadspace:  1825544.00 (9.43%) time:  0.01
-
-width:  2590.00
-height: 8176.00
-total area: 21175840.00
-block area: 19350296.00
-dead space:  1825544.00 (9.43%)
-
-area usage   (wrt. total area): 91.38%
-dead space % (wrt. total area): 8.62%
----------------------------
-
-Optimizing operators in the Polish expression...
-After operator optimization,
-width:  2590.00
-height: 8176.00
-total area: 21175840.00
-block area: 19350296.00
-dead space:  1825544.00 (9.43%)
-
-area usage   (wrt. total area): 91.38%
-dead space % (wrt. total area): 8.62%
----------------------------
-
-Output successfully written to dummy_output
-
-===== Thanks for using BloBB =====
diff -druN BloBB_CompaSS_050315/BloBB/expected_050315.out blob_compass/BloBB/expected_050315.out
--- BloBB_CompaSS_050315/BloBB/expected_050315.out	2005-03-14 22:21:43.000000000 -0800
+++ blob_compass/BloBB/expected_050315.out	1969-12-31 16:00:00.000000000 -0800
@@ -1,498 +0,0 @@
------ Running ../TESTS/MCNCami33.txt ...
-WARNING: The type of floorplan is not specified, 
-         default option "--slicing" is used.
-WARNING: The type of algorithm is not specified, 
-         default option "--hierarchical" is used.
-===== BloBB (Block-packing with Branch-and-bound) =====
-floorplanType: --slicing
-algorithmType: --hierarchical
-block orientn: --free-orient
-EXTRA: cluster base=4
-EXTRA: aspect ratio tolerance=1.50
-EXTRA: asepct ratio increment=1.50
-EXTRA: dead space increment=1.05
-EXTRA: cluster area deviation=2.00
-EXTRA: side resolution=1.90
-EXTRA: optimize operators in the Polish expression? Yes
-EXTRA: compact? Yes
-=======================================================
-===== after InitializeCluster =====
-===== Grouping 33 clusters... 
-===== Packing into 22 clusters... 
-
-totalArea:  1156449.00 deadspace:    25725.00 (2.22%) time:  0.01
-
-===== Grouping 22 clusters... 
-===== Packing into 16 clusters... 
-
-totalArea:  1156449.00 deadspace:    34496.00 (2.98%) time:  0.01
-
-===== Grouping 16 clusters... 
-===== Packing into 4 clusters... 
-
-totalArea:  1156449.00 deadspace:   142345.00 (12.31%) time:  0.01
-
-===== Grouping 4 clusters... 
-===== Packing into 1 clusters... 
-
-totalArea:  1156449.00 deadspace:   277291.00 (23.98%) time:  0.02
-
-width:  1463.00
-height: 980.00
-total area:  1433740.00
-block area:  1156449.00
-dead space:   277291.00 (23.98%)
-
-area usage   (wrt. total area): 80.66%
-dead space % (wrt. total area): 19.34%
----------------------------
-
-Optimizing operators in the Polish expression...
-After operator optimization,
-width:  1463.00
-height: 980.00
-total area:  1433740.00
-block area:  1156449.00
-dead space:   277291.00 (23.98%)
-
-area usage   (wrt. total area): 80.66%
-dead space % (wrt. total area): 19.34%
----------------------------
-
-Compacting...
-converted to B*-Tree: 1433740.00 (23.98%) -> 1372294.00 (18.66%)
-round 0:      2 blks changed: 1372294.00 (18.66%) -> 1372294.00 (18.66%)
-round 1:      0 blks changed: 1372294.00 (18.66%) -> 1372294.00 (18.66%)
-
-After compaction, 
-blkArea:  1156449.00 deadspace:   215845.00 (18.66%)
-
-width:  1463.00
-height: 938.00
-total area:  1372294.00
-block area:  1156449.00
-dead space:   215845.00 (18.66%)
-
-area usage   (wrt. total area): 84.27%
-dead space % (wrt. total area): 15.73%
----------------------------
-
-Output successfully written to dummy_output
-
-BloBB's total runtime: 0.02s
-===== Thanks for using BloBB =====
------ Running ../TESTS/MCNCami49_10.txt ...
-WARNING: The type of floorplan is not specified, 
-         default option "--slicing" is used.
-WARNING: The type of algorithm is not specified, 
-         default option "--hierarchical" is used.
-===== BloBB (Block-packing with Branch-and-bound) =====
-floorplanType: --slicing
-algorithmType: --hierarchical
-block orientn: --free-orient
-EXTRA: cluster base=4
-EXTRA: aspect ratio tolerance=1.50
-EXTRA: asepct ratio increment=1.50
-EXTRA: dead space increment=1.05
-EXTRA: cluster area deviation=2.00
-EXTRA: side resolution=1.90
-EXTRA: optimize operators in the Polish expression? Yes
-EXTRA: compact? Yes
-=======================================================
-===== after InitializeCluster =====
-===== Grouping 490 clusters... 
-===== Packing into 256 clusters... 
-
-totalArea:  3544542.40 deadspace:      335.16 (0.01%) time:  0.10
-
-===== Grouping 256 clusters... 
-===== Packing into 141 clusters... 
-
-totalArea:  3544542.40 deadspace:    14168.84 (0.40%) time:  0.13
-
-===== Grouping 141 clusters... 
-===== Packing into 84 clusters... 
-
-totalArea:  3544542.40 deadspace:    28433.72 (0.80%) time:  0.14
-
-===== Grouping 84 clusters... 
-===== Packing into 64 clusters... 
-
-totalArea:  3544542.40 deadspace:    37357.60 (1.05%) time:  0.15
-
-===== Grouping 64 clusters... 
-===== Packing into 39 clusters... 
-
-totalArea:  3544542.40 deadspace:    81532.08 (2.30%) time:  0.15
-
-===== Grouping 39 clusters... 
-===== Packing into 26 clusters... 
-
-totalArea:  3544542.40 deadspace:   155300.60 (4.38%) time:  0.15
-
-===== Grouping 26 clusters... 
-===== Packing into 19 clusters... 
-
-totalArea:  3544542.40 deadspace:   159785.08 (4.51%) time:  0.15
-
-===== Grouping 19 clusters... 
-===== Packing into 16 clusters... 
-
-totalArea:  3544542.40 deadspace:   166598.04 (4.70%) time:  0.15
-
-===== Grouping 16 clusters... 
-===== Packing into 4 clusters... 
-
-totalArea:  3544542.40 deadspace:   411505.92 (11.61%) time:  0.17
-
-===== Grouping 4 clusters... 
-===== Packing into 1 clusters... 
-
-totalArea:  3544542.40 deadspace:   738888.64 (20.85%) time:  0.17
-
-width:  1395.80
-height: 3068.80
-total area:  4283431.04
-block area:  3544542.40
-dead space:   738888.64 (20.85%)
-
-area usage   (wrt. total area): 82.75%
-dead space % (wrt. total area): 17.25%
----------------------------
-
-Optimizing operators in the Polish expression...
-After operator optimization,
-width:  1393.00
-height: 3068.80
-total area:  4274838.40
-block area:  3544542.40
-dead space:   730296.00 (20.60%)
-
-area usage   (wrt. total area): 82.92%
-dead space % (wrt. total area): 17.08%
----------------------------
-
-Compacting...
-converted to B*-Tree: 4274838.40 (20.60%) -> 4268987.80 (20.44%)
-round 0:    281 blks changed: 4268987.80 (20.44%) -> 4217502.52 (18.99%)
-round 1:     33 blks changed: 4217502.52 (18.99%) -> 4217502.52 (18.99%)
-round 2:      0 blks changed: 4217502.52 (18.99%) -> 4217502.52 (18.99%)
-
-After compaction, 
-blkArea:  3544542.40 deadspace:   672960.12 (18.99%)
-
-width:  1376.20
-height: 3064.60
-total area:  4217502.52
-block area:  3544542.40
-dead space:   672960.12 (18.99%)
-
-area usage   (wrt. total area): 84.04%
-dead space % (wrt. total area): 15.96%
----------------------------
-
-Output successfully written to dummy_output
-
-BloBB's total runtime: 0.19s
-===== Thanks for using BloBB =====
------ Running ../TESTS/MCNCami49.txt ...
-WARNING: The type of floorplan is not specified, 
-         default option "--slicing" is used.
-WARNING: The type of algorithm is not specified, 
-         default option "--hierarchical" is used.
-===== BloBB (Block-packing with Branch-and-bound) =====
-floorplanType: --slicing
-algorithmType: --hierarchical
-block orientn: --free-orient
-EXTRA: cluster base=4
-EXTRA: aspect ratio tolerance=1.50
-EXTRA: asepct ratio increment=1.50
-EXTRA: dead space increment=1.05
-EXTRA: cluster area deviation=2.00
-EXTRA: side resolution=1.90
-EXTRA: optimize operators in the Polish expression? Yes
-EXTRA: compact? Yes
-=======================================================
-===== after InitializeCluster =====
-===== Grouping 49 clusters... 
-===== Packing into 22 clusters... 
-
-totalArea: 35445424.00 deadspace:   450212.00 (1.27%) time:  0.01
-
-===== Grouping 22 clusters... 
-===== Packing into 16 clusters... 
-
-totalArea: 35445424.00 deadspace:   863576.00 (2.44%) time:  0.01
-
-===== Grouping 16 clusters... 
-===== Packing into 4 clusters... 
-
-totalArea: 35445424.00 deadspace:  3870804.00 (10.92%) time:  0.02
-
-===== Grouping 4 clusters... 
-===== Packing into 1 clusters... 
-
-totalArea: 35445424.00 deadspace:  6222608.00 (17.56%) time:  0.02
-
-width:  3612.00
-height: 11536.00
-total area: 41668032.00
-block area: 35445424.00
-dead space:  6222608.00 (17.56%)
-
-area usage   (wrt. total area): 85.07%
-dead space % (wrt. total area): 14.93%
----------------------------
-
-Optimizing operators in the Polish expression...
-After operator optimization,
-width:  3612.00
-height: 11536.00
-total area: 41668032.00
-block area: 35445424.00
-dead space:  6222608.00 (17.56%)
-
-area usage   (wrt. total area): 85.07%
-dead space % (wrt. total area): 14.93%
----------------------------
-
-Compacting...
-converted to B*-Tree: 41668032.00 (17.56%) -> 41668032.00 (17.56%)
-round 0:     21 blks changed: 41668032.00 (17.56%) -> 41668032.00 (17.56%)
-round 1:      0 blks changed: 41668032.00 (17.56%) -> 41668032.00 (17.56%)
-
-After compaction, 
-blkArea: 35445424.00 deadspace:  6222608.00 (17.56%)
-
-width:  3612.00
-height: 11536.00
-total area: 41668032.00
-block area: 35445424.00
-dead space:  6222608.00 (17.56%)
-
-area usage   (wrt. total area): 85.07%
-dead space % (wrt. total area): 14.93%
----------------------------
-
-Output successfully written to dummy_output
-
-BloBB's total runtime: 0.03s
-===== Thanks for using BloBB =====
------ Running ../TESTS/MCNCapte.txt ...
-WARNING: The type of floorplan is not specified, 
-         default option "--slicing" is used.
-WARNING: The type of algorithm is not specified, 
-         default option "--hierarchical" is used.
-===== BloBB (Block-packing with Branch-and-bound) =====
-floorplanType: --slicing
-algorithmType: --hierarchical
-block orientn: --free-orient
-EXTRA: cluster base=4
-EXTRA: aspect ratio tolerance=1.50
-EXTRA: asepct ratio increment=1.50
-EXTRA: dead space increment=1.05
-EXTRA: cluster area deviation=2.00
-EXTRA: side resolution=1.90
-EXTRA: optimize operators in the Polish expression? Yes
-EXTRA: compact? Yes
-=======================================================
-===== after InitializeCluster =====
-===== Grouping 9 clusters... 
-===== Packing into 4 clusters... 
-
-totalArea: 46561628.00 deadspace:        0.00 (0.00%) time:  0.00
-
-===== Grouping 4 clusters... 
-===== Packing into 1 clusters... 
-
-totalArea: 46561628.00 deadspace:  3178612.00 (6.83%) time:  0.00
-
-width:  6810.00
-height: 7304.00
-total area: 49740240.00
-block area: 46561628.00
-dead space:  3178612.00 (6.83%)
-
-area usage   (wrt. total area): 93.61%
-dead space % (wrt. total area): 6.39%
----------------------------
-
-Optimizing operators in the Polish expression...
-After operator optimization,
-width:  6810.00
-height: 7304.00
-total area: 49740240.00
-block area: 46561628.00
-dead space:  3178612.00 (6.83%)
-
-area usage   (wrt. total area): 93.61%
-dead space % (wrt. total area): 6.39%
----------------------------
-
-Compacting...
-converted to B*-Tree: 49740240.00 (6.83%) -> 49740240.00 (6.83%)
-round 0:      0 blks changed: 49740240.00 (6.83%) -> 49740240.00 (6.83%)
-
-After compaction, 
-blkArea: 46561628.00 deadspace:  3178612.00 (6.83%)
-
-width:  6810.00
-height: 7304.00
-total area: 49740240.00
-block area: 46561628.00
-dead space:  3178612.00 (6.83%)
-
-area usage   (wrt. total area): 93.61%
-dead space % (wrt. total area): 6.39%
----------------------------
-
-Output successfully written to dummy_output
-
-BloBB's total runtime: 0.00s
-===== Thanks for using BloBB =====
------ Running ../TESTS/MCNChp.txt ...
-WARNING: The type of floorplan is not specified, 
-         default option "--slicing" is used.
-WARNING: The type of algorithm is not specified, 
-         default option "--hierarchical" is used.
-===== BloBB (Block-packing with Branch-and-bound) =====
-floorplanType: --slicing
-algorithmType: --hierarchical
-block orientn: --free-orient
-EXTRA: cluster base=4
-EXTRA: aspect ratio tolerance=1.50
-EXTRA: asepct ratio increment=1.50
-EXTRA: dead space increment=1.05
-EXTRA: cluster area deviation=2.00
-EXTRA: side resolution=1.90
-EXTRA: optimize operators in the Polish expression? Yes
-EXTRA: compact? Yes
-=======================================================
-===== after InitializeCluster =====
-===== Grouping 11 clusters... 
-===== Packing into 4 clusters... 
-
-totalArea:  8830584.00 deadspace:   604856.00 (6.85%) time:  0.00
-
-===== Grouping 4 clusters... 
-===== Packing into 1 clusters... 
-
-totalArea:  8830584.00 deadspace:  1119944.00 (12.68%) time:  0.00
-
-width:  2128.00
-height: 4676.00
-total area:  9950528.00
-block area:  8830584.00
-dead space:  1119944.00 (12.68%)
-
-area usage   (wrt. total area): 88.74%
-dead space % (wrt. total area): 11.26%
----------------------------
-
-Optimizing operators in the Polish expression...
-After operator optimization,
-width:  2128.00
-height: 4676.00
-total area:  9950528.00
-block area:  8830584.00
-dead space:  1119944.00 (12.68%)
-
-area usage   (wrt. total area): 88.74%
-dead space % (wrt. total area): 11.26%
----------------------------
-
-Compacting...
-converted to B*-Tree: 9950528.00 (12.68%) -> 9950528.00 (12.68%)
-round 0:      1 blks changed: 9950528.00 (12.68%) -> 9950528.00 (12.68%)
-round 1:      0 blks changed: 9950528.00 (12.68%) -> 9950528.00 (12.68%)
-
-After compaction, 
-blkArea:  8830584.00 deadspace:  1119944.00 (12.68%)
-
-width:  2128.00
-height: 4676.00
-total area:  9950528.00
-block area:  8830584.00
-dead space:  1119944.00 (12.68%)
-
-area usage   (wrt. total area): 88.74%
-dead space % (wrt. total area): 11.26%
----------------------------
-
-Output successfully written to dummy_output
-
-BloBB's total runtime: 0.01s
-===== Thanks for using BloBB =====
------ Running ../TESTS/MCNCxerox.txt ...
-WARNING: The type of floorplan is not specified, 
-         default option "--slicing" is used.
-WARNING: The type of algorithm is not specified, 
-         default option "--hierarchical" is used.
-===== BloBB (Block-packing with Branch-and-bound) =====
-floorplanType: --slicing
-algorithmType: --hierarchical
-block orientn: --free-orient
-EXTRA: cluster base=4
-EXTRA: aspect ratio tolerance=1.50
-EXTRA: asepct ratio increment=1.50
-EXTRA: dead space increment=1.05
-EXTRA: cluster area deviation=2.00
-EXTRA: side resolution=1.90
-EXTRA: optimize operators in the Polish expression? Yes
-EXTRA: compact? Yes
-=======================================================
-===== after InitializeCluster =====
-===== Grouping 10 clusters... 
-===== Packing into 4 clusters... 
-
-totalArea: 19350296.00 deadspace:   852208.00 (4.40%) time:  0.00
-
-===== Grouping 4 clusters... 
-===== Packing into 1 clusters... 
-
-totalArea: 19350296.00 deadspace:  1825544.00 (9.43%) time:  0.01
-
-width:  2590.00
-height: 8176.00
-total area: 21175840.00
-block area: 19350296.00
-dead space:  1825544.00 (9.43%)
-
-area usage   (wrt. total area): 91.38%
-dead space % (wrt. total area): 8.62%
----------------------------
-
-Optimizing operators in the Polish expression...
-After operator optimization,
-width:  2590.00
-height: 8176.00
-total area: 21175840.00
-block area: 19350296.00
-dead space:  1825544.00 (9.43%)
-
-area usage   (wrt. total area): 91.38%
-dead space % (wrt. total area): 8.62%
----------------------------
-
-Compacting...
-converted to B*-Tree: 21175840.00 (9.43%) -> 20088040.00 (3.81%)
-round 0:      2 blks changed: 20088040.00 (3.81%) -> 20088040.00 (3.81%)
-round 1:      0 blks changed: 20088040.00 (3.81%) -> 20088040.00 (3.81%)
-
-After compaction, 
-blkArea: 19350296.00 deadspace:   737744.00 (3.81%)
-
-width:  2590.00
-height: 7756.00
-total area: 20088040.00
-block area: 19350296.00
-dead space:   737744.00 (3.81%)
-
-area usage   (wrt. total area): 96.33%
-dead space % (wrt. total area): 3.67%
----------------------------
-
-Output successfully written to dummy_output
-
-BloBB's total runtime: 0.01s
-===== Thanks for using BloBB =====
diff -druN BloBB_CompaSS_050315/BloBB/interface.cxx blob_compass/BloBB/interface.cxx
--- BloBB_CompaSS_050315/BloBB/interface.cxx	2005-03-14 22:11:13.000000000 -0800
+++ blob_compass/BloBB/interface.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,584 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "interface.h"
-#include "datastrst.h"
-#include "parameters.h"
-
-#include <iostream>
-#include <fstream>
-#include <string>
-#include <cstring>
-#include <iomanip>
-#include <cstdlib>
-using namespace std;
-
-string INF_FN_PREFIX("");
-string INF_FN_SUFFIX(".bbb");
-bool INF_SHOW_INTERMEDIATES = true;
-bool INF_SHOW_LANDMARKS = true;
-bool INF_SHOW_PRUNED_TABLE = true;
-bool INF_SHOW_SIMILARITY_TABLE = true;
-bool INF_SHOW_POLISH_EXPRESSION = true;
-// --------------------------------------------------------
-void ParseCommandLine(int argc,
-                      char *argv[],
-                      CommandOptions& choice)
-{
-   ifstream infile;
-   ofstream outfile;
-   
-   if (argc < 2)
-   {
-      PrintUsage();
-      cout << "       for details, type the option \"--help\"." << endl;
-      exit(1);
-   }
-   else if (!strcmp(argv[1], "--help"))
-   {
-      PrintHelp();
-      exit(0);
-   }
-   else if (argc < 3)
-   {
-      cout << "USAGE: " << argv[0] << " <input-file> <output-file> "
-           << "[-options]" << endl;
-      cout << "       for details, type the option \"--help\"." << endl;
-      exit(1);
-   }
-
-   infile.open(argv[1]);
-   if (!infile.good())
-   {
-      cout << "ERROR: cannot open input file \"" << argv[1]
-           << "\"." << endl;
-      exit(1);
-   }
-   infile.close();
-
-   outfile.open(argv[2]);
-   if (!outfile.good())
-   {
-      cout << "ERROR: cannot open output file \"" << argv[2]
-           << "\"." << endl;
-      exit(1);
-   }
-   outfile.close();
-
-   for (int i = 3; i < argc; i++)
-   {
-      if (!strcmp(argv[i], "--slicing") ||
-          !strcmp(argv[i], "-s"))
-         SetOption(choice.floorplanType, "--slicing");
-      else if (!strcmp(argv[i], "--non-slicing") ||
-               !strcmp(argv[i], "--general") ||
-               !strcmp(argv[i], "-n"))
-         SetOption(choice.floorplanType, "--non-slicing");
-      else if (!strcmp(argv[i], "--optimal") ||
-               !strcmp(argv[i], "-o"))
-         SetOption(choice.algorithmType, "--optimal");
-      else if (!strcmp(argv[i], "--hierarchical") ||
-               !strcmp(argv[i], "-h"))
-         SetOption(choice.algorithmType, "--hierarchical");
-      else if (!strcmp(argv[i], "--backtrack") ||
-               !strcmp(argv[i], "-b"))
-         SetOption(choice.algorithmType, "--backtrack");
-      else if (!strcmp(argv[i], "--enumerate") ||
-               !strcmp(argv[i], "-e"))
-         SetOption(choice.algorithmType, "--enumerate");
-      else if (!strcmp(argv[i], "--deadspace_percent") ||
-               !strcmp(argv[i], "-d"))
-      {
-         i++;
-         SetDeadspacePercent(argc, argv, i, choice);
-      }
-      else if (!strcmp(argv[i], "--file_prefix") ||
-               !strcmp(argv[i], "-f"))
-      {
-         i++;
-         SetFNPrefix(argc, argv, i);
-      }
-      // block orientation constraints
-      else if (!strcmp(argv[i], "--free-orient") ||
-	       !strcmp(argv[i], "-fr"))
-	 ENG_ORIENT_CONSIDERED = 2;
-      else if (!strcmp(argv[i], "--fixed-orient") ||
-	       !strcmp(argv[i], "-fx"))
-	 ENG_ORIENT_CONSIDERED = 1;
-      // numerical parameters for slice/nonslice
-      else if (!strcmp(argv[i], "--ENG_DEADSPACE_INCRE"))
-      {
-         i++;
-         SetDouble(argc, argv, i, ENG_DEADSPACE_INCRE);
-      }
-      else if (!strcmp(argv[i], "--ENG_INIT_DEADSPACE_PERCENT"))
-      {
-         i++;
-         SetDouble(argc, argv, i, ENG_INIT_DEADSPACE_PERCENT);
-         ENG_INIT_DEADSPACE_PERCENT /= 100;
-      }
-      // numerical parameters for hierarchical slicing
-      else if (!strcmp(argv[i], "--HIER_CLUSTER_BASE"))
-      {
-         i++;
-         SetInt(argc, argv, i, HIER_CLUSTER_BASE);
-      }
-      else if (!strcmp(argv[i], "--HIER_AR"))
-      {
-         i++;
-         SetDouble(argc, argv, i, HIER_AR);
-      }
-      else if (!strcmp(argv[i], "--HIER_AR_INCRE"))
-      {
-         i++;
-         SetDouble(argc, argv, i, HIER_AR_INCRE);
-      }
-      else if (!strcmp(argv[i], "--HIER_BEST_AREA_INCRE"))
-      {
-         i++;
-         SetDouble(argc, argv, i, HIER_BEST_AREA_INCRE);
-      }
-      else if (!strcmp(argv[i], "--HIER_CLUSTER_AREA_DEV"))
-      {
-         i++;
-         SetDouble(argc, argv, i, HIER_CLUSTER_AREA_DEV);
-      }
-      else if (!strcmp(argv[i], "--HIER_SIDE_RESOLUTION"))
-      {
-         i++;
-         SetDouble(argc, argv, i, HIER_SIDE_RESOLUTION);
-      }
-      else if (!strcmp(argv[i], "--no_compact"))
-      {
-         HIER_COMPACT = false;
-      }
-      else if (!strcmp(argv[i], "--no_opt_opr"))
-      {
-         HIER_OPTOPR = false;
-      }
-      // interface boolean options
-      else if (!strcmp(argv[i], "--verbose") ||
-               !strcmp(argv[i], "-v"))
-      {
-         INF_SHOW_INTERMEDIATES = true;
-         INF_SHOW_LANDMARKS = true;
-         INF_SHOW_PRUNED_TABLE = true;
-         INF_SHOW_SIMILARITY_TABLE = true;
-         INF_SHOW_POLISH_EXPRESSION = true;
-      }
-      else if (!strcmp(argv[i], "--terse") ||
-               !strcmp(argv[i], "-t"))
-      {
-         INF_SHOW_INTERMEDIATES = false;
-         INF_SHOW_LANDMARKS = false;
-         INF_SHOW_PRUNED_TABLE = false;
-         INF_SHOW_SIMILARITY_TABLE = false;
-         INF_SHOW_POLISH_EXPRESSION = false;
-      }
-      else if (!strcmp(argv[i], "--INF_SHOW_INTERMEDIATES"))
-         INF_SHOW_INTERMEDIATES = true;
-      else if (!strcmp(argv[i], "--nINF_SHOW_INTERMEDIATES"))
-         INF_SHOW_INTERMEDIATES = false;
-      else if (!strcmp(argv[i], "--INF_SHOW_LANDMARKS"))
-         INF_SHOW_LANDMARKS = true;
-      else if (!strcmp(argv[i], "--nINF_SHOW_LANDMARKS"))
-         INF_SHOW_LANDMARKS = false;
-      else if (!strcmp(argv[i], "--INF_SHOW_PRUNED_TABLE"))
-         INF_SHOW_PRUNED_TABLE = true;
-      else if (!strcmp(argv[i], "--nINF_SHOW_PRUNED_TABLE"))
-         INF_SHOW_PRUNED_TABLE = false;
-      else if (!strcmp(argv[i], "--INF_SHOW_SIMILARITY_TABLE"))
-         INF_SHOW_SIMILARITY_TABLE = true;
-      else if (!strcmp(argv[i], "--nINF_SHOW_SIMILARITY_TABLE"))
-         INF_SHOW_SIMILARITY_TABLE = false;
-      else if (!strcmp(argv[i], "--INF_SHOW_POLISH_EXPRESSION"))
-         INF_SHOW_POLISH_EXPRESSION = true;
-      else if (!strcmp(argv[i], "--nINF_SHOW_POLISH_EXPRESSION"))
-         INF_SHOW_POLISH_EXPRESSION = false;
-      else
-      {
-         cout << "ERROR: invalid option \"" << argv[i]
-              << "\"." << endl;
-         exit(1);
-      }
-   }
-   
-   // ----after command line----
-   CheckDeadspace(choice);
-   CheckFloorplanType(choice);
-   CheckAlgorithmType(choice);
-   CheckOrient();
-   CheckFNPrefix(choice, INF_FN_PREFIX);
-   if (choice.algorithmType == "--optimal" ||
-       choice.algorithmType == "--backtrack" ||
-       choice.algorithmType == "--enumerate")
-      CheckEng();
-   if (choice.algorithmType == "--hierarchical")
-      CheckHierarchical();
-}           
-// --------------------------------------------------------
-void SetOption(string& option,
-               const char *flag)
-{
-   if ((option != "") && (option != flag))
-   {
-      cout << "ERROR: options \"" << option << "\" and \""
-           << flag << "\" cannot be used together." << endl;
-      exit(1);
-   }
-   else
-      option = flag;
-}
-// --------------------------------------------------------
-void SetDeadspacePercent(int argc,
-                         char *argv[],
-                         int index,
-                         CommandOptions& choice)
-{
-   if (argc <= index)
-   {
-      cout << "ERROR: must specified a number after label \""
-           << argv[index-1] << "\"." << endl;
-      exit(1);
-   }
-   else if (choice.dpercent != -1)
-   {
-      cout << "ERROR: multiple specification of \""
-           << "--deadspace_percent\" (" << (choice.dpercent*100)
-           << " vs. " << argv[index] << ")." << endl;
-      exit(1);
-   }         
-   
-   SetDouble(argc, argv, index, choice.dpercent);
-   choice.dpercent /= 100;
-   if (choice.dpercent < 0)
-   {
-      cout << "ERROR: deadspace_percent cannot be negative." << endl;
-      exit(1);
-   }
-}
-// --------------------------------------------------------
-void SetFNPrefix(int argc,
-                 char *argv[],
-                 int index)
-{
-   if (argc <= index)
-   {
-      cout << "ERROR: must specified a number after label \""
-           << argv[index-1] << "\"." << endl;
-      exit(1);
-   }
-   else if (INF_FN_PREFIX != "")
-   {
-      cout << "ERROR: multiple specification of \""
-           << "--file_prefix\" (" << INF_FN_PREFIX
-           << " vs. " << argv[index] << ")." << endl;
-      exit(1);
-   }
-   INF_FN_PREFIX = argv[index];
-}
-// --------------------------------------------------------
-// void SetDouble(int argc,
-//                char *argv[],
-//                int index,
-//                double& param)
-// {
-//    if (argc <= index)
-//    {
-//       cout << "ERROR: must specified a number after label \""
-//            << argv[index-1] << "\"." << endl;
-//       exit(1);
-//    }
-   
-//    char **endp = new (char*);
-//    endp[0] = new char[100];         
-//    param = strtod(argv[index], endp);
-   
-//    if (strcmp(endp[0], ""))
-//    {
-//       cout << "ERROR: invalid number \""
-//            << argv[index] << "\"." << endl;
-//       delete endp; 
-//       exit(1);
-//    }
-//    else
-//       delete endp;
-// } 
-// // -------------------------------------------------------
-// void SetInt(int argc,
-//             char *argv[],
-//             int index,
-//             int& param)
-// {
-//    if (argc <= index)
-//    {
-//       cout << "ERROR: must specified a number after label \""
-//            << argv[index-1] << "\"." << endl;
-//       exit(1);
-//    }
-   
-//    char **endp = new (char*);
-//    endp[0] = new char[100];         
-//    param = strtol(argv[index], endp, 10);
-   
-//    if (strcmp(endp[0], ""))
-//    {
-//       cout << "ERROR: invalid number \""
-//            << argv[index] << "\"." << endl;
-//       delete endp;
-//       exit(1);
-//    }
-//    else
-//       delete endp;
-// }   
-// ========================================================
-void CheckDeadspace(CommandOptions& choice)
-{
-   if ((choice.algorithmType == "--backtrack") &&
-       (choice.dpercent == -1))
-   {
-      cout.setf(ios::fixed);
-      cout.precision(2);
-      cout << "WARNING: Option \"--backtrack\" is chosen but "
-           << "the deadspace threshold is not " << endl;
-      cout << "         specified.  Default value "
-           << (INF_DEADSPACE_DEFAULT * 100) << "% is used." << endl;
-      choice.dpercent = INF_DEADSPACE_DEFAULT;
-   }
-}
-// --------------------------------------------------------
-void CheckFloorplanType(CommandOptions& choice)
-{
-   if (choice.floorplanType  == "")
-   {
-      cout << "WARNING: The type of floorplan is not specified, " << endl;
-      cout << "         default option \"";
-      choice.floorplanType = "--slicing";
-      cout << choice.floorplanType << "\" is used." << endl;
-   }
-   
-}
-//.--------------------------------------------------------
-void CheckAlgorithmType(CommandOptions& choice)
-{
-   if (choice.algorithmType == "")
-   {
-      cout << "WARNING: The type of algorithm is not specified, " << endl;
-      cout << "         default option \"";
-      if (choice.floorplanType == "--slicing")
-         choice.algorithmType = "--hierarchical";
-      else
-         choice.algorithmType = "--optimal";
-      cout << choice.algorithmType << "\" is used." << endl;
-   }
-}
-// --------------------------------------------------------
-void CheckFNPrefix(const CommandOptions& choice,
-                   const string& INF_FN_PREFIX)
-{
-   if (choice.algorithmType == "--optimal" ||
-       choice.algorithmType == "--backtrack" ||
-       choice.algorithmType == "--enumerate")
-      if (INF_FN_PREFIX == "")
-      {
-         cout << "WARNING: No file name prefix is provided.  " << endl;
-         cout << "         Intermediate solutions are not saved." << endl;
-      }
-}
-// --------------------------------------------------------
-void CheckOrient()
-{
-   if (ENG_ORIENT_CONSIDERED == ENG_UNDEFINED_SENTINEL)
-      ENG_ORIENT_CONSIDERED = ENG_ORIENT_CONSIDERED_DEFAULT;
-}
-// --------------------------------------------------------
-void CheckEng()
-{
-   if (ENG_INIT_DEADSPACE_PERCENT == ENG_UNDEFINED_SENTINEL)
-   {
-      if (ENG_ORIENT_CONSIDERED == 1)
-	 ENG_INIT_DEADSPACE_PERCENT = ENG_INIT_DEADSPACE_PERCENT_FIXED_DEFAULT;
-      else if (ENG_ORIENT_CONSIDERED == 2)
-	 ENG_INIT_DEADSPACE_PERCENT = ENG_INIT_DEADSPACE_PERCENT_FREE_DEFAULT;
-   }
-
-   if (ENG_DEADSPACE_INCRE == ENG_UNDEFINED_SENTINEL)
-      ENG_DEADSPACE_INCRE = ENG_DEADSPACE_INCRE_DEFAULT;
-}
-// --------------------------------------------------------	 
-void CheckHierarchical()
-{
-   if (HIER_CLUSTER_BASE == HIER_UNDEFINED_SENTINEL)
-      HIER_CLUSTER_BASE = HIER_CLUSTER_BASE_DEFAULT;
-   
-   if (HIER_AR == HIER_UNDEFINED_SENTINEL)
-   {
-      if (ENG_ORIENT_CONSIDERED == 1)
-	 HIER_AR = HIER_AR_FIXED_DEFAULT;
-      else if (ENG_ORIENT_CONSIDERED == 2)
-	 HIER_AR = HIER_AR_FREE_DEFAULT;
-   }
-
-   if (HIER_AR_INCRE == HIER_UNDEFINED_SENTINEL)
-      HIER_AR_INCRE = HIER_AR_INCRE_DEFAULT;
-
-   if (HIER_BEST_AREA_INCRE == HIER_UNDEFINED_SENTINEL)
-   {
-      if (ENG_ORIENT_CONSIDERED == 1)
-	 HIER_BEST_AREA_INCRE = HIER_BEST_AREA_INCRE_FIXED_DEFAULT;
-      else if (ENG_ORIENT_CONSIDERED == 2)
-	 HIER_BEST_AREA_INCRE = HIER_BEST_AREA_INCRE_FREE_DEFAULT;
-   }
-
-   if (HIER_CLUSTER_AREA_DEV == HIER_UNDEFINED_SENTINEL)
-      HIER_CLUSTER_AREA_DEV = 2;
-
-   if (HIER_SIDE_RESOLUTION == HIER_UNDEFINED_SENTINEL)
-      HIER_SIDE_RESOLUTION = HIER_SIDE_RESOLUTION_DEFAULT;
-}      
-// ========================================================
-void PrintSimilarityTable(int blockNum,
-                          const bool same[][MAX_BLOCK_NUM],
-                          const int blkBefore[])
-{
-   for (int i = 0; i < blockNum; i++)
-   {
-      for (int j = 0; j < blockNum; j++)
-         if (same[i][j])
-            cout << "  T";
-         else
-            cout << "  -";
-      cout << endl;
-   }
-   
-   for (int i = 0; i < blockNum; i++)
-      cout << setw(3) << blkBefore[i];
-   cout << endl;
-}
-// --------------------------------------------------------
-void PrintExtraBacktrack(const CommandOptions& choice)
-{
-   cout.setf(ios::fixed);
-   cout.precision(2);
-   cout << INF_EXTRA_PREFIX << "deadspace_percent="
-        << (choice.dpercent*100) << "%." << endl;
-}
-// --------------------------------------------------------
-void PrintExtraEng()
-{
-   cout.setf(ios::fixed);
-   cout.precision(2);
-   cout << INF_EXTRA_PREFIX << "initial deadspace="
-	<< (ENG_INIT_DEADSPACE_PERCENT*100) << "% " << endl;
-   cout << INF_EXTRA_PREFIX << "dead space increment="
-	<< ENG_DEADSPACE_INCRE << endl;
-}
-// --------------------------------------------------------
-void PrintExtraHierarchical()
-{
-   cout.setf(ios::fixed);
-   cout.precision(2);
-   cout << INF_EXTRA_PREFIX << "cluster base="
-        << HIER_CLUSTER_BASE << endl;
-   cout << INF_EXTRA_PREFIX << "aspect ratio tolerance="
-        << HIER_AR << endl;
-   cout << INF_EXTRA_PREFIX << "asepct ratio increment="
-        << HIER_AR_INCRE << endl;
-   cout << INF_EXTRA_PREFIX << "dead space increment="
-        << HIER_BEST_AREA_INCRE << endl;
-   cout << INF_EXTRA_PREFIX << "cluster area deviation="
-        << HIER_CLUSTER_AREA_DEV << endl;
-   cout << INF_EXTRA_PREFIX << "side resolution="
-        << HIER_SIDE_RESOLUTION << endl;
-   cout << INF_EXTRA_PREFIX << "optimize operators in the Polish expression? "
-        << ((HIER_OPTOPR)? "Yes" : "No") << endl;
-   cout << INF_EXTRA_PREFIX << "compact? "
-        << ((HIER_COMPACT)? "Yes" : "No") << endl;
-}
-// --------------------------------------------------------
-void PrintUsage()
-{
-   cout << "USAGE: blobb <input-file> <output-file> "
-        << "[-options]" << endl;
-
-}
-// --------------------------------------------------------   
-void PrintHelp()
-{
-   PrintUsage();
-   cout << "=====Basic Options=====" << endl;
-   cout << "[Floorplan Types]" << endl;
-   cout << "\"-s\" or \"--slicing\" : \n";
-   cout << "consider slicing packings only.\n";
-   cout << "\"-n\" or \"--general\" or \"--non-slicing\" : \n";
-   cout << "consider general packings that are not necessary slicing\n";
-   cout << endl;
-   cout << "[Algorithm Types]" << endl;
-   cout << "\"-o\" or \"--optimal\" : \n";
-   cout << "find an optimal packing by branch-and-bound.\n";
-   cout << "\"-b\" or \"--backtrack\" : \n";
-   cout << "find a packing with deadspace smaller than a given percentage.\n";
-   cout << "That percentage is specified by following \"-d\" or "
-        << "\"--deadspace_percent\".\n";
-   cout << "\"-e\" or \"--enumerate\" : \n";
-   cout << "enumerate all non-symmetric optimal packings.  The last packing\n";
-   cout << "enumerated is stored in <outfile> while the rest (and the last)\n";
-   cout << "are stored in the intermediate files (see [Intermediate"
-        << " Packings]).\n";
-   cout << "\"-h\" or \"--hierarchical\" : \n";
-   cout << "find a sub-optimal packing using multilevel branch-and-bound.\n";
-   cout << endl;
-   cout << "[Other Options]" << endl;
-   cout << "\"-f <filename>\" or \"--file_prefix <filename>\" : \n";
-   cout << "specifies the prefix of the series files where the intermediate\n";
-   cout << "packings are stored, and the file names are extended with .txt\n";
-   cout << "\"-f\" can be used with all algorithm types, even though it is \n";
-   cout << "intended for non-symmetric packing enumeration (see [Algorithm "
-        << "Types]).\n";
-   cout << "If no intermediate file is specified, no intermediate packings\n";
-   cout << "are saved.\n";
-   cout << "\"-d <percent>\" or \"--deadspace_percent <percent>\" : \n";
-   cout << "specifies the maximum amount of deadspace allowed (see [Algorithm "
-        << "Types]).\n";
-   cout << endl;
-   cout << "[Examples]" << endl;
-   cout << "[0] blobb infile outfile -n --optimal \n";
-   cout << "[1] blobb infile outfile -s -b -d 4.3 \n";
-   cout << "[2] blobb infile outfile -s -e -f dummy \n\n";
-   cout << "[0] searches for an optimal non-slicing packing.  [1] looks for\n";
-   cout << "a packing with less than 4.30% deadspace.  [2] enumerates all \n";
-   cout << "non-symmetric optimal slicing packings.  All the intermediate \n";
-   cout << "packings are stored in dummy0.txt dummy1.txt dummy2.txt etc.\n";
-   cout << endl;
-   cout << "For more information, please read \"doc.pdf\".\n";
-}   
-// ========================================================
-
diff -druN BloBB_CompaSS_050315/BloBB/interface.h blob_compass/BloBB/interface.h
--- BloBB_CompaSS_050315/BloBB/interface.h	2005-03-13 22:07:37.000000000 -0800
+++ blob_compass/BloBB/interface.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,79 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef INTERFACE_H
-#define INTERFACE_H
-
-#include "datastr.h"
-#include "interfaceutil.h"
-
-#include <iostream>
-#include <fstream>
-#include <string>
-using namespace std;
-
-// --------------------------------------------------------
-struct CommandOptions
-{
-   string floorplanType;
-   string algorithmType;
-   double dpercent;
-};
-// --------------------------------------------------------
-void ParseCommandLine(int argc, char *argv[],
-                      CommandOptions& choice);
-void SetOption(string& option, const char *flag);
-void SetDeadspacePercent(int argc, char *argv[], int index,
-                         CommandOptions& choice);
-void SetFNPrefix(int argc, char *argv[], int index);
-// void SetDouble(int argc, char *argv[], int index, double& param);
-// void SetInt(int argc, char *argv[], int index, int& param);
-// --------------------------------------------------------
-void CheckDeadspace(CommandOptions& choice);
-void CheckFloorplanType(CommandOptions& choice);
-void CheckAlgorithmType(CommandOptions& choice);
-void CheckFNPrefix(const CommandOptions& choice,
-		   const string& INF_FN_PREFIX);
-void CheckOrient();
-void CheckEng();
-void CheckHierarchical();
-// --------------------------------------------------------
-void PrintSimilarityTable(int blockNum,
-                          const bool same[][MAX_BLOCK_NUM],
-                          const int blkBefore[]);
-void PrintExtraBacktrack(const CommandOptions& choice);
-void PrintExtraEng();
-void PrintExtraHierarchical();
-void PrintUsage();
-void PrintHelp();
-// --------------------------------------------------------
-
-#endif
diff -druN BloBB_CompaSS_050315/BloBB/main.cxx blob_compass/BloBB/main.cxx
--- BloBB_CompaSS_050315/BloBB/main.cxx	2005-03-14 22:10:02.000000000 -0800
+++ blob_compass/BloBB/main.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,98 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "interface.h"
-#include "nonslice.h"
-#include "slice.h"
-#include "slicehier.h"
-#include "parameters.h"
-
-#include "utilities.h"
-
-#include <iostream>
-using namespace std;
-
-int main(int argc, char *argv[])
-{
-   CommandOptions choice = {"", "", -1};
-   ParseCommandLine(argc, argv, choice);
-
-   cout << "===== BloBB (Block-packing with Branch-and-bound) =====" << endl;
-   cout << "floorplanType: " << choice.floorplanType << endl;
-   cout << "algorithmType: " << choice.algorithmType << endl;
-   cout << "block orientn: ";
-   switch (ENG_ORIENT_CONSIDERED)
-   {
-   case 1: cout << "--fixed-orient" << endl;
-      break;
-   case 2: cout << "--free-orient" << endl;
-      break;
-   default: cout << "ERROR: invalid value for \"ENG_ORIENT_CONSIDERED\" ("
-                 << ENG_ORIENT_CONSIDERED << ")." << endl;
-      exit(1);
-      break;
-   }
-
-   if (choice.algorithmType == "--backtrack")
-      PrintExtraBacktrack(choice);
-   else if (choice.algorithmType == "--optimal" ||
-            choice.algorithmType == "--enumerate")
-      PrintExtraEng();
-   else if (choice.algorithmType == "--hierarchical")
-      PrintExtraHierarchical();
-   cout << "=======================================================" << endl;
-
-   if (choice.floorplanType == "--slicing")
-   {
-      if (choice.algorithmType == "--optimal" ||
-          choice.algorithmType == "--backtrack" ||
-          choice.algorithmType == "--enumerate")
-         SliceEngine(argv, choice);
-      else
-         SliceHierEngine(argv, choice);
-   }
-   else if (choice.floorplanType == "--non-slicing")
-   {
-      if (choice.algorithmType == "--optimal" ||
-          choice.algorithmType == "--backtrack" ||
-          choice.algorithmType == "--enumerate")
-         NonsliceEngine(argv, choice);
-      else
-         cout << "Sorry!  Currently, non-slicing hierarchical block-packing "
-              << "is not supported." << endl;
-   }
-
-   cout.setf(ios::fixed);
-   cout.precision(2);
-   cout << "BloBB's total runtime: " << getTotalTime() << "s" << endl;
-   cout << "===== Thanks for using BloBB =====" << endl;
-   return 0;
-}
diff -druN BloBB_CompaSS_050315/BloBB/Makefile blob_compass/BloBB/Makefile
--- BloBB_CompaSS_050315/BloBB/Makefile	2005-03-14 22:40:43.000000000 -0800
+++ blob_compass/BloBB/Makefile	1969-12-31 16:00:00.000000000 -0800
@@ -1,76 +0,0 @@
-#/**************************************************************************
-#***    
-#*** Copyright (c) 2004 Regents of the University of Michigan,
-#***               Hayward H. Chan and Igor L. Markov
-#***
-#***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-#***  Original Affiliation:   EECS Department, 
-#***                          The University of Michigan,
-#***                          Ann Arbor, MI 48109-2122
-#***
-#***  Permission is hereby granted, free of charge, to any person obtaining 
-#***  a copy of this software and associated documentation files (the
-#***  "Software"), to deal in the Software without restriction, including
-#***  without limitation 
-#***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-#***  and/or sell copies of the Software, and to permit persons to whom the 
-#***  Software is furnished to do so, subject to the following conditions:
-#***
-#***  The above copyright notice and this permission notice shall be included
-#***  in all copies or substantial portions of the Software.
-#***
-#*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-#*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-#*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-#*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-#*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-#*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-#*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-#***
-#***
-#***************************************************************************/
-
-.SUFFIXES:        .o .cxx 
-
-CC = g++
-CCFLAGS = -Wall -O3 -ansi $(CCDIRS)
-PURIFY = purify -log-file=log.txt
-MOREOPT = -funroll-loops
-
-CCDIRS = -I../BTree -I../common -I../CompaSS 
-LDDIRS = -L../BTree -L../common -L../CompaSS 
-
-AR = ar cr
-
-blobb_OBJS = bound.o boundfixed.o boundst.o btreefromblobb.o datastr.o datastrhierst.o datastrst.o enginehierst.o enginest.o interface.o main.o nonslice.o parameters.o slice.o slicehier.o vectorize.o
-
-THISLIB = BloBB
-LIBNAME = lib$(THISLIB).a
-
-LDFINAL = $(CC)
-LIBBASE = ../lib
-LIBS = -L$(LIBBASE) -L. -l$(THISLIB) -lBloBB -lBTree -lcommon -lCompaSS
-
-# main.o nonslice.o datastr.o bound.o boundfixed.o slice.o datastrst.o boundst.o enginest.o datastrhierst.o vectorize.o enginehierst.o slicehier.o utilities.o interface.o parameters.o basepacking.o btree.o btreefromsstree.o btreefromblobb.o btreecompact.o btreecompactsstree.o datastrbacksoftst.o datastrfrontsoftst.o iosoftst.o
-
-# -----linking all together-----
-lib : $(LIBNAME)
-
-$(LIBNAME) : $(blobb_OBJS)
-	/bin/rm -f $(LIBNAME)
-	$(AR) $(LIBNAME) $(blobb_OBJS) 
-	/bin/rm -f $(LIBBASE)/$(LIBNAME)
-	ln -s ../BloBB/$(LIBNAME) $(LIBBASE)/$(LIBNAME)
-
-
-blobb : $(blobb_OBJS)
-	/bin/rm -f blobb
-	$(LDFINAL) -o blobb -static $(LIBS)
-	/bin/rm -f ../bin/blobb
-	ln -s ../BloBB/blobb ../bin/blobb
-
-.cxx.o : 
-	$(CC) $(CCFLAGS) -c $*.cxx
-
-clean :
-	rm -f *.o *~ blobb *.a
diff -druN BloBB_CompaSS_050315/BloBB/nonslice.cxx blob_compass/BloBB/nonslice.cxx
--- BloBB_CompaSS_050315/BloBB/nonslice.cxx	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/BloBB/nonslice.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,338 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "nonslice.h"
-#include "datastr.h"
-#include "bound.h"
-#include "boundfixed.h"
-#include "parameters.h"
-#include "utilities.h"
-#include "interface.h"
-
-#include <iostream>
-#include <fstream>
-#include <sstream>
-#include <string>
-#include <float.h>
-#include <limits.h>
-#include <iomanip>
-#include <algorithm>
-#include <cmath>
-using namespace std;
-
-// --------------------------------------------------------
-void NonsliceEngine(char *argv[],
-                    const CommandOptions& choice)
-{
-   ifstream infile;
-   ofstream outfile;
-   
-   OTree* ot_ptr = NULL;
-   FloorPlan best;
-   Dimension block[MAX_SIZE][ORIENT_NUM];
-   
-   double minEdge[MAX_SIZE];
-   bool same[MAX_BLOCK_NUM+1][MAX_BLOCK_NUM];
-   int blkBefore[MAX_SIZE] = {0};
-   OwnQueue<int> bContainer;
-   
-   infile.open(argv[1]);
-   Initialize(block, ot_ptr, infile);
-   infile.close();   
-   
-   InitializeBound(block, *ot_ptr, minEdge, same, blkBefore);
-   InitializeCounter();
-   for (int k = 0; k < ot_ptr ->BLOCK_NUM; k++)
-      bContainer.enqueue(k);
-
-   if (INF_SHOW_SIMILARITY_TABLE)
-   {
-      cout << "similarity table: " << endl;
-      PrintSimilarityTable(ot_ptr ->BLOCK_NUM, same, blkBefore);
-   }
-
-   if (choice.algorithmType == "--optimal")
-      BranchboundSearch(minEdge, same, blkBefore,
-                        block, *ot_ptr, bContainer, best);
-   else if (choice.algorithmType == "--backtrack")
-   {
-      BT_DEADSPACE_PERCENT = choice.dpercent;
-      BT_MIN_TOTAL = ot_ptr ->TOTAL_AREA * (1+BT_DEADSPACE_PERCENT);
-      BT_MIN_DEADSPACE = ot_ptr ->TOTAL_AREA * BT_DEADSPACE_PERCENT;
-      BacktrackSearch(minEdge, same, blkBefore,
-		      block, *ot_ptr, bContainer, best);
-   }
-   else if (choice.algorithmType == "--enumerate")
-      EnumerateSearch(minEdge, same, blkBefore,
-                      block, *ot_ptr, bContainer, best);
-   
-   outfile.open(argv[2]);
-   outputfp(block, best, outfile);
-   outfile.close();
-   cout << "Output written to " << argv[2] << "." << endl;
-
-   delete ot_ptr;
-}
-// --------------------------------------------------------
-void FindPacking(const ProceedType proceed,
-                 const CompareType compare,
-                 const double minEdge[],           // <-
-                 const bool same[][MAX_BLOCK_NUM], //  |-area min'n
-                 const int blkBefore[],            // <-
-                 Dimension block[][ORIENT_NUM], // <-
-                 OTree& ot,                     //  |---core engine
-                 OwnQueue<int>& bContainer,     //  |
-                 FloorPlan& best)               // <-                 
-{
-   static ofstream outs;
-   int qSize = bContainer.size();  
-      
-   if (qSize == 0)
-   {
-      double width = ot.width();
-      double height = ot.height();
-      double area = width * height;
-      if (compare(area, best.area))
-      {
-         // check if this is a better solution. If so,
-         // start counting from here
-         if (area < best.area)
-            counter[0][1] = counter[0][0]; 
-
-         best = ot;
-	 if (INF_FN_PREFIX != "")
-	 {
-	    stringstream filename;
-	    filename << INF_FN_PREFIX << counter[0][0] << INF_FN_SUFFIX;
-	    
-	    outs.open(filename.str().c_str());              
-	    outputfp(block, best, outs);
-	    outs.close();
-	 }
-
-	 if (INF_SHOW_INTERMEDIATES)
-	 {
-	    cout.setf(ios::fixed);
-	    cout.precision(2);
-	    cout << "[" << counter[0][0] << "] area: " << area
-		 << " (" << ((area / ot.TOTAL_AREA - 1) * 100) << "%) " 
-		 << setw(10) << getTotalTime() << endl;
-	 }
-
-         // ---file counter---
-         counter[0][0]++;
-      }
-      return;
-   }
-
-   for (int i = 0; i < 4; i++)
-   {
-      if (ot.push_tree(i))
-         for (int j = 0; j < qSize; j++)
-         {
-            int b = bContainer.dequeue();
-            ot.push_perm(b);
-            for (int k = 0; k < ENG_ORIENT_CONSIDERED; k++)
-            {
-               ot.push_orient(k);
-               ot.setpos_update(block, b);
-
-               counter[ot.perSize][0]++;
-               if (proceed(minEdge, same, blkBefore,
-                           bContainer, best, block, ot))
-               {
-                  counter[ot.perSize][1]++;
-                  FindPacking(proceed, compare,
-                              minEdge, same, blkBefore, block,
-                              ot, bContainer, best);       
-               }
-
-               ot.remove_block(b);
-               ot.pop_orient();
-            }
-            bContainer.enqueue(ot.pop_perm());
-
-            // landmarks, 2n of such marks during runtime
-            if (INF_SHOW_LANDMARKS && (ot.perSize == 0))
-	    {
-	       static int portion = 1;
-               cout << "finished " << setw(2) << portion << " / "
-		    << (2 * ot.BLOCK_NUM)
-                    << setw(8) << getTotalTime() << "s" << endl;
-	       portion++;
-	    }
-         }
-      ot.pop_tree();
-   }
-}
-// ========================================================
-void BranchboundSearch(const double minEdge[],           
-                       const bool same[][MAX_BLOCK_NUM], 
-                       const int blkBefore[],            
-                       Dimension block[][ORIENT_NUM], 
-                       OTree& ot,                     
-                       OwnQueue<int>& bContainer,                      
-                       FloorPlan& best)
-{
-   // fixed orientation or free orientation ?
-   ProceedType proceed = (ENG_ORIENT_CONSIDERED == 1)?
-      fixed_BranchBoundProceed : BranchBoundProceed;
-   
-   counterName[0] = "visited";
-   counterName[1] = "afterPrune";   
-   best.area = ot.TOTAL_AREA * (1 + ENG_INIT_DEADSPACE_PERCENT);
-   best.width = DBL_MAX;
-   best.height = DBL_MAX;
-   best.blockNum = 0;
-   while (best.blockNum == 0)
-   {
-      cout.setf(ios::fixed);
-      cout.precision(2);
-      cout << "Considering solutions with no more than "
-	   << ((best.area/ot.TOTAL_AREA - 1) * 100) << "% deadspace." << endl;
-      FindPacking(proceed, BranchBoundCompare,
-                  minEdge, same, blkBefore, 
-                  block, ot, bContainer, best);
-      if (INF_SHOW_PRUNED_TABLE)
-	 OutputCounter(cout, 2, ot.BLOCK_NUM+1);
-      
-      if (best.blockNum == 0)
-      {
-	 best.area *= ENG_DEADSPACE_INCRE;
-	 InitializeCounter();
-	 cout << "No solution found." << endl;
-      }
-   }
-   cout.setf(ios::fixed);
-   cout.precision(2);
-   cout << "width:  " << setw(10) << best.width << endl;
-   cout << "height: " << setw(10) << best.height << endl;
-   cout << "total area: " << best.area 
-        << " (" <<  (best.area / ot.TOTAL_AREA * 100 - 100) << "%)" << endl;
-   cout << "block area: " << ot.TOTAL_AREA << endl;
-}
-// --------------------------------------------------------
-void BacktrackSearch(const double minEdge[],
-                     const bool same[][MAX_BLOCK_NUM],
-                     const int blkBefore[],
-                     Dimension block[][ORIENT_NUM],
-                     OTree& ot,
-                     OwnQueue<int>& bContainer,
-                     FloorPlan& best)
-{
-   // fixed or free orientation?
-   ProceedType proceed = (ENG_ORIENT_CONSIDERED == 1)?
-      fixed_BacktrackProceed : BacktrackProceed;
-   
-   counterName[0] = "visited";
-   counterName[1] = "afterPrune";   
-   best.area = ot.TOTAL_AREA;
-   best.width = DBL_MAX;
-   best.height = DBL_MAX;
-   best.blockNum = 0;
-
-   best.area *= (1 + BT_DEADSPACE_PERCENT + 0.0001);
-   FindPacking(proceed, BacktrackCompare,
-               minEdge, same, blkBefore, 
-               block, ot, bContainer, best);
-   
-   if (INF_SHOW_PRUNED_TABLE)
-      OutputCounter(cout, 2, ot.BLOCK_NUM+1);
-
-   cout.setf(ios::fixed);
-   cout.precision(2);
-   if (best.blockNum == 0)
-      cout << "No solution found with no greater than "
-           << (BT_DEADSPACE_PERCENT * 100) << "% deadspace." << endl;
-   else
-   {
-      cout << "width:  " << setw(10) << best.width << endl;
-      cout << "height: " << setw(10) << best.height << endl;
-      cout << "total area: " << best.area 
-           << " (" <<  (best.area / ot.TOTAL_AREA * 100 - 100) << "%)" << endl;
-      cout << "block area: " << ot.TOTAL_AREA << endl;
-   }
-}   
-// --------------------------------------------------------
-void EnumerateSearch(const double minEdge[],           
-                     const bool same[][MAX_BLOCK_NUM], 
-                     const int blkBefore[],            
-                     Dimension block[][ORIENT_NUM], 
-                     OTree& ot,                     
-                     OwnQueue<int>& bContainer,                
-                     FloorPlan& best)
-{
-   // fixed or free orientation?
-   ProceedType proceed = (ENG_ORIENT_CONSIDERED == 1)?
-      fixed_EnumerateProceed : EnumerateProceed;
-   
-   counterName[0] = "visited";
-   counterName[1] = "afterPrune";   
-   best.area = ot.TOTAL_AREA * (1 + ENG_INIT_DEADSPACE_PERCENT);
-   best.width = DBL_MAX;
-   best.height = DBL_MAX;
-   best.blockNum = 0;
-   while (best.blockNum == 0)
-   {
-      cout.setf(ios::fixed);
-      cout.precision(2);
-      cout << "Considering solutions with no more than "
-	   << ((best.area/ot.TOTAL_AREA - 1) * 100) << "% deadspace." << endl;
-      FindPacking(proceed, EnumerateCompare,
-                  minEdge, same, blkBefore, 
-                  block, ot, bContainer, best);
-
-      if (INF_SHOW_PRUNED_TABLE)
-	 OutputCounter(cout, 2, ot.BLOCK_NUM+1);
-
-      cout.setf(ios::fixed);
-      cout.precision(2);
-      if (best.blockNum == 0)
-      {
-	 best.area *= ENG_DEADSPACE_INCRE;      
-	 InitializeCounter();
-	 cout << "No solution found." << endl;
-      }
-   }
-   cout << "# non-symmetric optimal solutions:   "
-	<< counter[0][0]-counter[0][1] << endl;
-   
-   if (INF_FN_PREFIX != "")
-      cout << "Solutions [" << counter[0][1] << "] to [" << counter[0][0]-1
-	   << "] correspond to optimal solutions." << endl;
-
-   cout << "width:  " << setw(10) << best.width << endl;
-   cout << "height: " << setw(10) << best.height << endl;
-   cout << "total area: " << best.area
-        << " (" <<  (best.area / ot.TOTAL_AREA * 100 - 100) << "%)" << endl;
-   cout << "block area: " << ot.TOTAL_AREA << endl;
-}
-// ========================================================
diff -druN BloBB_CompaSS_050315/BloBB/nonslice.h blob_compass/BloBB/nonslice.h
--- BloBB_CompaSS_050315/BloBB/nonslice.h	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/BloBB/nonslice.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,78 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef NONSLICE_H
-#define NONSLICE_H
-
-#include "stackqueue.h"
-#include "datastr.h"
-#include "bound.h"
-#include "interface.h"
-
-// ========================================================
-void NonsliceEngine(char *argv[], const CommandOptions& choice);
-// --------------------------------------------------------
-void FindPacking(const ProceedType proceed,
-                 const CompareType compare,
-                 const double minEdge[],
-                 const bool same[][MAX_BLOCK_NUM],
-                 const int blkBefore[],
-                 Dimension block[][ORIENT_NUM],
-                 OTree& ot,
-                 OwnQueue<int>& bContainer,
-                 FloorPlan& best);
-// ========================================================
-void BranchboundSearch(const double minEdge[],           
-                       const bool same[][MAX_BLOCK_NUM], 
-                       const int blkBefore[],            
-                       Dimension block[][ORIENT_NUM], 
-                       OTree& ot,                     
-                       OwnQueue<int>& bContainer,                      
-                       FloorPlan& best);
-// --------------------------------------------------------
-void BacktrackSearch(const double minEdge[],           
-                     const bool same[][MAX_BLOCK_NUM], 
-                     const int blkBefore[],            
-                     Dimension block[][ORIENT_NUM], 
-                     OTree& ot,                     
-                     OwnQueue<int>& bContainer,                
-                     FloorPlan& best);
-// --------------------------------------------------------
-void EnumerateSearch(const double minEdge[],           
-                     const bool same[][MAX_BLOCK_NUM], 
-                     const int blkBefore[],            
-                     Dimension block[][ORIENT_NUM], 
-                     OTree& ot,                     
-                     OwnQueue<int>& bContainer,                
-                     FloorPlan& best);
-// ========================================================
-   
-#endif
diff -druN BloBB_CompaSS_050315/BloBB/optoprblobb.h blob_compass/BloBB/optoprblobb.h
--- BloBB_CompaSS_050315/BloBB/optoprblobb.h	2004-05-10 13:45:40.000000000 -0700
+++ blob_compass/BloBB/optoprblobb.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,70 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef OPTOPR_H
-#define OPTOPR_H
-
-#include "datastrhierst.h"
-#include "datastrfrontsoftst.h"
-
-// --------------------------------------------------------
-class SoftSliceRecordFromBloBB : public SoftSliceRecord
-{
-public:
-   inline SoftSliceRecordFromBloBB(const Cluster& cluster);
-};
-// --------------------------------------------------------
-
-// =========================
-//      IMPLEMENTATIONS
-// =========================
-inline SoftSliceRecordFromBloBB::SoftSliceRecordFromBloBB(
-   const Cluster& cluster)
-   : SoftSliceRecord()
-{
-   minArea = cluster.area + cluster.deadspace;
-   minDeadspace = cluster.deadspace;
-
-   expression.resize(cluster.expression.size());
-   for (unsigned int i = 0; i < cluster.expression.size(); i++)
-   {
-      int sign = cluster.expression[i];
-      if (sign == cluster.PLUS)
-         expression[i] = SoftSTree::PLUS;
-      else if (sign == cluster.STAR)
-         expression[i] = SoftSTree::STAR;
-      else
-         expression[i] = sign;
-   }
-}
-// --------------------------------------------------------
-
-#endif
diff -druN BloBB_CompaSS_050315/BloBB/parameters.cxx blob_compass/BloBB/parameters.cxx
--- BloBB_CompaSS_050315/BloBB/parameters.cxx	2003-11-26 17:33:42.000000000 -0800
+++ blob_compass/BloBB/parameters.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,43 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "parameters.h"
-
-// used in bound.cpp, boundst.cpp
-double BT_DEADSPACE_PERCENT = -1;
-double BT_MIN_TOTAL = -1;
-double BT_MIN_DEADSPACE = -1;
-
-// used in nonslice.cpp, slice.cpp
-int ENG_ORIENT_CONSIDERED = ENG_UNDEFINED_SENTINEL;
-double ENG_DEADSPACE_INCRE = ENG_UNDEFINED_SENTINEL;
-double ENG_INIT_DEADSPACE_PERCENT = ENG_UNDEFINED_SENTINEL;
-
diff -druN BloBB_CompaSS_050315/BloBB/parameters.h blob_compass/BloBB/parameters.h
--- BloBB_CompaSS_050315/BloBB/parameters.h	2004-05-10 13:23:35.000000000 -0700
+++ blob_compass/BloBB/parameters.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,94 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef PARAMETERS_H
-#define PARAMETERS_H
-
-#include <string>
-using namespace std;
-
-// defined in interface.cpp
-// mainly used by nonslice.cpp, enginest.cpp/slice.cpp
-const double INF_DEADSPACE_DEFAULT = 0.04;
-const string INF_EXTRA_PREFIX = "EXTRA: ";
-
-extern string INF_FN_PREFIX;
-extern string INF_FN_SUFFIX;
-extern bool INF_SHOW_INTERMEDIATES;
-extern bool INF_SHOW_LANDMARKS;
-extern bool INF_SHOW_PRUNED_TABLE;
-extern bool INF_SHOW_SIMILARITY_TABLE;
-extern bool INF_SHOW_POLISH_EXPRESSION;
-
-// defined in parameters.cpp
-// used in nonslice.cpp, enginest.cpp/slice.cpp
-const int ENG_UNDEFINED_SENTINEL = -1;
-const int ENG_ORIENT_CONSIDERED_DEFAULT = 2;
-const double ENG_DEADSPACE_INCRE_DEFAULT = 1.05;
-const double ENG_INIT_DEADSPACE_PERCENT_FIXED_DEFAULT = 0.10;
-const double ENG_INIT_DEADSPACE_PERCENT_FREE_DEFAULT = 0.05;
-
-extern int ENG_ORIENT_CONSIDERED;
-extern double ENG_DEADSPACE_INCRE;
-extern double ENG_INIT_DEADSPACE_PERCENT;
-
-// defined in parameters.cpp
-// used in bound.cpp, boundst.cpp
-extern double BT_DEADSPACE_PERCENT;
-extern double BT_MIN_TOTAL;
-extern double BT_MIN_DEADSPACE;
-
-// defined in enginehierst.cpp
-// used in enginehierst.cpp
-const int HIER_CLUSTER_BASE_DEFAULT = 8;
-const double HIER_AR_FIXED_DEFAULT = 1.5;
-const double HIER_AR_FREE_DEFAULT = 1.5;
-const double HIER_AR_INCRE_DEFAULT = 1.5;
-const double HIER_BEST_AREA_INCRE_FIXED_DEFAULT = 1.10;
-const double HIER_BEST_AREA_INCRE_FREE_DEFAULT = 1.05;
-const double HIER_CLUSTER_AREA_DEV_DEFAULT = 2;
-const double HIER_SIDE_RESOLUTION_DEFAULT = 1.9;
-const unsigned int HIER_SORT_VEC_MAX_SIZE = 300000;
-const bool HIER_COMPACT_DEFAULT = false;
-
-const int HIER_UNDEFINED_SENTINEL = -1;
-extern int HIER_CLUSTER_BASE;
-extern bool HIER_USE_AR;  
-extern double HIER_AR;    
-extern double HIER_AR_INCRE;
-extern double HIER_BEST_AREA_INCRE;
-extern double HIER_CLUSTER_AREA_DEV;
-extern double HIER_SIDE_RESOLUTION;
-extern const unsigned int HIER_SORT_VEC_MAX_SIZE;
-extern bool HIER_COMPACT;
-extern bool HIER_OPTOPR;
-
-#endif
diff -druN BloBB_CompaSS_050315/BloBB/regression blob_compass/BloBB/regression
--- BloBB_CompaSS_050315/BloBB/regression	2005-03-14 22:21:55.000000000 -0800
+++ blob_compass/BloBB/regression	1969-12-31 16:00:00.000000000 -0800
@@ -1,42 +0,0 @@
-#!/bin/sh 
-
-DIFF=/usr/bin/diff
-WC=/usr/bin/wc
-RM=/bin/rm
-RELEASE=050315
-PROG=blobb
-BASELINE=expected_"$RELEASE".out
-INPUTS=../TESTS/*
-
-if [ -f new.out ]; then
-    echo "new.out found"
-    if [ -L new.out ]; then
-        echo "Warning: new.out is a link, removing it can be dangerous"
-        $RM -i new.out
-    else
-        $RM -f new.out
-    fi
-    echo "new.out removed"
-fi
-
-for i in $INPUTS; do
-    echo "----- Running $i ..." >> new.out
-    echo "----- Running $i ..."
-
-    $PROG $i dummy_output --HIER_CLUSTER_BASE 4 >> new.out
-    echo "OK"
-done
-
-if [ -f dummy_output ]; then
-   $RM dummy_output
-fi
-
-sed 's/time:/\ntime:/' $BASELINE | egrep -i -v time: > $BASELINE.notime
-sed 's/time:/\ntime:/' new.out | egrep -i -v time: > new.out.notime
-
-$DIFF new.out.notime $BASELINE.notime > diffs.out
-echo "Differences from precomputed results" 
-echo "  lines:  words:  bytes:    error log:" 
-$WC diffs.out 
-
-$RM -f new.out new.out.notime $BASELINE.notime
diff -druN BloBB_CompaSS_050315/BloBB/slice.cxx blob_compass/BloBB/slice.cxx
--- BloBB_CompaSS_050315/BloBB/slice.cxx	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/BloBB/slice.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,267 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "slice.h"
-#include "stackqueue.h"
-#include "datastrst.h"
-#include "boundst.h"
-#include "enginest.h"
-
-#include "parameters.h"
-#include "utilities.h"
-#include "interface.h"
-
-#include <iostream>
-#include <fstream>
-#include <iomanip>
-using namespace std;
-
-// --------------------------------------------------------
-void SliceEngine(char* argv[],
-		 const CommandOptions& choice)
-{
-   Dimension block[MAX_SIZE][ORIENT_NUM];
-   bool same[MAX_BLOCK_NUM][MAX_BLOCK_NUM];
-   int blkBefore[MAX_SIZE];
-
-   STree* st_ptr = NULL;
-   OwnQueue<int> bContainer;
-   SliceRecord best;
-   FloorPlan fp;
-
-   ifstream infile;
-   ofstream outfile;
-   int blockNum = 0;
-
-   infile.open(argv[1]);
-   InitializeSlice(block, st_ptr, blockNum, infile);
-   InitializeBound(block, *st_ptr, same, blkBefore);
-   infile.close();
-      
-   // size of bContainer is 1 LESS than st_ptr ->BLOCK_NUM
-   for (int i = 1; i < blockNum; i++)
-      bContainer.enqueue(i);
-   
-   if (INF_SHOW_SIMILARITY_TABLE)
-   {
-      cout << "similarity table: " << endl;
-      PrintSimilarityTable(st_ptr ->BLOCK_NUM, same, blkBefore);
-   }
-
-   if (choice.algorithmType == "--optimal")
-      BranchBoundSearch(block, same, blkBefore,
-			*st_ptr, bContainer, best);
-   else if (choice.algorithmType == "--backtrack")
-   {
-      BT_DEADSPACE_PERCENT = choice.dpercent;
-      BT_MIN_DEADSPACE = st_ptr ->TOTAL_AREA * BT_DEADSPACE_PERCENT;
-      BacktrackSearch(block, same, blkBefore,
-		      *st_ptr, bContainer, best);
-   }
-   else if (choice.algorithmType == "--enumerate")
-      EnumerateSearch(block, same, blkBefore,
-		      *st_ptr, bContainer, best);
-
-   if (best.blockNum > 0)
-   {  // Evaluate gives seg fault if best.blockNum == 0
-      Evaluate(block, best, fp);
-      outfile.open(argv[2]);
-      outputfp(block, fp, outfile);
-      outfile.close();
-      cout << "Ouput written to " << argv[2] << "." << endl;
-   }
-   else
-      cout << "No output written to " << argv[2] << "." << endl;
-
-   delete st_ptr;
-}
-// --------------------------------------------------------
-void BranchBoundSearch(const Dimension block[][ORIENT_NUM],
-		       const bool same[][MAX_BLOCK_NUM],
-		       const int blkBefore[],
-		       STree& st,
-		       OwnQueue<int>& bContainer,
-		       SliceRecord& best)
-{
-   counterName[0] = "visited";
-   counterName[1] = "operand";
-   counterName[2] = "opd left";
-   counterName[3] = "operator";
-   counterName[4] = "opr left";
-   best.area = st.TOTAL_AREA * (1 + ENG_INIT_DEADSPACE_PERCENT);
-   best.deadspace = best.area - st.TOTAL_AREA;
-   while (best.blockNum == 0)
-   {
-      cout.setf(ios::fixed);
-      cout.precision(2);
-      cout << "Considering solutions with no more than "
-	   << (best.deadspace / st.TOTAL_AREA * 100) << "% deadspace." << endl;
-
-      st.push_orient(0);
-      st.push_operand(0, block);
-      
-      FindSlice(BranchBoundOperandBound,
-		BranchBoundOperatorBound,
-		BranchBoundCompare,
-		block, same, blkBefore, 
-                st, bContainer, best);
-
-      st.pop_operand();
-      st.pop_orient();
-
-      if (INF_SHOW_PRUNED_TABLE)
-	 OutputCounter(cout, 5, 2*st.BLOCK_NUM);
-      
-      if (best.blockNum == 0)
-      {
-	 best.area *= ENG_DEADSPACE_INCRE;
-	 best.deadspace = best.area - st.TOTAL_AREA;
-	 InitializeCounter();
-	 cout << "No solution found." << endl;
-      }
-   }
-   cout.setf(ios::fixed);
-   cout.precision(2);
-   cout << "width:  " << setw(10) << best.width << endl;
-   cout << "height: " << setw(10) << best.height << endl;
-   cout << "total area: " << best.area 
-        << " (" <<  ((best.deadspace / st.TOTAL_AREA) * 100) << "%)" << endl;
-   cout << "block area: " << st.TOTAL_AREA << endl;
-   if (INF_SHOW_POLISH_EXPRESSION)
-      outputNPE(best, cout);
-}
-// --------------------------------------------------------
-void BacktrackSearch(const Dimension block[][ORIENT_NUM],
-		     const bool same[][MAX_BLOCK_NUM],
-		     const int blkBefore[],
-		     STree& st,
-		     OwnQueue<int>& bContainer,
-		     SliceRecord& best)
-{
-   counterName[0] = "visited";
-   counterName[1] = "operand";
-   counterName[2] = "opd left";
-   counterName[3] = "operator";
-   counterName[4] = "opr left";
-   best.area = st.TOTAL_AREA * (1 + BT_DEADSPACE_PERCENT + 0.0001);
-   best.deadspace = best.area - st.TOTAL_AREA;
-
-   st.push_orient(0);
-   st.push_operand(0, block);
-   
-   FindSlice(BacktrackOperandBound,
-	     BacktrackOperatorBound,
-	     BacktrackCompare,
-	     block, same, blkBefore, 
-	     st, bContainer, best);
-
-   st.pop_operand();
-   st.pop_orient();
-
-   if (INF_SHOW_PRUNED_TABLE)
-      OutputCounter(cout, 5, 2*st.BLOCK_NUM);
-
-   cout.setf(ios::fixed);
-   cout.precision(2);
-   if (best.blockNum == 0)
-      cout << "No solution found with no greater than "
-           << (BT_DEADSPACE_PERCENT * 100) << "% deadspace." << endl;
-   else
-   {
-      cout << "width:  " << setw(10) << best.width << endl;
-      cout << "height: " << setw(10) << best.height << endl;
-      cout << "total area: " << best.area 
-           << " (" <<  (best.deadspace / st.TOTAL_AREA * 100) << "%)" << endl;
-      cout << "block area: " << st.TOTAL_AREA << endl;   
-      if (INF_SHOW_POLISH_EXPRESSION)
-	 outputNPE(best, cout);
-   }
-}
-// --------------------------------------------------------
-void EnumerateSearch(const Dimension block[][ORIENT_NUM],
-		     const bool same[][MAX_BLOCK_NUM],
-		     const int blkBefore[],
-		     STree& st,
-		     OwnQueue<int>& bContainer,
-		     SliceRecord& best)
-{
-   counterName[0] = "visited";
-   counterName[1] = "operand";
-   counterName[2] = "opd left";
-   counterName[3] = "operator";
-   counterName[4] = "opr left";
-   best.area = st.TOTAL_AREA * (1 + ENG_INIT_DEADSPACE_PERCENT);
-   best.deadspace = best.area - st.TOTAL_AREA;
-   while (best.blockNum == 0)
-   {
-      cout.setf(ios::fixed);
-      cout.precision(2);
-      cout << "Considering solutions with no more than "
-	   << (best.deadspace / st.TOTAL_AREA * 100) << "% deadspace." << endl;
-      
-      st.push_orient(0);
-      st.push_operand(0, block);
-      
-      FindSlice(EnumerateOperandBound,
-		EnumerateOperatorBound,
-		EnumerateCompare,
-		block, same, blkBefore, 
-                st, bContainer, best);
-
-      st.pop_operand();
-      st.pop_orient();
-
-      if (INF_SHOW_PRUNED_TABLE)
-	 OutputCounter(cout, 5, 2*st.BLOCK_NUM);
-      
-      if (best.blockNum == 0)
-      {
-	 best.area *= ENG_DEADSPACE_INCRE;
-	 best.deadspace = best.area - st.TOTAL_AREA;
-	 InitializeCounter();
-	 cout << "No solution found." << endl;
-      }
-   }
-   
-   cout << "# non-symmetric optimal solutions:   "
-	<< counter[0][0]-counter[0][1] << endl;
-   
-   if (INF_FN_PREFIX != "")
-      cout << "Solutions [" << counter[0][1] << "] to [" << counter[0][0]-1
-	   << "] correspond to optimal solutions." << endl;
-   
-   cout << "width:  " << setw(10) << best.width << endl;
-   cout << "height: " << setw(10) << best.height << endl;
-   cout << "total area: " << best.area
-        << " (" <<  (best.deadspace / st.TOTAL_AREA * 100) << "%)" << endl;
-   cout << "block area: " << st.TOTAL_AREA << endl;
-}
-// ========================================================
diff -druN BloBB_CompaSS_050315/BloBB/slice.h blob_compass/BloBB/slice.h
--- BloBB_CompaSS_050315/BloBB/slice.h	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/BloBB/slice.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,66 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef SLICE_H
-#define SLICE_H
-
-#include "stackqueue.h"
-#include "datastrst.h"
-#include "interface.h"
-
-#include <iostream>
-using namespace std;
-
-void SliceEngine(char* argv[],
-		 const CommandOptions& choice);
-// ========================================================
-void BranchBoundSearch(const Dimension block[][ORIENT_NUM],
-		       const bool same[][MAX_BLOCK_NUM],
-		       const int blkBefore[],
-		       STree& st,
-		       OwnQueue<int>& bContainer,
-		       SliceRecord& best);
-// --------------------------------------------------------
-void BacktrackSearch(const Dimension block[][ORIENT_NUM],
-		     const bool same[][MAX_BLOCK_NUM],
-		     const int blkBefore[],
-		     STree& st,
-		     OwnQueue<int>& bContainer,
-		     SliceRecord& best);
-// --------------------------------------------------------
-void EnumerateSearch(const Dimension block[][ORIENT_NUM],
-		     const bool same[][MAX_BLOCK_NUM],
-		     const int blkBefore[],
-		     STree& st,
-		     OwnQueue<int>& bContainer,
-		     SliceRecord& best);
-// ========================================================
-#endif
diff -druN BloBB_CompaSS_050315/BloBB/slicehier.cxx blob_compass/BloBB/slicehier.cxx
--- BloBB_CompaSS_050315/BloBB/slicehier.cxx	2004-05-12 10:52:40.000000000 -0700
+++ blob_compass/BloBB/slicehier.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,167 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "datastrhierst.h"
-#include "enginehierst.h"
-#include "vectorize.h"
-#include "utilities.h"
-#include "interface.h"
-#include "parameters.h"
-
-#include "btreefromblobb.h"
-#include "btreecompactsstree.h"
-#include "optoprblobb.h"
-
-#include <iostream>
-#include <fstream>
-#include <queue>
-#include <iomanip>
-using namespace std;
-
-void SliceHierEngine(char *argv[],
-                     const CommandOptions& choice)
-{
-   ifstream infile;
-   ofstream outfile;
-
-   vector< vector<Dimension> > block;
-   int blockNum = 0;   
-   FloorPlanVec fp;
-
-   vector<Cluster> clusters;
-   vector<ClusterSet> clusterSets;
-   
-   cout.setf(ios::fixed);
-   cout.precision(0);
-   
-   infile.open(argv[1]);
-   InitializeSlice(block, blockNum, infile);
-   infile.close();
-   
-   InitializeCluster(block, blockNum, clusters);
-   if (INF_SHOW_INTERMEDIATES)
-      cout << "===== after InitializeCluster =====" << endl;
-   
-   while (clusters.size() > 1)
-   {
-      if (INF_SHOW_INTERMEDIATES)
-         cout << "===== Grouping " << clusters.size()
-              << " clusters... " << endl;
-      GroupClusterSets(clusters, clusterSets);
-      
-      int clusterSetNum = clusterSets.size();
-      HIER_USE_AR = clusterSetNum > 1; // HIER_CLUSTER_BASE;
-
-      if (INF_SHOW_INTERMEDIATES)
-         cout << "===== Packing into " << clusterSets.size()
-              << " clusters... " << endl;
-      CoreEngine(blockNum, clusterSets, clusters);
-      
-      int clusterNum = clusters.size();
-      double totalArea = 0;
-      double deadspace = 0;
-      for (int i = 0; i < clusterNum; i++)
-      {
-         totalArea += clusters[i].area;
-         deadspace += clusters[i].deadspace;
-      }
-      if (INF_SHOW_INTERMEDIATES)
-      {
-	 cout.setf(ios::fixed);
-	 cout.precision(2);
-	 cout << endl;
-         cout << "totalArea: " << setw(11) << totalArea 
-              << " deadspace: " << setw(11) << deadspace 
-              << " (" << ((deadspace / totalArea) * 100) 
-              << "%) time: " << setw(5) << getTotalTime() << endl;
-         cout << endl;
-      }
-   }
-
-   cout.setf(ios::fixed);
-   cout.precision(2);
-   PrintDimensions(clusters[0].width, clusters[0].height);
-   PrintAreas(clusters[0].deadspace, clusters[0].area);
-   cout << endl;
-   PrintUtilization(clusters[0].deadspace, clusters[0].area);
-   cout << endl;
-
-   Evaluate(block, clusters[0], fp);   
-   SoftPacking *spk_ptr = NULL;
-   
-   // ----optimizing operators-----
-   if (HIER_OPTOPR)
-   {
-      cout << "Optimizing operators in the Polish expression..." << endl;
-      infile.clear();
-      infile.open(argv[1]);
-      BlockInfoType blockinfo(infile);
-      infile.close();
-
-      SoftSliceRecordFromBloBB ssr(clusters[0]);   
-      spk_ptr = new SoftPacking(ssr, blockinfo);
-
-      cout << "After operator optimization," << endl;
-      PrintDimensions(spk_ptr->totalWidth, spk_ptr->totalHeight);
-      PrintAreas(spk_ptr->deadspace, spk_ptr->blockArea);
-      cout << endl;
-      PrintUtilization(spk_ptr->deadspace, spk_ptr->blockArea);
-      cout << endl;
-   }
-   else
-      spk_ptr = new SoftPackingFromBloBB(block, clusters[0], fp);
-
-   // ----compaction-----
-   if (HIER_COMPACT)
-   {
-      cout << "Compacting..." << endl;
-      BTreeCompactSlice(*spk_ptr, argv[2]);
-   }
-   else
-   {
-      outfile.open(argv[2]);
-      spk_ptr->output(outfile);
-
-      if (outfile.good())
-         cout << "Output successfully written to " << argv[2] << endl;
-      else
-      {
-         cout << "Something wrong with the file " << argv[2] << endl;
-         exit(1);
-      }
-      outfile.close();
-   }
-   cout << endl;
-   delete spk_ptr;
-}
-// --------------------------------------------------------
-   
-
diff -druN BloBB_CompaSS_050315/BloBB/slicehier.h blob_compass/BloBB/slicehier.h
--- BloBB_CompaSS_050315/BloBB/slicehier.h	2003-11-26 17:33:42.000000000 -0800
+++ blob_compass/BloBB/slicehier.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,41 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef SLICEHIER_H
-#define SLICEHIER_H
-
-#include "interface.h"
-
-// ------interface function of "--slicing" "--hierarchical"-----
-void SliceHierEngine(char *argv[], const CommandOptions& choice);
-
-#endif
-
diff -druN BloBB_CompaSS_050315/BloBB/stackqueue.h blob_compass/BloBB/stackqueue.h
--- BloBB_CompaSS_050315/BloBB/stackqueue.h	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/BloBB/stackqueue.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,165 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef STACKQUEUE_H
-#define STACKQUEUE_H
-
-#include <iostream>
-using namespace std;
-
-const int MAX_SIZE = 2001; // ONE MORE THAN max-handle size
-
-// -----STACK AND QUEUE WITH NO ERROR HANDLING AT ALL------
-template <typename T>
-class OwnStack
-{
-public:
-   OwnStack();
-   int size() const;
-
-   void push(const T& newItem);
-   T pop();
-
-   T operator[](int index) const;
-   T top() const;
-
-private:
-   int next;
-   T item[MAX_SIZE];
-};
-// --------------------------------------------------------
-template <typename T>
-class OwnQueue
-{
-public:
-   OwnQueue();
-   int size() const;
-
-   void enqueue(const T& newItem);
-   T dequeue();
-
-   T operator[](int index) const;
-   T front() const;
-   T back() const;
-
-private:
-   int head;
-   int tail;
-   T item[MAX_SIZE];
-};
-
-
-// -----IMPLEMENTATIONS------------------------------------
-// -----OwnStack CLASS MEMBER FUNCTIONS--------------------
-template <typename T>
-OwnStack<T>::OwnStack() : next(0)
-{}
-// --------------------------------------------------------
-template <typename T>
-int OwnStack<T>::size() const
-{
-   return next;
-}
-// --------------------------------------------------------
-template <typename T>
-void OwnStack<T>::push(const T& newItem)
-{
-   item[next++] = newItem;
-}
-// --------------------------------------------------------
-template <typename T>
-T OwnStack<T>::pop()
-{
-   return item[--next];
-}
-// --------------------------------------------------------
-template <typename T>
-T OwnStack<T>::operator [](int index) const
-{
-   return item[index];
-}
-// --------------------------------------------------------
-template <typename T>
-T OwnStack<T>::top() const
-{
-   return item[next-1];
-}
-// -----OwnQueue CLASS MEMBER FUNCTIONS--------------------
-template <typename T>
-OwnQueue<T>::OwnQueue() : head(0), tail(0)
-{}
-// --------------------------------------------------------
-template <typename T>
-int OwnQueue<T>::size() const
-{
-   return (tail >= head)? (tail-head) : (tail-head+MAX_SIZE);
-}
-// --------------------------------------------------------
-template <typename T>
-void OwnQueue<T>::enqueue(const T& newItem)
-{
-   item[tail++] = newItem;
-   tail %= MAX_SIZE;
-}
-// --------------------------------------------------------
-template <typename T>
-T OwnQueue<T>::dequeue()
-{
-   T result = item[head];
-   head++;
-   head %= MAX_SIZE;
-   return result;
-}
-// --------------------------------------------------------
-template <typename T>
-T OwnQueue<T>::operator [](int index) const
-{
-   index += head;
-   index %= MAX_SIZE;
-   return item[index];
-}
-// --------------------------------------------------------
-template <typename T>
-T OwnQueue<T>::front() const
-{
-   return item[head];
-}
-// --------------------------------------------------------
-template <typename T>
-T OwnQueue<T>::back() const
-{
-   int index = tail-1;
-   if (index < 0)
-      index += MAX_SIZE;
-   return item[index];
-}
-// --------------------------------------------------------
-#endif
diff -druN BloBB_CompaSS_050315/BloBB/vectorize.cxx blob_compass/BloBB/vectorize.cxx
--- BloBB_CompaSS_050315/BloBB/vectorize.cxx	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/BloBB/vectorize.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,253 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "vectorize.h"
-#include "datastrst.h"
-#include "datastrhierst.h"
-#include "parameters.h"
-
-#include <iostream>
-using namespace std;
-
-// --------------------------------------------------------
-void InitializeSlice(vector< vector<Dimension> >& block,
-                     int& blockNum,
-                     istream& ins)
-{
-   double area = 0;
-   ins >> blockNum;
-
-   block.resize(blockNum);
-   for (int i = 0; i < blockNum; i++)
-      block[i].resize(ORIENT_NUM);
-
-   for (int i = 0; i < blockNum; i++)
-   {
-      double width, height;
-      ins >> width >> height;
-      for (int j = 0; j < ORIENT_NUM; j++)
-         if (j % ENG_ORIENT_CONSIDERED == 0)
-         {
-            block[i][j].width = width;
-            block[i][j].height = height;
-         }
-         else if (j % ENG_ORIENT_CONSIDERED == 1)
-         {
-            block[i][j].width = height;
-            block[i][j].height = width;
-         }
-	 else
-	 {
-	    cout << "ERROR: invalid \"ENG_ORIENT_CONSIDERED\" ("
-		 << ENG_ORIENT_CONSIDERED << ")." << endl;
-	    exit(1);
-	 }
-      area += width * height;
-   }   
-}
-// --------------------------------------------------------
-void InitializeCluster(const vector< vector<Dimension> >& block,
-                       int blockNum,
-                       vector<Cluster>& clusters)
-{
-   for (int i = 0; i < blockNum; i++)
-   {
-      Cluster c(blockNum);
-      
-      c.BLBlock = i;
-      c.width = block[i][0].width;
-      c.height = block[i][0].height;
-      c.area = c.width * c.height;
-      c.deadspace = 0;
-
-      c.expression.push_back(i);
-      c.orient.push_back(0);
-
-      clusters.push_back(c);
-   }
-}
-// --------------------------------------------------------
-void Evaluate(const vector< vector<Dimension> >& block,
-              const Cluster& finalCluster,
-              FloorPlanVec& fp)
-{
-   const int EXPR_SIZE = finalCluster.expression.size();
-   const int BLOCK_NUM = finalCluster.orient.size();
-
-   stack<int> temp_expr;
-   stack<int> temp_orient;
-   vector<TreeNode> tree(EXPR_SIZE);
-   int next = 0;
-
-   for (int i = 0; i < EXPR_SIZE; i++)
-      temp_expr.push(finalCluster.expression[i]);
-
-   for (int i = 0; i < BLOCK_NUM; i++)
-      temp_orient.push(finalCluster.orient[i]);
-
-   // ---initialize fp---
-   fp.xLoc.resize(BLOCK_NUM);
-   fp.yLoc.resize(BLOCK_NUM);
-   fp.orient.resize(BLOCK_NUM);
-
-   ConstructTree(block, BLOCK_NUM, temp_expr, temp_orient, tree, next, fp);
-   EvaluateTree(BLOCK_NUM, tree, 0, fp);
-
-   fp.blockNum = BLOCK_NUM;
-   fp.width = tree[0].width;
-   fp.height = tree[0].height;
-   fp.area = fp.width * fp.height;   
-}
-// --------------------------------------------------------
-int ConstructTree(const vector< vector<Dimension> >& block,
-                  const int BLOCK_NUM,
-                  stack<int>& expression,
-                  stack<int>& orient,
-                  vector<TreeNode>& tree,
-                  int& next,
-                  FloorPlanVec& fp)
-{
-   int sign = expression.top();
-   expression.pop();
-   int here = next;
-
-   next++;
-   tree[here].sign = sign;
-
-   if (sign >= BLOCK_NUM)
-   {
-      tree[here].right = ConstructTree(block, BLOCK_NUM, expression, 
-                                       orient, tree, next, fp);
-      tree[here].left = ConstructTree(block, BLOCK_NUM, expression,
-                                      orient, tree, next, fp);
-      tree[tree[here].right].parent = here;
-      tree[tree[here].left].parent = here;
-   }
-   else
-   {
-      tree[here].right = -1;
-      tree[here].left = -1;
-
-      int theta = orient.top();
-      orient.pop();
-      tree[here].width = block[sign][theta].width;
-      tree[here].height = block[sign][theta].height;
-
-      fp.orient[sign] = theta;
-   }
-   return here;
-}
-// --------------------------------------------------------
-void EvaluateTree(const int BLOCK_NUM,
-                  vector<TreeNode>& tree,
-                  int ptr,
-                  FloorPlanVec& fp)
-{
-   static const int PLUS = BLOCK_NUM;
-   static const int STAR = BLOCK_NUM+1;
-   static const int ROOT = -1;
-
-   int parent = tree[ptr].parent;
-   int parMode = (parent == -1)? ROOT : tree[parent].sign;
-   int hereMode = tree[ptr].sign;
-
-   if (parMode == PLUS)
-   {
-      tree[ptr].x = tree[parent].x;
-      tree[ptr].y = tree[parent].y + tree[parent].height;      
-   }
-   else if (parMode == STAR)
-   {
-      tree[ptr].x = tree[parent].x + tree[parent].width;
-      tree[ptr].y = tree[parent].y;      
-   }
-   else if (parMode == ROOT)
-   {
-      tree[ptr].x = 0;
-      tree[ptr].y = 0;
-   }   
-   
-   if (tree[ptr].left == -1)
-   {
-      int rect = tree[ptr].sign;
-      fp.xLoc[rect] = tree[ptr].x;
-      fp.yLoc[rect] = tree[ptr].y;      
-      return;
-   }
-
-   tree[ptr].width = 0;
-   tree[ptr].height = 0;
-
-   EvaluateTree(BLOCK_NUM, tree, tree[ptr].left, fp);
-   if (hereMode == PLUS)
-      tree[ptr].height += tree[tree[ptr].left].height;
-   else if (hereMode == STAR)
-      tree[ptr].width += tree[tree[ptr].left].width;
-
-
-   EvaluateTree(BLOCK_NUM, tree, tree[ptr].right, fp);
-   if (hereMode == PLUS)
-   {
-      tree[ptr].height += tree[tree[ptr].right].height;
-      tree[ptr].width = max(tree[tree[ptr].left].width,
-                            tree[tree[ptr].right].width);
-   }
-   else if (hereMode == STAR)
-   {
-      tree[ptr].width += tree[tree[ptr].right].width;
-      tree[ptr].height = max(tree[tree[ptr].left].height,
-                             tree[tree[ptr].right].height);
-   }   
-}
-// --------------------------------------------------------
-void outputfp(const vector< vector<Dimension> >& block,
-              const FloorPlanVec& fp,
-              ostream& outs)
-{
-   outs.setf(ios::fixed);
-   outs.precision(3);
-   outs << fp.width << endl;
-   outs << fp.height << endl;
-   outs << fp.blockNum << endl;
-   for (int i = 0; i < fp.blockNum; i++)
-   {
-      double width = block[i][fp.orient[i]].width;
-      double height = block[i][fp.orient[i]].height;
-      outs << width << " " << height << endl;
-   }
-   outs << endl;
-   for (int i = 0; i < fp.blockNum; i++)
-   {
-      outs << fp.xLoc[i] << " " << fp.yLoc[i] << endl;
-   }
-   outs << endl;
-}
-// --------------------------------------------------------
diff -druN BloBB_CompaSS_050315/BloBB/vectorize.h blob_compass/BloBB/vectorize.h
--- BloBB_CompaSS_050315/BloBB/vectorize.h	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/BloBB/vectorize.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,82 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef VECTORIZE_H
-#define VECTORIZE_H
-
-#include "datastrst.h"
-#include "datastrhierst.h"
-
-#include <vector>
-#include <stack>
-#include <iostream>
-using namespace std;
-
-struct FloorPlanVec
-{
-   vector<double> xLoc;
-   vector<double> yLoc;
-   vector<int> orient;
-   int blockNum;
-
-   double width;
-   double height;
-   double area;
-};
-// --------------------------------------------------------
-
-// -----Initializing functions-----
-void InitializeSlice(vector< vector<Dimension> >& block,
-                     int& blockNum,
-                     istream& ins);
-void InitializeCluster(const vector< vector<Dimension> >& block,
-                       int blockNum,
-                       vector<Cluster>& clusters);
-
-// -----Evaluating floorplan functions-----
-void Evaluate(const vector< vector<Dimension> >& block,
-              const Cluster& finalCluster,
-              FloorPlanVec& fp);
-int ConstructTree(const vector< vector<Dimension> >& block,
-                  const int BLOCK_NUM,
-                  stack<int>& expression,
-                  stack<int>& orient,
-                  vector<TreeNode>& tree,
-                  int& next,
-                  FloorPlanVec& fp);
-void EvaluateTree(const int BLOCK_NUM,
-                  vector<TreeNode>& tree,
-                  int ptr,
-                  FloorPlanVec& fp);
-void outputfp(const vector< vector<Dimension> >& block,
-              const FloorPlanVec& fp,
-              ostream& outs);
-#endif
diff -druN BloBB_CompaSS_050315/BTree/btreecompact.cxx blob_compass/BTree/btreecompact.cxx
--- BloBB_CompaSS_050315/BTree/btreecompact.cxx	2005-03-14 21:32:27.000000000 -0800
+++ blob_compass/BTree/btreecompact.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,167 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "btreecompact.h"
-
-#include <vector>
-using namespace std;
-
-// --------------------------------------------------------
-void BTreeCompactor::build_orth_tree()
-{
-   clean_contour(in_contour);
-   clean_tree(in_orth_tree);
-   
-   int tree_prev = NUM_BLOCKS;
-   int tree_curr = in_tree[NUM_BLOCKS].left; // start with first block
-   while (tree_curr != NUM_BLOCKS) // until reach the root again
-   {
-      if (tree_prev == in_tree[tree_curr].parent)
-      {
-         build_orth_tree_add_block(tree_curr);
-         tree_prev = tree_curr;
-         if (in_tree[tree_curr].left != UNDEFINED)
-            tree_curr = in_tree[tree_curr].left;
-         else if (in_tree[tree_curr].right != UNDEFINED)
-            tree_curr = in_tree[tree_curr].right;
-         else
-            tree_curr = in_tree[tree_curr].parent;
-      }
-      else if (tree_prev == in_tree[tree_curr].left)
-      {
-         tree_prev = tree_curr;
-         if (in_tree[tree_curr].right != UNDEFINED)
-            tree_curr = in_tree[tree_curr].right;
-         else
-            tree_curr = in_tree[tree_curr].parent;
-      }
-      else
-      {
-         tree_prev = tree_curr;
-         tree_curr = in_tree[tree_curr].parent;
-      }
-   }
-   in_totalWidth = in_contour[NUM_BLOCKS+1].begin;
-
-   int contour_ptr = in_contour[NUM_BLOCKS].next;
-   in_totalHeight = 0;
-   while (contour_ptr != NUM_BLOCKS+1)
-   {
-      in_totalHeight = max(in_totalHeight, in_contour[contour_ptr].CTL);
-      contour_ptr = in_contour[contour_ptr].next;
-   }
-   in_totalArea = in_totalWidth * in_totalHeight;
-
-   fix_orth_tree(in_orth_tree);
-}
-// --------------------------------------------------------
-void BTreeCompactor::build_orth_tree_add_block(int tree_ptr)
-{
-   int tree_parent = in_tree[tree_ptr].parent;
-   int orth_tree_parent = NUM_BLOCKS;
-   
-   double maxCTL = -1;
-   int contour_ptr = UNDEFINED;
-   int contour_prev = UNDEFINED;
-   
-   if (tree_ptr == in_tree[in_tree[tree_ptr].parent].left)
-   {
-      in_contour[tree_ptr].begin = in_contour[tree_parent].end;
-      contour_ptr = in_contour[tree_parent].next;
-   }
-   else
-   {
-      in_contour[tree_ptr].begin = in_contour[tree_parent].begin;
-      contour_ptr = tree_parent;
-   }
-   contour_prev = in_contour[contour_ptr].prev; // begins of cPtr/tPtr match
-   orth_tree_parent = contour_ptr;       // initialize necessary
-   maxCTL = in_contour[contour_ptr].CTL; // since width/height may be 0
-
-   int block = in_tree[tree_ptr].block_index;
-   int theta = in_tree[tree_ptr].orient;
-   in_contour[tree_ptr].end =
-      in_contour[tree_ptr].begin + in_blockinfo[block].width[theta];
-
-   while (in_contour[contour_ptr].end <=
-          in_contour[tree_ptr].end + TOLERANCE)
-   {
-      if (in_contour[contour_ptr].CTL > maxCTL)
-      {
-         maxCTL = in_contour[contour_ptr].CTL;
-         orth_tree_parent = contour_ptr;
-      }
-      contour_ptr = in_contour[contour_ptr].next;
-   }
-
-   if (in_contour[contour_ptr].begin + TOLERANCE <
-       in_contour[tree_ptr].end)
-   {
-      if (in_contour[contour_ptr].CTL > maxCTL)
-      {
-         maxCTL = in_contour[contour_ptr].CTL;
-         orth_tree_parent = contour_ptr;
-      }
-   }
-   
-   in_xloc[tree_ptr] = in_contour[tree_ptr].begin;
-   in_yloc[tree_ptr] = maxCTL;
-   in_width[tree_ptr] = in_blockinfo[block].width[theta];
-   in_height[tree_ptr] = in_blockinfo[block].height[theta];
-      
-   in_contour[tree_ptr].CTL =  maxCTL + in_blockinfo[block].height[theta];
-   in_contour[tree_ptr].next = contour_ptr;
-   in_contour[contour_ptr].prev = tree_ptr;
-   in_contour[contour_ptr].begin = in_contour[tree_ptr].end;
-
-   in_contour[tree_ptr].prev = contour_prev;
-   in_contour[contour_prev].next = tree_ptr;
-   in_contour[tree_ptr].begin = in_contour[contour_prev].end;
-
-   // edit "in_orth_tree", the orthogonal tree
-   if (in_orth_tree[orth_tree_parent].left == UNDEFINED)
-   {
-      // left-child of the parent
-      in_orth_tree[orth_tree_parent].left = tree_ptr;
-      in_orth_tree[tree_ptr].parent = orth_tree_parent;
-   }
-   else
-   {
-      // sibling fo the left-child of the parent
-      int orth_tree_ptr = in_orth_tree[orth_tree_parent].left;
-      while (in_orth_tree[orth_tree_ptr].right != UNDEFINED)
-         orth_tree_ptr = in_orth_tree[orth_tree_ptr].right;
-
-      in_orth_tree[orth_tree_ptr].right = tree_ptr;
-      in_orth_tree[tree_ptr].parent = orth_tree_ptr;
-   }
-}
-// --------------------------------------------------------
diff -druN BloBB_CompaSS_050315/BTree/btreecompact.h blob_compass/BTree/btreecompact.h
--- BloBB_CompaSS_050315/BTree/btreecompact.h	2005-03-14 21:32:45.000000000 -0800
+++ blob_compass/BTree/btreecompact.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,173 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef BTREECOMPACT_H
-#define BTREECOMPACT_H
-
-#include "btree.h"
-
-#include <vector>
-#include <algorithm>
-using namespace std;
-
-// --------------------------------------------------------
-class BTreeCompactor : public BTree
-{
-public:
-   inline BTreeCompactor(const BTree& orig_tree);
-   inline void operator =(const BTree& new_tree);
-   inline void slimAssign(const BTree& new_tree); // suffices if evaluation
-                                                  // follows
-   
-   inline int compact();
-   void build_orth_tree();
-   
-   const vector<BTreeNode>& orth_tree;
-
-private:
-   vector<BTreeNode> in_orth_tree; // [NUM_BLOCKS] ~ in_tree[NUM_BLOCKS+1]
-                                   // [NUM_BLOCKS+1] ~ in_tree[NUM_BLOCKS]
-
-   void build_orth_tree_add_block(int treePtr);
-
-   // (a) swap NUM_BLK vs. NUM_BLK+1
-   // (b) fix parent of BL-block
-   // used by build_orth_tree() only!!!
-   inline static void fix_orth_tree(vector<BTreeNode>& orth_tree);
-};
-// --------------------------------------------------------
-
-// =========================
-//      IMPLEMENTATIONS
-// =========================
-BTreeCompactor::BTreeCompactor(const BTree& orig_tree)
-   : BTree(orig_tree),
-     orth_tree(in_orth_tree),
-     in_orth_tree(orig_tree.tree.size())
-{
-   int vec_size = in_orth_tree.size();
-   for (int i = 0; i < vec_size; i++)
-   {
-      in_orth_tree[i].parent = UNDEFINED;
-      in_orth_tree[i].left = UNDEFINED;
-      in_orth_tree[i].right = UNDEFINED;
-      in_orth_tree[i].block_index = orig_tree.tree[i].block_index;
-      in_orth_tree[i].orient =
-         OrientedPacking::flip(OrientedPacking::ORIENT(orig_tree.tree[i].orient));
-   }
-}
-// --------------------------------------------------------
-inline void BTreeCompactor::operator =(const BTree& new_tree)
-{
-   this->BTree::operator =(new_tree);
-   for (unsigned int i = 0; i < in_orth_tree.size(); i++)
-   {
-      in_orth_tree[i].parent = UNDEFINED;
-      in_orth_tree[i].left = UNDEFINED;
-      in_orth_tree[i].right = UNDEFINED;
-      in_orth_tree[i].block_index = new_tree.tree[i].block_index;
-      in_orth_tree[i].orient =
-         OrientedPacking::flip(OrientedPacking::ORIENT(new_tree.tree[i].orient));
-   }      
-}
-// --------------------------------------------------------
-inline void BTreeCompactor::slimAssign(const BTree& new_tree)
-{
-   in_tree = new_tree.tree;
-   in_blockArea = new_tree.blockArea();
-   for (unsigned int i = 0; i < in_orth_tree.size(); i++)
-   {
-      in_orth_tree[i].parent = UNDEFINED;
-      in_orth_tree[i].left = UNDEFINED;
-      in_orth_tree[i].right = UNDEFINED;
-      in_orth_tree[i].block_index = new_tree.tree[i].block_index;
-      in_orth_tree[i].orient =
-         OrientedPacking::flip(OrientedPacking::ORIENT(new_tree.tree[i].orient));
-   }      
-}
-// --------------------------------------------------------
-inline int BTreeCompactor::compact()
-{
-   vector<double> orig_xloc(in_xloc);
-   vector<double> orig_yloc(in_yloc);
-
-   build_orth_tree();
-   swap_ranges(in_tree.begin(), in_tree.end(),
-              in_orth_tree.begin());
-//    cout << "-----here1: after build_orth_tree()-----" << endl;
-//    cout << "in_tree: " << endl;
-//    OutputBTree(cout, in_tree);
-//    cout << endl << endl;
-//    cout << "in_orth_tree:" << endl;
-//    OutputBTree(cout, in_orth_tree);
-//    cout << endl << endl;
-
-   build_orth_tree();
-   swap_ranges(in_tree.begin(), in_tree.end(),
-              in_orth_tree.begin());
-//    cout << "-----here2: after build_orth_tree()-----" << endl;
-//    cout << "in_tree: " << endl;
-//    OutputBTree(cout, in_tree);
-//    cout << endl << endl;
-//    cout << "in_orth_tree: " << endl;
-//    OutputBTree(cout, in_orth_tree);
-//    cout << endl << endl;
-//    cout << "-----flipped packing-----" << endl;
-//    OutputPacking(cout, BTreeOrientedPacking(*this));
-
-//    ofstream outfile;
-//    outfile.open("dummy_flipped");
-//    Save_bbb(outfile, BTreeOrientedPacking(*this));
-//    outfile.close();
-
-   build_orth_tree();
-
-   int count = 0;
-   for (int i = 0; i < NUM_BLOCKS; i++)
-   {
-      if ((orig_xloc[i] != in_xloc[i]) ||
-          (orig_yloc[i] != in_yloc[i]))
-         count ++;
-   }
-   return count;
-}
-// --------------------------------------------------------
-inline void BTreeCompactor::fix_orth_tree(vector<BTree::BTreeNode>& orth_tree)
-{   
-   // fix the tree s.t. in_tree[NUM_BLOCKS] corresponds to the root
-   const int NUM_BLOCKS = orth_tree.size() - 2;
-   int bottomLeftBlock = orth_tree[NUM_BLOCKS+1].left;
-   
-   orth_tree[bottomLeftBlock].parent = NUM_BLOCKS;
-   iter_swap(&(orth_tree[NUM_BLOCKS]), &(orth_tree[NUM_BLOCKS+1]));
-}
-// --------------------------------------------------------
-#endif
diff -druN BloBB_CompaSS_050315/BTree/btreecompactsstree.cxx blob_compass/BTree/btreecompactsstree.cxx
--- BloBB_CompaSS_050315/BTree/btreecompactsstree.cxx	2005-03-14 21:33:04.000000000 -0800
+++ blob_compass/BTree/btreecompactsstree.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,100 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "btreecompactsstree.h"
-#include "basepacking.h"
-#include "btreecompact.h"
-#include "btreefromsstree.h"
-
-#include <fstream>
-#include <string>
-#include <iomanip>
-using namespace std;
-
-// --------------------------------------------------------
-double BTreeCompactSlice(const SoftPacking& spk,
-                         const string& outfilename)
-{
-   SoftPackingHardBlockInfoType hardblockinfo(spk);
-   BTreeFromSoftPacking btree(hardblockinfo, spk,
-                              getTolerance(hardblockinfo));
-   BTreeCompactor compactor(btree);
-
-   int numChanged = 0;
-   int i = 0;
-
-   double orig_totalArea = compactor.totalArea();
-   double orig_blockArea = compactor.blockArea();
-   double spk_totalArea = spk.totalWidth * spk.totalHeight;
-   printf("converted to B*-Tree: %.2lf (%.2lf%%) -> %.2lf (%.2lf%%)\n",
-          spk_totalArea, (spk.deadspace / spk.blockArea) * 100,
-          orig_totalArea, (orig_totalArea / orig_blockArea - 1)* 100);
-   do
-   {
-      numChanged = compactor.compact();
-   
-      printf("round %d: %6d blks changed: %.2lf (%.2lf%%) -> %.2lf (%.2lf%%)\n",
-             i, numChanged, orig_totalArea,
-             (orig_totalArea / orig_blockArea - 1) * 100,
-             compactor.totalArea(),
-             (compactor.totalArea() / compactor.blockArea() - 1) * 100);
-      i++;
-      orig_totalArea = compactor.totalArea();
-      orig_blockArea = compactor.blockArea();
-   } while (numChanged != 0);
-
-   double final_blkArea = compactor.blockArea();
-   double final_deadspace = compactor.totalArea() - final_blkArea;
-   cout << endl;
-   cout << "After compaction, " << endl;
-   cout << "blkArea: " << setw(11) << final_blkArea
-        << " deadspace: " << setw(11) << final_deadspace
-        << " (" << ((final_deadspace / final_blkArea) * 100) << "%)" << endl;
-
-   cout << endl;
-   PrintDimensions(compactor.totalWidth(), compactor.totalHeight());
-   PrintAreas(final_deadspace, final_blkArea);
-   cout << endl;
-   PrintUtilization(final_deadspace, final_blkArea);
-   cout << endl;
-   
-   ofstream outfile;
-   outfile.open(outfilename.c_str());
-   Save_bbb(outfile, BTreeOrientedPacking(compactor));
-   if (outfile.good())
-      cout << "Output successfully written to " << outfilename << endl;
-   else
-      cout << "Something wrong with the file " << outfilename << endl;
-   outfile.close();
-
-   return (compactor.totalArea() - compactor.blockArea());
-}
-// --------------------------------------------------------
diff -druN BloBB_CompaSS_050315/BTree/btreecompactsstree.h blob_compass/BTree/btreecompactsstree.h
--- BloBB_CompaSS_050315/BTree/btreecompactsstree.h	2005-03-14 21:33:16.000000000 -0800
+++ blob_compass/BTree/btreecompactsstree.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,67 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef BTREECOMPACTSSTREE_H
-#define BTREECOMPACTSSTREE_H
-
-#include "datastrfrontsoftst.h"
-
-#include "btreecompact.h"
-#include "btreefromsstree.h"
-#include "basepacking.h"
-
-#include <string>
-#include <cfloat>
-#include <algorithm>
-using namespace std;
-
-const double DEFAULT_SIDE_ACCURACY = 10000000;
-// --------------------------------------------------------
-double BTreeCompactSlice(const SoftPacking& spk,
-                         const string& outfilename);
-inline double getTolerance(const HardBlockInfoType& blockinfo);
-// --------------------------------------------------------
-
-// ========================
-//      IMPLEMENTATION
-// ========================
-inline double getTolerance(const HardBlockInfoType& blockinfo)
-{
-   double min_side = DBL_MAX;
-   for (int i = 0; i < blockinfo.blocknum(); i++)
-      min_side = min(min_side,
-                     min(blockinfo[i].width[0], blockinfo[i].height[0]));
-
-   return min_side / DEFAULT_SIDE_ACCURACY;
-}
-// --------------------------------------------------------
-
-#endif
diff -druN BloBB_CompaSS_050315/BTree/btree.cxx blob_compass/BTree/btree.cxx
--- BloBB_CompaSS_050315/BTree/btree.cxx	2005-03-14 21:32:01.000000000 -0800
+++ blob_compass/BTree/btree.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,556 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "btree.h"
-
-#include <iostream>
-#include <fstream>
-#include <string>
-#include <cmath>
-#include <float.h>
-#include <vector>
-#include <algorithm>
-using namespace std;
-using namespace basepacking_h;
-
-const int BTree::UNDEFINED = Dimension::UNDEFINED;
-// ========================================================
-BTree::BTree(const HardBlockInfoType& blockinfo)
-   : tree(in_tree),
-     contour(in_contour),
-     NUM_BLOCKS(blockinfo.blocknum()),
-     in_blockinfo(blockinfo),
-     in_tree(blockinfo.blocknum()+2),
-     in_contour(blockinfo.blocknum()+2),
-     
-     in_xloc(blockinfo.blocknum()+2, UNDEFINED),
-     in_yloc(blockinfo.blocknum()+2, UNDEFINED),
-     in_width(blockinfo.blocknum()+2, UNDEFINED),
-     in_height(blockinfo.blocknum()+2, UNDEFINED),
-     
-     in_blockArea(blockinfo.blockArea()),
-     in_totalArea(0),
-     in_totalWidth(0),
-     in_totalHeight(0),
-
-     TOLERANCE(0)
-{
-   int vec_size = NUM_BLOCKS+2;
-   for (int i = 0; i < vec_size; i++)
-   {
-      in_tree[i].parent = UNDEFINED;
-      in_tree[i].left = UNDEFINED;
-      in_tree[i].right = UNDEFINED;
-      in_tree[i].block_index = i;
-      in_tree[i].orient = UNDEFINED;
-
-      in_contour[i].next = UNDEFINED;
-      in_contour[i].prev = UNDEFINED;
-      in_contour[i].begin = UNDEFINED;
-      in_contour[i].end = UNDEFINED;
-      in_contour[i].CTL = UNDEFINED;
-   }
-
-   in_contour[NUM_BLOCKS].next = NUM_BLOCKS+1;
-   in_contour[NUM_BLOCKS].prev = UNDEFINED;
-   in_contour[NUM_BLOCKS].begin = 0;
-   in_contour[NUM_BLOCKS].end = 0;
-   in_contour[NUM_BLOCKS].CTL = Dimension::INFTY;
-
-   in_xloc[NUM_BLOCKS] = 0;
-   in_yloc[NUM_BLOCKS] = 0;
-   in_width[NUM_BLOCKS] = 0;
-   in_height[NUM_BLOCKS] = Dimension::INFTY;
-   
-   in_contour[NUM_BLOCKS+1].next = UNDEFINED;
-   in_contour[NUM_BLOCKS+1].prev = NUM_BLOCKS;
-   in_contour[NUM_BLOCKS+1].begin = 0;
-   in_contour[NUM_BLOCKS+1].end = Dimension::INFTY;
-   in_contour[NUM_BLOCKS+1].CTL = 0;
-
-   in_xloc[NUM_BLOCKS+1] = 0;
-   in_yloc[NUM_BLOCKS+1] = 0;
-   in_width[NUM_BLOCKS+1] = Dimension::INFTY;
-   in_height[NUM_BLOCKS+1] = 0;
-}
-// --------------------------------------------------------
-BTree::BTree(const HardBlockInfoType& blockinfo,
-             double nTolerance)
-   : tree(in_tree),
-     contour(in_contour),
-     NUM_BLOCKS(blockinfo.blocknum()),
-     in_blockinfo(blockinfo),
-     in_tree(blockinfo.blocknum()+2),
-     in_contour(blockinfo.blocknum()+2),
-     
-     in_xloc(blockinfo.blocknum()+2, UNDEFINED),
-     in_yloc(blockinfo.blocknum()+2, UNDEFINED),
-     in_width(blockinfo.blocknum()+2, UNDEFINED),
-     in_height(blockinfo.blocknum()+2, UNDEFINED),
-     
-     in_blockArea(blockinfo.blockArea()),
-     in_totalArea(0),
-     in_totalWidth(0),
-     in_totalHeight(0),
-
-     TOLERANCE(nTolerance)
-{
-   int vec_size = NUM_BLOCKS+2;
-   for (int i = 0; i < vec_size; i++)
-   {
-      in_tree[i].parent = UNDEFINED;
-      in_tree[i].left = UNDEFINED;
-      in_tree[i].right = UNDEFINED;
-      in_tree[i].block_index = i;
-      in_tree[i].orient = UNDEFINED;
-
-      in_contour[i].next = UNDEFINED;
-      in_contour[i].prev = UNDEFINED;
-      in_contour[i].begin = UNDEFINED;
-      in_contour[i].end = UNDEFINED;
-      in_contour[i].CTL = UNDEFINED;
-   }
-
-   in_contour[NUM_BLOCKS].next = NUM_BLOCKS+1;
-   in_contour[NUM_BLOCKS].prev = UNDEFINED;
-   in_contour[NUM_BLOCKS].begin = 0;
-   in_contour[NUM_BLOCKS].end = 0;
-   in_contour[NUM_BLOCKS].CTL = Dimension::INFTY;
-
-   in_xloc[NUM_BLOCKS] = 0;
-   in_yloc[NUM_BLOCKS] = 0;
-   in_width[NUM_BLOCKS] = 0;
-   in_height[NUM_BLOCKS] = Dimension::INFTY;
-   
-   in_contour[NUM_BLOCKS+1].next = UNDEFINED;
-   in_contour[NUM_BLOCKS+1].prev = NUM_BLOCKS;
-   in_contour[NUM_BLOCKS+1].begin = 0;
-   in_contour[NUM_BLOCKS+1].end = Dimension::INFTY;
-   in_contour[NUM_BLOCKS+1].CTL = 0;
-
-   in_xloc[NUM_BLOCKS+1] = 0;
-   in_yloc[NUM_BLOCKS+1] = 0;
-   in_width[NUM_BLOCKS+1] = Dimension::INFTY;
-   in_height[NUM_BLOCKS+1] = 0;
-}
-// --------------------------------------------------------
-void BTree::evaluate(const vector<BTreeNode>& ntree)
-{
-   if (ntree.size() != in_tree.size())
-   {
-      cout << "ERROR: size of btree's doesn't match." << endl;
-      exit(1);
-   }
-
-   in_tree = ntree;
-   contour_evaluate();
-}  
-// --------------------------------------------------------
-void BTree::evaluate(const vector<int>& tree_bits,
-                     const vector<int>& perm,
-                     const vector<int>& orient)
-{
-   if (int(perm.size()) != NUM_BLOCKS)
-   {
-      cout << "ERROR: the permutation length doesn't match with "
-           << "size of the tree." << endl;
-      exit(1);
-   }
-   bits2tree(tree_bits, perm, orient, in_tree);
-//   OutputBTree(cout, in_tree);
-   contour_evaluate();
-}
-// --------------------------------------------------------
-void BTree::bits2tree(const vector<int>& tree_bits,
-                       const vector<int>& perm,
-                       const vector<int>& orient,
-                       vector<BTreeNode>& ntree)
-{
-   int perm_size = perm.size();
-   ntree.resize(perm_size+2);
-   clean_tree(ntree);
-
-   int treePtr = perm_size;
-   int bitsPtr = 0;
-
-   int lastAct = -1;
-   for (int i = 0; i < perm_size; i++)
-   {
-      int currAct = tree_bits[bitsPtr];
-      while (currAct == 1)
-      {
-         // move up a level/sibling
-         if (lastAct == 1)
-            treePtr = ntree[treePtr].parent;
-
-         // move among siblings
-         while (ntree[treePtr].right != UNDEFINED)
-            treePtr = ntree[treePtr].parent;
-         bitsPtr++;
-         lastAct = 1;
-         currAct = tree_bits[bitsPtr];
-      }
-
-      if (lastAct != 1)
-         ntree[treePtr].left = perm[i];
-      else // lastAct == 1
-         ntree[treePtr].right = perm[i];
-      
-      ntree[perm[i]].parent = treePtr;
-      ntree[perm[i]].block_index = perm[i];
-      ntree[perm[i]].orient = orient[i];
-
-      treePtr = perm[i];
-      lastAct = 0;
-      bitsPtr++;
-   }         
-}
-// --------------------------------------------------------
-void BTree::swap(int indexOne,
-                 int indexTwo)
-{
-   int indexOne_left = in_tree[indexOne].left;
-   int indexOne_right = in_tree[indexOne].right;
-   int indexOne_parent = in_tree[indexOne].parent;
-
-   int indexTwo_left = in_tree[indexTwo].left;
-   int indexTwo_right = in_tree[indexTwo].right;
-   int indexTwo_parent = in_tree[indexTwo].parent;
-
-   if (indexOne == indexTwo_parent)
-      swap_parent_child(indexOne, (indexTwo == in_tree[indexOne].left));
-   else if (indexTwo == indexOne_parent)
-      swap_parent_child(indexTwo, (indexOne == in_tree[indexTwo].left));
-   else
-   {
-      // update around indexOne
-      in_tree[indexOne].parent = indexTwo_parent;
-      in_tree[indexOne].left = indexTwo_left;
-      in_tree[indexOne].right = indexTwo_right;
-
-      if (indexOne == in_tree[indexOne_parent].left)
-         in_tree[indexOne_parent].left = indexTwo;
-      else
-         in_tree[indexOne_parent].right = indexTwo;
-
-      if (indexOne_left != UNDEFINED)
-         in_tree[indexOne_left].parent = indexTwo;
-      
-      if (indexOne_right != UNDEFINED)
-         in_tree[indexOne_right].parent = indexTwo;
-      
-      // update around indexTwo
-      in_tree[indexTwo].parent = indexOne_parent;
-      in_tree[indexTwo].left = indexOne_left;
-      in_tree[indexTwo].right = indexOne_right;
-      
-      if (indexTwo == in_tree[indexTwo_parent].left)
-         in_tree[indexTwo_parent].left = indexOne;
-      else
-         in_tree[indexTwo_parent].right = indexOne;
-      
-      if (indexTwo_left != UNDEFINED)
-         in_tree[indexTwo_left].parent = indexOne;
-      
-      if (indexTwo_right != UNDEFINED)
-         in_tree[indexTwo_right].parent = indexOne;
-   }
-   contour_evaluate();   
-}
-// --------------------------------------------------------
-void BTree::swap_parent_child(int parent,
-                              bool isLeft)
-{
-   int parent_parent = in_tree[parent].parent;
-   int parent_left = in_tree[parent].left;
-   int parent_right = in_tree[parent].right;
-
-   int child = (isLeft)? in_tree[parent].left : in_tree[parent].right;
-   int child_left = in_tree[child].left;
-   int child_right = in_tree[child].right;
-
-   if (isLeft)
-   {
-      in_tree[parent].parent = child;
-      in_tree[parent].left = child_left;
-      in_tree[parent].right = child_right;
-
-      if (parent == in_tree[parent_parent].left)
-         in_tree[parent_parent].left = child;
-      else
-         in_tree[parent_parent].right = child;
-
-      if (parent_right != UNDEFINED)
-         in_tree[parent_right].parent = child;
-
-      in_tree[child].parent = parent_parent;
-      in_tree[child].left = parent;
-      in_tree[child].right = parent_right;
-
-      if (child_left != UNDEFINED)
-         in_tree[child_left].parent = parent;
-
-      if (child_right != UNDEFINED)
-         in_tree[child_right].parent = parent;
-   }
-   else
-   {
-      in_tree[parent].parent = child;
-      in_tree[parent].left = child_left;
-      in_tree[parent].right = child_right;
-
-      if (parent == in_tree[parent_parent].left)
-         in_tree[parent_parent].left = child;
-      else
-         in_tree[parent_parent].right = child;
-
-      if (parent_left != UNDEFINED)
-         in_tree[parent_left].parent = child;
-
-      in_tree[child].parent = parent_parent;
-      in_tree[child].left = parent_left;
-      in_tree[child].right = parent;
-
-      if (child_left != UNDEFINED)
-         in_tree[child_left].parent = parent;
-
-      if (child_right != UNDEFINED)
-         in_tree[child_right].parent = parent;
-   }
-}
-// --------------------------------------------------------
-void BTree::move(int index,
-                 int target,
-                 bool leftChild)
-{
-   int index_parent = in_tree[index].parent;
-   int index_left = in_tree[index].left;
-   int index_right = in_tree[index].right;
-
-   // remove "index" from the tree
-   if ((index_left != UNDEFINED) && (index_right != UNDEFINED))
-      remove_left_up_right_down(index);
-   else if (index_left != UNDEFINED)
-   {
-      in_tree[index_left].parent = index_parent;
-      if (index == in_tree[index_parent].left)
-         in_tree[index_parent].left = index_left;
-      else
-         in_tree[index_parent].right = index_left;
-   }
-   else if (index_right != UNDEFINED)
-   {
-      in_tree[index_right].parent = index_parent;
-      if (index == in_tree[index_parent].left)
-         in_tree[index_parent].left = index_right;
-      else
-         in_tree[index_parent].right = index_right;
-   }
-   else
-   {
-      if (index == in_tree[index_parent].left)
-         in_tree[index_parent].left = UNDEFINED;
-      else
-         in_tree[index_parent].right = UNDEFINED;
-   }
-
-   int target_left = in_tree[target].left;
-   int target_right = in_tree[target].right;
-   
-   // add "index" to the required location
-   if (leftChild)
-   {
-      in_tree[target].left = index;
-      if (target_left != UNDEFINED)
-         in_tree[target_left].parent = index;
-         
-      in_tree[index].parent = target;
-      in_tree[index].left = target_left;
-      in_tree[index].right = UNDEFINED;
-   }
-   else
-   {
-      in_tree[target].right = index;
-      if (target_right != UNDEFINED)
-         in_tree[target_right].parent = index;
-
-      in_tree[index].parent = target;
-      in_tree[index].left = UNDEFINED;
-      in_tree[index].right = target_right;
-   }
-   
-   contour_evaluate();
-}
-// --------------------------------------------------------
-void BTree::remove_left_up_right_down(int index)
-{
-   int index_parent = in_tree[index].parent;
-   int index_left = in_tree[index].left;
-   int index_right = in_tree[index].right;
-
-   in_tree[index_left].parent = index_parent;
-   if (index == in_tree[index_parent].left)
-      in_tree[index_parent].left = index_left;
-   else
-      in_tree[index_parent].right = index_left;
-
-   int ptr = index_left;
-   while (in_tree[ptr].right != UNDEFINED)
-      ptr = in_tree[ptr].right;
-
-   in_tree[ptr].right = index_right;
-   in_tree[index_right].parent = ptr;
-}
-// --------------------------------------------------------
-void BTree::contour_evaluate() // assume the tree is set
-{
-   clean_contour(in_contour);
-   
-   int tree_prev = NUM_BLOCKS;
-   int tree_curr = in_tree[NUM_BLOCKS].left; // start with first block
-   while (tree_curr != NUM_BLOCKS) // until reach the root again
-   {
-//      cout << "tree_curr: " << tree_curr << endl;
-      if (tree_prev == in_tree[tree_curr].parent)
-      {
-         contour_add_block(tree_curr);
-         tree_prev = tree_curr;
-         if (in_tree[tree_curr].left != UNDEFINED)
-            tree_curr = in_tree[tree_curr].left;
-         else if (in_tree[tree_curr].right != UNDEFINED)
-            tree_curr = in_tree[tree_curr].right;
-         else
-            tree_curr = in_tree[tree_curr].parent;
-      }
-      else if (tree_prev == in_tree[tree_curr].left)
-      {
-         tree_prev = tree_curr;
-         if (in_tree[tree_curr].right != UNDEFINED)
-            tree_curr = in_tree[tree_curr].right;
-         else
-            tree_curr = in_tree[tree_curr].parent;
-      }
-      else
-      {
-         tree_prev = tree_curr;
-         tree_curr = in_tree[tree_curr].parent;
-      }
-   }
-   in_totalWidth = in_contour[NUM_BLOCKS+1].begin;
-
-   int contour_ptr = in_contour[NUM_BLOCKS].next;
-   in_totalHeight = 0;
-   while (contour_ptr != NUM_BLOCKS+1)
-   {
-      in_totalHeight = max(in_totalHeight, in_contour[contour_ptr].CTL);
-      contour_ptr = in_contour[contour_ptr].next;
-   }
-   in_totalArea = in_totalWidth * in_totalHeight;
-}
-// --------------------------------------------------------
-void BTree::contour_add_block(const int tree_ptr)
-{
-   int tree_parent = in_tree[tree_ptr].parent;
-   double maxCTL = -1;
-   int contour_ptr = UNDEFINED;
-   int contour_prev = UNDEFINED;
-   
-   if (tree_ptr == in_tree[in_tree[tree_ptr].parent].left)
-   {
-      in_contour[tree_ptr].begin = in_contour[tree_parent].end;
-      contour_ptr = in_contour[tree_parent].next;
-   }
-   else
-   {
-      in_contour[tree_ptr].begin = in_contour[tree_parent].begin;
-      contour_ptr = tree_parent;
-   }
-   contour_prev = in_contour[contour_ptr].prev; // begins of cPtr/tPtr match
-   maxCTL = in_contour[contour_ptr].CTL;
-
-   int block = in_tree[tree_ptr].block_index;
-   int theta = in_tree[tree_ptr].orient;
-   in_contour[tree_ptr].end =
-      in_contour[tree_ptr].begin + in_blockinfo[block].width[theta];
-
-   while (in_contour[contour_ptr].end <=
-          in_contour[tree_ptr].end + TOLERANCE)
-   {
-      maxCTL = max(maxCTL, in_contour[contour_ptr].CTL);
-      contour_ptr = in_contour[contour_ptr].next;
-   }
-
-   if (in_contour[contour_ptr].begin + TOLERANCE < in_contour[tree_ptr].end)
-      maxCTL = max(maxCTL, in_contour[contour_ptr].CTL);
-   
-   in_xloc[tree_ptr] = in_contour[tree_ptr].begin;
-   in_yloc[tree_ptr] = maxCTL;
-   in_width[tree_ptr] = in_blockinfo[block].width[theta];
-   in_height[tree_ptr] = in_blockinfo[block].height[theta];
-      
-   in_contour[tree_ptr].CTL =  maxCTL + in_blockinfo[block].height[theta];
-   in_contour[tree_ptr].next = contour_ptr;
-   in_contour[contour_ptr].prev = tree_ptr;
-   in_contour[contour_ptr].begin = in_contour[tree_ptr].end;
-
-   in_contour[tree_ptr].prev = contour_prev;
-   in_contour[contour_prev].next = tree_ptr;
-   in_contour[tree_ptr].begin = in_contour[contour_prev].end;
-}
-// --------------------------------------------------------
-void BTree::save_bbb(const string& filename) const
-{
-   ofstream outfile;
-   outfile.open(filename.c_str());
-   if (!outfile.good())
-   {
-      cout << "ERROR: cannot open file" << filename << endl;
-      exit(1);
-   }
-
-   outfile.setf(ios::fixed);
-   outfile.precision(3);
-
-   outfile << in_totalWidth << endl;
-   outfile << in_totalHeight << endl;
-   outfile << NUM_BLOCKS << endl;
-   for (int i = 0; i < NUM_BLOCKS; i++)
-      outfile << in_width[i] << " " << in_height[i] << endl;
-   outfile << endl;
-
-   for (int i = 0; i < NUM_BLOCKS; i++)
-      outfile << in_xloc[i] << " " << in_yloc[i] << endl;
-   outfile << endl;
-}
-// --------------------------------------------------------
-      
-
-   
diff -druN BloBB_CompaSS_050315/BTree/btreefromsstree.cxx blob_compass/BTree/btreefromsstree.cxx
--- BloBB_CompaSS_050315/BTree/btreefromsstree.cxx	2005-03-14 21:33:29.000000000 -0800
+++ blob_compass/BTree/btreefromsstree.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,149 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "btreefromsstree.h"
-
-#include <fstream>
-#include <vector>
-using namespace std;
-using namespace basepacking_h;
-
-// --------------------------------------------------------
-SoftPackingHardBlockInfoType::SoftPackingHardBlockInfoType(
-   const SoftPacking& spk)
-   : HardBlockInfoType(spk.xloc.size())
-{
-   int blocknum = spk.xloc.size();
-   
-   in_blocks.resize(blocknum+2);
-   in_block_names.resize(blocknum+2);
-   for (int i = 0; i < blocknum; i++)
-   {
-      set_dimensions(i, spk.width[i], spk.height[i]);
-
-      char temp[100];
-      sprintf(temp, "%d", i);
-      in_block_names[i] = temp;
-   }
-
-   set_dimensions(blocknum, 0, Dimension::INFTY);
-   in_block_names[blocknum] = "LEFT";
-
-   set_dimensions(blocknum+1, Dimension::INFTY, 0);
-   in_block_names[blocknum+1] = "BOTTOM";
-}
-// --------------------------------------------------------
-BTreeFromSoftPacking::BTreeFromSoftPacking(const HardBlockInfoType& nBlockinfo,
-                                           const SoftPacking& spk)
-   : BTree(nBlockinfo)
-{
-   EvaluateTree(spk);
-   evaluate(in_tree);
-}
-// --------------------------------------------------------
-BTreeFromSoftPacking::BTreeFromSoftPacking(const HardBlockInfoType& nBlockinfo,
-                                           const SoftPacking& spk,
-                                           double nTolerance)
-   : BTree(nBlockinfo, nTolerance)
-{
-   EvaluateTree(spk);
-   evaluate(in_tree);
-}
-// --------------------------------------------------------
-void BTreeFromSoftPacking::EvaluateTree(const SoftPacking& spk)
-{
-   int expr_size = spk.expression.size();
-   int blocknum = spk.xloc.size();
-   for (int i = 0; i < expr_size; i++)
-   {
-      int sign = spk.expression[i];
-      if (SoftSTree::isOperand(sign))
-      {
-         in_buffer.push_back(SymbolicNodeType(sign, sign, sign, sign,
-                                              spk.width[sign]));
-         in_tree[sign].parent = blocknum;
-         in_tree[sign].left = UNDEFINED;
-         in_tree[sign].right = UNDEFINED;
-         in_tree[sign].block_index = sign;
-         in_tree[sign].orient = 0;
-      }
-      else
-      {
-         SymbolicNodeType TR_cluster(in_buffer.back());
-         in_buffer.pop_back();
-         
-         SymbolicNodeType BL_cluster(in_buffer.back());
-         in_buffer.pop_back();
-
-         int new_BL_block = BL_cluster.BL_block;
-         int new_TL_block = UNDEFINED;
-         int new_R_block = UNDEFINED;
-         double new_width = UNDEFINED;
-         if (sign == SoftSTree::STAR)
-         {
-            new_TL_block = BL_cluster.TL_block;
-            new_R_block = TR_cluster.R_block;
-            new_width = BL_cluster.width + TR_cluster.width;
-
-            in_tree[TR_cluster.BL_block].parent = BL_cluster.R_block;
-            in_tree[BL_cluster.R_block].left = TR_cluster.BL_block;
-         }
-         else if (sign == SoftSTree::PLUS)
-         {            
-            new_TL_block = TR_cluster.TL_block;
-            new_R_block = (BL_cluster.width > TR_cluster.width)?
-               BL_cluster.R_block : TR_cluster.R_block;
-            new_width = max(BL_cluster.width, TR_cluster.width);
- 
-            in_tree[TR_cluster.BL_block].parent = BL_cluster.TL_block;
-            in_tree[BL_cluster.TL_block].right = TR_cluster.BL_block;
-         }
-         else
-         {
-            cout << "ERROR in BTreeFromSoftPacking::EvaluateTree()" << endl;
-            exit(1);
-         }
-         in_buffer.push_back(SymbolicNodeType(sign,
-                                              new_BL_block, new_TL_block,
-                                              new_R_block, new_width));
-      }
-   }
-   in_tree[blocknum].left = spk.expression[0];
-}
-// --------------------------------------------------------
-
-             
-            
-                             
-
-   
-   
-     
diff -druN BloBB_CompaSS_050315/BTree/btreefromsstree.h blob_compass/BTree/btreefromsstree.h
--- BloBB_CompaSS_050315/BTree/btreefromsstree.h	2005-03-14 21:33:44.000000000 -0800
+++ blob_compass/BTree/btreefromsstree.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,78 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef BTREEFROMSSTREE_H
-#define BTREEFROMSSTREE_H
-
-#include "datastrfrontsoftst.h"
-
-#include "basepacking.h"
-#include "btree.h"
-
-#include <string>
-#include <vector>
-using namespace std;
-
-// --------------------------------------------------------
-class SoftPackingHardBlockInfoType : public HardBlockInfoType
-{
-public:
-   SoftPackingHardBlockInfoType(const SoftPacking& spk);
-};
-// --------------------------------------------------------
-class BTreeFromSoftPacking : public BTree
-{
-public:
-   BTreeFromSoftPacking(const HardBlockInfoType& nBlockinfo,
-                        const SoftPacking& spk);
-   BTreeFromSoftPacking(const HardBlockInfoType& nBlockinfo,
-                        const SoftPacking& spk,
-                        double nTolerance);   
-
-protected:
-   class SymbolicNodeType
-   {
-   public:
-      SymbolicNodeType(int s, int BL, int TL, int R, double w)
-         : sign(s), BL_block(BL), TL_block(TL), R_block(R), width(w) {}
-      
-      int sign;
-      int BL_block;
-      int TL_block;
-      int R_block;
-      double width;      
-   };
-   vector<SymbolicNodeType> in_buffer;
-   void EvaluateTree(const SoftPacking& spk);
-};
-// --------------------------------------------------------
-
-#endif
diff -druN BloBB_CompaSS_050315/BTree/btree.h blob_compass/BTree/btree.h
--- BloBB_CompaSS_050315/BTree/btree.h	2005-03-14 21:30:55.000000000 -0800
+++ blob_compass/BTree/btree.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,310 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef BTREE_H
-#define BTREE_H
-
-#include "basepacking.h"
-
-#include <iostream>
-#include <vector>
-using namespace std;
-
-// --------------------------------------------------------
-class BTree
-{
-public:
-   BTree(const HardBlockInfoType& blockinfo);
-   BTree(const HardBlockInfoType& blockinfo, double nTolerance);
-   inline BTree(const BTree& newBTree);
-   inline bool operator =(const BTree& newBTree); // true if succeeds
-
-   class BTreeNode;
-   class ContourNode;
-   const vector<BTreeNode>& tree;
-   const vector<ContourNode>& contour;
-
-   inline const vector<double>& xloc() const;
-   inline const vector<double>& yloc() const;
-   inline double xloc(int index) const;
-   inline double yloc(int index) const;
-   inline double width(int index) const;
-   inline double height(int index) const;
-   
-   inline double blockArea() const;
-   inline double totalArea() const;
-   inline double totalWidth() const;
-   inline double totalHeight() const;
-
-   inline void setTree(const vector<BTreeNode>& ntree);
-   void evaluate(const vector<BTreeNode>& ntree); 
-   void evaluate(const vector<int>& tree_bits,    // assume the lengths of
-                 const vector<int>& perm,         // these 3 are compatible 
-                 const vector<int>& orient);      // with size of old tree
-   static void bits2tree(const vector<int>& tree_bits, // assume lengths of 
-                         const vector<int>& perm,      // these 3 compatible
-                         const vector<int>& orient,
-                         vector<BTreeNode>& ntree);
-   inline static void clean_tree(vector<BTreeNode>& otree);
-   inline static void clean_contour(vector<ContourNode>& oContour);
-
-   // perturb the tree, evaluate contour from scratch
-   enum MoveType {SWAP, ROTATE, MOVE};
-   
-   void swap(int indexOne, int indexTwo); 
-   inline void rotate(int index, int newOrient);
-   void move(int index, int target, bool leftChild); // target = 0..n
-
-   const int NUM_BLOCKS;
-   static const int UNDEFINED; // = basepacking_h::Dimension::UNDEFINED;
-
-   class BTreeNode
-   {
-   public:
-      int parent;
-      int left;
-      int right;
-      
-      int block_index;
-      int orient;
-   };
-
-   class ContourNode
-   {
-   public:
-      int next;
-      int prev;
-      
-      double begin;
-      double end;
-      double CTL;
-   };
-
-   // -----output functions-----
-   void save_bbb(const string& filename) const;
-   
-protected:
-   const HardBlockInfoType& in_blockinfo;
-   vector<BTreeNode> in_tree;
-   vector<ContourNode> in_contour;
-
-   // blah[i] refers the attribute of in_tree[i].
-   vector<double> in_xloc;
-   vector<double> in_yloc;
-   vector<double> in_width;
-   vector<double> in_height;
-
-   double in_blockArea;
-   double in_totalArea;
-   double in_totalWidth;
-   double in_totalHeight;
-
-   const double TOLERANCE;
-
-   void contour_evaluate();
-   void contour_add_block(int treePtr);
-
-   void swap_parent_child(int parent, bool isLeft);
-   void remove_left_up_right_down(int index);
-};   
-// --------------------------------------------------------
-class BTreeOrientedPacking : public OrientedPacking
-{
-public:
-   inline BTreeOrientedPacking() {}
-   inline BTreeOrientedPacking(const BTree& bt);
-
-   inline void operator =(const BTree& bt);
-};
-// --------------------------------------------------------
-
-// =========================
-//      Implementations
-// =========================
-inline BTree::BTree(const BTree& newBtree)
-   : tree(in_tree),
-     contour(in_contour),
-     NUM_BLOCKS(newBtree.NUM_BLOCKS),
-     in_blockinfo(newBtree.in_blockinfo),
-     in_tree(newBtree.in_tree),
-     in_contour(newBtree.in_contour),
-     
-     in_xloc(newBtree.in_xloc),
-     in_yloc(newBtree.in_yloc),
-     in_width(newBtree.in_width),
-     in_height(newBtree.in_height),
-     
-     in_blockArea(newBtree.in_blockArea),
-     in_totalArea(newBtree.in_totalArea),
-     in_totalWidth(newBtree.in_totalWidth),
-     in_totalHeight(newBtree.in_totalHeight),
-
-     TOLERANCE(newBtree.TOLERANCE)
-{}
-// --------------------------------------------------------
-inline bool BTree::operator =(const BTree& newBtree)
-{
-   if (NUM_BLOCKS == newBtree.NUM_BLOCKS)
-   {
-      in_tree = newBtree.in_tree;
-      in_contour = newBtree.in_contour;
-
-      in_xloc = newBtree.in_xloc;
-      in_yloc = newBtree.in_yloc;
-      in_width = newBtree.in_width;
-      in_height = newBtree.in_height;
-
-      in_blockArea = newBtree.in_blockArea;
-      in_totalArea = newBtree.in_totalArea;
-      in_totalWidth = newBtree.in_totalWidth;
-      in_totalHeight = newBtree.in_totalHeight;
-      
-      return true;
-   }
-   else
-      return false;
-}
-// --------------------------------------------------------
-inline const vector<double>& BTree::xloc() const
-{  return in_xloc; }
-// --------------------------------------------------------
-inline const vector<double>& BTree::yloc() const
-{  return in_yloc; }
-// --------------------------------------------------------
-inline double BTree::xloc(int index) const
-{  return in_xloc[index]; }
-// --------------------------------------------------------
-inline double BTree::yloc(int index) const
-{  return in_yloc[index]; }
-// --------------------------------------------------------
-inline double BTree::width(int index) const
-{  return in_width[index]; }
-// --------------------------------------------------------
-inline double BTree::height(int index) const
-{  return in_height[index]; }
-// --------------------------------------------------------
-inline double BTree::blockArea() const
-{  return in_blockArea; }
-// --------------------------------------------------------
-inline double BTree::totalArea() const
-{  return in_totalArea; }
-// --------------------------------------------------------
-inline double BTree::totalWidth() const
-{  return in_totalWidth; }
-// --------------------------------------------------------
-inline double BTree::totalHeight() const
-{  return in_totalHeight; }
-// --------------------------------------------------------
-inline void BTree::setTree(const vector<BTreeNode>& ntree)
-{   in_tree = ntree; }
-// --------------------------------------------------------
-inline void BTree::clean_tree(vector<BTreeNode>& otree)
-{
-   int vec_size = otree.size();
-   for (int i = 0; i < vec_size; i++)
-   {
-      otree[i].parent = UNDEFINED;
-      otree[i].left = UNDEFINED;
-      otree[i].right = UNDEFINED;
-   }
-   otree[vec_size-2].block_index = vec_size-2;
-   otree[vec_size-1].block_index = vec_size-1;
-
-   otree[vec_size-2].orient = UNDEFINED;
-   otree[vec_size-1].orient = UNDEFINED;
-}
-// --------------------------------------------------------
-inline void BTree::clean_contour(vector<ContourNode>& oContour)
-{
-   int vec_size = oContour.size();
-   int Ledge = vec_size-2;
-   int Bedge = vec_size-1;
-
-   oContour[Ledge].next = Bedge;
-   oContour[Ledge].prev = UNDEFINED;
-   oContour[Ledge].begin = 0;
-   oContour[Ledge].end = 0;
-   oContour[Ledge].CTL = basepacking_h::Dimension::INFTY;
-
-   oContour[Bedge].next = UNDEFINED;
-   oContour[Bedge].prev = Ledge;
-   oContour[Bedge].begin = 0;
-   oContour[Bedge].end = basepacking_h::Dimension::INFTY;
-   oContour[Bedge].CTL = 0;
-}
-// --------------------------------------------------------
-inline void BTree::rotate(int index,
-                          int newOrient)
-{
-   in_tree[index].orient = newOrient;
-   contour_evaluate();
-}
-// ========================================================
-inline BTreeOrientedPacking::BTreeOrientedPacking(const BTree& bt)
-{
-   int blocknum = bt.NUM_BLOCKS;
-
-   xloc.resize(blocknum);
-   yloc.resize(blocknum);
-   width.resize(blocknum);
-   height.resize(blocknum);
-   orient.resize(blocknum);
-   for (int i = 0; i < blocknum; i++)
-   {
-      xloc[i] = bt.xloc(i);
-      yloc[i] = bt.yloc(i);
-      width[i] = bt.width(i);
-      height[i] = bt.height(i);
-      orient[i] = OrientedPacking::ORIENT(bt.tree[i].orient);
-   }
-}
-// --------------------------------------------------------
-inline void BTreeOrientedPacking::operator =(const BTree& bt)
-{
-   int blocknum = bt.NUM_BLOCKS;
-
-   xloc.resize(blocknum);
-   yloc.resize(blocknum);
-   width.resize(blocknum);
-   height.resize(blocknum);
-   orient.resize(blocknum);
-   for (int i = 0; i < blocknum; i++)
-   {
-      xloc[i] = bt.xloc(i);
-      yloc[i] = bt.yloc(i);
-      width[i] = bt.width(i);
-      height[i] = bt.height(i);
-      orient[i] = OrientedPacking::ORIENT(bt.tree[i].orient);
-   }
-}  
-// ========================================================
-
-#endif
diff -druN BloBB_CompaSS_050315/BTree/btreeslackeval.cxx blob_compass/BTree/btreeslackeval.cxx
--- BloBB_CompaSS_050315/BTree/btreeslackeval.cxx	2005-03-14 21:33:57.000000000 -0800
+++ blob_compass/BTree/btreeslackeval.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,134 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "btreeslackeval.h"
-// #include "debug.h"
-
-#include <vector>
-#include <algorithm>
-using namespace std;
-
-// ---------------------------------------------------------
-const vector<double>& BTreeSlackEval::evaluateXSlacks(const BTree& orig_btree)
-{
-   const int NUM_BLOCKS = orig_btree.NUM_BLOCKS;
-   _btree.build_orth_tree();   
-
-   reverse_tree(_btree.orth_tree, _rev_orth_tree);
-   _btree.evaluate(_rev_orth_tree);
-
-   double width = orig_btree.totalWidth();
-   for (int i = 0; i < NUM_BLOCKS; i++)
-   {
-      _xlocRight[i] = _btree.yloc(i);
-      _xSlack[i] = width -
-         orig_btree.width(i) - _xlocRight[i] - orig_btree.xloc(i);
-   }
-   return _xSlack;
-}
-// --------------------------------------------------------
-const vector<double>& BTreeSlackEval::evaluateYSlacks(const BTree& orig_btree)
-{
-   reverse_tree(orig_btree.tree, _rev_tree);
-   _btree.evaluate(_rev_tree);
-
-   const int NUM_BLOCKS = _btree.NUM_BLOCKS;
-   double height = orig_btree.totalHeight();
-   for (int i = 0; i < NUM_BLOCKS; i++)
-   {
-      _ylocTop[i] = _btree.yloc(i);
-      _ySlack[i] = height -
-         orig_btree.height(i) - _ylocTop[i] - orig_btree.yloc(i);
-   }
-   return _ySlack;
-}
-// ---------------------------------------------------------
-void BTreeSlackEval::reverse_tree(const vector<BTree::BTreeNode>& tree,
-                                  vector<BTree::BTreeNode>& rev_tree)
-{
-   // assume "rev_tree" has the same size as "tree"
-   BTree::clean_tree(rev_tree);
-   
-   static const int UNDEFINED =  BTree::UNDEFINED;   
-   const int NUM_BLOCKS = tree.size() - 2;
-   int tree_prev = NUM_BLOCKS;
-   int tree_curr = tree[NUM_BLOCKS].left; // start with the first child of root
-   vector<int> true_parent(tree.size(), UNDEFINED); // book-keeping variable
-   while (tree_curr != NUM_BLOCKS)
-   {
-      if (tree_prev == tree[tree_curr].parent)
-      {
-         if (tree_curr == tree[tree_prev].left)
-         {
-            // left-child
-            rev_tree[tree_prev].left = tree_curr;
-            rev_tree[tree_curr].parent = tree_prev;
-            rev_tree[tree_curr].block_index = tree[tree_curr].block_index;
-            rev_tree[tree_curr].orient = tree[tree_curr].orient;
-
-            true_parent[tree_curr] = tree_prev;
-         }
-         else
-         {
-            // right-child
-            int tree_parent = true_parent[tree_prev];
-            rev_tree[tree_parent].left = tree_curr; // prob. overwrite 
-            rev_tree[tree_curr].parent = tree_parent;
-            rev_tree[tree_curr].block_index = tree[tree_curr].block_index;
-            rev_tree[tree_curr].orient = tree[tree_curr].orient;
-               
-            rev_tree[tree_prev].parent = tree_curr;
-            rev_tree[tree_curr].right = tree_prev;
-
-            true_parent[tree_curr] = tree_parent;
-         }
-         tree_prev = tree_curr;
-         if (tree[tree_curr].right != UNDEFINED)
-            tree_curr = tree[tree_curr].right;
-         else if (tree[tree_curr].left != UNDEFINED)
-            tree_curr = tree[tree_curr].left;
-         else
-            tree_curr = tree[tree_curr].parent;
-      }
-      else if (tree_prev == tree[tree_curr].right)
-      {
-         tree_prev = tree_curr;
-         tree_curr = (tree[tree_curr].left != UNDEFINED)?
-            tree[tree_curr].left : tree[tree_curr].parent; 
-      }
-      else
-      {
-         tree_prev = tree_curr;
-         tree_curr = tree[tree_curr].parent;
-      }
-   }
-}
-// --------------------------------------------------------
diff -druN BloBB_CompaSS_050315/BTree/btreeslackeval.h blob_compass/BTree/btreeslackeval.h
--- BloBB_CompaSS_050315/BTree/btreeslackeval.h	2005-03-14 21:34:08.000000000 -0800
+++ blob_compass/BTree/btreeslackeval.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,119 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef BTREESLACKEVAL_H
-#define BTREESLACKEVAL_H
-
-#include "basepacking.h"
-#include "btree.h"
-#include "btreecompact.h"
-
-#include <vector>
-using namespace std;
-
-// --------------------------------------------------------
-class BTreeSlackEval 
-{
-public:
-   inline BTreeSlackEval(const BTree& newBTree);
-
-   inline void evaluateSlacks(const BTree& newBTree);
-   const vector<double>& evaluateXSlacks(const BTree& orig_btree);
-   const vector<double>& evaluateYSlacks(const BTree& orig_btree);
-
-   inline const vector<double>& xSlack() const;
-   inline const vector<double>& ySlack() const;
-
-   inline const vector<double>& xlocRight() const; // xloc from Right 
-   inline const vector<double>& ylocTop() const;   // yloc from Top
-   
-   inline const BTreeCompactor& btree() const;
-   inline const vector<BTree::BTreeNode>& rev_tree() const;
-   inline const vector<BTree::BTreeNode>& rev_orth_tree() const;
-
-   static void reverse_tree(const vector<BTree::BTreeNode>& tree,
-                            vector<BTree::BTreeNode>& rev_tree);   
-
-private:
-   BTreeCompactor _btree;
-   vector<double> _xSlack;
-   vector<double> _ySlack;
-
-   vector<double> _xlocRight;
-   vector<double> _ylocTop;
-   
-   vector<BTree::BTreeNode> _rev_tree;
-   vector<BTree::BTreeNode> _rev_orth_tree;
-
-   BTreeSlackEval(const BTreeSlackEval&); // copy forbidden
-};
-// --------------------------------------------------------
-
-// ===============
-// IMPLEMENTATIONS
-// ===============
-BTreeSlackEval::BTreeSlackEval(const BTree& newBTree)
-   : _btree(newBTree),
-     _xSlack(newBTree.NUM_BLOCKS),
-     _ySlack(newBTree.NUM_BLOCKS),
-     _xlocRight(newBTree.NUM_BLOCKS),
-     _ylocTop(newBTree.NUM_BLOCKS),
-     _rev_tree(newBTree.tree.size()),
-     _rev_orth_tree(newBTree.tree.size())
-{
-   BTree::clean_tree(_rev_tree);
-   BTree::clean_tree(_rev_orth_tree);   
-}
-// --------------------------------------------------------
-void BTreeSlackEval::evaluateSlacks(const BTree& newBTree)
-{
-   _btree.slimAssign(newBTree);
-   evaluateXSlacks(newBTree); // mess with "_btree" only
-   evaluateYSlacks(newBTree);
-}
-// --------------------------------------------------------
-const vector<double>& BTreeSlackEval::xSlack() const
-{   return _xSlack; }
-// --------------------------------------------------------
-const vector<double>& BTreeSlackEval::ySlack() const
-{   return _ySlack; }
-// --------------------------------------------------------
-const BTreeCompactor& BTreeSlackEval::btree() const
-{   return _btree; }
-// --------------------------------------------------------
-const vector<BTree::BTreeNode>& BTreeSlackEval::rev_tree() const
-{   return _rev_tree; }
-// --------------------------------------------------------
-const vector<BTree::BTreeNode>& BTreeSlackEval::rev_orth_tree() const
-{   return _rev_orth_tree; }
-// --------------------------------------------------------
-
-#endif
diff -druN BloBB_CompaSS_050315/BTree/debug.cxx blob_compass/BTree/debug.cxx
--- BloBB_CompaSS_050315/BTree/debug.cxx	2005-03-14 21:34:27.000000000 -0800
+++ blob_compass/BTree/debug.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,2285 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "basepacking.h"
-#include "btree.h"
-#include "debug.h"
-#include "netlist.h"
-#include "btreecompact.h"
-#include "btreeanneal.h"
-// #include "btreefromsstree.h"
-// #include "btreecompactsstree.h"
-#include "btreeslackeval.h"
-#include "mixedpacking.h"
-#include "mixedpackingfromdb.h"
-
-#include "pltobtree.h"
-#include "plsptobtree.h"
-#include "plcompact.h"
-
-// #include "datastrbacksoftst.h"
-// #include "datastrfrontsoftst.h"
-
-#include "allparquet.h"
-#include "ABKCommon/paramproc.h"
-#include "ABKCommon/abktimer.h"
-
-#include <iostream>
-#include <fstream>
-#include <iomanip>
-#include <string>
-#include <ctime>
-#include <cstdlib>
-#include <algorithm>
-#include <iterator>
-
-//#include <algo.h>
-using namespace std;
-using namespace basepacking_h;
-using parquetfp::DB;
-using parquetfp::Command_Line;
-using parquetfp::SPeval;
-using parquetfp::Pl2SP;
-
-// --------------------------------------------------------
-int main(int argc, char *argv[])
-{
-//    ifstream infile;
-
-//    infile.open(argv[1]);
-//    if (!infile.good())
-//    {
-//       cout << "ERROR: cannot read file " << argv[1] << endl;
-//       exit(1);
-//    }
-//    HardBlockInfoType blockinfo(infile);
-//    OutputHardBlockInfoType(cout, blockinfo);
-
-//    cout.setf(ios::fixed);
-//    cout.precision(0);
-//    cout << "blocknum:  " << blockinfo.blocknum() << endl;
-//    cout << "blockarea: " << blockinfo.blockArea() << endl;
-
-//   BTree bt(blockinfo);
-//   OutputBTree(cout, bt);
-
-//   DebugBits2Tree(argc, argv);
-//   DebugEvaluate(argc, argv);
-//   DebugSwap(argc, argv);
-//   DebugMove(argc, argv);
-
-//   DebugParseBlocks(argc, argv);
-//   DebugParseNets(argc, argv);
-//   DebugHPWL(argc, argv);
-
-//   DebugCopy(argc, argv);
-//   DebugCompact(argc, argv);
-//   DebugAnneal(argc, argv);
-//   DebugWireAnneal(argc, argv);
-//   DebugSSTreeToBTree(argc, argv);
-//   DebugParquetBTree(argc, argv);
-   DebugBTreeSlack(argc, argv);
-//   DebugMixedPacking(argc, argv);
-//   DebugSoftPacking(argc, argv);
-//   DebugPltoSP(argc, argv);
-//   DebugPltoBTree(argc, argv);
-//   DebugPlSPtoBTree(argc, argv);
-//   DebugShiftBlock(argc, argv);
-//   DebugShiftLegalizer(argc, argv);
-//   DebugMixedBlockInfoTypeFromDB(argc, argv);
-//   DebugBTreeAnnealerFromDB(argc, argv);   
-   return 0;
-}
-// --------------------------------------------------------
-void DebugBTreeAnnealerFromDB(int argc, char *argv[])
-{
-   BoolParam help1 ("h", argc, argv);
-   BoolParam help2 ("help", argc, argv);
-   NoParams  noParams(argc,argv);  // this acts as a flag
-   Command_Line* params = new Command_Line(argc, (const char **)argv);
-   params->printAnnealerParams();
-
-   if (noParams.found() || help1.found() || help2.found())
-   {
-      params->printHelp(argc, const_cast<const char**>(argv));
-      exit (0);
-   }	
-
-   Timer T;
-   T.stop();
-   double totalTime=0;
-   double successTime = 0;
-   double successAvgWL = 0;
-   double successAvgArea = 0;
-
-   double minArea=1e100;
-   double minWS=1e100;
-   double minWL=1e100;
-   double aveArea=0;
-   double aveWS=0;
-   double aveWL=0;
-   double currArea;
-   double lastArea;
-   double currWS;
-   double currWL;
-   double currXSize;
-   double currYSize;
-   double successAR=0;
-		
-   for (int i=0; i<params->iterations; i++)
-   {
-      DB* db = new DB(params->inFileName);
-      double blocksArea = db->getNodesArea();
-      double reqdArea = (1+(params->maxWS/100))*blocksArea;
-      double reqdWidth = sqrt(reqdArea*params->reqdAR);
-      double reqdHeight = reqdWidth/params->reqdAR;
-      bool gotBetterSol = false;
-
-      string blocksfilename(params->inFileName);
-      blocksfilename += ".blocks";
-      MixedBlockInfoType blockinfo(blocksfilename, "blocks");     
-
-      T.start(0.0);
-      BTreeAreaWireAnnealer *annealer_ptr = NULL;
-
-      if (!strcmp(argv[argc-1], "--db"))
-         annealer_ptr = new BTreeAreaWireAnnealer(params, db);
-      else          
-         annealer_ptr = new BTreeAreaWireAnnealer(blockinfo, params, db);      
-      BTreeAreaWireAnnealer& annealer = *annealer_ptr;
-      
-      annealer.go();
-      annealer.currSolution().save_bbb("dummy_out");
-      T.stop();
-
-      totalTime += T.getUserTime();
-      currXSize = annealer.currSolution().totalWidth();  // db->getXSize();
-      currYSize = annealer.currSolution().totalHeight(); // db->getYSize();
-      currArea = currXSize*currYSize;
-      currWS = 100*(currArea - blocksArea)/blocksArea; // currArea;
-      currWL = db->evalHPWL();
-      aveArea += currArea;
-      aveWS += currWS;
-      aveWL += currWL;
-      if(minArea > currArea)
-      {
-         minArea = currArea;
-         gotBetterSol = true;
-      }
-      if(minWS > currWS)
-         minWS = currWS;
-      if(minWL > currWL)
-         minWL = currWL;
-
-      if(params->reqdAR != -9999 && ((currArea<=reqdArea && 
-                                      currXSize<=reqdWidth && currYSize<=reqdHeight) || db->successAR))
-      {
-         ++successAR;
-         successTime += T.getUserTime();
-         successAvgWL += currWL;
-         successAvgArea += currArea;
-      }
-      //plot and save the best solution
-
-      if(gotBetterSol)
-      {
-         if(params->plot)
-         {
-            double currAR = currXSize/currYSize;
-            bool plotSlacks = !params->plotNoSlacks;
-            bool plotNets = !params->plotNoNets;
-            bool plotNames = !params->plotNoNames;
-            db->plot("out.gpl", currArea, currWS, currAR, T.getUserTime(), 
-                     currWL, plotSlacks, plotNets, plotNames);
-         }
-         if(params->savePl)
-            db->getNodes()->savePl(params->outPlFile);
-
-         if(params->saveCapoPl)
-            db->getNodes()->saveCapoPl(params->capoPlFile);
-
-         if(params->saveCapo)
-            db->saveCapo(params->capoBaseFile, params->reqdAR);
-
-         if(params->save)
-            db->save(params->baseFile);
-	      
-         //if(db->successAR)
-         //db->saveBestCopyPl("best.pl");
-      }
-      cout<<endl;
-      delete annealer_ptr;
-   }
-   aveArea /= params->iterations;
-   aveWS /= params->iterations;
-   aveWL /= params->iterations;
-   totalTime /= params->iterations;
-   successTime /= successAR;
-   successAvgWL /= successAR;
-   successAvgArea /= successAR;
-   successAR /= params->iterations;
-	
-   cout<<endl<<"Average Area: "<<aveArea<<" Minimum Area: "<<minArea<<endl
-       <<"Average HPWL: "<<aveWL<<" Minimum HPWL: "<<minWL<<endl
-       <<"Average WhiteSpace: "<<aveWS<<"%"<<" Minimum WhiteSpace: "
-       <<minWS<<"%"<<endl
-       <<"Average Time: "<<totalTime<<endl;
-   if(params->reqdAR != -9999)
-   {
-      cout<<endl<<"Success Rate of satisfying fixed outline: "
-          <<100*successAR<<" %"<<endl;
-      cout<<"Average Time for successfull AR runs: "<<successTime<<endl;
-      cout<<"Average Area for successfull AR runs: "<<successAvgArea<<endl;
-      cout<<"Average WL for successfull AR runs: "<<successAvgWL<<endl;
-   }
-}
-// --------------------------------------------------------
-void DebugMixedBlockInfoTypeFromDB(int argc, char *argv[])
-{
-   ifstream infile;
-   string blocksfilename(argv[1]);
-   blocksfilename += ".blocks";
-   infile.open(blocksfilename.c_str());
-   if (!infile.good())
-   {
-      cout << "ERROR: Cannot open file: " << blocksfilename << endl;
-      exit(1);
-   }
-
-   MixedBlockInfoType blockinfoOne(blocksfilename, "blocks");
-
-   DB db(argv[1]);
-   MixedBlockInfoTypeFromDB blockinfoTwo(db);
-
-   ofstream outfile1("dummy_file");
-   ofstream outfile2("dummy_db");
-
-   outfile1.setf(ios::fixed);
-   outfile1.precision(1);
-   OutputMixedBlockInfoType(outfile1, blockinfoOne);
-
-   outfile2.setf(ios::fixed);
-   outfile2.precision(1);
-   OutputMixedBlockInfoType(outfile2, blockinfoTwo);
-}
-// --------------------------------------------------------
-// void DebugShiftLegalizer(int argc, char *argv[])
-// {
-//    ifstream infile;
-//    infile.open(argv[1]);
-
-//    OrientedPacking packing;
-//    Read_bbb(infile, packing);
-//    Save_bbb(cout, packing);
-   
-//    double left_bound, right_bound, bottom_bound, top_bound;
-//    cout << "Enter boundary <xStart><xEnd><yStart><yEnd> ->";
-//    cin >> left_bound >> right_bound >> bottom_bound >> top_bound;
-
-//    ShiftLegalizer legalizer(packing.xloc, packing.yloc,
-//                             packing.width, packing.height,
-//                             left_bound, right_bound,
-//                             top_bound, bottom_bound);
-
-   
-//    int blocknum = packing.xloc.size();
-
-//    vector<int> checkBlks;
-//    vector<int> badBlks;
-
-// //    for (int i = 0; i < blocknum; i++)
-// //       checkBlks.push_back((i) % blocknum);
-
-//    checkBlks.push_back(0);
-//    checkBlks.push_back(1);
-//    checkBlks.push_back(2);
-
-//    bool success = legalizer.legalizeAll(ShiftLegalizer::NAIVE,
-//                                         checkBlks, badBlks);
-//    cout << ((success)? "no overlap afterwards" : "still have overlaps")
-//         << endl;
-// //    while (cin.good())
-// //    {
-// //       int currBlk = -1;
-// //       cout << "Select a block (0-" << (blocknum-1) << ") ->";
-// //       cin >> currBlk;
-// //       if (!cin.good())
-// //          break;
-
-// //       ShiftBlock shift_block(legalizer.xloc(), legalizer.yloc(),
-// //                              legalizer.widths(), legalizer.heights(),
-// //                              legalizer.leftBound(), legalizer.rightBound(),
-// //                              legalizer.topBound(), legalizer.bottomBound());
-      
-// //       vector<ShiftBlock::ShiftInfo> currShiftinfo;
-// //       shift_block(currBlk, currShiftinfo);
-
-// //       cout << "----currShiftInfo[" << currBlk << "]-----" << endl;
-// //       OutputShiftInfo(cout, currShiftinfo);
-
-// //       bool success = legalizer.legalizeBlock(currBlk);
-// //       cout << ((success)? "no overlap afterwards" : "still have overlap")
-// //            << endl;
-
-// //       OrientedPacking newPK;
-// //       newPK.xloc = legalizer.xloc();
-// //       newPK.yloc = legalizer.yloc();
-// //       newPK.width = legalizer.widths();
-// //       newPK.height = legalizer.heights();
-
-// //       Save_bbb(cout, newPK);
-// //    }
-//    OrientedPacking finalPK;
-//    finalPK.xloc = legalizer.xloc();
-//    finalPK.yloc = legalizer.yloc();
-//    finalPK.width = legalizer.widths();
-//    finalPK.height = legalizer.heights();
-
-//    ofstream outfile;
-//    outfile.open(argv[2]);
-//    Save_bbb(outfile, finalPK);
-// }     
-// // --------------------------------------------------------
-// void DebugShiftBlock(int argc, char *argv[])
-// {   
-//    ifstream infile;
-//    infile.open(argv[1]);
-   
-//    OrientedPacking packing;
-//    Read_bbb(infile, packing);
-
-//    Save_bbb(cout, packing);
-
-//    double left_bound, right_bound, bottom_bound, top_bound;
-//    cout << "Enter boundary <xStart><xEnd><yStart><yEnd> ->";
-//    cin >> left_bound >> right_bound >> bottom_bound >> top_bound;
-
-//    ShiftBlock shift_block(packing.xloc, packing.yloc,
-//                           packing.width, packing.height,
-//                           left_bound, right_bound,
-//                           top_bound, bottom_bound);
-   
-//    int blocknum = packing.xloc.size();
-//    while (cin.good())
-//    {
-//       int currBlk = -1;
-//       cout << "Select a block (0-" << (blocknum-1) << ") ->";
-//       cin >> currBlk;
-
-//       vector<ShiftBlock::ShiftInfo> currShiftinfo;
-//       shift_block(currBlk, currShiftinfo);
-
-//       cout << "----currShiftInfo[" << currBlk << "]-----" << endl;
-//       cout << "NORTH: " << endl;
-//       cout << "shiftRangeMin: "
-//            << currShiftinfo[ShiftBlock::NORTH].shiftRangeMin << endl;
-//       cout << "shiftRangeMax: "
-//            << currShiftinfo[ShiftBlock::NORTH].shiftRangeMax << endl;
-//       cout << "overlapMin: "
-//            << currShiftinfo[ShiftBlock::NORTH].overlapMin << endl;
-//       cout << "overlapMax: "
-//            << currShiftinfo[ShiftBlock::NORTH].overlapMax << endl;
-//       cout << endl;
-
-//       cout << "EAST: " << endl;
-//       cout << "shiftRangeMin: "
-//            << currShiftinfo[ShiftBlock::EAST].shiftRangeMin << endl;
-//       cout << "shiftRangeMax: "
-//            << currShiftinfo[ShiftBlock::EAST].shiftRangeMax << endl;
-//       cout << "overlapMin: "
-//            << currShiftinfo[ShiftBlock::EAST].overlapMin << endl;
-//       cout << "overlapMax: "
-//            << currShiftinfo[ShiftBlock::EAST].overlapMax << endl;
-//       cout << endl;
-      
-//       cout << "SOUTH: " << endl;
-//       cout << "shiftRangeMin: "
-//            << currShiftinfo[ShiftBlock::SOUTH].shiftRangeMin << endl;
-//       cout << "shiftRangeMax: "
-//            << currShiftinfo[ShiftBlock::SOUTH].shiftRangeMax << endl;
-//       cout << "overlapMin: "
-//            << currShiftinfo[ShiftBlock::SOUTH].overlapMin << endl;
-//       cout << "overlapMax: "
-//            << currShiftinfo[ShiftBlock::SOUTH].overlapMax << endl;
-//       cout << endl;
-
-//       cout << "WEST: " << endl;
-//       cout << "shiftRangeMin: "
-//            << currShiftinfo[ShiftBlock::WEST].shiftRangeMin << endl;
-//       cout << "shiftRangeMax: "
-//            << currShiftinfo[ShiftBlock::WEST].shiftRangeMax << endl;
-//       cout << "overlapMin: "
-//            << currShiftinfo[ShiftBlock::WEST].overlapMin << endl;
-//       cout << "overlapMax: "
-//            << currShiftinfo[ShiftBlock::WEST].overlapMax << endl;
-//       cout << endl;
-//       cout << "--------" << endl;
-//    }
-// }     
-// // --------------------------------------------------------
-// void DebugPlSPtoBTree(int argc, char *argv[])
-// {
-//    srand(time(NULL));
-//    srand48(time(NULL));
-   
-//    Timer tm1;
-//    tm1.stop();
-//    ifstream infile;
-//    infile.open(argv[1]);
-   
-//    OrientedPacking packing;
-//    Read_bbb(infile, packing);
-
-//    //    cout << "-----before pl2sp-----" << endl;
-// //    tm1.start();
-// //    Pl2SP pl2sp(packing.xloc, packing.yloc,
-// //                packing.width, packing.height,
-// //                parquetfp::TCG_ALGO);
-// //    tm1.stop();
-// //    cout << "-----pls2sp(TCG_ALGO) takes: " << tm1.getUserTime() << endl;
-
-// //    if (packing.xloc.size() < 400)
-// //    {
-// //       cout << "XX: ";
-// //       for (unsigned int i = 0; i < packing.xloc.size(); i++)
-// //          cout << pl2sp.getXSP()[i] << " ";
-// //       cout << endl;
-// //       cout << "YY: ";
-// //       for (unsigned int i = 0; i < packing.xloc.size(); i++)
-// //          cout << pl2sp.getYSP()[i] << " ";
-// //       cout << endl;
-// //    }
-
-// //    tm1.start();
-// //    PlSP2BTree plsp2btree(packing.xloc, packing.yloc,
-// //                          packing.width, packing.height,
-// //                          pl2sp.getXSP(), pl2sp.getYSP());
-// //    tm1.stop();
-// //    cout << "-----plsp2btree takes: " << tm1.getUserTime() << endl;
-
-//    infile.clear();
-//    infile.close();
-//    infile.open(argv[1]);
-
-//    double width, height;
-//    infile >> width >> height;
-//    HardBlockInfoType blockinfo(infile, "txt");
-// // //   OutputHardBlockInfoType(cout, blockinfo);
-   
-// //    BTree recon_btree(blockinfo);
-// //    recon_btree.evaluate(plsp2btree.btree());   
-// //    tm1.start();
-// //    Pl2BTree pl2btree(packing.xloc, packing.yloc,
-// //                      packing.width, packing.height,
-// //                      Pl2BTree::TCG);
-// //    tm1.stop();
-// //    cout << "-----TCG algo takes: " << tm1.getUserTime() << endl;
-  
-//    tm1.start();
-//    Pl2BTree pl2btree2(packing.xloc, packing.yloc,
-//                       packing.width, packing.height,
-//                       Pl2BTree::HEURISTIC);
-//    tm1.stop();
-//    cout << "-----heuristic algo takes: " << tm1.getUserTime() << endl;
-
-// //    BTree recon_btree_tcg(blockinfo, 1e-10);
-// //    recon_btree_tcg.evaluate(pl2btree.btree());
-   
-//    BTree recon_btree_heur(blockinfo, 1e-6);
-//    recon_btree_heur.evaluate(pl2btree2.btree());
-//    BTreeOrientedPacking bopacking(recon_btree_heur);
-   
-//    ofstream outfile;
-//    outfile.open("dummy_out");
-//    outfile.precision(0);
-//    Save_bbb(outfile, bopacking);
-
-//    printf("orig width: %.2lf height: %.2lf\n", width, height);
-//    printf("heur width: %.2lf height: %.2lf\n",
-//           recon_btree_heur.totalWidth(), recon_btree_heur.totalHeight());
-
-// //    bool same = true;
-// //    for (unsigned int i = 0; i < plsp2btree.btree().size(); i++)
-// //    {
-// //       const BTree::BTreeNode& node1 = pl2btree.btree()[i];
-// //       const BTree::BTreeNode& node2 = pl2btree2.btree()[i];
-// //       same = (same &&
-// //               node1.parent == node2.parent &&
-// //               node1.left == node2.left &&
-// //               node1.right == node2.right &&
-// //               node1.block_index == node2.block_index &&
-// //               node1.orient == node2.orient);
-// //    }
-   
-// //    cout << ((same)? "TCG and heur btree same" : "btree not the same") << endl;
-// //    printf("orig width: %.2lf height: %.2lf \n", width, height);
-// //    printf("TCG  width: %.2lf height: %.2lf \nHeuristic width: %.2lf height: %.2lf\n",
-// //           recon_btree_tcg.totalWidth(), recon_btree_tcg.totalHeight(),
-// //           recon_btree_heur.totalWidth(), recon_btree_heur.totalHeight());
-
-// //    // ----compare sequence-pairs-----
-// //    bool sp_same = true;
-// //    for (unsigned int i = 0; i < pl2sp.getXSP().size(); i++)
-// //    {
-// //       sp_same = (sp_same &&
-// //                  int(pl2sp.getXSP()[i]) == pl2btree.getXX()[i] &&
-// //                  int(pl2sp.getYSP()[i]) == pl2btree.getYY()[i]);
-// //    }
-// //    cout << ((sp_same)? "SP same" : "SP not same") << endl;
-
-// //    // ----verify sequence-pairs-----
-// //    SPeval sp_eval(packing.height, packing.width, false);
-// //    sp_eval.evaluate(const_cast< vector<unsigned>& >(pl2sp.getXSP()),
-// //                     const_cast< vector<unsigned>& >(pl2sp.getYSP()));
-// //    cout << "-----sequence-pairs-----" << endl;
-// //    printf("Pl2SP(TCG_ALOG) width: %.2lf height: %.2lf\n",
-// //           sp_eval.xSize, sp_eval.ySize);
-
-// //    vector<unsigned> XXus(pl2btree.getXX().size());
-// //    vector<unsigned> YYus(pl2btree.getYY().size());
-// //    for (unsigned int i = 0; i < pl2btree.getXX().size(); i++)
-// //    {
-// //       XXus[i] = pl2btree.getXX()[i];
-// //       YYus[i] = pl2btree.getYY()[i];
-// //    }   
-// //    sp_eval.evaluate(XXus, YYus);
-// //    printf("pl2btree (TCG) width: %.2lf height: %.2lf\n",
-// //           sp_eval.xSize, sp_eval.ySize);
-// }
-// // --------------------------------------------------------
-// void DebugPltoBTree(int argc, char *argv[])
-// {
-//    srand(time(NULL));
-//    srand48(time(NULL));
-   
-//    ifstream infile;
-//    infile.open(argv[1]);
-
-//    OrientedPacking packing;
-//    Read_bbb(infile, packing);
-
-//    vector<unsigned int> XXrand(packing.xloc.size());
-//    vector<unsigned int> YYrand(packing.yloc.size());
-
-//    int trial_num = 1000;
-//    int numSuccess = 0;
-//    for (int i = 0; i < trial_num; i++)
-//    {
-      
-//    for (unsigned int i = 0; i < packing.xloc.size(); i++)
-//    {
-//       XXrand[i] = i;
-//       YYrand[i] = i;
-//    }
-//    random_shuffle(XXrand.begin(), XXrand.end());
-//    random_shuffle(YYrand.begin(), YYrand.end());
-
-// //    cout << "XX: ";
-// //    for (unsigned int i = 0; i < packing.xloc.size(); i++)
-// //       cout << XXrand[i] << " ";
-// //    cout << endl;
-// //    cout << "YY: ";
-// //    for (unsigned int i = 0; i < packing.yloc.size(); i++)
-// //       cout << YYrand[i] << " ";
-// //    cout << endl;
-
-//    SPeval sp_eval(packing.height, packing.width, false);
-//    sp_eval.evaluate(XXrand, YYrand);
-   
-// //    cout << "-----before pl2sp-----" << endl;
-//    Pl2SP pl2sp(sp_eval.xloc, sp_eval.yloc,
-//                packing.width, packing.height,
-//                parquetfp::TCG_ALGO);
-// //    cout << "-----after pl2sp-----" << endl;
-
-
-// //    cout << "-----before pl2btree-----" << endl;
-//    Pl2BTree pl2btree(sp_eval.xloc,
-//                      sp_eval.yloc,
-//                      packing.width,
-//                      packing.height,
-//                      Pl2BTree::TCG);
-// //    cout << "-----after pl2btree-----" << endl;
-
-//    vector<unsigned int> XXnew(pl2btree.getXX().size());
-//    vector<unsigned int> YYnew(pl2btree.getYY().size());
-//    for (unsigned int i = 0; i < XXnew.size(); i++)
-//    {
-//       XXnew[i] = pl2btree.getXX()[i];
-//       YYnew[i] = pl2btree.getYY()[i];
-//    }
-
-//    if (pl2sp.getXSP() == XXnew && pl2sp.getYSP() == YYnew)
-//       numSuccess++;
-// //    if (pl2sp.getXSP() == XXnew)
-// // //       cout << "XX ok" << endl;
-// // //    else
-// // //       cout << "XX's differ" << endl;
-
-// //    if (pl2sp.getYSP() == YYnew)
-// // //       cout << "YY ok" << endl;
-// // //    else
-// // //       cout << "YY's differ" << endl;
-//    }
-
-//    cout << "numSuccess / trial_num: " << numSuccess << " / " << trial_num << endl;
-   
-// //   OutputHardBlockInfoType(cout, blockinfo);
-
-// //    BTree recon_btree(blockinfo);
-// //    recon_btree.evaluate(pl2btree.btree());
-// // //   OutputBTree(cout, recon_btree);
-   
-// //    BTreeOrientedPacking bopacking(recon_btree);
-   
-// //    ofstream outfile;
-// //    outfile.open("dummy_out");
-// //    outfile.precision(0);
-// //    Save_bbb(outfile, bopacking);
-// }
-// // --------------------------------------------------------
-// void DebugPltoSP(int argc, char *argv[])
-// {
-//    ifstream infile;
-//    infile.open(argv[1]);
-//    HardBlockInfoType blockinfo(infile, "txt");
-
-//    int blocknum = blockinfo.blocknum();
-//    vector<unsigned int> XX(blocknum);
-//    vector<unsigned int> YY(blocknum);
-//    for (int i = 0; i < blocknum; i++)
-//    {
-//       XX[i] = unsigned(i);
-//       YY[i] = unsigned(i);
-//    }
-//    random_shuffle(XX.begin(), XX.end());
-//    random_shuffle(YY.begin(), YY.end());
-
-//    vector<double> widths(blocknum);
-//    vector<double> heights(blocknum);
-//    for (int i = 0; i < blocknum; i++)
-//    {
-//       widths[i] = blockinfo[i].width[0];
-//       heights[i] = blockinfo[i].height[0];
-//    }
-
-//    SPeval sp_eval(heights, widths, false);
-//    sp_eval.evaluate(XX, YY);
-//    cout << "done evaluate" << endl;
-
-//    Pl2SP pl2sp(sp_eval.xloc, sp_eval.yloc,
-//                widths, heights, parquetfp::TCG_ALGO);
-//    cout << "done pl2sp" << endl;   
-// }
-// // --------------------------------------------------------
-// void DebugSoftPacking(int argc, char *argv[])
-// {
-//    BoolParam help1 ("h", argc, argv);
-//    BoolParam help2 ("help", argc, argv);
-//    NoParams  noParams(argc,argv);  // this acts as a flag
-//    Command_Line* params = new Command_Line(argc, (const char **)argv);
-//    params->printAnnealerParams();
-
-//    if (noParams.found() || help1.found() || help2.found())
-//    {
-//       params->printHelp ();
-//       exit (0);
-//    }	
-
-//    DB* db = new DB(params->inFileName);
-
-//    string blocksfilename(params->inFileName);
-//    blocksfilename += ".blocks";
-//    MixedBlockInfoType blockinfo(blocksfilename, "blocks");
-   
-//    BTreeAreaWireAnnealer annealer(blockinfo, params, db);
-   
-//    cout << "---before packSoftBlocks()-----" << endl;   
-//    cout << endl;
-   
-//    const BTree& initSolution = annealer.currSolution();
-//    initSolution.save_bbb("dummy_init");
-
-//    cout << "right before packSoftBlocks()" << endl;
-   
-//    double oldArea = annealer.currSolution().totalArea();
-//    double newArea = oldArea;
-//    int iter = 0;
-//    while (cin.good())
-//    {
-//       annealer.packSoftBlocks(2);
-//       newArea = annealer.currSolution().totalArea();
-//       printf("[%d] area %.2lf -> %.2lf\n",
-//              iter, oldArea, newArea);
-//       iter++;
-//       oldArea = newArea;
-//       cin.get();
-//    }
-//    cout << "right after packSoftBlocks()" << endl;
-   
-//    const BTree& finalSolution = annealer.currSolution();
-//    finalSolution.save_bbb("dummy_final");
-
-//    cout << "---after packSoftBlocks()-----" << endl;
-//    cout << endl;
-// }  
-// // --------------------------------------------------------
-// void DebugMixedPacking(int argc, char *argv[])
-// {
-//    MixedBlockInfoType blockinfo(argv[1], "blocks");
-//    OutputMixedBlockInfoType(cout, blockinfo);
-// }
-// // --------------------------------------------------------
-void DebugBTreeSlack(int argc, char *argv[])
-{
-//   srand(time(NULL)); // 2
-   
-   ifstream infile;
-   infile.open(argv[1]);
-   if (!infile.good())
-   {
-      cout << "ERROR: cannot read file " << argv[1] << endl;
-      exit(1);
-   }
-   HardBlockInfoType blockinfo(infile, "txt");
-   BTree btree(blockinfo);
-
-   BTreeAreaWireAnnealer::GenerateRandomSoln(btree, btree.NUM_BLOCKS);
-   OutputBTree(cout, btree.tree);
-
-   vector<BTree::BTreeNode> rev_tree(btree.tree.size());
-   BTreeSlackEval::reverse_tree(btree.tree, rev_tree);
-   OutputBTree(cout, rev_tree);
-
-   cout << "bit-vectors" << endl;
-   int UNDEFINED = BTree::UNDEFINED;
-   int tree_prev = btree.NUM_BLOCKS;
-   int tree_curr = btree.tree[btree.NUM_BLOCKS].left;
-
-   const vector<BTree::BTreeNode>& tree = btree.tree;
-   vector<int> tree_bits;
-   while (tree_curr != btree.NUM_BLOCKS)
-   {
-      if (tree_prev == tree[tree_curr].parent)
-      {
-         if (tree_curr == tree[tree_prev].left)
-         {
-            cout << "0";
-            tree_bits.push_back(0);
-         }
-         else
-         {
-            cout << "10";
-            tree_bits.push_back(1);
-            tree_bits.push_back(0);
-         }
-
-         tree_prev = tree_curr;
-         if (tree[tree_curr].left != UNDEFINED)
-            tree_curr = tree[tree_curr].left;
-         else if (tree[tree_curr].right != UNDEFINED)
-            tree_curr = tree[tree_curr].right;
-         else
-            tree_curr = tree[tree_curr].parent;
-      }
-      else if (tree_prev == tree[tree_curr].left)
-      {
-         cout << "1";
-         tree_bits.push_back(1);
-
-         tree_prev = tree_curr;
-         if (tree[tree_curr].right != UNDEFINED)
-            tree_curr = tree[tree_curr].right;
-         else
-            tree_curr = tree[tree_curr].parent;
-      }
-      else
-      {
-         tree_prev = tree_curr;
-         tree_curr = tree[tree_curr].parent;
-      }
-   }
-   cout << "1" << endl;
-   tree_bits.push_back(1);
-   tree_prev = btree.NUM_BLOCKS;
-   tree_curr = rev_tree[btree.NUM_BLOCKS].left;
-
-   vector<int> rev_tree_bits;
-   while (tree_curr != btree.NUM_BLOCKS)
-   {
-      if (tree_prev == rev_tree[tree_curr].parent)
-      {
-         if (tree_curr == rev_tree[tree_prev].left)
-         {
-            cout << "0";
-            rev_tree_bits.push_back(0);
-         }
-         else
-         {
-            cout << "10";
-            rev_tree_bits.push_back(1);
-            rev_tree_bits.push_back(0);
-         }
-
-         tree_prev = tree_curr;
-         if (rev_tree[tree_curr].left != UNDEFINED)
-            tree_curr = rev_tree[tree_curr].left;
-         else if (rev_tree[tree_curr].right != UNDEFINED)
-            tree_curr = rev_tree[tree_curr].right;
-         else
-            tree_curr = rev_tree[tree_curr].parent;
-      }
-      else if (tree_prev == rev_tree[tree_curr].left)
-      {
-         cout << "1";
-         rev_tree_bits.push_back(1);
-
-         tree_prev = tree_curr;
-         if (rev_tree[tree_curr].right != UNDEFINED)
-            tree_curr = rev_tree[tree_curr].right;
-         else
-            tree_curr = rev_tree[tree_curr].parent;
-      }
-      else
-      {
-         tree_prev = tree_curr;
-         tree_curr = rev_tree[tree_curr].parent;
-      }
-   }
-   cout << "1" << endl;
-   rev_tree_bits.push_back(1);
-
-   for (unsigned int i = 0; i < rev_tree_bits.size(); i++)
-      rev_tree_bits[i] = (rev_tree_bits[i] == 1)? 0 : 1;
-
-   cout << endl << "compare" << endl;
-   copy(tree_bits.begin(), tree_bits.end(), ostream_iterator<int>(cout, ""));
-   cout << endl;
-   
-   reverse(rev_tree_bits.begin(), rev_tree_bits.end());
-   copy(rev_tree_bits.begin(), rev_tree_bits.end(), ostream_iterator<int>(cout, ""));
-   cout << endl;
-
-   btree.evaluate(btree.tree);
-   btree.save_bbb("dummy");
-
-   btree.evaluate(rev_tree);
-   btree.save_bbb("dummy_rev");
-
-   BTreeSlackEval slackEval(btree);
-
-   slackEval.evaluateSlacks(btree);
-   const vector<double> xSlack = slackEval.xSlack();
-   const vector<double> ySlack = slackEval.ySlack();
-   for (int i = 0; i < btree.NUM_BLOCKS; i++)
-      cout << i << ": " << xSlack[i] << ", " << ySlack[i] << endl;
-}
-// // --------------------------------------------------------
-// void DebugParquetBTree(int argc, char *argv[])
-// {
-//    BoolParam help1 ("h", argc, argv);
-//    BoolParam help2 ("help", argc, argv);
-//    NoParams  noParams(argc,argv);  // this acts as a flag
-//    Command_Line* params = new Command_Line(argc, (const char **)argv);
-//    params->printAnnealerParams();
-
-//    if (noParams.found() || help1.found() || help2.found())
-//    {
-//       params->printHelp ();
-//       exit (0);
-//    }	
-
-//    Timer T;
-//    T.stop();
-//    double totalTime=0;
-//    double successTime = 0;
-//    double successAvgWL = 0;
-//    double successAvgArea = 0;
-
-//    double minArea=1e100;
-//    double minWS=1e100;
-//    double minWL=1e100;
-//    double aveArea=0;
-//    double aveWS=0;
-//    double aveWL=0;
-//    double currArea;
-//    double lastArea;
-//    double currWS;
-//    double currWL;
-//    double currXSize;
-//    double currYSize;
-//    double successAR=0;
-		
-//    for (int i=0; i<params->iterations; i++)
-//    {
-//       DB* db = new DB(params->inFileName);
-//       double blocksArea = db->getNodesArea();
-//       double reqdArea = (1+(params->maxWS/100))*blocksArea;
-//       double reqdWidth = sqrt(reqdArea*params->reqdAR);
-//       double reqdHeight = reqdWidth/params->reqdAR;
-//       bool gotBetterSol = false;
-
-//       string blocksfilename(params->inFileName);
-//       blocksfilename += ".blocks";
-//       MixedBlockInfoType blockinfo(blocksfilename, "blocks");     
-
-//       T.start(0.0);
-//       BTreeAreaWireAnnealer annealer(blockinfo, params, db);
-//       annealer.go();
-//       annealer.currSolution().save_bbb("dummy_out");
-//       T.stop();
-
-//       totalTime += T.getUserTime();
-//       currXSize = annealer.currSolution().totalWidth();  // db->getXSize();
-//       currYSize = annealer.currSolution().totalHeight(); // db->getYSize();
-//       currArea = currXSize*currYSize;
-//       currWS = 100*(currArea - blocksArea)/blocksArea; // currArea;
-//       currWL = db->evalHPWL();
-//       aveArea += currArea;
-//       aveWS += currWS;
-//       aveWL += currWL;
-//       if(minArea > currArea)
-//       {
-//          minArea = currArea;
-//          gotBetterSol = true;
-//       }
-//       if(minWS > currWS)
-//          minWS = currWS;
-//       if(minWL > currWL)
-//          minWL = currWL;
-
-//       if(params->reqdAR != -9999 && ((currArea<=reqdArea && 
-//                                       currXSize<=reqdWidth && currYSize<=reqdHeight) || db->successAR))
-//       {
-//          ++successAR;
-//          successTime += T.getUserTime();
-//          successAvgWL += currWL;
-//          successAvgArea += currArea;
-//       }
-//       //plot and save the best solution
-
-//       if(gotBetterSol)
-//       {
-//          if(params->plot)
-//          {
-//             double currAR = currXSize/currYSize;
-//             bool plotSlacks = !params->plotNoSlacks;
-//             bool plotNets = !params->plotNoNets;
-//             bool plotNames = !params->plotNoNames;
-//             db->plot("out.gpl", currArea, currWS, currAR, T.getUserTime(), 
-//                      currWL, plotSlacks, plotNets, plotNames);
-//          }
-//          if(params->savePl)
-//             db->getNodes()->savePl(params->outPlFile);
-
-//          if(params->saveCapoPl)
-//             db->getNodes()->saveCapoPl(params->capoPlFile);
-
-//          if(params->saveCapo)
-//             db->saveCapo(params->capoBaseFile, params->reqdAR);
-
-//          if(params->save)
-//             db->save(params->baseFile);
-	      
-//          //if(db->successAR)
-//          //db->saveBestCopyPl("best.pl");
-//       }
-//       cout<<endl;
-//    }
-//    aveArea /= params->iterations;
-//    aveWS /= params->iterations;
-//    aveWL /= params->iterations;
-//    totalTime /= params->iterations;
-//    successTime /= successAR;
-//    successAvgWL /= successAR;
-//    successAvgArea /= successAR;
-//    successAR /= params->iterations;
-	
-//    cout<<endl<<"Average Area: "<<aveArea<<" Minimum Area: "<<minArea<<endl
-//        <<"Average HPWL: "<<aveWL<<" Minimum HPWL: "<<minWL<<endl
-//        <<"Average WhiteSpace: "<<aveWS<<"%"<<" Minimum WhiteSpace: "
-//        <<minWS<<"%"<<endl
-//        <<"Average Time: "<<totalTime<<endl;
-//    if(params->reqdAR != -9999)
-//    {
-//       cout<<endl<<"Success Rate of satisfying fixed outline: "
-//           <<100*successAR<<" %"<<endl;
-//       cout<<"Average Time for successfull AR runs: "<<successTime<<endl;
-//       cout<<"Average Area for successfull AR runs: "<<successAvgArea<<endl;
-//       cout<<"Average WL for successfull AR runs: "<<successAvgWL<<endl;
-//    }
-// }
-// // --------------------------------------------------------
-// void DebugSSTreeToBTree(int argc, char *argv[])
-// {
-//    srand(time(NULL));
-   
-// //    ifstream infile;
-// //    infile.open(argv[1]);
-// //    if (!infile.good())
-// //    {
-// //       cout << "ERROR: cannot read file " << argv[1] << endl;
-// //       exit(1);
-// //    }
-// //    HardBlockInfoType blockinfo(infile, "txt"); // didn't sort
-
-//    ifstream infile2;
-//    infile2.open(argv[1]);
-//    if (!infile2.good())
-//    {
-//       cout << "ERROR: cannot read file " << argv[1] << endl;
-//       exit(1);
-//    }
-//    BlockInfoType softblockinfo(BlockInfoType::TXT, infile2); // sorted   
-//    SoftSTree sst(softblockinfo);
-
-//    cout << "DONE WITH I/O (blocknum: " << softblockinfo.BLOCK_NUM() << ")" << endl;
-//    int blocknum = softblockinfo.BLOCK_NUM();
-//    vector<int> perm(blocknum);
-//    for (int i = 0; i < blocknum; i++)
-//       perm[i] = i;
-//    random_shuffle(perm.begin(), perm.end());
-//    cout << "after random_shuffle (perm.size: " << perm.size() << ")" << endl;
-
-//    int perm_ptr = 0;
-//    for (int i = 0; i < 2*blocknum - 1; i++)
-//    {
-//       if (sst.balance() <= 1)
-//       {
-//          sst.push_operand(perm[perm_ptr]);
-//          // cout << perm.back() << " ";
-//          perm_ptr++;
-//       }
-//       else
-//       {
-//          double rand_num = double(rand()) / RAND_MAX;
-//          if (perm_ptr < perm.size())
-//          {
-//             if (rand_num < 0.55)
-//             {
-//                sst.push_operand(perm[perm_ptr]);
-//                // cout << perm.back() << " ";
-//                perm_ptr++;
-//             }
-//             else if (rand_num < 0.775)
-//             {
-//                sst.push_operator(SoftSTree::STAR);
-// //               cout << "* ";
-//             }
-//             else
-//             {
-//                sst.push_operator(SoftSTree::PLUS);
-//                // cout << "+ ";
-//             }
-//          }
-//          else
-//          {
-//             if (rand_num < 0.5)
-//             {
-//                sst.push_operator(SoftSTree::BOTH);
-//                // cout << "- ";
-//             }
-//             else
-//             {
-//                sst.push_operator(SoftSTree::BOTH);
-//                // cout << "- ";
-//             }
-//          }            
-//       }
-
-//       if (i % 100 == 0)
-//          cout << "i: " << i << endl;
-//    }
-
-//    cout << "DONE WITH RANDOM STUFF (blocknum: " << perm.size() << ")" << endl;
-//    SoftSliceRecord ssr(sst); cout << "set SoftSliceRecord" << endl;
-//    SoftPacking spk(ssr, softblockinfo); cout << "set SoftPacking" << endl;
-
-//    BTreeCompactSlice(spk, "dummy_compacted");
-// //    for (vector<int>::iterator ptr = spk.expression.begin();
-// //         ptr != spk.expression.end(); ptr++)
-// //    {
-// //       int sign = *ptr;
-// //       if (SoftSTree::isOperand(sign))
-// //          cout << sign << " ";
-// //       else if (sign == SoftSTree::PLUS)
-// //          cout << "+ ";
-// //       else if (sign == SoftSTree::STAR)
-// //          cout << "* ";
-// //       else if (sign == SoftSTree::BOTH)
-// //          cout << "- ";
-// //       else
-// //          cout << "? ";
-// //    }
-// //    cout << endl;
-   
-// //    ExplicitSoftPacking espk(spk); cout << "set ExplicitSoftPacking" << endl;
-// // //    for (vector<int>::iterator ptr = espk.expression.begin();
-// // //         ptr != espk.expression.end(); ptr++)
-// // //    {
-// // //       int sign = *ptr;
-// // //       if (SoftSTree::isOperand(sign))
-// // //          cout << sign << " ";
-// // //       else if (sign == SoftSTree::PLUS)
-// // //          cout << "+ ";
-// // //       else if (sign == SoftSTree::STAR)
-// // //          cout << "* ";
-// // //       else if (sign == SoftSTree::BOTH)
-// // //          cout << "- ";
-// // //       else
-// // //          cout << "? ";
-// // //    }
-// // //    cout << endl;   
-// //    SoftPackingHardBlockInfoType softhardblockinfo(spk); cout << "set SoftPackingHardBlockInfoType" << endl;
-// //    BTreeFromSoftPacking btree(softhardblockinfo, espk); cout << "set BTreeFromSoftPacking" << endl;
-
-// //    ofstream outfile[2];
-
-// //    outfile[0].open("dummy_slice");
-// //    spk.output(outfile[0]);
-// //    printf("slicing packing area: %.2lf (%%%.2lf)\n",
-// //           spk.totalWidth * spk.totalHeight,
-// //           (((spk.totalWidth * spk.totalHeight) / spk.blockArea) - 1) * 100);
-
-// //    btree.save_bbb("dummy_btree");
-// //    printf("btree packing area:   %.2lf (%%%.2lf)\n",
-// //           btree.totalArea(), (btree.totalArea() / btree.blockArea() - 1) * 100);
-
-// //    BTreeCompactor compactor(btree); cout << "set BTreeCompactor" << endl;
-// //    BTree orig_tree(btree);
-// //    int numChanged = 0;
-// //    int i = 0;
-// //    do
-// //    {
-// //       numChanged = compactor.compact();
-   
-// // //    cout << "-----compacted packing-----" << endl;
-// // //    OutputPacking(cout, BTreeOrientedPacking(compactor));
-// // //    cout << "area: " << compactor.totalArea() << endl << endl;
-
-// //       printf("[%d] changed %6d: %.2lf (%%%.2lf) -> %.2lf (%%%.2lf)\n",
-// //              i, numChanged, orig_tree.totalArea(),
-// //              (orig_tree.totalArea() / orig_tree.blockArea() - 1) * 100,
-// //              compactor.totalArea(),
-// //              (compactor.totalArea() / compactor.blockArea() - 1) * 100);
-// //       i++;
-// //       orig_tree = compactor;
-// //    } while (numChanged != 0);
-
-// //    ofstream outfile_done;
-// //    outfile_done.open("dummy_done");
-// //    Save_bbb(outfile_done, BTreeOrientedPacking(compactor));
-// //    outfile_done.close();
-// }
-// // --------------------------------------------------------
-// void DebugWireAnneal(int argc, char *argv[])
-// {
-//    cout << "Inside debugWireAnneal" << endl;
-
-//    ifstream infile;
-//    Command_Line *params = new Command_Line(argc, (const char **)argv);
-//    DB *db = new DB(params->inFileName);
-
-//    // read "blockinfo"
-//    string blocksfilename(params->inFileName);
-//    blocksfilename += ".blocks";
-//    infile.open(blocksfilename.c_str());
-//    if (!infile.good())
-//    {
-//       cout << "ERROR: cannot read file " << blocksfilename << endl;
-//       exit(1);
-//    }
-//    else
-//       cout << "Opened file " << blocksfilename << endl;
-//    MixedBlockInfoType blockinfo(blocksfilename, "blocks");      
-         
-//    BTreeAreaWireAnnealer annealer(blockinfo, params, db);
-//    cout << "annealer initialized sucessfully" << endl;
-
-//    cout << endl << endl;
-//    params->printAnnealerParams();   
-//    annealer.go();
-
-//    cout << "Exit successfully" << endl;   
-// }
-// // --------------------------------------------------------
-// // void DebugAnneal(int argc, char *argv[])
-// // {
-// //    srand(time(NULL)); // 2
-
-// //    ifstream infile;
-// //    infile.open(argv[1]);
-// //    if (!infile.good())
-// //    {
-// //       cout << "ERROR: cannot read file " << argv[1] << endl;
-// //       exit(1);
-// //    }
-// //    HardBlockInfoType blockinfo(infile, "txt");
-
-// //    BTreeAreaAnnealer annealer(blockinfo);
-   
-// //    BTree *final_ptr = annealer.go_free_outline();
-// // //   double blkArea = blockinfo.blockArea();
-// // //   double dspace = atof(argv[2]);
-// // //   double ar = atof(argv[3]);
-// // //   BTree *final_ptr = annealer.go_fixed_outline(sqrt((blkArea * (1+dspace)) * ar),
-// // //                                                sqrt((blkArea * (1+dspace)) / ar));
-
-// // //   printf("dspace: %.2lf%% ar: %.2lf\n", dspace*100, ar);
-// //    printf("blockArea:   %.0lf\n", final_ptr ->blockArea());
-// //    printf("totalArea:   %.0lf (%.2lf%%)\n",
-// //           final_ptr ->totalArea(), 
-// //           ((final_ptr ->totalArea() / final_ptr ->blockArea() - 1) * 100));
-// // //    printf("width:  %.2lf (%.2lf)\n",
-// // //           final_ptr ->totalWidth(), sqrt((blkArea * (1+dspace)) * ar));
-// // //    printf("height: %.2lf (%.2lf)\n",
-// // //           final_ptr ->totalHeight(), sqrt((blkArea * (1+dspace)) / ar));          
-
-// //    ofstream outfile;
-// //    outfile.open("dummy");
-// //    Save_bbb(outfile, BTreeOrientedPacking(*final_ptr));
-// //    outfile.close();
-
-// //    BTreeCompactor compactor(*final_ptr);
-
-// //    int changeCount = 0;
-// //    double orig_area = compactor.totalArea();
-// //    do
-// //    {
-// //       changeCount = compactor.compact();
-// //       printf("changeCount: %3d %.2lf -> %.2lf\n",
-// //              changeCount, orig_area, compactor.totalArea());
-// //       orig_area = compactor.totalArea();
-// //    } while (changeCount > 0);
-
-// //    delete final_ptr;
-// // }      
-// // -------------------------------------------------------- 
-// void DebugCompact(int argc, char *argv[]) 
-// {
-//    srand(time(NULL));
-
-//    ifstream infile;
-//    infile.open(argv[1]);
-//    if (!infile.good())
-//    {
-//       cout << "ERROR: cannot read file " << argv[1] << endl;
-//       exit(1);
-//    }
-//    HardBlockInfoType blockinfo(infile, "txt");
-
-//    vector<int> tree_bits;
-//    vector<int> tree_perm;
-//    vector<int> tree_orient;
-//    int balance = 0;
-//    for (int i = 0; i < 2*blockinfo.blocknum(); i++)
-//    {
-//       bool assigned = false;
-//       while (!assigned)
-//       {
-//          double rand_num = double(rand()) / (RAND_MAX+1.0);
-//          double threshold;
-
-//          if (balance == 0)
-//             threshold = 1; // push_back "0" for sure
-//          else if (balance == blockinfo.blocknum()) 
-//             threshold = 0; // push_back "1" for sure
-//          else
-//             threshold = 1 / (rand_num * (balance - rand_num));
-         
-//          if (rand_num >= threshold)
-//          {
-//             tree_bits.push_back(1);
-//             balance--;
-//             assigned = true;
-//          }
-//          else
-//          {
-//             tree_bits.push_back(0);
-//             balance++;
-//             assigned = true;
-//          }
-//       }
-//    }
-
-//    tree_perm.resize(blockinfo.blocknum());
-//    iota(tree_perm.begin(), tree_perm.end(), 0);
-//    random_shuffle(tree_perm.begin(), tree_perm.end());
-
-//    for (int i = 0; i < blockinfo.blocknum(); i++)
-//    {
-//       int rand_num = int(8 * (double(rand()) / (RAND_MAX + 1.0)));
-//       tree_orient.push_back(rand_num);
-//    }
-
-// //    cout << "tree_bits: ";
-// //    copy(tree_bits.begin(), tree_bits.end(), ostream_iterator<int>(cout));
-// //    cout << endl;
-
-// //    cout << "tree_perm: ";
-// //    copy(tree_perm.begin(), tree_perm.end(), ostream_iterator<int>(cout, " "));
-// //    cout << endl;
-
-// //    cout << "tree_orient: ";
-// //    copy(tree_orient.begin(), tree_orient.end(), ostream_iterator<int>(cout, " "));
-// //    cout << endl;
-   
-//    BTree orig_tree(blockinfo);
-//    orig_tree.evaluate(tree_bits, tree_perm, tree_orient);
-
-// //    cout << "-----original packing-----" << endl;
-// //    OutputPacking(cout, BTreeOrientedPacking(orig_tree));
-// //    cout << "area: " << orig_tree.totalArea() << endl << endl;
-
-//    ofstream outfile;
-//    outfile.open("dummy");
-//    Save_bbb(outfile, BTreeOrientedPacking(orig_tree));
-//    outfile.close();
-
-//    BTreeCompactor compactor(orig_tree);
-//    int numChanged = 0;
-//    int i = 0;
-//    do
-//    {
-//       numChanged = compactor.compact();
-   
-// //    cout << "-----compacted packing-----" << endl;
-// //    OutputPacking(cout, BTreeOrientedPacking(compactor));
-// //    cout << "area: " << compactor.totalArea() << endl << endl;
-
-//       printf("[%d] changed %6d: %.2lf (%%%.2lf) -> %.2lf (%%%.2lf)\n",
-//              i, numChanged, orig_tree.totalArea(),
-//              (orig_tree.totalArea() / orig_tree.blockArea() - 1) * 100,
-//              compactor.totalArea(),
-//              (compactor.totalArea() / compactor.blockArea() - 1) * 100);
-//       i++;
-//       orig_tree = compactor;
-//    } while (numChanged != 0);
-
-//    ofstream outfile_done;
-//    outfile_done.open("dummy_done");
-//    Save_bbb(outfile_done, BTreeOrientedPacking(compactor));
-//    outfile_done.close();
-// }
-// // --------------------------------------------------------
-// void DebugCopy(int argc, char *argv[])
-// {
-//    ifstream infile[3];
-//    string base_name(argv[1]);
-//    char filename[100];
-
-//    sprintf(filename, "%s.blocks", base_name.c_str());
-//    infile[0].open(filename);
-
-//    sprintf(filename, "%s.nets", base_name.c_str());
-//    infile[1].open(filename);
-
-//    sprintf(filename, "%s.pl", base_name.c_str());
-//    infile[2].open(filename);
-
-//    HardBlockInfoType blockinfo(infile[0], "blocks");
-//    NetListType netlist(infile[2], infile[1], blockinfo);
-
-//    vector<int> tree_bits;
-//    vector<int> tree_perm;
-//    vector<int> tree_orient;
-//    int balance = 0;
-//    for (int i = 0; i < 2*blockinfo.blocknum(); i++)
-//    {
-//       bool assigned = false;
-//       while (!assigned)
-//       {
-//          int rand_num = int(2 * (double(rand()) / (RAND_MAX+1.0)));
-//          if (rand_num == 1)
-//          {
-//             if (balance > 0)
-//             {
-//                tree_bits.push_back(rand_num);
-//                balance--;
-//                assigned = true;
-//             }
-//          }
-//          else
-//          {
-//             if (balance < blockinfo.blocknum())
-//             {
-//                tree_bits.push_back(rand_num);
-//                balance++;
-//                assigned = true;
-//             }
-//          }
-//       }
-//    }
-
-//    for (int i = 0; i < blockinfo.blocknum(); i++)
-//       tree_perm.push_back(i);
-//    random_shuffle(tree_perm.begin(), tree_perm.end());
-
-//    for (int i = 0; i < blockinfo.blocknum(); i++)
-//    {
-//       int rand_num = int(8 * (double(rand()) / (RAND_MAX + 1.0)));
-//       tree_orient.push_back(rand_num);
-//    }
-
-//    BTree oldTree(blockinfo);
-//    BTree newTree(oldTree);
-   
-//    oldTree.evaluate(tree_bits, tree_perm, tree_orient);
-//    newTree.evaluate(tree_bits, tree_perm, tree_orient);
-
-//    cout << "-----old packing-----" << endl;
-//    OutputPacking(cout, BTreeOrientedPacking(oldTree));
-//    cout << endl << endl;
-
-//    cout << "-----new packing-----" << endl;
-//    OutputPacking(cout, BTreeOrientedPacking(newTree));
-//    cout << endl << endl;
-   
-//    printf("oldHPWL: %lf newHPWL: %lf\n",
-//           netlist.getHPWL(BTreeOrientedPacking(oldTree)),
-//           netlist.getHPWL(BTreeOrientedPacking(newTree)));
-//    while (cin.good())
-//    {
-//       int blkA, blkB;
-//       cout << "block A ->";
-//       cin >> blkA;
-
-//       do
-//       {
-//          cout << "block B ->";
-//          cin >> blkB;
-//       } while (blkA == blkB);
-
-//       newTree.swap(blkA, blkB);
-//       printf("oldHPWL: %lf newHPWL: %lf\n",
-//              netlist.getHPWL(BTreeOrientedPacking(oldTree)),
-//              netlist.getHPWL(BTreeOrientedPacking(newTree)));
-
-//       oldTree = newTree;
-//    }
-// }  
-// // --------------------------------------------------------
-// void DebugHPWL(int argc, char *argv[])
-// {
-//    ifstream infile[3];
-//    ifstream infile_bbb;
-
-//    string base_name(argv[1]);
-//    string bbb_name(argv[2]);
-//    char filename[100];
-
-//    sprintf(filename, "%s.blocks", base_name.c_str());
-//    infile[0].open(filename);
-
-//    sprintf(filename, "%s.nets", base_name.c_str());
-//    infile[1].open(filename);
-
-//    sprintf(filename, "%s.pl", base_name.c_str());
-//    infile[2].open(filename);
-
-//    infile_bbb.open(bbb_name.c_str());
-
-//    HardBlockInfoType blockinfo(infile[0], "blocks");
-//    NetListType netlist(infile[2], infile[1], blockinfo);
-//    OrientedPacking packing;
-//    Read_bbb(infile_bbb, packing);
-
-//    for (int i = 0; i < 10000; i++)
-//    {
-//       double HPWL = netlist.getHPWL(packing);
-//       cout << i << endl;
-//    }
-// }
-// // --------------------------------------------------------
-// void DebugParseNets(int argc, char *argv[])
-// {
-//    ifstream infile_blocks, infile_nets, infile_pl;
-//    ofstream outfile;
-
-//    infile_blocks.open(argv[1]);
-//    if (!infile_blocks.good())
-//    {
-//       cout << "ERROR: cannot read file " << argv[1] << endl;
-//       exit(1);
-//    }
-
-//    infile_nets.open(argv[2]);
-//    if (!infile_nets.good())
-//    {
-//       cout << "ERROR: cannot read file " << argv[2] << endl;
-//       exit(1);
-//    }
-
-//    infile_pl.open(argv[3]);
-//    if (!infile_pl.good())
-//    {
-//       cout << "ERROR: cannot read file " << argv[3] << endl;
-//       exit(1);
-//    }
-
-//    HardBlockInfoType blockinfo(infile_blocks, "blocks");
-//    NetListType netlist(infile_pl, infile_nets, blockinfo);
-
-//    ofstream outfile_recon;
-//    outfile_recon.open("recon_nets");
-
-//    outfile_recon << "NumNets : " << netlist.nets.size() << endl << endl;
-//    int numNets = netlist.nets.size();
-//    for (int i = 0; i < numNets; i++)
-//    {
-//       char line[100];
-//       int netDegree = netlist.nets[i].pins.size() + netlist.nets[i].pads.size();
-//       sprintf(line, "NetDegree : %d", netDegree);
-//       outfile_recon << line << endl;
-
-//       for (unsigned int k = 0; k < netlist.nets[i].pads.size(); k++)
-//       {
-//          string pad_name("default");
-//          for (unsigned int p = 0; p < netlist.padinfo.size(); p++)
-//             if ((netlist.nets[i].pads[k].xloc == netlist.padinfo[p].xloc) &&
-//                 (netlist.nets[i].pads[k].yloc == netlist.padinfo[p].yloc))
-//             {
-//                pad_name = netlist.padinfo[p].pad_name;
-//                break;
-//             }
-//          outfile_recon << pad_name << " B" << endl;
-//       }
-
-//       for (unsigned int k = 0; k < netlist.nets[i].pins.size(); k++)
-//       {
-//          int block = netlist.nets[i].pins[k].block;
-//          double x_percent = (netlist.nets[i].pins[k].x_offset / blockinfo[block].width[0]) * 200;
-//          double y_percent = (netlist.nets[i].pins[k].y_offset / blockinfo[block].height[0]) * 200;
-//          sprintf(line, "%s B \t: %%%.1lf %%%.1lf",
-//                  blockinfo.block_names[block].c_str(), x_percent, y_percent);
-//          outfile_recon << line << endl;
-//       }
-//    }
-// }
-// // --------------------------------------------------------
-// void DebugParseBlocks(int argc, char *argv[])
-// {
-//    ifstream infile, infile2;
-//    ofstream outfile, outfile2;
-
-//    infile.open(argv[1]);
-//    if (!infile.good())
-//    {
-//       cout << "ERROR: cannot read file " << argv[1] << endl;
-//       exit(1);
-//    }
-//    outfile.open("out1");
-
-//    HardBlockInfoType blockinfo(infile, "blocks");
-//    OutputHardBlockInfoType(outfile, blockinfo);
-//    outfile.close();
-//    infile.close();
-   
-//    infile2.open(argv[2]);
-//    if (!infile2.good())
-//    {
-//       cout << "ERROR: cannot open file " << argv[2] << endl;
-//       exit(1);
-//    }
-//    outfile2.open("out2");
-   
-//    HardBlockInfoType bbb_info(infile2, "txt");
-//    OutputHardBlockInfoType(outfile2, bbb_info);
-//    outfile2.close();
-//    infile2.close();
-
-//    cout << "-----block_names-----" << endl;
-//    for (unsigned int i = 0; i < blockinfo.block_names.size(); i++)
-//       printf("[%d]: %s\n", i, blockinfo.block_names[i].c_str());
-
-//    cout << endl;
-//    cout << "-----block_names (txt)-----" << endl;
-//    for (unsigned int i = 0; i < bbb_info.block_names.size(); i++)
-//       printf("[%d]: %s\n", i, bbb_info.block_names[i].c_str());
-// }
-// // --------------------------------------------------------
-// void DebugMove(int argc, char *argv[])
-// {
-//    ifstream infile;
-
-//    infile.open(argv[1]);
-//    if (!infile.good())
-//    {
-//       cout << "ERROR: cannot read file " << argv[1] << endl;
-//       exit(1);
-//    }
-//    HardBlockInfoType blockinfo(infile, "txt");
-
-//    vector<int> tree_bits;
-//    vector<int> perm;
-//    vector<int> orient;
-
-//    string bits_string(argv[2]);
-//    for (unsigned int i = 0; i < bits_string.length(); i++)
-//    {
-//       string dummy;
-//       dummy += bits_string[i];
-//       int this_bit = atoi(dummy.c_str());
-
-//       tree_bits.push_back(this_bit);
-//    }
-
-//    string orients_string(argv[3]);
-//    for (unsigned int i = 0; i < orients_string.length(); i++)
-//    {
-//       string dummy;
-//       dummy += orients_string[i];
-//       int this_orient = atoi(dummy.c_str());
-
-//       orient.push_back(this_orient);
-//    }
-
-//    if (tree_bits.size() != 2 * orient.size())
-//    {
-//       cout << "ERROR: the sizes of tree_bits and orient not consistent."
-//            << endl;
-//       cout << "tree: " << tree_bits.size() << " vz. orient: "
-//            << orient.size() << endl;
-//       exit(1);
-//    }
-
-//    for (unsigned int i = 0; i < orient.size(); i++)
-//    {
-//       int blk = i;
-//       perm.push_back(blk);
-//    }
-   
-//    cout << "tree:   ";
-//    for (unsigned int i = 0; i < tree_bits.size(); i++)
-//       cout << tree_bits[i] << " ";
-//    cout << endl;
-
-//    cout << "perm:   ";
-//    for (unsigned int i = 0; i < perm.size(); i++)
-//       cout << perm[i] << " ";
-//    cout << endl;
-
-//    cout << "orient: ";
-//    for (unsigned int i = 0; i < orient.size(); i++)
-//       cout << orient[i] << " ";
-//    cout << endl;
-
-//    cout << endl;
-
-// //    vector<BTree::BTreeNode> btree;
-// //    BTree::bits2tree(tree_bits, perm, orient, btree);
-// //    OutputBTree(cout, btree);
-
-//    BTree bt(blockinfo);
-//    bt.evaluate(tree_bits, perm, orient);
-
-//    OutputBTree(cout, bt);
-
-//    int index, target, leftChild;
-//    cout << "----move-----" << endl;
-//    cout << "index ->";
-//    cin >> index;
-
-//    cout << "target ->";
-//    cin >> target;
-
-//    cout << "leftChild (0 for true, 1 for false)->";
-//    cin >> leftChild;
-
-//    bt.move(index, target, (leftChild == 0));
-//    OutputBTree(cout, bt);
-//    bt.save_bbb(argv[argc-1]);
-// }
-// // --------------------------------------------------------
-// void DebugSwap(int argc, char *argv[])
-// {
-//    ifstream infile;
-
-//    infile.open(argv[1]);
-//    if (!infile.good())
-//    {
-//       cout << "ERROR: cannot read file " << argv[1] << endl;
-//       exit(1);
-//    }
-//    HardBlockInfoType blockinfo(infile, "txt");
-
-//    vector<int> tree_bits;
-//    vector<int> perm;
-//    vector<int> orient;
-
-//    string bits_string(argv[2]);
-//    for (unsigned int i = 0; i < bits_string.length(); i++)
-//    {
-//       string dummy;
-//       dummy += bits_string[i];
-//       int this_bit = atoi(dummy.c_str());
-
-//       tree_bits.push_back(this_bit);
-//    }
-
-//    string orients_string(argv[3]);
-//    for (unsigned int i = 0; i < orients_string.length(); i++)
-//    {
-//       string dummy;
-//       dummy += orients_string[i];
-//       int this_orient = atoi(dummy.c_str());
-
-//       orient.push_back(this_orient);
-//    }
-
-//    if (tree_bits.size() != 2 * orient.size())
-//    {
-//       cout << "ERROR: the sizes of tree_bits and orient not consistent."
-//            << endl;
-//       cout << "tree: " << tree_bits.size() << " vz. orient: "
-//            << orient.size() << endl;
-//       exit(1);
-//    }
-
-//    for (unsigned int i = 0; i < orient.size(); i++)
-//    {
-//       int blk = -1;
-//       cout << "Enter next block ->";
-//       cin >> blk;
-         
-//       perm.push_back(blk);
-//    }
-   
-//    cout << "tree:   ";
-//    for (unsigned int i = 0; i < tree_bits.size(); i++)
-//       cout << tree_bits[i] << " ";
-//    cout << endl;
-
-//    cout << "perm:   ";
-//    for (unsigned int i = 0; i < perm.size(); i++)
-//       cout << perm[i] << " ";
-//    cout << endl;
-
-//    cout << "orient: ";
-//    for (unsigned int i = 0; i < orient.size(); i++)
-//       cout << orient[i] << " ";
-//    cout << endl;
-
-//    cout << endl;
-
-// //    vector<BTree::BTreeNode> btree;
-// //    BTree::bits2tree(tree_bits, perm, orient, btree);
-// //    OutputBTree(cout, btree);
-
-//    BTree bt(blockinfo);
-//    bt.evaluate(tree_bits, perm, orient);
-
-//    OutputBTree(cout, bt);
-
-//    int indexOne, indexTwo;
-//    cout << "----swap-----" << endl;
-//    cout << "block One ->";
-//    cin >> indexOne;
-
-//    cout << "block Two ->";
-//    cin >> indexTwo;
-
-//    bt.swap(indexOne, indexTwo);
-//    OutputBTree(cout, bt);
-//    bt.save_bbb(argv[argc-1]);
-// }
-// // --------------------------------------------------------
-// void DebugEvaluate(int argc, char *argv[])
-// {
-//    ifstream infile;
-
-//    infile.open(argv[1]);
-//    if (!infile.good())
-//    {
-//       cout << "ERROR: cannot read file " << argv[1] << endl;
-//       exit(1);
-//    }
-//    HardBlockInfoType blockinfo(infile, "txt");
-
-//    vector<int> tree_bits;
-//    vector<int> perm;
-//    vector<int> orient;
-
-//    string bits_string(argv[2]);
-//    for (unsigned int i = 0; i < bits_string.length(); i++)
-//    {
-//       string dummy;
-//       dummy += bits_string[i];
-//       int this_bit = atoi(dummy.c_str());
-
-//       tree_bits.push_back(this_bit);
-//    }
-
-//    string orients_string(argv[3]);
-//    for (unsigned int i = 0; i < orients_string.length(); i++)
-//    {
-//       string dummy;
-//       dummy += orients_string[i];
-//       int this_orient = atoi(dummy.c_str());
-
-//       orient.push_back(this_orient);
-//    }
-
-//    if (tree_bits.size() != 2 * orient.size())
-//    {
-//       cout << "ERROR: the sizes of tree_bits and orient not consistent."
-//            << endl;
-//       cout << "tree: " << tree_bits.size() << " vz. orient: "
-//            << orient.size() << endl;
-//       exit(1);
-//    }
-
-//    for (unsigned int i = 0; i < orient.size(); i++)
-//    {
-//       int blk = -1;
-//       cout << "Enter next block ->";
-//       cin >> blk;
-         
-//       perm.push_back(blk);
-//    }
-   
-//    cout << "tree:   ";
-//    for (unsigned int i = 0; i < tree_bits.size(); i++)
-//       cout << tree_bits[i] << " ";
-//    cout << endl;
-
-//    cout << "perm:   ";
-//    for (unsigned int i = 0; i < perm.size(); i++)
-//       cout << perm[i] << " ";
-//    cout << endl;
-
-//    cout << "orient: ";
-//    for (unsigned int i = 0; i < orient.size(); i++)
-//       cout << orient[i] << " ";
-//    cout << endl;
-
-//    cout << endl;
-
-// //    vector<BTree::BTreeNode> btree;
-// //    BTree::bits2tree(tree_bits, perm, orient, btree);
-// //    OutputBTree(cout, btree);
-
-//    BTree bt(blockinfo);
-//    bt.evaluate(tree_bits, perm, orient);
-
-//    OutputBTree(cout, bt);
-
-//    cout << "-----take 2-----" << endl;
-//    cout << "tree: ";
-//    for (int i = 0; i < 2*bt.NUM_BLOCKS; i++)
-//       cin >> tree_bits[i];
-
-//    cout << "perm: ";
-//    for (int i = 0; i < bt.NUM_BLOCKS; i++)
-//       cin >> perm[i];
-
-//    cout << "orient: ";
-//    for (int i = 0; i < bt.NUM_BLOCKS; i++)
-//       cin >> orient[i];
-
-//    bt.evaluate(tree_bits, perm, orient);
-//    OutputBTree(cout, bt);
-//    bt.save_bbb(argv[argc-1]);
-// }
-// // --------------------------------------------------------
-// void DebugBits2Tree(int argc, char *argv[])
-// {
-//    ifstream infile;
-   
-//    infile.open(argv[1]);
-//    if (!infile.good())
-//    {
-//       cout << "ERROR: cannot read file " << argv[1] << endl;
-//       exit(1);
-//    }
-//    HardBlockInfoType blockinfo(infile, "txt");
-
-//    vector<int> tree_bits;
-//    vector<int> perm;
-//    vector<int> orient;
-
-//    string bits_string(argv[2]);
-//    for (unsigned int i = 0; i < bits_string.length(); i++)
-//    {
-//       string dummy;
-//       dummy += bits_string[i];
-//       int this_bit = atoi(dummy.c_str());
-
-//       tree_bits.push_back(this_bit);
-//    }
-
-//    string orients_string(argv[3]);
-//    for (unsigned int i = 0; i < orients_string.length(); i++)
-//    {
-//       string dummy;
-//       dummy += orients_string[i];
-//       int this_orient = atoi(dummy.c_str());
-
-//       orient.push_back(this_orient);
-//    }
-
-//    if (tree_bits.size() != 2 * orient.size())
-//    {
-//       cout << "ERROR: the sizes of tree_bits and orient not consistent."
-//            << endl;
-//       cout << "tree: " << tree_bits.size() << " vz. orient: "
-//            << orient.size() << endl;
-//       exit(1);
-//    }
-
-//    for (unsigned int i = 0; i < orient.size(); i++)
-//    {
-//       perm.push_back(i);
-//    }
-
-//    for (unsigned int i = 0; i < tree_bits.size(); i++)
-//       cout << tree_bits[i] << " ";
-//    cout << endl;
-
-//    for (unsigned int i = 0; i < perm.size(); i++)
-//       cout << perm[i] << " ";
-//    cout << endl;
-
-//    for (unsigned int i = 0; i < orient.size(); i++)
-//       cout << orient[i] << " ";
-//    cout << endl;
-
-//    vector<BTree::BTreeNode> btree;
-//    cout << "-----BEFORE-----" << endl;
-//    OutputBTree(cout, btree);
-//    cout << endl;
-   
-//    BTree::bits2tree(tree_bits, perm, orient, btree);
-
-//    cout << "-----AFTER-----" << endl;
-//    OutputBTree(cout, btree);
-//    cout << endl;
-// }
-// // --------------------------------------------------------
-void OutputHardBlockInfoType(ostream& outs,
-                             const HardBlockInfoType& blockinfo)
-{
-   outs << "index:     ";
-   for (int i = 0; i < blockinfo.blocknum()+2; i++)
-      outs << setw(FIELD_WIDTH) << i;
-   outs << endl << endl;
-
-   for (int j = 0; j < HardBlockInfoType::ORIENT_NUM; j++)
-   {
-      outs << "width[" << j << "]:  ";
-      for (int i = 0; i < blockinfo.blocknum()+2; i++)
-         if (blockinfo[i].width[j] >= Dimension::INFTY)
-            outs << " infty";
-         else
-            outs << setw(FIELD_WIDTH) << blockinfo[i].width[j];
-      outs << endl;
-
-      outs << "height[" << j << "]: ";
-      for (int i = 0; i < blockinfo.blocknum()+2; i++)
-         if (blockinfo[i].height[j] >= Dimension::INFTY)
-            outs << " infty";
-         else
-            outs << setw(FIELD_WIDTH) << blockinfo[i].height[j];
-      outs << endl << endl;
-   }
-}
-// --------------------------------------------------------
-void OutputBTree(ostream& outs,
-                 const vector<BTree::BTreeNode>& btree)
-{
-   int btree_size = btree.size();
-   outs << "btree_size: " << btree_size << endl;
-   outs << "index:      ";
-   for (int i = 0; i < btree_size; i++)
-      outs << setw(FIELD_WIDTH) << i;
-   outs << endl;
-          
-   outs << "tree.par:   ";
-   for (int i = 0; i < btree_size; i++)
-      OutputIndex(outs, btree[i].parent);
-   outs << endl;
-
-   outs << "tree.left:  ";
-   for (int i = 0; i < btree_size; i++)
-      OutputIndex(outs, btree[i].left);
-   outs << endl;
-
-   outs << "tree.right: ";
-   for (int i = 0; i < btree_size; i++)
-      OutputIndex(outs, btree[i].right);
-   outs << endl;
-
-   outs << "tree.bkind: ";
-   for (int i = 0; i < btree_size; i++)
-      OutputIndex(outs, btree[i].block_index);
-   outs << endl;
-
-   outs << "tree.orien: ";
-   for (int i = 0; i < btree_size; i++)
-      OutputIndex(outs, btree[i].orient);
-   outs << endl;
-
-   outs << endl;
-
-}
-// --------------------------------------------------------
-void OutputBTree(ostream& outs,
-                 const BTree& bt)
-{
-   outs << "NUM_BLOCKS: " << bt.NUM_BLOCKS << endl << endl;
-   outs << "index:      ";
-   for (int i = 0; i < bt.NUM_BLOCKS+2; i++)
-      OutputIndex(cout, i);
-   outs << endl;
-          
-   outs << "tree.par:   ";
-   for (int i = 0; i < bt.NUM_BLOCKS+2; i++)
-      OutputIndex(cout, bt.tree[i].parent);
-   outs << endl;
-
-   outs << "tree.left:  ";
-   for (int i = 0; i < bt.NUM_BLOCKS+2; i++)
-      OutputIndex(cout, bt.tree[i].left);
-   outs << endl;
-
-   outs << "tree.right: ";
-   for (int i = 0; i < bt.NUM_BLOCKS+2; i++)
-      OutputIndex(cout, bt.tree[i].right);
-   outs << endl;
-
-   outs << "tree.bkind: ";
-   for (int i = 0; i < bt.NUM_BLOCKS+2; i++)
-      OutputIndex(cout, bt.tree[i].block_index);
-   outs << endl;
-
-   outs << "tree.orien: ";
-   for (int i = 0; i < bt.NUM_BLOCKS+2; i++)
-      OutputIndex(cout, bt.tree[i].orient);
-   outs << endl;
-
-   outs << endl;
-
-   outs << "cont.next:  ";
-   for (int i = 0; i < bt.NUM_BLOCKS+2; i++)
-      OutputIndex(cout, bt.contour[i].next);
-   outs << endl;
-
-   outs << "cont.prev:  ";
-   for (int i = 0; i < bt.NUM_BLOCKS+2; i++)
-      OutputIndex(cout, bt.contour[i].prev);
-   outs << endl;
-
-   outs << "cont.begin: ";
-   for (int i = 0; i < bt.NUM_BLOCKS+2; i++)
-      OutputDouble(outs, bt.contour[i].begin);
-   outs << endl;
-
-   outs << "cont.end:   ";
-   for (int i = 0; i < bt.NUM_BLOCKS+2; i++)
-      OutputDouble(outs, bt.contour[i].end);
-   outs << endl;//    while (cin.good())
-
-   outs << "cont.CTL:   ";
-   for (int i = 0; i < bt.NUM_BLOCKS+2; i++)
-      OutputDouble(outs, bt.contour[i].CTL);
-   outs << endl;
-
-   outs << endl;
-
-   outs << "xloc:       ";
-   for (int i = 0; i < bt.NUM_BLOCKS+2; i++)
-      OutputDouble(outs, bt.xloc(i));
-   outs << endl;
-
-   outs << "yloc:       ";
-   for (int i = 0; i < bt.NUM_BLOCKS+2; i++)
-      OutputDouble(outs, bt.yloc(i));
-   outs << endl;
-
-   outs << "width:      ";
-   for (int i = 0; i < bt.NUM_BLOCKS+2; i++)
-      OutputDouble(outs, bt.width(i));
-   outs << endl;
-
-   outs << "height:     ";
-   for (int i = 0; i < bt.NUM_BLOCKS+2; i++)
-      OutputDouble(outs, bt.height(i));
-   outs << endl;
-
-   outs << endl;
-
-   outs << "blockArea:   " << bt.blockArea() << endl;
-   outs << "totalArea:   " << bt.totalArea() << endl;
-   outs << "totalWidth:  " << bt.totalWidth() << endl;
-   outs << "totalHeight: " << bt.totalHeight() << endl;
-
-   outs << endl;
-   outs << "-----contour (L to R)-----" << endl;
-
-   outs << "index: ";
-   int cPtr = bt.NUM_BLOCKS;
-   while (cPtr != BTree::UNDEFINED)
-   {
-      outs << setw(FIELD_WIDTH) << cPtr;
-      cPtr = bt.contour[cPtr].next;
-   }
-   outs << endl;
-
-   outs << "begin: ";
-   cPtr = bt.NUM_BLOCKS;
-   while (cPtr != BTree::UNDEFINED)
-   {
-      OutputDouble(cout, bt.contour[cPtr].begin);
-      cPtr = bt.contour[cPtr].next;
-   }
-   outs << endl;
-
-   outs << "end:   ";
-   cPtr = bt.NUM_BLOCKS;
-   while (cPtr != BTree::UNDEFINED)
-   {
-      OutputDouble(cout, bt.contour[cPtr].end);
-      cPtr = bt.contour[cPtr].next;
-   }
-   outs << endl;
-
-   outs << "CTL:   ";
-   cPtr = bt.NUM_BLOCKS;
-   while (cPtr != BTree::UNDEFINED)
-   {
-      OutputDouble(cout, bt.contour[cPtr].CTL);
-      cPtr = bt.contour[cPtr].next;
-   }
-   outs << endl;
-}
-// --------------------------------------------------------
-void OutputPacking(ostream& outs,
-                   const OrientedPacking& pk)
-{
-   int blocknum = pk.xloc.size();
-   outs << setw(9) << "xloc: ";
-   for (int i = 0; i < blocknum; i++)
-      outs << setw(5) << pk.xloc[i];
-   outs << endl;
-
-   outs << setw(9) << "yloc: ";
-   for (int i = 0; i < blocknum; i++)
-      outs << setw(5) << pk.yloc[i];
-   outs << endl;
-
-   outs << setw(9) << "width: ";
-   for (int i = 0; i < blocknum ; i++)
-      outs << setw(5) << pk.width[i];
-   outs << endl;
-
-   outs << setw(9) << "height: ";
-   for (int i = 0; i < blocknum; i++)
-      outs << setw(5) << pk.height[i];
-   outs << endl;
-
-   outs << setw(9) << "orient: ";
-   for (int i = 0; i < blocknum; i++)
-      outs << setw(5) << pk.orient[i];
-   outs << endl;
-}
-// --------------------------------------------------------
-void OutputDouble(ostream& outs, double d)
-{
-   outs.setf(ios::fixed);
-   outs.precision(1);
-   if (d >= Dimension::INFTY)
-      outs << setw(FIELD_WIDTH) << "infty";
-
-   else if (d == Dimension::UNDEFINED)
-      outs << setw(FIELD_WIDTH) << "-";
-   else
-      outs << setw(FIELD_WIDTH) << d;
-}
-// --------------------------------------------------------
-void OutputIndex(ostream& outs, int i)
-{
-   if (i == Dimension::UNDEFINED)
-      outs << setw(FIELD_WIDTH) << "-";
-   else
-      outs << setw(FIELD_WIDTH) << i;
-}
-// --------------------------------------------------------
-void OutputMixedBlockInfoType(ostream& outs,
-                              const MixedBlockInfoType& blockinfo)
-{
-   int vec_size = blockinfo.blockARinfo.size();
-
-   outs << "_currDimensions: " << endl;
-   outs << "name:     ";
-   for (int i = 0; i < vec_size; i++)
-   {
-      char name[100];
-      sprintf(name, "\"%s\"",
-              blockinfo.currDimensions.block_names[i].c_str());
-      outs << setw(FIELD_WIDTH) << name;
-   }
-   outs << endl;
-   OutputHardBlockInfoType(outs, blockinfo.currDimensions);
-   outs << endl;
-
-   outs << "_blockARinfo: " << endl;
-   outs.setf(ios::fixed);
-   outs.precision(2);
-   outs << "index:    ";
-   for (int i = 0; i < vec_size; i++)
-      OutputIndex(outs, i);
-   outs << endl;
-   for (int j = 0; j < MixedBlockInfoType::ORIENT_NUM; j++)
-   {
-      outs << "minAR[" << j << "]: ";      
-      for (int i = 0; i < vec_size; i++)
-         OutputDouble(outs, blockinfo.blockARinfo[i].minAR[j]);
-      outs << endl;
-      outs << "maxAR[" << j << "]: ";
-      for (int i = 0; i < vec_size; i++)
-         OutputDouble(outs, blockinfo.blockARinfo[i].maxAR[j]);
-      outs << endl << endl;
-   }
-   outs << "area:  ";
-   for (int i = 0; i < vec_size; i++)
-      OutputDouble(outs, blockinfo.blockARinfo[i].area);
-   outs << endl;
-
-   outs << "isSoft: ";
-   for (int i = 0; i < vec_size; i++)
-      outs << setw(FIELD_WIDTH)
-           << ((blockinfo.blockARinfo[i].isSoft)? "SOFT" : "HARD");
-   outs << endl;
-}
-// --------------------------------------------------------
-   
-   
-   
diff -druN BloBB_CompaSS_050315/BTree/debugflags.h blob_compass/BTree/debugflags.h
--- BloBB_CompaSS_050315/BTree/debugflags.h	2005-03-14 21:35:03.000000000 -0800
+++ blob_compass/BTree/debugflags.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,38 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef DEBUGFLAGS_H
-#define DEBUGFLAGS_H
-
-// #define PARQUET_DEBUG_HAYWARD_ASSERT_BTREEANNEAL
-// #define PARQUET_DEBUG_HAYWARD_DISPLAY_MIXEDPACKINGFROMDB
-
-#endif
diff -druN BloBB_CompaSS_050315/BTree/debug.h blob_compass/BTree/debug.h
--- BloBB_CompaSS_050315/BTree/debug.h	2005-03-14 21:34:47.000000000 -0800
+++ blob_compass/BTree/debug.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,91 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef DEBUG_H
-#define DEBUG_H
-
-#include "btree.h"
-#include "netlist.h"
-
-#include <iostream>
-#include <fstream>
-#include <iomanip>
-#include <string>
-using namespace std;
-
-const int FIELD_WIDTH = 10;
-
-void OutputHardBlockInfoType(ostream& outs,
-                             const HardBlockInfoType& blockinfo);
-void OutputBTree(ostream& outs,
-                 const BTree& bt);
-void OutputBTree(ostream& outs,
-                 const vector<BTree::BTreeNode>& tree);
-void OutputPacking(ostream& outs,
-                   const OrientedPacking& pk);
-
-void OutputMixedBlockInfoType(ostream& outs,
-                              const MixedBlockInfoType& blockinfo);
-   
-void OutputDouble(ostream& outs, double d);
-void OutputIndex(ostream& outs, int i);
-
-void DebugBits2Tree(int argc, char *argv[]);
-void DebugEvaluate(int argc, char *argv[]);
-void DebugSwap(int argc, char *argv[]);
-void DebugMove(int argc, char *argv[]);
-
-void DebugParseBlocks(int argc, char *argv[]);
-void DebugParseNets(int argc, char *argv[]);
-void DebugHPWL(int argc, char *argv[]);
-
-void DebugCopy(int argc, char *argv[]);
-void DebugCompact(int argc, char *argv[]);
-
-void DebugAnneal(int argc, char *argv[]);
-void DebugWireAnneal(int argc, char *argv[]);
-
-void DebugSSTreeToBTree(int argc, char *argv[]);
-
-void DebugParquetBTree(int argc, char *argv[]);
-void DebugBTreeSlack(int argc, char *argv[]);
-void DebugMixedPacking(int argc, char *argv[]);
-void DebugSoftPacking(int argc, char *argv[]);
-void DebugPltoSP(int argc, char *argv[]);
-void DebugPltoBTree(int argc, char *argv[]);
-void DebugPlSPtoBTree(int argc, char *argv[]);
-void DebugShiftBlock(int argc, char *argv[]);
-void DebugShiftLegalizer(int argc, char *argv[]);
-void DebugMixedBlockInfoTypeFromDB(int argc, char *argv[]);
-void DebugBTreeAnnealerFromDB(int argc, char *argv[]);
-
-#endif
-
diff -druN BloBB_CompaSS_050315/BTree/Makefile blob_compass/BTree/Makefile
--- BloBB_CompaSS_050315/BTree/Makefile	2005-03-14 22:41:12.000000000 -0800
+++ blob_compass/BTree/Makefile	1969-12-31 16:00:00.000000000 -0800
@@ -1,68 +0,0 @@
-#/**************************************************************************
-#***    
-#*** Copyright (c) 2004 Regents of the University of Michigan,
-#***               Hayward H. Chan and Igor L. Markov
-#***
-#***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-#***  Original Affiliation:   EECS Department, 
-#***                          The University of Michigan,
-#***                          Ann Arbor, MI 48109-2122
-#***
-#***  Permission is hereby granted, free of charge, to any person obtaining 
-#***  a copy of this software and associated documentation files (the
-#***  "Software"), to deal in the Software without restriction, including
-#***  without limitation 
-#***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-#***  and/or sell copies of the Software, and to permit persons to whom the 
-#***  Software is furnished to do so, subject to the following conditions:
-#***
-#***  The above copyright notice and this permission notice shall be included
-#***  in all copies or substantial portions of the Software.
-#***
-#*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-#*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-#*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-#*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-#*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-#*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-#*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-#***
-#***
-#***************************************************************************/
-
-.SUFFIXES:        .o .cxx 
-
-CC = g++
-CCFLAGS = -Wall -O3 -ansi $(CCDIRS)
-PURIFY = purify -log-file=log.txt
-MOREOPT = -funroll-loops
-
-CCDIRS = -I../BloBB -I../CompaSS -I../common 
-LDDIRS = -L../BloBB -L../CompaSS -L../common 
-
-AR = ar cr
-
-btree_OBJS = btreecompact.o btreecompactsstree.o btree.o btreefromsstree.o btreeslackeval.o 
-
-THISLIB = BTree
-LIBNAME = lib$(THISLIB).a
-
-LDFINAL = $(CC)
-LIBBASE = ../lib
-LIBS = -L$(LIBBASE) -L. -l$(THISLIB) -lBloBB -lBTree -lcommon -lCompaSS
-
-# -----linking all together-----
-lib : $(LIBNAME)
-
-$(LIBNAME) : $(btree_OBJS)
-	/bin/rm -f $(LIBNAME)
-	$(AR) $(LIBNAME) $(btree_OBJS) 
-	/bin/rm -f $(LIBBASE)/$(LIBNAME)
-	ln -s ../BTree/$(LIBNAME) $(LIBBASE)/$(LIBNAME)
-
-.cxx.o : 
-	$(CC) $(CCFLAGS) -c $*.cxx
-
-clean :
-	rm -f *.o *~ *.a
-
diff -druN BloBB_CompaSS_050315/BTree/temp blob_compass/BTree/temp
--- BloBB_CompaSS_050315/BTree/temp	2004-09-11 12:15:42.000000000 -0700
+++ blob_compass/BTree/temp	1969-12-31 16:00:00.000000000 -0800
@@ -1,10 +0,0 @@
-0a1,9
-> 5,6c5,6
-> < *** Copyright (c) 2000-2002 Regents of the University of Michigan,
-> < ***               Saurabh N. Adya and Igor L. Markov
-> ---
-> > *** Copyright (c) 2000-2004 Regents of the University of Michigan,
-> > ***               Saurabh N. Adya, Jarrod A. Roy and Igor L. Markov
-> 36a37,38
-> > 
-> > 
diff -druN BloBB_CompaSS_050315/common/basepacking.cxx blob_compass/common/basepacking.cxx
--- BloBB_CompaSS_050315/common/basepacking.cxx	2005-03-14 21:37:27.000000000 -0800
+++ blob_compass/common/basepacking.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,290 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "basepacking.h"
-#include "parsers.h"
-
-#include <float.h>
-#include <stdio.h>
-#include <iostream>
-#include <vector>
-using namespace std;
-using namespace parse_utils;
-using namespace basepacking_h;
-
-// ======================
-// Contructors in the end
-// ======================
-const double Dimension::INFTY = 1e100;
-const double Dimension::EPSILON_ACCURACY = 1e10;
-const int Dimension::UNDEFINED = -1;
-const int Dimension::ORIENT_NUM = 8;
-
-const int HardBlockInfoType::ORIENT_NUM = Dimension::ORIENT_NUM;
-// ========================================================
-void HardBlockInfoType::set_dimensions(int i,
-                                       double w,
-                                       double h)
-{
-   in_blocks[i].width.resize(ORIENT_NUM);
-   in_blocks[i].height.resize(ORIENT_NUM);
-   for (int j = 0; j < ORIENT_NUM; j++)
-      if (j % 2 == 0)
-      {
-         in_blocks[i].width[j] = w;
-         in_blocks[i].height[j] = h;
-      }
-      else
-      {
-         in_blocks[i].width[j] = h;
-         in_blocks[i].height[j] = w;
-      }
-}
-// --------------------------------------------------------
-HardBlockInfoType::HardBlockInfoType(ifstream& ins,
-                                     const string& format)
-   : blocks(in_blocks),
-     block_names(in_block_names)
-{
-   if (format == "txt")
-      ParseTxt(ins);
-   else if (format == "blocks")
-      ParseBlocks(ins);
-   else
-   {
-      cout << "ERROR: invalid format: " << format << endl;
-      exit(1);
-   }
-}
-// --------------------------------------------------------
-void HardBlockInfoType::ParseTxt(ifstream& ins)
-{
-   int blocknum = -1;
-   ins >> blocknum;
-
-   if (!ins.good())
-   {
-      cout << "ERROR: cannot read the block count." << endl;
-      exit(1);
-   }
-
-   in_blocks.resize(blocknum+2);
-   in_block_names.resize(blocknum+2);
-   for (int i = 0; i < blocknum; i++)
-   {
-      double w, h;
-      ins >> w >> h;
-
-      if (!ins.good())
-      {
-         cout << "ERROR: cannot read block no." << i << endl;
-         exit(1);
-      }
-
-      set_dimensions(i, w, h);
-
-      char temp[100];
-      temp[0] = '\0';
-      sprintf(temp, "%d", i);
-      in_block_names[i] = temp;
-   }
-   set_dimensions(blocknum, 0, Dimension::INFTY);
-   in_block_names[blocknum] = "LEFT";
-   
-   set_dimensions(blocknum+1, Dimension::INFTY, 0);
-   in_block_names[blocknum+1] = "BOTTOM";
-}
-// --------------------------------------------------------
-// taken from Nodes.cxx of Parquet using FPcommon.h/cxx
-// --------------------------------------------------------
-void HardBlockInfoType::ParseBlocks(ifstream& ins)
-{
-    char block_name[100];
-    char block_type[100];
-    char tempWord[100];
-    
-    int numSoftBl=0;
-    int numHardBl=0;
-    int numTerm=0;
-    
-    int indexBlock=0;
-
-    if(!ins)
-    {
-       cout << "ERROR: .blocks file could not be opened successfully"
-            << endl;
-       exit(1);
-    }
-    
-    skiptoeol(ins);
-    while(!ins.eof())
-    {
-       ins >> tempWord;
-       if(!(strcmp(tempWord,"NumSoftRectangularBlocks")))
-	  break;
-    }
-    
-    if (!ins.good())
-    {
-       cout << "ERROR in parsing .blocks file." << endl;
-       exit(1);
-    }
-    
-    ins >> tempWord;
-    ins >> numSoftBl;
-    if (numSoftBl != 0)
-    {
-       cout << "ERROR: soft block packing is not supported for now." << endl;
-       exit(0);
-    }
-    
-    while(!ins.eof())
-    {
-       ins >> tempWord;
-       if (!(strcmp(tempWord, "NumHardRectilinearBlocks")))
-	  break;
-    }
-    ins >> tempWord;
-    ins >> numHardBl;
-    
-    while(!ins.eof())
-    {
-       ins >> tempWord;
-       if (!(strcmp(tempWord, "NumTerminals")))
-	  break;
-    }
-    ins >> tempWord;
-    ins >> numTerm;
-
-    in_blocks.resize(numHardBl+2);
-    in_block_names.resize(numHardBl+2);
-    while(ins.good())
-    {
-       block_type[0] = '\0';
-       eatblank(ins);
-       
-       if (ins.eof())
-	  break;
-       if (ins.peek() == '#')
-          eathash(ins);
-       else
-       {
-	  eatblank(ins);
-          if (ins.peek() == '\n' || ins.peek() == '\r')
-          {
-             ins.get();
-             continue;
-          }
-          
-	  ins >> block_name;
-	  ins >> block_type;
-
-	  if (!strcmp(block_type, "softrectangular"))
-          {
-             cout << "ERROR: soft block packing is not supported now." << endl;
-             exit(1);
-          }
-	  else if (!strcmp(block_type,"hardrectilinear"))
-	  {
-             Point tempPoint;
-             vector<Point> vertices;
-             int numVertices;
-             bool success;
-             double width, height;
-
-             ins >> numVertices;             
-             success = true;
-             if (numVertices != 4)
-             {
-                cout << "ERROR in parsing .blocks file. "
-                     << "rectilinear blocks can be only rectangles for now"
-                     << endl;
-                exit(1);
-             }
-             
-             for (int i=0; i < numVertices; ++i)
-	     {
-                success &= needCaseChar(ins, '(');  ins.get();
-                ins >> tempPoint.x;
-                success &= needCaseChar(ins, ',');  ins.get();
-                ins >> tempPoint.y;
-                success &= needCaseChar(ins, ')');  ins.get();
-                vertices.push_back(tempPoint);
-	     }
-             if (!success)
-             {
-                cout << "ERROR in parsing .blocks file while processing "
-                     << "hardrectilinear blocks." << endl;
-                exit(1);
-             }
-	    
-             width = vertices[2].x - vertices[0].x;
-             height = vertices[2].y - vertices[0].y;
-
-             // consider a block
-//             cout << "[" << indexBlock << "] "
-//                  << setw(10) << block_name 
-//                  << " width: " << width
-//                  << " height: " << height << endl;
-             set_dimensions(indexBlock, width, height);
-             if (indexBlock >= int(block_names.size()))
-             {
-                cout << "ERROR: too many hard block specified." << endl;
-                exit(1);
-             }                 
-             in_block_names[indexBlock] = block_name;
-             ++indexBlock;
-	  }
-	  else if (!strcmp(block_type,"terminal"))
-          {  /* a pad */ }
-	  else if (ins.good())
-          {
-             cout << "ERROR: invalid block type: " << block_type << endl;
-             exit(1);
-          }  
-       }
-    } // end of while-loop
-    ins.close();
-    
-    if (numSoftBl+numHardBl != indexBlock)
-    {
-       cout << "ERROR in parsing .blocks file. # blocks do not tally "
-            << (indexBlock) << " vs. "
-            << (numSoftBl+numHardBl) << endl;
-       exit(1);
-    }
-    set_dimensions(numHardBl, 0, Dimension::INFTY);
-    in_block_names[numHardBl] = "LEFT";
-    
-    set_dimensions(numHardBl+1, Dimension::INFTY, 0);
-    in_block_names[numHardBl+1] = "BOTTOM";
-}
-// ========================================================
diff -druN BloBB_CompaSS_050315/common/basepacking.h blob_compass/common/basepacking.h
--- BloBB_CompaSS_050315/common/basepacking.h	2005-03-14 21:37:16.000000000 -0800
+++ blob_compass/common/basepacking.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,324 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef BASEPACKING_H
-#define BASEPACKING_H
-
-#include <fstream>
-#include <string>
-#include <iostream>
-#include <iomanip>
-#include <vector>
-using namespace std;
-
-// struct-like classes for representation conversion
-// --------------------------------------------------------
-class BasePacking
-{
-public:
-   vector<double> xloc;
-   vector<double> yloc;
-   vector<double> width;
-   vector<double> height;
-};
-// --------------------------------------------------------
-class OrientedPacking : public BasePacking
-{
-public:
-   enum ORIENT {N, E, S, W, FN, FE, FS, FW, UNDEFINED = -1};
-   vector<ORIENT> orient;
-
-   inline static ORIENT toOrient(char* orient);
-   inline static char* toChar(ORIENT orient);
-   inline static ORIENT flip(ORIENT orient);
-
-};
-inline ostream& operator << (ostream& outs, OrientedPacking::ORIENT);
-inline void Save_bbb(ostream& outs, const OrientedPacking& pk);
-inline void Read_bbb(istream& ins, const OrientedPacking& pk);
-// --------------------------------------------------------
-namespace basepacking_h
-{   
-   class Dimension
-   {
-   public:
-      vector<double> width;
-      vector<double> height;
-      
-      static const double INFTY; // = 1e100;
-      static const double EPSILON_ACCURACY; // = 1e10;
-      static const int UNDEFINED; // = -1;
-      static const int ORIENT_NUM; // = 8;
-   };
-}
-// --------------------------------------------------------
-class HardBlockInfoType
-{
-public:
-   HardBlockInfoType(ifstream& ins,         // formats:
-                     const string& format); // "txt" or "blocks"
-   const vector<basepacking_h::Dimension>& blocks;
-   const vector<string>& block_names;
-   inline const basepacking_h::Dimension& operator [](int index) const;
-   inline int blocknum() const;
-   inline double blockArea() const;
-
-   static const int ORIENT_NUM; // = basepacking_h::Dimension::ORIENT_NUM;
-
-   friend class MixedBlockInfoType;
-   friend class MixedBlockInfoTypeFromDB;
-   
-protected:
-   vector<basepacking_h::Dimension> in_blocks;   // store the left & bottom edges at the back
-   vector<string> in_block_names; // parallel array with in_blocks
-
-   void set_dimensions(int i, double w, double h);
-   void ParseTxt(ifstream& ins);
-   void ParseBlocks(ifstream& ins);
-
-   HardBlockInfoType(int blocknum)
-      : blocks(in_blocks),
-        block_names(in_block_names),
-        in_blocks(blocknum+2),
-        in_block_names(blocknum+2) {}
-
-   HardBlockInfoType(const HardBlockInfoType&);
-};
-// --------------------------------------------------------
-inline void PrintDimensions(double width, double height);
-inline void PrintAreas(double deadspace, double blockArea);
-inline void PrintUtilization(double deadspace, double blockArea);
-// --------------------------------------------------------
-
-// =========================
-//      IMPLEMENTATIONS
-// =========================
-inline ostream& operator << (ostream& outs,
-                             OrientedPacking::ORIENT orient)
-{
-   switch (orient)
-   {
-   case OrientedPacking::N:
-      outs << "N";
-      break;
-   case OrientedPacking::E:         
-      outs << "E";
-      break;
-   case OrientedPacking::S:
-      outs << "S";
-      break;
-   case OrientedPacking::W:
-      outs << "W";
-      break;
-   case OrientedPacking::FN:
-      outs << "FN";
-      break;
-   case OrientedPacking::FE:
-      outs << "FE";
-      break;
-   case OrientedPacking::FS:
-      outs << "FS";
-      break;
-   case OrientedPacking::FW:
-      outs << "FW";
-      break;
-   case OrientedPacking::UNDEFINED:
-      outs << "--";
-      break;
-   default:
-      cout << "ERROR in outputting orientations." << endl;
-      exit(1);
-      break;
-   }
-   return outs;
-}
-// --------------------------------------------------------
-inline void Save_bbb(ostream& outs,
-                     const OrientedPacking& pk)
-{
-   double totalWidth = 0;
-   double totalHeight = 0;
-   int blocknum = pk.xloc.size();
-   for (int i = 0; i < blocknum; i++)
-   {
-      totalWidth = max(totalWidth, pk.xloc[i]+pk.width[i]);
-      totalHeight = max(totalHeight, pk.yloc[i]+pk.height[i]);
-   }
-
-   outs << totalWidth << endl;
-   outs << totalHeight << endl;
-   outs << blocknum << endl;
-   for (int i = 0; i < blocknum; i++)
-      outs << pk.width[i] << " " << pk.height[i] << endl;
-   outs << endl;
-
-   for (int i = 0; i < blocknum; i++)
-      outs << pk.xloc[i] << " " << pk.yloc[i] << endl;
-}
-// --------------------------------------------------------
-inline void Read_bbb(istream& ins,
-                     OrientedPacking& pk)
-{
-   double width, height;
-   ins >> width >> height;
-   
-   int blocknum = -1;
-   ins >> blocknum;
-
-   pk.xloc.resize(blocknum);
-   pk.yloc.resize(blocknum);
-   pk.width.resize(blocknum);
-   pk.height.resize(blocknum);
-   pk.orient.resize(blocknum);
-   for (int i = 0; i < blocknum; i++)
-   {
-      ins >> pk.width[i] >> pk.height[i];
-      pk.orient[i] = OrientedPacking::N;
-   }
-
-   for (int i = 0; i < blocknum; i++)
-      ins >> pk.xloc[i] >> pk.yloc[i];
-}   
-// --------------------------------------------------------
-inline OrientedPacking::ORIENT OrientedPacking::flip(OrientedPacking::ORIENT
-                                                     orient)
-{
-   switch(orient)
-   {
-   case N: return FE;
-   case E: return FN;
-   case S: return FW;
-   case W: return FS;
-   case FN: return E;
-   case FE: return N;
-   case FS: return W;
-   case FW: return S;
-   case UNDEFINED: return UNDEFINED;
-   default:
-      cout << "ERROR: invalid orientation: " << orient << endl;
-      exit(1);
-      break;
-   }
-}
-// --------------------------------------------------------
-inline OrientedPacking::ORIENT OrientedPacking::toOrient(char* orient)
-{
-   if(!strcmp(orient, "N"))
-      return N;
-   if(!strcmp(orient, "E"))
-      return E;
-   if(!strcmp(orient, "S"))
-      return S;
-   if(!strcmp(orient, "W"))
-      return W;
-   if(!strcmp(orient, "FN"))
-      return FN;
-   if(!strcmp(orient, "FE"))
-      return FE;
-   if(!strcmp(orient, "FS"))
-      return FS;
-   if(!strcmp(orient, "FW"))
-      return FW;
-   if (!strcmp(orient, "--"))
-      return UNDEFINED;
-   
-   cout << "ERROR: in converting char* to ORIENT" << endl;
-   exit(1);
-   return UNDEFINED;
-}
-// --------------------------------------------------------
-inline char* OrientedPacking::toChar(ORIENT orient)
-{
-  if(orient == N)
-     return("N"); 
-  if(orient == E)
-     return("E"); 
-  if(orient == S)
-     return("S"); 
-  if(orient == W)
-     return("W"); 
-  if(orient == FN)
-     return("FN"); 
-  if(orient == FE)
-     return("FE"); 
-  if(orient == FS)
-     return("FS"); 
-  if(orient == FW)
-     return("FW"); 
-  if (orient == UNDEFINED)
-     return("--");
-  
-  cout << "ERROR in converting ORIENT to char* " << endl;
-  exit(1);
-  return "--";
-}
-// ========================================================
-inline const basepacking_h::Dimension& HardBlockInfoType::operator [](int index) const
-{  return in_blocks[index]; }
-// --------------------------------------------------------
-inline int HardBlockInfoType::blocknum() const
-{  return (in_blocks.size()-2); }
-// --------------------------------------------------------
-inline double HardBlockInfoType::blockArea() const
-{
-   double sum = 0;
-   for (int i = 0; i < blocknum(); i++)
-      sum += in_blocks[i].width[0] * in_blocks[i].height[0];
-   return sum;
-}
-// ========================================================
-void PrintDimensions(double width, double height)
-{
-   cout << "width:  " << width << endl;
-   cout << "height: " << height << endl;
-}
-// --------------------------------------------------------
-void PrintAreas(double deadspace, double blockArea)
-{
-   cout << "total area: " << setw(11)
-        << deadspace + blockArea << endl;
-   cout << "block area: " << setw(11) << blockArea << endl;
-   cout << "dead space: " << setw(11) << deadspace
-        << " (" << (deadspace / blockArea) * 100 << "%)" << endl;
-}
-// --------------------------------------------------------
-void PrintUtilization(double deadspace, double blockArea)
-{
-   double totalArea = deadspace + blockArea;
-   cout << "area usage   (wrt. total area): "
-        << ((1 - (deadspace / totalArea)) * 100) << "%" << endl;
-   cout << "dead space % (wrt. total area): "
-        << ((deadspace / totalArea) * 100) << "%" << endl;
-   cout << "---------------------------" << endl;
-}
-// ========================================================
-
-#endif
diff -druN BloBB_CompaSS_050315/common/interfaceutil.cxx blob_compass/common/interfaceutil.cxx
--- BloBB_CompaSS_050315/common/interfaceutil.cxx	2005-03-14 21:37:42.000000000 -0800
+++ blob_compass/common/interfaceutil.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,91 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "interfaceutil.h"
-
-#include <iostream>
-using namespace std;
-
-// ========================================================
-void SetDouble(int argc,
-               char *argv[],
-               int index,
-               double& param)
-{
-   if (argc <= index)
-   {
-      cout << "ERROR: must specified a number after label \""
-           << argv[index-1] << "\"." << endl;
-      exit(1);
-   }
-   
-   char **endp = new (char*);
-   endp[0] = new char[100];         
-   param = strtod(argv[index], endp);
-   
-   if (strcmp(endp[0], ""))
-   {
-      cout << "ERROR: invalid number \""
-           << argv[index] << "\"." << endl;
-      delete endp; 
-      exit(1);
-   }
-   else
-      delete endp;
-} 
-// --------------------------------------------------------
-void SetInt(int argc,
-            char *argv[],
-            int index,
-            int& param)
-{
-   if (argc <= index)
-   {
-      cout << "ERROR: must specified a number after label \""
-           << argv[index-1] << "\"." << endl;
-      exit(1);
-   }
-   
-   char **endp = new (char*);
-   endp[0] = new char[100];         
-   param = strtol(argv[index], endp, 10);
-   
-   if (strcmp(endp[0], ""))
-   {
-      cout << "ERROR: invalid number \""
-           << argv[index] << "\"." << endl;
-      delete endp;
-      exit(1);
-   }
-   else
-      delete endp;
-}   
-// ========================================================
diff -druN BloBB_CompaSS_050315/common/interfaceutil.h blob_compass/common/interfaceutil.h
--- BloBB_CompaSS_050315/common/interfaceutil.h	2005-03-14 21:37:50.000000000 -0800
+++ blob_compass/common/interfaceutil.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,43 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef INTERFACEUTIL_H
-#define INTERFACEUTIL_H
-
-#include <iostream>
-#include <cstring>
-
-using namespace std;
-
-void SetDouble(int argc, char *argv[], int index, double& param);
-void SetInt(int argc, char *argv[], int index, int& param);
-
-#endif
diff -druN BloBB_CompaSS_050315/common/Makefile blob_compass/common/Makefile
--- BloBB_CompaSS_050315/common/Makefile	2005-03-14 22:41:03.000000000 -0800
+++ blob_compass/common/Makefile	1969-12-31 16:00:00.000000000 -0800
@@ -1,68 +0,0 @@
-#/**************************************************************************
-#***    
-#*** Copyright (c) 2004 Regents of the University of Michigan,
-#***               Hayward H. Chan and Igor L. Markov
-#***
-#***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-#***  Original Affiliation:   EECS Department, 
-#***                          The University of Michigan,
-#***                          Ann Arbor, MI 48109-2122
-#***
-#***  Permission is hereby granted, free of charge, to any person obtaining 
-#***  a copy of this software and associated documentation files (the
-#***  "Software"), to deal in the Software without restriction, including
-#***  without limitation 
-#***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-#***  and/or sell copies of the Software, and to permit persons to whom the 
-#***  Software is furnished to do so, subject to the following conditions:
-#***
-#***  The above copyright notice and this permission notice shall be included
-#***  in all copies or substantial portions of the Software.
-#***
-#*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-#*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-#*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-#*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-#*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-#*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-#*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-#***
-#***
-#***************************************************************************/
-
-.SUFFIXES:        .o .cxx 
-
-CC = g++
-CCFLAGS = -Wall -O3 -ansi $(CCDIRS)
-PURIFY = purify -log-file=log.txt
-MOREOPT = -funroll-loops
-
-CCDIRS = 
-LDDIRS = 
-
-AR = ar cr
-
-common_OBJS = basepacking.o mixedpacking.o utilities.o interfaceutil.o
-
-THISLIB = common
-LIBNAME = lib$(THISLIB).a
-
-LDFINAL = $(CC)
-LIBBASE = ../lib
-LIBS = -L$(LIBBASE) -L. -l$(THISLIB) -lBloBB -lBTree -lcommon -lCompaSS
-
-# -----linking all together-----
-lib : $(LIBNAME)
-
-$(LIBNAME) : $(common_OBJS)
-	/bin/rm -f $(LIBNAME)
-	$(AR) $(LIBNAME) $(common_OBJS) 
-	/bin/rm -f $(LIBBASE)/$(LIBNAME)
-	ln -s ../common/$(LIBNAME) $(LIBBASE)/$(LIBNAME)
-
-.cxx.o : 
-	$(CC) $(CCFLAGS) -c $*.cxx
-
-clean :
-	rm -f *.o *~ *.a
-
diff -druN BloBB_CompaSS_050315/common/mixedpacking.cxx blob_compass/common/mixedpacking.cxx
--- BloBB_CompaSS_050315/common/mixedpacking.cxx	2005-03-14 21:39:06.000000000 -0800
+++ blob_compass/common/mixedpacking.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,244 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "mixedpacking.h"
-#include "basepacking.h"
-#include "parsers.h"
-
-#include <fstream>
-#include <cmath>
-using namespace std;
-using namespace parse_utils;
-using namespace basepacking_h;
-
-const int MixedBlockInfoType::ORIENT_NUM = HardBlockInfoType::ORIENT_NUM;
-// --------------------------------------------------------
-MixedBlockInfoType::MixedBlockInfoType(const string& blocksfilename,
-                                       const string& format)
-   : currDimensions(_currDimensions),
-     blockARinfo(_blockARinfo),
-     _currDimensions(0)
-{
-   ifstream infile;
-   infile.open(blocksfilename.c_str());
-   if (!infile.good())
-   {
-      cout << "ERROR: cannot open file " << blocksfilename << endl;
-      exit(1);
-   }
-  
-   if (format == "txt")
-   {
-      cout << "Sorry, .txt format isn't supported now." << endl;
-      exit(0);
-   }
-   else if (format == "blocks")
-      ParseBlocks(infile);
-}
-// --------------------------------------------------------
-void MixedBlockInfoType::ParseBlocks(ifstream& input)
-{
-   char block_name[1024];
-   char block_type[1024];
-   char tempWord1[1024];
-    
-   vector<Point> vertices;
-   int numVertices;
-   bool success; 
-   double width, height;
-   
-   double area,minAr,maxAr;
-   int numSoftBl=0;
-   int numHardBl=0;
-   int numBl = numSoftBl + numHardBl;
-   int numTerm=0;
-   
-   int indexBlock=0;
-   int indexTerm=0;
-   
-   if(!input)
-   {
-      cout<<"ERROR: .blocks file could not be opened successfully"<<endl;
-      exit(0);
-   }
-
-   while(!input.eof())
-   {
-      input>>tempWord1;
-      if(!(strcmp(tempWord1,"NumSoftRectangularBlocks")))
-         break;
-   }
-   input>>tempWord1;
-   input>>numSoftBl;
-
-   while(!input.eof())
-   {
-      input>>tempWord1;
-      if(!(strcmp(tempWord1,"NumHardRectilinearBlocks")))
-         break;
-   }
-   input>>tempWord1;
-   input>>numHardBl;
-    
-   while(!input.eof())
-   {
-      input>>tempWord1;
-      if(!(strcmp(tempWord1,"NumTerminals")))
-         break;
-   }
-   input>>tempWord1;
-   input>>numTerm;
-
-   numBl = numHardBl + numSoftBl;
-   _currDimensions.in_blocks.resize(numBl+2);
-   _currDimensions.in_block_names.resize(numBl+2);
-   _blockARinfo.resize(numHardBl+numSoftBl+2);
-   while(!input.eof())
-   {
-      block_type[0] = '\0';
-      eatblank(input);
-      if(input.eof())
-         break;
-      if(input.peek()=='#')
-         eathash(input);
-      else
-      {
-         eatblank(input);
-         if(input.peek() == '\n' || input.peek() == '\r')
-         {
-            input.get();
-            continue;
-         }
-         
-         input >> block_name;
-         input >> block_type ;
-         
-         if(!strcmp(block_type,"softrectangular")) 
-         {
-	    input >> area;
-	    input >> minAr;
-	    input >> maxAr;
-
-            width = sqrt(area);
-            height = sqrt(area);
-
-//             printf("[%d]: area: %.2lf minAR: %.2lf maxAR: %.2lf width: %.2lf height: %.2lf\n",
-//                    indexBlock, area, minAr, maxAr, width, height);
-            _currDimensions.set_dimensions(indexBlock, width, height);
-            if (indexBlock >= int(_currDimensions.block_names.size()))
-            {
-               cout << "ERROR: too many hard block specified." << endl;
-               exit(1);
-            }                 
-            _currDimensions.in_block_names[indexBlock] = block_name;
-
-            _blockARinfo[indexBlock].area = area;
-            set_blockARinfo_AR(indexBlock, min(minAr, maxAr), max(minAr, maxAr));
-            _blockARinfo[indexBlock].isSoft = true;
-            
-	    ++indexBlock;
-	    //cout<<block_name<<" "<<area<<endl;
-         }
-         else if(!strcmp(block_type,"hardrectilinear"))
-         {
-	    input >> numVertices;
-	    Point tempPoint;
-	    success = 1;
-	    if(numVertices > 4)
-               cout<<"ERROR in parsing .blocks file. rectilinear blocks can be only rectangles for now\n";
-	    for(int i=0; i<numVertices; ++i)
-            {
-	       success &= needCaseChar(input, '(');  input.get();
-	       input >> tempPoint.x;
-	       success &= needCaseChar(input, ',');  input.get();
-	       input >> tempPoint.y;
-	       success &= needCaseChar(input, ')');  input.get();
-	       vertices.push_back(tempPoint);
-            }
-	    if(!success)
-               cout<<"ERROR in parsing .blocks file while processing hardrectilinear blocks"<<endl;
-	    
-	    width = vertices[2].x - vertices[0].x;
-	    height = vertices[2].y - vertices[0].y;
-	    area = width*height;
-	    minAr = width/height;
-	    maxAr = minAr;
-
-            _currDimensions.set_dimensions(indexBlock, width, height);
-            if (indexBlock >= int(_currDimensions.block_names.size()))
-            {
-               cout << "ERROR: too many hard block specified." << endl;
-               exit(1);
-            }                 
-            _currDimensions.in_block_names[indexBlock] = block_name;
-            
-            _blockARinfo[indexBlock].area = area;
-            set_blockARinfo_AR(indexBlock, min(minAr, maxAr), max(minAr, maxAr));
-            _blockARinfo[indexBlock].isSoft = false;
-
-	    ++indexBlock;
-	    vertices.clear();
-	    //cout<<block_name<<" "<<area<<endl;
-         }
-         else if(!strcmp(block_type,"terminal"))
-         {
-	    ++indexTerm;
-	    //cout<<indexTerm<<"  "<<block_name<<endl;
-         }
-         /*
-           else
-	   cout<<"ERROR in parsing .blocks file"<<endl;
-         */
-      }  
-   }
-   input.close();
-   
-   if(numSoftBl+numHardBl != indexBlock)
-      cout << "ERROR in parsing .blocks file. No: of blocks do not tally "
-           << (indexBlock+indexTerm) << " vs " << (numSoftBl+numHardBl+numTerm)
-           << endl;
-
-   _currDimensions.set_dimensions(numBl, 0, Dimension::INFTY);
-   _currDimensions.in_block_names[numBl] = "LEFT";
-   _blockARinfo[numBl].area = 0;
-   _blockARinfo[numBl].minAR.resize(ORIENT_NUM, 0);
-   _blockARinfo[numBl].maxAR.resize(ORIENT_NUM, 0);
-   _blockARinfo[numBl].isSoft = false;
-
-   _currDimensions.set_dimensions(numBl+1, Dimension::INFTY, 0);
-   _currDimensions.in_block_names[numBl+1] = "BOTTOM";
-   _blockARinfo[numBl+1].area = 0;
-   _blockARinfo[numBl+1].minAR.resize(ORIENT_NUM, Dimension::INFTY);
-   _blockARinfo[numBl+1].maxAR.resize(ORIENT_NUM, Dimension::INFTY);
-   _blockARinfo[numBl+1].isSoft = false;
-}
-// --------------------------------------------------------
-      
diff -druN BloBB_CompaSS_050315/common/mixedpacking.h blob_compass/common/mixedpacking.h
--- BloBB_CompaSS_050315/common/mixedpacking.h	2005-03-14 21:39:20.000000000 -0800
+++ blob_compass/common/mixedpacking.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,109 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef MIXEDPACKING_H
-#define MIXEDPACKING_H
-
-#include "basepacking.h"
-
-#include <vector>
-#include <string>
-using namespace std;
-
-// --------------------------------------------------------
-class MixedBlockInfoType
-{
-public:
-   MixedBlockInfoType(const string& blocksfilename,
-                      const string& format); // "blocks" or "txt"
-   virtual ~MixedBlockInfoType() {}
-   
-   class BlockARInfo
-   {
-   public:
-      double area;
-      vector<double> maxAR; // maxAR/minAR for the "North" orientation
-      vector<double> minAR;
-      bool isSoft;
-   };
-   const HardBlockInfoType& currDimensions;
-   const vector<BlockARInfo>& blockARinfo;
-   static const int ORIENT_NUM; // = HardBlockInfoType::ORIENT_NUM;
-
-   inline void setBlockDimensions(int index, double newWidth, double newHeight,
-                                  int theta);
-
-protected:
-   HardBlockInfoType _currDimensions;
-   vector<BlockARInfo> _blockARinfo;
-
-   void ParseBlocks(ifstream& input);
-   inline void set_blockARinfo_AR(int index, double minAR, double maxAR);
-
-   // used by descendent class "MixedBlockInfoTypeFromDB"
-   MixedBlockInfoType(int blocknum)
-      : currDimensions(_currDimensions),
-        blockARinfo(_blockARinfo),
-        _currDimensions(blocknum),
-        _blockARinfo(blocknum+2)
-      {}
-};
-// --------------------------------------------------------
-
-// ===============
-// IMPLEMENTATIONS
-// ===============
-void MixedBlockInfoType::setBlockDimensions(int index,
-                                            double newWidth,
-                                            double newHeight,
-                                            int theta)
-{
-   double realWidth = (theta % 2 == 0)? newWidth : newHeight;
-   double realHeight = (theta % 2 == 0)? newHeight : newWidth;
-   _currDimensions.set_dimensions(index, realWidth, realHeight);
-}
-// --------------------------------------------------------
-void MixedBlockInfoType::set_blockARinfo_AR(int index,
-                                            double minAR,
-                                            double maxAR)
-{
-   _blockARinfo[index].minAR.resize(ORIENT_NUM);
-   _blockARinfo[index].maxAR.resize(ORIENT_NUM);
-   for (int i = 0; i < ORIENT_NUM; i++)
-   {
-      _blockARinfo[index].minAR[i] = ((i%2 == 0)?
-                                      minAR : (1.0 / maxAR));
-      _blockARinfo[index].maxAR[i] = ((i%2 == 0)?
-                                      maxAR : (1.0 / minAR));
-   }
-}         
-// -------------------------------------------------------- 
-#endif
diff -druN BloBB_CompaSS_050315/common/parsers.h blob_compass/common/parsers.h
--- BloBB_CompaSS_050315/common/parsers.h	2005-03-14 21:39:35.000000000 -0800
+++ blob_compass/common/parsers.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,107 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef PARSERS_H
-#define PARSERS_H
-
-#include <string>
-#include <iostream>
-#include <iomanip>
-#include <fstream>
-#include <vector>
-#include <algorithm>
-#include <math.h>
-#include <stdlib.h>
-#include <time.h>
-
-using namespace std;
-
-namespace parse_utils
-{
-   struct ltstr
-   {
-      inline bool operator ()(const char* s1, const char* s2) const
-         {   return strcmp(s1, s2) < 0; }
-   };
-   
-   struct Point
-   {
-      double x;
-      double y;
-   };
-   
-   struct IntPoint
-   {
-      int x;
-      int y;
-   };
-   
-   // global parsing functions
-   inline void eatblank(ifstream& i);   
-   inline void skiptoeol(ifstream& i);   
-   inline void eathash(ifstream& i);   
-   inline bool needCaseChar(ifstream& i, char character);
-}
-// namespace parse_utils
-   
-// =========================
-//      IMPLEMENTATIONS
-// =========================
-inline void parse_utils::eatblank(ifstream& i)
-{
-   while (i.peek()==' ' || i.peek()=='\t')
-      i.get();
-}
-// --------------------------------------------------------
-inline void parse_utils::skiptoeol(ifstream& i)
-{
-   while (!i.eof() && i.peek()!='\n' && i.peek()!='\r')
-      i.get();
-   i.get();
-}
-// --------------------------------------------------------
-inline bool parse_utils::needCaseChar(ifstream& i,
-                                      char character)
-{
-   while(!i.eof() && i.peek() != character)
-      i.get();
-   if(i.eof())
-      return false;
-   else
-      return true;
-}
-// --------------------------------------------------------
-inline void parse_utils::eathash(ifstream& i)
-{
-  skiptoeol(i);
-}
-// --------------------------------------------------------
-#endif
diff -druN BloBB_CompaSS_050315/common/utilities.cxx blob_compass/common/utilities.cxx
--- BloBB_CompaSS_050315/common/utilities.cxx	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/common/utilities.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,97 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "utilities.h"
-
-int counter[COUNTER_LENGTH][COUNTER_SIZE];
-string counterName[COUNTER_SIZE];
-
-// ========================================================
-//             RECORD_H IMPLEMENTATION
-// ========================================================
-void InitializeCounter()
-{
-   for (int i = 0; i < COUNTER_SIZE; i++)
-      for (int j = 0; j < COUNTER_SIZE; j++)
-         counter[i][j] = 0;
-}
-// --------------------------------------------------------
-void OutputCounter(ostream& outs,
-                   int columnNum,
-                   int rowNum)
-{
-   int sum = 0;
-   outs << "-size-";
-   for (int i = 0; i < columnNum; i++)
-   {
-      int spaceNum = max(0u, 10-counterName[i].length());
-      outs << "-" << counterName[i];
-      for (int j = 0; j < spaceNum; j++)
-         outs << "-";
-      outs << "-";
-   }
-   outs << endl;
-
-   for (int i = 1; i < rowNum; i++)
-   {
-      outs << setw(4) << i << "  ";
-      for (int j = 0; j < columnNum; j++)
-         outs << setw(12) << counter[i][j];
-      outs << endl;
-      sum += counter[i][0];
-   }
-   outs << "----" << endl << "sum:  " << setw(12) << sum << endl;
-}
-// --------------------------------------------------------
-
-
-// ========================================================
-//                CPUUSAGE_H IMPLEMENTATION
-// ========================================================
-double getTotalTime()
-{
-	// struct to store return values for getrusage()
-	// this struct is defined in the manpages
-	struct rusage infoStruct;
-	
-	// getrusage() returns seconds and fractions of a second (as micro-
-	// seconds) in separate variables for both system time and
-	// user time
-	getrusage(RUSAGE_SELF, &infoStruct);
-	
-	// total time is defined as system time + user time
-	double totalTime = infoStruct.ru_stime.tv_sec + 
-	  infoStruct.ru_utime.tv_sec + (double(infoStruct.ru_stime.tv_usec +
-	  infoStruct.ru_utime.tv_usec) / 1000000);
-	  
-	return totalTime;
-}
-// --------------------------------------------------------
diff -druN BloBB_CompaSS_050315/common/utilities.h blob_compass/common/utilities.h
--- BloBB_CompaSS_050315/common/utilities.h	2003-11-26 17:33:41.000000000 -0800
+++ blob_compass/common/utilities.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,98 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2003 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef UTILITIES_H
-#define UTILITIES_H
-
-#include <string>
-#include <algorithm>
-#include <iomanip>
-
-#include <sys/time.h>
-#include <sys/resource.h>
-#include <iostream>
-using namespace std;
-
-// ========
-// RECORD_H
-// ========
-// --------------------------------------------------------
-const int COUNTER_SIZE = 20;
-const int COUNTER_LENGTH = 100;
-extern int counter[COUNTER_LENGTH][COUNTER_SIZE];
-extern string counterName[COUNTER_SIZE];  // length <= 10
-
-void InitializeCounter();
-void OutputCounter(ostream& outs, int columnNum, int rowNum);
-// --------------------------------------------------------
-
-// ==========
-// CPUUSAGE_H
-// ==========
-// --------------------------------------------------------
-// EECS 281: Algorithms and Data Structures
-// Project 3
-// getrusage() demo
-//
-// by David Zohrob, dzohrob@umich.edu; please e-mail
-// with comments or corrections.
-//
-// This program sorts as much of a given array as it can
-// using BubbleSort, and quits after a specified time limit
-// suppplied in seconds
-
-
-// array size for bubble sort example
-#define ARRAY_SIZE 10000
-
-// time limit
-#define TIME_LIMIT 10
-
-// these definitions are provided in the getrusage() man pages
-// you can consider them to be "magic" if you like - they deal
-// with process hierarchies in UNIX.
-
-#ifndef RUSAGE_SELF
-#define RUSAGE_SELF      0              /* calling process */
-#endif
-
-#ifndef RUSAGE_CHILDREN
-#define RUSAGE_CHILDREN  -1     /* terminated child processes */
-#endif
-
-using namespace std;
-
-// this function uses getrusage() to return the total time your
-// program has been running in both system and user modes
-double getTotalTime();
-// --------------------------------------------------------
-
-#endif
diff -druN BloBB_CompaSS_050315/CompaSS/boundsoftst.cxx blob_compass/CompaSS/boundsoftst.cxx
--- BloBB_CompaSS_050315/CompaSS/boundsoftst.cxx	2004-02-07 20:17:14.000000000 -0800
+++ blob_compass/CompaSS/boundsoftst.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,79 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "boundsoftst.h"
-#include "datastrbacksoftst.h"
-#include "datastrfrontsoftst.h"
-
-#include <algorithm>
-using namespace std;
-
-double OPTIMAL_ACCURACY = DEFAULT_OPTIMAL_ACCURACY;
-double HIER_ACCURACY = DEFAULT_HIER_TXT_ACCURACY;
-
-// --------------------------------------------------------
-double extDeadspace(const SoftSTree& sst)
-{
-   int bSize = sst.buffer_size();
-   if (bSize < 2)
-      return 0;
-
-   double ext_deadspace = 0;
-
-   int cul_bdySize = sst.buffer_top().boundary.size();
-   double cul_minWidth = sst.buffer_top().boundary[0].xCoord();
-   double cul_minHeight = sst.buffer_top().boundary[cul_bdySize-1].yCoord();
-
-   for (int i = bSize-2; i >= 0; i--)
-   {
-      int curr_bdySize = sst.buffer(i).boundary.size();
-      double curr_maxWidth = sst.buffer(i).boundary[curr_bdySize-2].xCoord();
-      double curr_maxHeight = sst.buffer(i).boundary[1].yCoord();
-      
-      double curr_minWidth = sst.buffer(i).boundary[1].xCoord();
-      double curr_minHeight = sst.buffer(i).boundary[curr_bdySize-2].yCoord();
-
-      if ((curr_maxWidth < cul_minWidth) &&
-          (curr_maxHeight < cul_minHeight))
-      {
-         // have extended deadspace
-         ext_deadspace += min(curr_minWidth * (cul_minHeight-curr_maxHeight),
-                              curr_minHeight * (cul_minWidth-curr_maxWidth));
-      }
-      else
-      {
-         cul_minWidth = max(cul_minWidth, curr_minWidth);
-         cul_minHeight = max(cul_minHeight, curr_minHeight);
-      }
-   }
-   return ext_deadspace;
-}
-// --------------------------------------------------------
diff -druN BloBB_CompaSS_050315/CompaSS/boundsoftst.h blob_compass/CompaSS/boundsoftst.h
--- BloBB_CompaSS_050315/CompaSS/boundsoftst.h	2004-02-07 20:15:05.000000000 -0800
+++ blob_compass/CompaSS/boundsoftst.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,173 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef BOUNDSOFTST_H
-#define BOUNDSOFTST_H
-
-#include "datastrbacksoftst.h"
-#include "datastrfrontsoftst.h"
-#include "utilities.h"
-
-const double DEFAULT_OPTIMAL_ACCURACY = 1.0001;
-const double DEFAULT_HIER_TXT_ACCURACY = 1.005;
-const double DEFAULT_HIER_SOFT_ACCURACY = 1.02;
-
-extern double OPTIMAL_ACCURACY;
-extern double HIER_ACCURACY;
-
-typedef bool (*SoftCompareType)(const SoftSTree& sst,
-                                const SoftSliceRecord& best);
-typedef bool (*SoftOperandProceed)(const vector< vector<bool> >& same,
-                                   const vector<int>& blkBefore,
-                                   const SoftSTree& sst,
-                                   const SoftSliceRecord& best);
-typedef bool (*SoftOperatorProceed)(const SoftSTree& sst,
-                                    const SoftSliceRecord& best);
-
-// ========================================================
-// Lower bounds and symmetry-breaking functions (back-end)
-// ========================================================
-inline bool buffer_sym(const SoftSTree& sst)
-{
-   int bSize = sst.buffer_size();
-   return ((bSize < 2) ||
-           (sst.buffer(bSize-2).BLBlock < sst.buffer(bSize-1).BLBlock));
-}
-// --------------------------------------------------------
-inline bool abut_sym(const SoftSTree& sst)
-{
-   int sSize = sst.storage_size();
-   return ((sst.buffer_top().sign != sst.storage_top().sign) ||
-           (sst.storage(sSize-1).TRblblock < sst.storage(sSize-2).BLBlock));
-}
-// --------------------------------------------------------
-inline bool sameBlockProceed(const vector< vector<bool> >& same,
-                             const vector<int>& blkBefore,
-                             const SoftSTree& sst)
-{
-   int rect = sst.expression_top();
-   int rect_pos = sst.expression_size() - 1;
-   int blkCount = blkBefore[rect];
-
-   for (int i = 0; i < rect_pos; i++)
-   {
-      int sign = sst.expression(i);
-      if (blkCount == 0)
-         return true;
-      else if (sign >= 0 &&
-               same[rect][sign])
-         blkCount--;
-   }
-   return (blkCount == 0);
-}
-// --------------------------------------------------------
-double extDeadspace(const SoftSTree& sst);
-// --------------------------------------------------------
-// ========================================================
-// Interface functions used by the engines (front-end)
-// ========================================================
-inline bool BranchBoundCompare(const SoftSTree& sst,
-                               const SoftSliceRecord& best)
-{  return sst.deadspace() < best.minDeadspace; }
-// --------------------------------------------------------
-inline bool BruteProceed(const vector< vector<bool> >& same,
-                         const vector<int>& blkBefore,
-                         const SoftSTree& sst,
-                         const SoftSliceRecord& best)
-{   return true; }
-// --------------------------------------------------------
-inline bool BruteProceed(const SoftSTree& sst,
-                         const SoftSliceRecord& best)
-{   return true; }
-// --------------------------------------------------------
-inline bool BranchBoundProceed(const vector< vector<bool> >& same,
-                               const vector<int>& blkBefore,
-                               const SoftSTree& sst,
-                               const SoftSliceRecord& best)
-{
-   if (!buffer_sym(sst))
-      return false;   
-   if (!sameBlockProceed(same, blkBefore, sst))
-      return false;
-   counter[sst.expression_size()][2]++;
-
-   return true;
-}
-// --------------------------------------------------------
-inline bool BranchBoundExplicitProceed(const SoftSTree& sst,
-                                       const SoftSliceRecord& best)
-{
-   if (sst.total_area() * OPTIMAL_ACCURACY >= best.minArea)
-      return false;
-
-   if (!abut_sym(sst))
-      return false;
-
-   if (sst.total_area() + extDeadspace(sst) >= best.minArea)
-      return false;
-   counter[sst.expression_size()][4]++;
-
-   return true;
-}
-// --------------------------------------------------------
-inline bool BranchBoundImplicitProceed(const SoftSTree& sst,
-                                       const SoftSliceRecord& best)
-{
-   if (sst.total_area() * OPTIMAL_ACCURACY >= best.minArea)
-      return false;
-   counter[sst.expression_size()][5]++;
-
-   if (sst.total_area() + extDeadspace(sst) >= best.minArea)
-      return false;
-   counter[sst.expression_size()][6]++;
-
-   return true;
-}                               
-// --------------------------------------------------------
-inline bool BranchBoundHierarchicalProceed(const SoftSTree& sst,
-                                           const SoftSliceRecord& best)
-{
-   if (sst.total_area() * HIER_ACCURACY >= best.minArea)
-      return false;
-
-   if (!abut_sym(sst))
-      return false;
-   counter[sst.expression_size()][5]++;
-
-   if (sst.total_area() + extDeadspace(sst) >= best.minArea)
-      return false;
-   counter[sst.expression_size()][6]++;
-
-   return true;
-}
-// --------------------------------------------------------
-
-#endif
diff -druN BloBB_CompaSS_050315/CompaSS/COPYRIGHT blob_compass/CompaSS/COPYRIGHT
--- BloBB_CompaSS_050315/CompaSS/COPYRIGHT	2004-02-07 20:14:21.000000000 -0800
+++ blob_compass/CompaSS/COPYRIGHT	1969-12-31 16:00:00.000000000 -0800
@@ -1,31 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
diff -druN BloBB_CompaSS_050315/CompaSS/datastrbacksoftst.cxx blob_compass/CompaSS/datastrbacksoftst.cxx
--- BloBB_CompaSS_050315/CompaSS/datastrbacksoftst.cxx	2004-05-09 10:45:47.000000000 -0700
+++ blob_compass/CompaSS/datastrbacksoftst.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,592 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "datastrbacksoftst.h"
-
-#include <float.h>
-#include <vector>
-#include <algorithm>
-#include <cmath>
-using namespace std;
-
-// --------------------------------------------------------
-const double Point::INFTY = pow(DBL_MAX, 0.3);
-double Point::X_BOUND = Point::INFTY;
-double Point::Y_BOUND = Point::INFTY;
-// --------------------------------------------------------
-BoundaryType::BoundaryType(int instr,
-                           const BoundaryType& b1,
-                           const BoundaryType& b2)
-   : in_min_point(-1, -1)
-{
-   switch (instr)
-   {
-   case PLUS:
-      PlusCurves(b1.in_curve, b2.in_curve, in_curve);
-      break;
-      
-   case STAR:
-      StarCurves(b1.in_curve, b2.in_curve, in_curve);
-      break;
-
-   case OR:
-      OrCurves(b1.in_curve, b2.in_curve, in_curve);
-      break;
-
-   case BOTH:
-      BothCurves(b1.in_curve, b2.in_curve, in_curve);
-      break;
-   }
-   in_min_point = *min_element(in_curve.begin(), in_curve.end());
-}
-// --------------------------------------------------------
-BoundaryType::BoundaryType(int instr,
-                           const BoundaryType& b1,
-                           const BoundaryType& b2,
-                           double width_limit,
-                           double height_limit)
-   : in_min_point(width_limit*2, height_limit*2)
-{
-   switch (instr)
-   {
-   case PLUS:
-      PlusCurves(b1.in_curve, b2.in_curve, in_curve);
-      break;
-      
-   case STAR:
-      StarCurves(b1.in_curve, b2.in_curve, in_curve);
-      break;
-
-   case OR:
-      OrCurves(b1.in_curve, b2.in_curve, in_curve);
-      break;
-
-   case BOTH:
-      BothCurves(b1.in_curve, b2.in_curve, in_curve);
-      break;
-   }
-
-   int curveSize = in_curve.size();
-   int start_ptr = 0;
-   while ((start_ptr < curveSize) &&
-          (in_curve[start_ptr].yCoord() > height_limit))
-      start_ptr++;
-
-   int end_ptr = curveSize-1;
-   while ((end_ptr >= 0) &&
-          (in_curve[end_ptr].xCoord() > width_limit))
-      end_ptr--;
-
-   if (start_ptr <= end_ptr)
-      in_min_point = *min_element(&(in_curve[start_ptr]),
-                                  &(in_curve[end_ptr+1]));
-//    else
-//       in_min_point = Point(in_curve[1].yCoord(),
-//                            in_curve[curveSize-2].xCoord());
-//   in_min_point = *min_element(in_curve.begin(), in_curve.end());
-}  
-// --------------------------------------------------------
-double BoundaryType::getX(double yCoord) const 
-{
-   int left = 0;
-   int right = in_curve.size()-1;
-   int mid = right / 2;
-
-   if (yCoord < in_curve[right].yCoord())
-      return -1; // no solution found if yCoord too small
-   
-   while (left < right)
-   {
-      if (mid > left &&
-          in_curve[mid-1].yCoord() >= yCoord &&
-          in_curve[mid].yCoord() <= yCoord)
-      {
-         // special case?
-         if (yCoord == in_curve[mid-1].yCoord())
-         {
-            double minX = in_curve[mid-1].xCoord();
-            int curr = mid-2;
-            while (curr >= left && yCoord == in_curve[curr].yCoord())
-            {
-               minX = in_curve[curr].xCoord();
-               curr--;
-            }
-            return minX;
-         }
-         else
-            return interpolateX(in_curve[mid-1], in_curve[mid], yCoord);
-      }
-      else if (mid < right &&
-               in_curve[mid].yCoord() >= yCoord &&
-               in_curve[mid+1].yCoord() <= yCoord)
-         return interpolateX(in_curve[mid], in_curve[mid+1], yCoord);
-      else if (in_curve[mid].yCoord() > yCoord)
-      {
-         left = mid;
-         mid = (right+left) / 2;
-      }
-      else if (in_curve[mid].yCoord() < yCoord)
-      {
-         right = mid;
-         mid = (right+left) / 2;
-      }
-   }
-   return -2;  // a bug if reaches here
-}
-// --------------------------------------------------------
-double BoundaryType::getY(double xCoord) const
-{
-   int left = 0;
-   int right = in_curve.size() - 1;
-   int mid = right / 2;
-
-   if (xCoord < in_curve[left].xCoord())
-      return -1;  // no solution found if xCoord too small
-
-   while (left < right)
-   {
-      if (mid < right &&
-          in_curve[mid].xCoord() <= xCoord &&
-          in_curve[mid+1].xCoord() >= xCoord)
-      {
-         // special case?
-         if (xCoord == in_curve[mid+1].xCoord())
-         {
-            double minY = in_curve[mid+1].yCoord();
-            int curr = mid+2;
-            
-            while (curr <= right && xCoord == in_curve[curr].xCoord())
-            {
-               minY = in_curve[curr].yCoord();
-               curr++;
-            }
-            return minY;
-         }
-         else
-            return interpolateY(in_curve[mid], in_curve[mid+1], xCoord);
-      }
-      else if (mid > left &&
-          in_curve[mid-1].xCoord() <= xCoord &&
-          in_curve[mid].xCoord() >= xCoord)
-         return interpolateY(in_curve[mid-1], in_curve[mid], xCoord);
-      else if (in_curve[mid].xCoord() < xCoord)
-      {
-         left = mid;
-         mid = (right+left) / 2;
-      }
-      else if (in_curve[mid].xCoord() > xCoord)
-      {
-         right = mid;
-         mid = (right+left) / 2;
-      }
-   }
-   return -2; // a bug if reaches here
-}
-// --------------------------------------------------------     
-void BoundaryType::PlusCurves(const vector<Point>& curveA,
-                              const vector<Point>& curveB,
-                              vector<Point>& outCurve)
-{
-   int cA_size = curveA.size();
-   int cB_size = curveB.size();
-
-   int cA_prev = 1;
-   int cA_curr = 2;
-   int cB_prev = 1;
-   int cB_curr = 2;
-
-   outCurve.reserve(cA_size + cB_size);
-   if (curveA[cA_prev].xCoord() < curveB[cB_prev].xCoord())
-   {
-      while ((cA_curr < cA_size) &&
-             (curveA[cA_curr].xCoord() < curveB[cB_prev].xCoord()))
-      {
-         cA_prev = cA_curr;
-         cA_curr++;
-      }
-
-      double first_xCoord = curveB[cB_prev].xCoord();
-      double first_yCoord = curveB[cB_prev].yCoord() +
-         interpolateY(curveA[cA_prev], curveA[cA_curr], first_xCoord);
-
-      outCurve.push_back(Point(first_xCoord, Point::INFTY));
-      outCurve.push_back(Point(first_xCoord, first_yCoord));
-   }
-   else
-   {
-      while ((cB_curr < cB_size) &&
-             (curveB[cB_curr].xCoord() < curveA[cA_prev].xCoord()))
-      {
-         cB_prev = cB_curr;
-         cB_curr++;
-      }
-
-      double first_xCoord = curveA[cA_prev].xCoord();
-      double first_yCoord = curveA[cA_prev].yCoord() +
-         interpolateY(curveB[cB_prev], curveB[cB_curr], first_xCoord);
-
-      outCurve.push_back(Point(first_xCoord, Point::INFTY));
-      outCurve.push_back(Point(first_xCoord, first_yCoord));
-   }
-
-   double back_xCoord = outCurve.back().xCoord();
-   double back_yCoord = outCurve.back().yCoord();
-   while ((cA_curr < cA_size) && (cB_curr < cB_size))
-   {
-      while ((cA_curr < cA_size) &&
-             (curveA[cA_curr].xCoord() <= curveB[cB_curr].xCoord()))
-      {
-         double xCoord = curveA[cA_curr].xCoord();
-         double yCoord = curveA[cA_curr].yCoord() +
-            interpolateY(curveB[cB_prev], curveB[cB_curr], xCoord);
-
-         if (xCoord != back_xCoord || yCoord != back_yCoord)
-         {
-            outCurve.push_back(Point(xCoord, yCoord));
-            back_xCoord = xCoord;
-            back_yCoord = yCoord;
-         }
-
-         cA_prev = cA_curr;
-         cA_curr++;
-      }
-
-      if (cA_curr < cA_size)
-         while ((cB_curr < cB_size) &&
-                (curveB[cB_curr].xCoord() <= curveA[cA_curr].xCoord()))
-         {
-            double xCoord = curveB[cB_curr].xCoord();
-            double yCoord = curveB[cB_curr].yCoord() +
-               interpolateY(curveA[cA_prev], curveA[cA_curr], xCoord);
-
-            if (xCoord != back_xCoord || yCoord != back_yCoord)
-            {
-               outCurve.push_back(Point(xCoord, yCoord));
-               back_xCoord = xCoord;
-               back_yCoord = yCoord;
-            }
-            
-            cB_prev = cB_curr;
-            cB_curr++;
-         }
-   }
-}
-// --------------------------------------------------------
-void BoundaryType::StarCurves(const vector<Point>& curveA,
-                              const vector<Point>& curveB,
-                              vector<Point>& outCurve)
-{
-   int cA_last = curveA.size()-1;
-   int cB_last = curveB.size()-1;
-
-   int cA_prev = cA_last-1;
-   int cA_curr = cA_last-2;
-   int cB_prev = cB_last-1;
-   int cB_curr = cB_last-2;
-
-   outCurve.reserve(cA_last + cB_last);
-   if (curveA[cA_prev].yCoord() < curveB[cB_prev].yCoord())
-   {
-      while ((cA_curr >= 0) &&
-             (curveA[cA_curr].yCoord() < curveB[cB_prev].yCoord()))
-      {
-         cA_prev = cA_curr;
-         cA_curr--;
-      }
-      double first_yCoord = curveB[cB_prev].yCoord();
-      double first_xCoord = curveB[cB_prev].xCoord() +
-         interpolateX(curveA[cA_curr], curveA[cA_prev], first_yCoord);
-      
-      outCurve.push_back(Point(Point::INFTY, first_yCoord));
-      outCurve.push_back(Point(first_xCoord, first_yCoord));
-   }
-   else // curveB[cB_prev].yCoord() <= curveA[cA_prev].yCoord()
-   {
-      while ((cB_curr >= 0) &&
-             (curveB[cB_curr].yCoord() < curveA[cA_prev].yCoord()))
-      {
-         cB_prev = cB_curr;
-         cB_curr--;
-      }
-      double first_yCoord = curveA[cA_prev].yCoord();
-      double first_xCoord = curveA[cA_prev].xCoord() +
-         interpolateX(curveB[cB_curr], curveB[cB_prev], first_yCoord);
-
-      outCurve.push_back(Point(Point::INFTY, first_yCoord));
-      outCurve.push_back(Point(first_xCoord, first_yCoord));
-   }
-
-   double back_xCoord = outCurve.back().xCoord();
-   double back_yCoord = outCurve.back().yCoord();
-   while (cA_curr >= 0 && cB_curr >= 0)
-   {
-      while ((cA_curr >= 0) &&
-             (curveA[cA_curr].yCoord() <= curveB[cB_curr].yCoord()))
-      {
-         double yCoord = curveA[cA_curr].yCoord();
-         double xCoord = curveA[cA_curr].xCoord() +
-            interpolateX(curveB[cB_curr], curveB[cB_prev], yCoord);
-
-         if (xCoord != back_xCoord || yCoord != back_yCoord)
-         {
-            outCurve.push_back(Point(xCoord, yCoord));
-            back_xCoord = xCoord;
-            back_yCoord = yCoord;
-         }
-         
-         cA_prev = cA_curr;
-         cA_curr--;
-      }
-
-      if (cA_curr >= 0)
-         while ((cB_curr >= 0) &&
-                (curveB[cB_curr].yCoord() <= curveA[cA_curr].yCoord()))
-         {
-            double yCoord = curveB[cB_curr].yCoord();
-            double xCoord = curveB[cB_curr].xCoord() +
-               interpolateX(curveA[cA_curr], curveA[cA_prev], yCoord);
-
-            if (xCoord != back_xCoord || yCoord != back_yCoord)
-            {
-               outCurve.push_back(Point(xCoord, yCoord));
-               back_xCoord = xCoord;
-               back_yCoord = yCoord;
-            }
-            
-            cB_prev = cB_curr;
-            cB_curr--;
-         }
-   }
-   reverse(outCurve.begin(), outCurve.end());
-}
-// --------------------------------------------------------
-void BoundaryType::OrCurves(const vector<Point>& c1,
-                            const vector<Point>& c2,
-                            vector<Point>& outCurve)
-{
-   const vector<Point> *cA_ptr = NULL;
-   const vector<Point> *cB_ptr = NULL;
-   if (c1[1].xCoord() < c2[1].xCoord())
-   {
-      cA_ptr = &c1;
-      cB_ptr = &c2;
-   }
-   else if (c1[1].xCoord() > c2[1].xCoord())
-   {
-      cA_ptr = &c2;
-      cB_ptr = &c1;
-   }
-   else
-   {
-      double y1 = c1[1].yCoord();
-      double y2 = c2[1].yCoord();
-      cA_ptr = (y1 >= y2)? &c1 : &c2;
-      cB_ptr = (y1 >= y2)? &c2 : &c1;
-   }
-
-   const vector<Point>& curveA = *cA_ptr;
-   const vector<Point>& curveB = *cB_ptr;
-   
-   int cA_last = curveA.size() - 1;
-   int cB_last = curveB.size() - 1;
-
-   int cA_prev = 0;
-   int cA_curr = 1;
-   int cB_prev = 0;
-   int cB_curr = 1;
-
-   outCurve.reserve(cA_last + cB_last + 2);
-
-   // add the first point
-   double first_xCoord = curveA[1].xCoord();
-   outCurve.push_back(Point(first_xCoord, Point::INFTY));
-
-   // add the points until curveB needs to be considered
-   // keeping cA_prev <= cB_prev (xCoord)
-   while ((cA_curr <= cA_last) &&
-          (curveA[cA_curr].xCoord() <= curveB[cB_curr].xCoord()))
-   {
-      double xCoord = curveA[cA_curr].xCoord();
-      double yCoord = curveA[cA_curr].yCoord();
-      outCurve.push_back(Point(xCoord, yCoord));
-
-      cA_prev++;
-      cA_curr++;
-   }
-
-   // consider all points in both curves
-   // lastUpdated == 0 <-- last point lies on A
-   //                1 <-- last point lies on B
-   int lastUpdated = 0;
-   while (cA_curr < cA_last || cB_curr < cB_last)
-   {
-      double A_xCoord = curveA[cA_curr].xCoord();
-      double B_xCoord = curveB[cB_curr].xCoord();
-
-      if (A_xCoord <= B_xCoord)
-      {
-         double A_yCoord = curveA[cA_curr].yCoord();
-         double A_first_yCoord =
-            interpolateY(curveB[cB_prev], curveB[cB_curr], A_xCoord);
-
-         if (A_yCoord < A_first_yCoord)
-         {
-            if (lastUpdated == 1)            
-               outCurve.push_back(Point(A_xCoord, A_first_yCoord));
-            outCurve.push_back(Point(A_xCoord, A_yCoord));
-            lastUpdated = 0;
-         }
-         else if (A_first_yCoord < A_yCoord)
-         {
-            if (lastUpdated == 0)
-            {
-               outCurve.push_back(Point(A_xCoord, A_yCoord));
-               outCurve.push_back(Point(A_xCoord, A_first_yCoord));
-            }
-            lastUpdated = 1;
-         }
-         else 
-            outCurve.push_back(Point(A_xCoord, A_yCoord));
-
-         cA_prev++;
-         cA_curr++;
-      }
-      else
-      {
-         double B_yCoord = curveB[cB_curr].yCoord();
-         double B_first_yCoord =
-            interpolateY(curveA[cA_prev], curveA[cA_curr], B_xCoord);
-
-         if (B_yCoord < B_first_yCoord)
-         {
-            if (lastUpdated == 0)
-               outCurve.push_back(Point(B_xCoord, B_first_yCoord));
-            outCurve.push_back(Point(B_xCoord, B_yCoord));
-            lastUpdated = 1;
-         }
-         else if (B_first_yCoord < B_yCoord)
-         {
-            if (lastUpdated == 1)
-            {
-               outCurve.push_back(Point(B_xCoord, B_yCoord));
-               outCurve.push_back(Point(B_xCoord, B_first_yCoord));
-            }
-            lastUpdated = 0;
-         }
-         else
-            outCurve.push_back(Point(B_xCoord, B_yCoord));
-         
-         cB_prev++;
-         cB_curr++;
-      }
-   }
-   double last_yCoord = min(curveA[cA_last].yCoord(),
-                            curveB[cB_last].yCoord());
-   outCurve.push_back(Point(Point::INFTY, last_yCoord));
-}                  
-// --------------------------------------------------------
-double BoundaryType::interpolateY(const Point& left,
-                                  const Point& right,
-                                  double newX)
-{
-   double leftX = left.xCoord();
-   double rightX = right.xCoord();
-
-   if (leftX == rightX)
-      return right.yCoord();
-   else
-   {
-      double leftY = left.yCoord();
-      double rightY = right.yCoord();
-      double ratio = (newX - leftX) / (rightX - leftX);
-
-      return leftY * (1-ratio) + rightY * ratio;
-   }
-}
-// --------------------------------------------------------
-double BoundaryType::interpolateX(const Point& top,
-                                  const Point& bottom,
-                                  double newY)
-{
-   double topY = top.yCoord();
-   double bottomY = bottom.yCoord();
-
-   if (topY == bottomY)
-      return top.xCoord();
-   else
-   {
-      double topX = top.xCoord();
-      double bottomX = bottom.xCoord();
-      double ratio = (newY - bottomY) / (topY - bottomY);
-
-      return topX * ratio + bottomX * (1-ratio);
-   }
-}
-// ========================================================
-// ----temporary-----
-BoundaryType::BoundaryType(int instr,
-                           const BoundaryType& b)
-   : in_min_point(Point::INFTY, Point::INFTY)
-{
-   switch (instr)
-   {
-   case FLIP:
-      FlipCurve(b.in_curve, in_curve);
-      break;
-
-   case FLIP_OR:
-      FlipOrCurve(b.in_curve, in_curve);
-      break;
-
-   case NOOP:
-      in_curve = b.in_curve;
-      break;
-   }
-   in_min_point = *min_element(in_curve.begin(), in_curve.end());
-}
-// --------------------------------------------------------
-void BoundaryType::FlipCurve(const vector<Point>& inCurve,
-                             vector<Point>& outCurve)
-{
-   int curveSize = inCurve.size();
-   outCurve.reserve(curveSize);
-   for (int i = 0; i < curveSize; i++)
-   {
-      double xCoord = inCurve[i].xCoord();
-      double yCoord = inCurve[i].yCoord();
-
-      outCurve.push_back(Point(yCoord, xCoord));
-   }
-   reverse(outCurve.begin(), outCurve.end());
-}
-// ========================================================
-      
-   
diff -druN BloBB_CompaSS_050315/CompaSS/datastrbacksoftst.h blob_compass/CompaSS/datastrbacksoftst.h
--- BloBB_CompaSS_050315/CompaSS/datastrbacksoftst.h	2004-05-09 11:58:21.000000000 -0700
+++ blob_compass/CompaSS/datastrbacksoftst.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,250 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef DATASTRBACKSOFTST_H
-#define DATASTRBACKSOFTST_H
-
-#include <iostream>
-#include <vector>
-#include <algorithm>
-using namespace std;
-
-// --------------------------------------------------------
-class Point
-{
-public:
-   Point(double nX, double nY)
-      : in_x(nX), in_y(nY), in_area(nX*nY) {}
-   Point(const Point& p2)
-      : in_x(p2.in_x), in_y(p2.in_y), in_area(p2.in_area) {}
-
-   inline double xCoord() const
-      {  return in_x; }
-
-   inline double yCoord() const
-      {  return in_y; }
-
-   inline double area() const
-      {  return in_area; }
-
-   inline void operator =(const Point& p2)
-      {  in_x = p2.in_x; in_y = p2.in_y; in_area = p2.in_area; }
-
-   // zero-tolorance to errors
-   inline bool operator ==(const Point& p2) const
-      {  return ((in_x == p2.in_x) &&
-                 (in_y == p2.in_y) &&
-                 (in_area == p2.in_area)); }
-   
-   inline bool operator <(const Point& p2) const
-      {
-         bool p1fit = (in_x < X_BOUND) && (in_y < Y_BOUND);
-         bool p2fit = (p2.in_x < X_BOUND) && (p2.in_y < Y_BOUND);
-         if (p1fit && p2fit)
-            return in_area < p2.in_area;
-         else if (p1fit)
-            return true;
-         else if (p2fit)
-            return false;
-         else
-         {
-            double p1viol = (in_x - X_BOUND) + (in_y - Y_BOUND);
-            double p2viol = (p2.in_x - X_BOUND) + (p2.in_y - Y_BOUND);
-            return p1viol < p2viol;
-         }
-      }
-
-   static const double INFTY;
-   static double X_BOUND;
-   static double Y_BOUND;
-
-private:
-   double in_x;
-   double in_y;
-   double in_area;
-};
-// --------------------------------------------------------
-class BoundaryType
-{
-public:
-   BoundaryType(const vector<Point>& nCurve)
-      : in_curve(nCurve),
-        in_min_point(*min_element(nCurve.begin(), nCurve.end())) {}
-   
-   BoundaryType(int instr,
-                const BoundaryType& c1,
-                const BoundaryType& c2);
-   
-   BoundaryType(int instr,
-                const BoundaryType& c1,
-                const BoundaryType& c2,
-                double width_limit,
-                double height_limit);
-
-   BoundaryType(const BoundaryType& b2)
-      : in_curve(b2.in_curve), in_min_point(b2.in_min_point) {}
-
-   enum InstrType {PLUS = -2, STAR = -3, OR= -4,
-                   BOTH = -5, FLIP = -6, FLIP_OR = -7, NOOP = -8};
-
-   inline const vector<Point>& curve() const
-      {  return in_curve; }
-   
-   inline Point operator [](int index) const
-      {  return in_curve[index]; }
-
-   inline int size() const
-      {  return in_curve.size(); }
-
-   inline double min_area() const
-      {  return in_min_point.area(); }
-
-   inline Point min_point() const
-      {  return in_min_point; }
-
-   inline void operator =(const BoundaryType& b2)
-      {  in_curve = b2.in_curve;  in_min_point = b2.in_min_point; }
-
-   // 0-tolarance to errors
-   inline bool operator ==(const BoundaryType& b2) const 
-      {  return in_curve == b2.in_curve; }
-   inline bool operator <(const BoundaryType& b2) const
-      {  return in_min_point.area() < b2.in_min_point.area(); }
-   
-   // return -1 if the value is too small to be on the curve
-   double getX(double yCoord) const;
-   double getY(double xCoord) const;
-   
-   // assume c1, c2 have at least 3 points ie. there exists
-   // feasible point with finite coordinates
-   // OrCurves(): may overestimate the area required
-   //             lines intersection assumes one of them is vertical
-   static void PlusCurves(const vector<Point>& c1,
-                          const vector<Point>& c2,
-                          vector<Point>& outCurve);
-   static void StarCurves(const vector<Point>& c1,
-                          const vector<Point>& c2,
-                          vector<Point>& outCurve);
-   static void OrCurves(const vector<Point>& c1,
-                        const vector<Point>& c2,
-                        vector<Point>& outCurve);
-   inline static void BothCurves(const vector<Point>& c1,
-                                 const vector<Point>& c2,
-                                 vector<Point>& outCurve)
-      {
-         vector<Point> plused;
-         vector<Point> starred;
-
-         PlusCurves(c1, c2, plused);
-         StarCurves(c1, c2, starred);
-         OrCurves(plused, starred, outCurve);
-      }
-
-   // ----temporary for hierarchical packer-----
-   BoundaryType(int instr,
-                const BoundaryType& b1);
-   static void FlipCurve(const vector<Point>& inCurve,
-                         vector<Point>& outCurve);
-   inline static void FlipOrCurve(const vector<Point>& inCurve,
-                                  vector<Point>& outCurve)
-      {
-         vector<Point> flipped;
-         FlipCurve(inCurve, flipped);
-         OrCurves(inCurve, flipped, outCurve);
-      }
-   
-private:
-   vector<Point> in_curve;
-   Point in_min_point;
-
-   // used by Plus/StarCurves
-   static double interpolateY(const Point& left,
-                              const Point& right, double newX);
-   static double interpolateX(const Point& top,
-                              const Point& bottom, double newY);
-};
-// --------------------------------------------------------
-class SoftNode
-{
-public:
-   SoftNode(int nBlk, const BoundaryType& nBoundary)
-      : sign(nBlk), BLBlock(nBlk), TRblblock(nBlk),
-        boundary(nBoundary),
-        blkArea(nBoundary.min_area()),
-        minArea(nBoundary.min_area()),
-        minDeadspace(0) {}
-   
-   SoftNode(int instr, const SoftNode& BLNode, const SoftNode& TRNode)
-      : sign(instr), BLBlock(BLNode.BLBlock), TRblblock(TRNode.BLBlock),
-        boundary(instr, BLNode.boundary, TRNode.boundary),
-        blkArea(BLNode.blkArea + TRNode.blkArea),
-        minArea(max(boundary.min_area(), blkArea)),
-        minDeadspace(minArea - blkArea) {}
-
-   SoftNode(int instr, const SoftNode& BLNode, const SoftNode& TRNode,
-            double width_limit, double height_limit)
-      : sign(instr), BLBlock(BLNode.BLBlock), TRblblock(TRNode.BLBlock),
-        boundary(instr, BLNode.boundary, TRNode.boundary, width_limit, height_limit),
-        blkArea(BLNode.blkArea + TRNode.blkArea),
-        minArea(max(boundary.min_area(), blkArea)),
-        minDeadspace(minArea - blkArea) {}
-
-   SoftNode(const SoftNode& sn2)
-      : sign(sn2.sign), BLBlock(sn2.BLBlock), TRblblock(sn2.TRblblock),
-        boundary(sn2.boundary),
-        blkArea(sn2.blkArea),
-        minArea(sn2.minArea),
-        minDeadspace(sn2.minDeadspace)  {}
-
-   inline void operator =(const SoftNode& sn2)
-      {
-         sign = sn2.sign;
-         BLBlock = sn2.BLBlock;
-         TRblblock = sn2.TRblblock;
-         boundary = sn2.boundary;
-
-         blkArea = sn2.blkArea;
-         minArea = sn2.minArea;
-         minDeadspace = sn2.minDeadspace;
-      }
-   
-   int sign;
-   int BLBlock;
-   int TRblblock;
-   BoundaryType boundary;
-   
-   double blkArea;
-   double minArea;
-   double minDeadspace;
-};
-// --------------------------------------------------------
-
-#endif
diff -druN BloBB_CompaSS_050315/CompaSS/datastrfrontsoftst.cxx blob_compass/CompaSS/datastrfrontsoftst.cxx
--- BloBB_CompaSS_050315/CompaSS/datastrfrontsoftst.cxx	2004-05-10 12:57:48.000000000 -0700
+++ blob_compass/CompaSS/datastrfrontsoftst.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,397 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "datastrbacksoftst.h"
-#include "datastrfrontsoftst.h"
-
-#include <iostream>
-#include <fstream>
-#include <sstream>
-#include <iomanip>
-#include <algorithm>
-using namespace std;
-
-// ========================================================
-int BlockInfoType::CURVE_ACCURACY = DEFAULT_CURVE_ACCURACY;
-// --------------------------------------------------------
-BlockInfoType::BlockInfoType(istream& ins)
-   : in_total_area(0)
-{
-   ReadTxtFormat(ins);
-}       
-// --------------------------------------------------------   
-BlockInfoType::BlockInfoType(int format,
-                             istream& ins)
-   : in_total_area(0)
-{
-   switch (format)
-   {
-   case SOFT:
-      ReadSoftFormat(CURVE_ACCURACY, ins);
-      break;
-
-   case TXT:
-      ReadTxtFormat(ins);
-      break;
-
-   case TXT_FIXED:
-      ReadTxtFixedFormat(ins);
-      break;
-      
-   default:
-      cout << "ERROR: invalid input file format. " << endl;
-      exit(1);
-      break;
-   }
-   sort(blocks.begin(), blocks.end());
-}       
-// --------------------------------------------------------
-BlockInfoType::BlockInfoType(int format,
-                             int accuracy,
-                             istream& ins)
-   : in_total_area(0)
-{
-   CURVE_ACCURACY = accuracy;
-   switch (format)
-   {
-   case SOFT:
-      ReadSoftFormat(accuracy, ins);
-      break;
-
-   case TXT:
-      ReadTxtFormat(ins);
-      break;
-
-   case TXT_FIXED:
-      ReadTxtFixedFormat(ins);
-      break;
-
-   default:
-      cout << "ERROR: invalid input file format. " << endl;
-      exit(1);
-      break;
-   }
-   sort(blocks.begin(), blocks.end());
-}
-// ========================================================
-void SoftSTree::push_operator(int sign)
-{
-   in_expression.push_back(sign);
-
-   SoftNode *TRNodePtr = in_buffer.back();
-   in_buffer.pop_back();
-   
-   SoftNode *BLNodePtr = in_buffer.back();
-   in_buffer.pop_back();
-
-   in_storage.push_back(TRNodePtr);
-   in_storage.push_back(BLNodePtr);
-
-   SoftNode *temp = new SoftNode(sign, *BLNodePtr, *TRNodePtr);
-   in_buffer.push_back(temp);
-
-   in_deadspace += (in_buffer.back())->minDeadspace -
-      TRNodePtr->minDeadspace - BLNodePtr->minDeadspace;
-
-   in_balance--;
-}
-// --------------------------------------------------------
-void SoftSTree::push_operator(int sign,
-                              double width_limit,
-                              double height_limit)
-{
-   in_expression.push_back(sign);
-
-   SoftNode *TRNodePtr = in_buffer.back();
-   in_buffer.pop_back();
-   
-   SoftNode *BLNodePtr = in_buffer.back();
-   in_buffer.pop_back();
-
-   in_storage.push_back(TRNodePtr);
-   in_storage.push_back(BLNodePtr);
-
-   SoftNode *temp = new SoftNode(sign, *BLNodePtr, *TRNodePtr,
-                                 width_limit, height_limit);
-   in_buffer.push_back(temp);
-
-   in_deadspace += (in_buffer.back())->minDeadspace -
-      TRNodePtr->minDeadspace - BLNodePtr->minDeadspace;
-
-   in_balance--;
-}
-// --------------------------------------------------------
-void SoftSTree::pop_operator()
-{
-   in_balance++;
-
-   double oldDeadspace = (in_buffer.back())->minDeadspace;
-   delete in_buffer.back();
-   in_buffer.pop_back();
-
-   double BLDeadspace = (in_storage.back())->minDeadspace;
-   in_buffer.push_back(in_storage.back());
-   in_storage.pop_back();
-
-   double TRDeadspace = (in_storage.back())->minDeadspace;
-   in_buffer.push_back(in_storage.back());
-   in_storage.pop_back();
-
-   in_expression.pop_back();
-   in_deadspace += BLDeadspace + TRDeadspace - oldDeadspace;
-}
-// ========================================================
-void SoftPacking::Evaluate(const BlockInfoType& blockinfo)
-{
-   int expr_size = expression.size();
-   vector<TreeNode> tree(expr_size);
-   tree.resize(expr_size);
-
-   int tree_ptr = 0;
-   int expr_ptr = expr_size - 1;
-
-   ConstructTree(tree, tree_ptr, expr_ptr, -1);
-   AssignBoundaries(blockinfo, tree);
-
-   double boxWidth = (tree[0].bdy_ptr)->min_point().xCoord();
-   double boxHeight = (tree[0].bdy_ptr)->min_point().yCoord();
-   tree[0].xloc = 0;
-   tree[0].yloc = 0;
-   tree[0].width = 0;
-   tree[0].height = 0;
-
-   if (tree[0].sign == SoftSTree::BOTH)
-      tree[0].sign = getSign(tree, 0, boxWidth, boxHeight);
-      
-   switch (tree[0].sign)
-   {
-   case SoftSTree::PLUS:
-      EvaluateTree(tree, tree[0].left, boxWidth);
-
-      tree[0].height = tree[tree[0].left].height;
-      EvaluateTree(tree, tree[0].right, boxWidth);
-      break;
-
-   case SoftSTree::STAR:
-      EvaluateTree(tree, tree[0].left, boxHeight);
-
-      tree[0].width = tree[tree[0].left].width;
-      EvaluateTree(tree, tree[0].right, boxHeight);
-      break;
-   }      
-
-   tree[0].width = boxWidth;
-   tree[0].height = boxHeight;
-
-   totalWidth = boxWidth;
-   totalHeight = boxHeight;
-   blockArea = blockinfo.total_area();
-   deadspace = (totalWidth * totalHeight) - blockArea;
-
-   ExpressionFromTree(tree);
-}
-// --------------------------------------------------------
-void SoftPacking::ConstructTree(vector<TreeNode>& tree,
-                                int& tree_ptr,
-                                int& expr_ptr,
-                                int parent)
-{
-   int sign = expression[expr_ptr];
-   int curr_pos = tree_ptr;
-
-   tree[curr_pos].sign = sign;
-   tree[curr_pos].parent = parent;
-   tree_ptr++;
-   expr_ptr--;
-
-   if (SoftSTree::isOperator(sign))
-   {
-      tree[curr_pos].right = tree_ptr;
-      ConstructTree(tree, tree_ptr, expr_ptr, curr_pos);   
-      
-      tree[curr_pos].left = tree_ptr;
-      ConstructTree(tree, tree_ptr, expr_ptr, curr_pos);
-   }
-   else
-   {
-      tree[curr_pos].left = -1;
-      tree[curr_pos].right = -1;
-   }
-}
-// --------------------------------------------------------
-void SoftPacking::AssignBoundaries(const BlockInfoType& blockinfo,
-                                   vector<TreeNode>& tree)
-{
-   for (int tree_ptr = tree.size()-1 ; tree_ptr >= 0; tree_ptr--)
-   {
-      int sign = tree[tree_ptr].sign;
-      if (SoftSTree::isOperator(sign))
-      {
-         const BoundaryType *left_bd = tree[tree[tree_ptr].left].bdy_ptr;
-         const BoundaryType *right_bd = tree[tree[tree_ptr].right].bdy_ptr;
-         
-         tree[tree_ptr].bdy_ptr = new BoundaryType(sign,
-                                                   *left_bd, *right_bd);
-      }
-      else
-         tree[tree_ptr].bdy_ptr = &(blockinfo[sign]);
-   }
-}
-// --------------------------------------------------------
-void SoftPacking::EvaluateTree(vector<TreeNode>& tree,
-                               int tree_ptr,
-                               double bound_length)
-{
-   int sign = tree[tree_ptr].sign;
-   int parent = tree[tree_ptr].parent;
-   int parent_sign = tree[parent].sign;
-   double boxWidth = -1;
-   double boxHeight = -1;
-
-   tree[tree_ptr].xloc = tree[parent].xloc + tree[parent].width;
-   tree[tree_ptr].yloc = tree[parent].yloc + tree[parent].height;
-
-   switch (parent_sign)
-   {
-   case SoftSTree::PLUS:
-      boxWidth = bound_length; 
-      boxHeight = (tree[tree_ptr].bdy_ptr)->getY(boxWidth);
-      boxWidth = (tree[tree_ptr].bdy_ptr)->getX(boxHeight);
-      break;
-      
-   case SoftSTree::STAR:
-      boxHeight = bound_length;
-      boxWidth = (tree[tree_ptr].bdy_ptr)->getX(boxHeight);
-      boxHeight = (tree[tree_ptr].bdy_ptr)->getY(boxWidth);
-      break;
-   }
-
-   if (sign == SoftSTree::BOTH)
-   {
-      sign = getSign(tree, tree_ptr, boxWidth, boxHeight);
-      tree[tree_ptr].sign = sign;
-   }
-   
-   switch (sign)
-   {
-   case SoftSTree::PLUS:
-      tree[tree_ptr].height = 0;      
-      EvaluateTree(tree, tree[tree_ptr].left, boxWidth);
-
-      tree[tree_ptr].height = tree[tree[tree_ptr].left].height;
-      EvaluateTree(tree, tree[tree_ptr].right, boxWidth);
-      break;
-
-   case SoftSTree::STAR:
-      tree[tree_ptr].width = 0;
-      EvaluateTree(tree, tree[tree_ptr].left, boxHeight);
-
-      tree[tree_ptr].width = tree[tree[tree_ptr].left].width;
-      EvaluateTree(tree, tree[tree_ptr].right, boxHeight);
-      break;
-   }
-
-   tree[tree_ptr].width = boxWidth;
-   tree[tree_ptr].height = boxHeight;
-
-   if ((sign != SoftSTree::PLUS) &&
-       (sign != SoftSTree::STAR))
-   {
-      xloc[sign] = tree[tree_ptr].xloc;
-      yloc[sign] = tree[tree_ptr].yloc;
-      width[sign] = tree[tree_ptr].width;
-      height[sign] = tree[tree_ptr].height;
-   }
-}
-// --------------------------------------------------------      
-int SoftPacking::getSign(const vector<TreeNode>& tree,
-                         int tree_ptr,
-                         double boxWidth,
-                         double boxHeight) const
-{
-   int left_ptr = tree[tree_ptr].left;
-   int right_ptr = tree[tree_ptr].right;
-
-   double star_width
-      = ((tree[left_ptr].bdy_ptr)->getX(boxHeight) +
-         (tree[right_ptr].bdy_ptr)->getX(boxHeight));
-   double star_error = star_width / boxWidth;
-
-   double plus_height
-      = ((tree[left_ptr].bdy_ptr)->getY(boxWidth) +
-         (tree[right_ptr].bdy_ptr)->getY(boxWidth));
-   double plus_error = plus_height / boxHeight;
-
-   if (star_error < plus_error)
-      return SoftSTree::STAR;
-   else
-      return SoftSTree::PLUS;
-}
-// --------------------------------------------------------
-void SoftPacking::ExpressionFromTree(const vector<TreeNode>& tree)
-{
-   int tree_curr = tree[0].left;
-   int tree_prev = 0;
-
-   // post-order traversal of the tree
-   int expr_ptr = 0;
-   while (tree_curr != -1)
-   {
-      int sign = tree[tree_curr].sign;
-      if (SoftSTree::isOperand(sign))
-      {
-         expression[expr_ptr] = sign;
-         expr_ptr++;
-
-         tree_prev = tree_curr;
-         tree_curr = tree[tree_curr].parent;
-      }
-      else if (tree_prev == tree[tree_curr].right)
-      {
-         expression[expr_ptr] = sign;
-         expr_ptr++;
-
-         tree_prev = tree_curr;
-         tree_curr = tree[tree_curr].parent;
-      }
-      else if (tree_prev == tree[tree_curr].left)
-      {
-         tree_prev = tree_curr;
-         tree_curr = tree[tree_curr].right;
-      }
-      else if (tree_prev == tree[tree_curr].parent)
-      {
-         tree_prev = tree_curr;
-         tree_curr = tree[tree_curr].left;
-      }
-   }
-}
-// ========================================================
diff -druN BloBB_CompaSS_050315/CompaSS/datastrfrontsoftst.h blob_compass/CompaSS/datastrfrontsoftst.h
--- BloBB_CompaSS_050315/CompaSS/datastrfrontsoftst.h	2005-03-13 21:17:56.000000000 -0800
+++ blob_compass/CompaSS/datastrfrontsoftst.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,359 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef DATASTRFRONTSOFTST_H
-#define DATASTRFRONTSOFTST_H
-
-#include "datastrbacksoftst.h"
-
-#include <iostream>
-#include <vector>
-#include <algorithm>
-#include <cmath>
-#include <float.h>
-#include <limits>
-using namespace std;
-
-class SoftCluster;
-class SoftClusterSet;
-
-const int DEFAULT_CURVE_ACCURACY = 200;
-// --------------------------------------------------------
-class BlockInfoType
-{
-public:
-   BlockInfoType(istream& ins);
-   BlockInfoType(int format, istream& ins);
-   BlockInfoType(int format, int accuracy, istream& ins);
-   BlockInfoType(const SoftClusterSet& clusterSet);
-   BlockInfoType(const BlockInfoType& bit)
-      : blocks(bit.blocks), in_total_area(bit.in_total_area) {}
-
-   inline const BoundaryType& operator [](int index) const
-      {  return blocks[index]; }
-
-   inline int size() const
-      {  return blocks.size(); }
-
-   inline int BLOCK_NUM() const
-      {  return blocks.size(); }
-
-   inline double total_area() const
-      {  return in_total_area; }
-
-   inline double block_area() const
-      {  return in_total_area; }
-   
-   enum FormatType {SOFT = 0, TXT, TXT_FIXED};
-   static int CURVE_ACCURACY;      
-   
-private:
-   vector<BoundaryType> blocks;
-   double in_total_area;
-
-   void ReadSoftFormat(int accuracy, istream& ins);
-   void ReadTxtFormat(istream& ins);
-   void ReadTxtFixedFormat(istream& ins);
-};
-// --------------------------------------------------------
-class SoftSTree 
-{
-public:
-   SoftSTree(const BlockInfoType& blockinfo) 
-      : in_balance(0), in_perSize(0), in_deadspace(0),
-        in_blkArea(blockinfo.total_area())
-      {
-         in_expression.reserve(2*blockinfo.BLOCK_NUM());
-         in_buffer.reserve(blockinfo.BLOCK_NUM());
-         in_storage.reserve(2*blockinfo.BLOCK_NUM());
-
-         int blockinfo_size = blockinfo.size();
-         for (int i = 0; i < blockinfo_size; i++)
-            BLOCK_NODES.push_back(SoftNode(i, blockinfo[i]));
-      }
-
-   enum OprType {STAR = BoundaryType::STAR,
-                 PLUS = BoundaryType::PLUS,
-                 BOTH = BoundaryType::BOTH,
-                 FLIP_OR = BoundaryType::FLIP_OR};
-
-   inline static bool isOperand(int sign)
-      {   return (sign >= 0); }
-
-   inline static bool isOperator(int sign)
-      {   return ((sign == PLUS) ||
-                  (sign == STAR) ||
-                  (sign == BOTH)); }
-
-   friend class Debug;
-   
-   inline int expression_size() const
-      {  return in_expression.size(); }
-   inline int expression_top() const
-      {  return in_expression.back(); }
-   inline const vector<int>& expression() const
-      {  return in_expression; }
-   inline int expression(int i) const
-      {  return in_expression[i]; }
-
-   inline int buffer_size() const
-      {  return in_buffer.size(); }
-   inline const SoftNode& buffer_top() const
-      {  return *(in_buffer.back()); }
-   inline const SoftNode& buffer(int i) const
-      {  return *(in_buffer[i]); }
-
-   inline int storage_size() const
-      {  return in_storage.size(); }
-   inline const SoftNode& storage_top() const
-      {  return *(in_storage.back()); }
-   inline const SoftNode& storage(int i) const
-      {  return *(in_storage[i]); }
-
-   inline int balance() const
-      {  return in_balance; }
-
-   inline int perSize() const
-      {  return in_perSize; }
-
-   inline double deadspace() const
-      {  return in_deadspace; }
-
-   inline double total_area() const
-      {  return in_blkArea + in_deadspace; }
-   
-   inline void push_operand(int blk)
-      {
-         in_expression.push_back(blk);
-         in_buffer.push_back(&(BLOCK_NODES[blk]));
-         in_balance++;
-         in_perSize++;
-      }
-   
-   inline void pop_operand()
-      {
-         in_perSize--;
-         in_balance--;
-         in_buffer.pop_back();
-         in_expression.pop_back();
-      }   
-
-   inline bool can_push_operator(int sign) const
-      {  return ((in_balance > 1) &&
-                 (sign != in_expression.back())); }
-
-   void push_operator(int sign);
-   void push_operator(int sign, double width_limit, double height_limit);
-   void pop_operator();
-
-private:
-   int in_balance;      // # operands - # operators
-   int in_perSize;      // # operands
-   double in_deadspace; // overall deadspace
-   double in_blkArea;   // total block area
-
-   vector<int> in_expression;   // the NPE
-   vector<SoftNode*> in_buffer; 
-   vector<SoftNode*> in_storage;
-
-   vector<SoftNode> BLOCK_NODES; // used in push_operand()
-   
-   SoftSTree(const SoftSTree&);
-   void operator =(const SoftSTree);   
-};
-// --------------------------------------------------------
-class SoftSliceRecord
-{
-public:
-   SoftSliceRecord()
-      : minArea(0), minDeadspace(0),
-        boundary(vector<Point>(3, Point(0,0))) {}
-                 
-   SoftSliceRecord(const SoftSTree& sst)
-      : minArea(sst.total_area()), minDeadspace(sst.deadspace()),
-        expression(sst.expression()),
-        boundary(sst.buffer(0).boundary) {}
-
-   SoftSliceRecord(double area, double deadspace)
-      : minArea(area), minDeadspace(deadspace),
-        boundary(vector<Point>(3, Point(0, 0))) {}
-
-   SoftSliceRecord(const SoftCluster& cluster);      
-      
-   SoftSliceRecord(const SoftSliceRecord& ssr)
-      : minArea(ssr.minArea), minDeadspace(ssr.minDeadspace),
-        expression(ssr.expression),
-        boundary(ssr.boundary) {}
-
-   double minArea;
-   double minDeadspace;
-
-   vector<int> expression;
-   BoundaryType boundary;
-
-   inline void operator =(const SoftSliceRecord& ssr)
-      {
-         minArea = ssr.minArea;
-         minDeadspace = ssr.minDeadspace;
-         expression = ssr.expression;
-         boundary = ssr.boundary;
-      }
-};
-// --------------------------------------------------------
-class SoftSliceRecordList
-{
-public:
-   SoftSliceRecordList(double deft_area, double deft_deadspace)
-      : in_list(1, SoftSliceRecord(deft_area, deft_deadspace)) {}
-
-   inline bool empty() const
-      {  return in_list.size() == 1; }
-
-   inline void add_record(const SoftSTree& sst)
-      {  in_list.push_back(SoftSliceRecord(sst)); }
-
-   inline void set_deadspace(double deadspace)
-      {
-         double original = in_list[0].minArea - in_list[0].minDeadspace;
-         in_list[0].minArea = original + deadspace;
-         in_list[0].minDeadspace = deadspace;
-      }
-         
-   inline const SoftSliceRecord& operator [](int index) const
-      {  return in_list[index]; }
-
-   inline const SoftSliceRecord& last() const
-      {  return in_list[in_list.size()-1]; }
-
-private:
-   vector<SoftSliceRecord> in_list;
-};
-// --------------------------------------------------------
-class SoftPacking
-{
-public:
-   SoftPacking() {}
-   SoftPacking(const SoftSliceRecord& ssr,
-               const BlockInfoType& blockinfo)
-      : xloc((ssr.expression.size()+1) / 2),
-        yloc((ssr.expression.size()+1) / 2),
-        width((ssr.expression.size()+1) / 2),
-        height((ssr.expression.size()+1) / 2),
-        expression(ssr.expression)
-      {   Evaluate(blockinfo); }
-         
-   SoftPacking(const SoftPacking& spk)
-      : deadspace(spk.deadspace), blockArea(spk.blockArea),
-        totalWidth(spk.totalWidth), totalHeight(spk.totalHeight),
-        xloc(spk.xloc), yloc(spk.yloc),
-        width(spk.width), height(spk.height),
-        expression(spk.expression) {}
-
-   inline void operator =(const SoftPacking& spk)
-      {
-         deadspace = spk.deadspace;
-         blockArea = spk.blockArea;
-         totalWidth = spk.totalWidth;
-         totalHeight = spk.totalHeight;
-         xloc = spk.xloc;
-         yloc = spk.yloc;
-         width = spk.width;
-         height = spk.height;
-         expression = spk.expression;
-      }
-
-   double deadspace;
-   double blockArea;
-   double totalWidth;
-   double totalHeight;
-
-   vector<double> xloc;
-   vector<double> yloc;
-   vector<double> width;
-   vector<double> height;
-   vector<int> expression;
-
-   void output(ostream& outs) const;
-   
-protected:
-   struct TreeNode
-   {
-      TreeNode()
-         : width(0), height(0), xloc(-1), yloc(-1),
-           sign(-1), parent(-1), left(-1), right(-1),
-           bdy_ptr(NULL) {}
-      
-      TreeNode(const TreeNode& tn)
-         : width(tn.width), height(tn.height),
-           xloc(tn.xloc), yloc(tn.yloc),
-           sign(tn.sign), parent(tn.parent),
-           left(tn.left), right(tn.right),
-           bdy_ptr(NULL)
-         {
-            if (SoftSTree::isOperator(sign))
-               bdy_ptr = new BoundaryType(*tn.bdy_ptr);
-            else
-               bdy_ptr = tn.bdy_ptr;
-         }
-      
-      ~TreeNode()
-         {
-            if (SoftSTree::isOperator(sign))
-               delete bdy_ptr;
-         }
-      
-      double width;
-      double height;
-      double xloc;
-      double yloc;
-
-      int sign;
-      int parent;
-      int left;
-      int right;
-      const BoundaryType *bdy_ptr;
-   };
-   
-   void Evaluate(const BlockInfoType& blockinfo);
-   void ConstructTree(vector<TreeNode>& tree,
-                      int& tree_ptr, int& expr_ptr, int parent);
-   void AssignBoundaries(const BlockInfoType& blockinfo,
-                         vector<TreeNode>& tree);
-   void EvaluateTree(vector<TreeNode>& tree, int tree_ptr,
-                     double bound_length);
-   int getSign(const vector<TreeNode>& tree, int tree_ptr,
-               double boxWidth, double boxHeight) const;
-   void ExpressionFromTree(const vector<TreeNode>& tree);
-};
-// --------------------------------------------------------
-
-#endif
-
diff -druN BloBB_CompaSS_050315/CompaSS/datastrhiersoftst.cxx blob_compass/CompaSS/datastrhiersoftst.cxx
--- BloBB_CompaSS_050315/CompaSS/datastrhiersoftst.cxx	2004-02-07 20:17:19.000000000 -0800
+++ blob_compass/CompaSS/datastrhiersoftst.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,73 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "datastrhiersoftst.h"
-#include "datastrbacksoftst.h"
-#include "datastrfrontsoftst.h"
-
-#include <vector>
-using namespace std;
-
-// --------------------------------------------------------
-SoftCluster::SoftCluster(int instr,
-                         const SoftClusterSet& clusterSet,
-                         const SoftSliceRecord& ssr)
-   : in_boundary(instr, ssr.boundary),
-     in_blkArea(0),
-     in_deadspace(ssr.minDeadspace)   
-{
-   for (unsigned int i = 0; i < ssr.expression.size(); i++)
-   {
-      int big_sign = ssr.expression[i];
-      if (SoftSTree::isOperand(big_sign))
-      {
-         int expr_size = clusterSet[big_sign].expression_size();
-         for (int j = 0; j < expr_size; j++)
-         {
-            int small_sign = clusterSet[big_sign].expression(j);
-            if (SoftSTree::isOperand(small_sign))
-               in_expression.push_back(small_sign);
-            else
-               in_expression.push_back(small_sign);
-         }
-
-         double newBlkArea = clusterSet[big_sign].blkArea();
-         double newDeadspace = clusterSet[big_sign].deadspace();
-         in_blkArea += newBlkArea;
-         in_deadspace += newDeadspace;
-      }
-      else
-         in_expression.push_back(SoftSTree::BOTH);
-   }
-}
-// --------------------------------------------------------
-   
-            
diff -druN BloBB_CompaSS_050315/CompaSS/datastrhiersoftst.h blob_compass/CompaSS/datastrhiersoftst.h
--- BloBB_CompaSS_050315/CompaSS/datastrhiersoftst.h	2004-02-07 20:15:12.000000000 -0800
+++ blob_compass/CompaSS/datastrhiersoftst.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,118 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef DATASTRHIERSOFTST_H
-#define DATASTRHIERSOFTST_H
-
-#include "datastrbacksoftst.h"
-#include "datastrfrontsoftst.h"
-
-#include <vector>
-using namespace std;
-
-class SoftClusterSet;
-// --------------------------------------------------------
-class SoftCluster
-{
-public:
-   SoftCluster(int block, const BoundaryType& newBoundary)
-      : in_expression(1, block),
-        in_boundary(newBoundary),
-        in_blkArea(newBoundary.min_area()),
-        in_deadspace(0) {}
-   SoftCluster(int instr,
-               const SoftClusterSet& clusterSet,
-               const SoftSliceRecord& ssr);
-   SoftCluster(const SoftCluster& sc)
-      : in_expression(sc.in_expression),
-        in_boundary(sc.in_boundary),
-        in_blkArea(sc.in_blkArea),
-        in_deadspace(sc.in_deadspace) {}
-
-   void operator =(const SoftCluster& sc)
-      {
-         in_expression = sc.in_expression;
-         in_boundary = sc.in_boundary;
-         in_blkArea = sc.in_blkArea;
-         in_deadspace = sc.in_deadspace;
-      }
-
-   inline const vector<int>& expression() const
-      {  return in_expression; }
-   inline int expression_size() const
-      {  return in_expression.size(); }
-   inline int expression(int i) const
-      {  return in_expression[i]; }
-
-   inline const BoundaryType& boundary() const
-      {  return in_boundary; }
-
-   inline double blkArea() const
-      {  return in_blkArea; }
-
-   inline double deadspace() const
-      {  return in_deadspace; }
-   
-private:
-   vector<int> in_expression;
-   BoundaryType in_boundary;
-   double in_blkArea;
-   double in_deadspace;
-};
-// --------------------------------------------------------
-class SoftClusterSet
-{
-public:
-   SoftClusterSet() {}
-   SoftClusterSet(const BlockInfoType& blockinfo)
-      {         
-         for (int i = 0; i < blockinfo.size(); i++)
-            in_set.push_back(SoftCluster(i, blockinfo[i]));
-      }
-   SoftClusterSet(const SoftClusterSet& scs)
-      : in_set(scs.in_set) {}
-   void operator =(const SoftClusterSet& scs)
-      {  in_set = scs.in_set; }
-
-   inline int size() const
-      {  return in_set.size(); }
-   inline const SoftCluster& operator[](int i) const
-      {  return in_set[i]; };
-
-   inline void push_cluster(const SoftCluster& sc)
-      {  in_set.push_back(sc); }
-
-private:
-   vector<SoftCluster> in_set;
-};
-// --------------------------------------------------------
-
-#endif
diff -druN BloBB_CompaSS_050315/CompaSS/debug.cxx blob_compass/CompaSS/debug.cxx
--- BloBB_CompaSS_050315/CompaSS/debug.cxx	2004-02-07 20:17:21.000000000 -0800
+++ blob_compass/CompaSS/debug.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,1113 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "debug.h"
-#include "datastrbacksoftst.h"
-#include "datastrfrontsoftst.h"
-#include "datastrhiersoftst.h"
-#include "enginesoftst.h"
-#include "enginehiersoftst.h"
-
-#include <iostream>
-#include <fstream>
-#include <sstream>
-#include <iomanip>
-#include <string>
-#include <algorithm>
-using namespace std;
-
-// --------------------------------------------------------
-int Debug::count = 0;
-string Debug::filePrefix("");
-string Debug::fileSuffix("");
-const string Debug::TEMP_FILE_NAME("out");
-// --------------------------------------------------------
-void Debug::initialize(const string& nName)
-{
-   stringstream old(nName);
-   char ch;
-
-   filePrefix = "";
-   old.get(ch);
-   while (ch != '.' && old.good())
-   {
-      filePrefix += ch;
-      old.get(ch);
-   }
-
-   fileSuffix = "";
-   fileSuffix += '.';
-   old.get(ch);
-   if (old.good())
-      while (old.good())
-      {
-         fileSuffix += ch;
-         old.get(ch);
-      }
-   else
-      fileSuffix = ".ps";
-}
-// --------------------------------------------------------    
-void Debug::OutputBoundary(int format,
-                           ostream& outs,
-                           const BoundaryType& boundary)
-{
-   if (boundary.size() < 3)
-   {
-      cout << "ERROR: in OutputBoundary(), boundary has less than "
-           << "3 elements. " << endl;
-      exit(1);
-   }
-
-   int ptr = boundary.size()-1;
-   while (boundary[ptr].xCoord() >= Point::INFTY)
-      ptr--;
-   double xEnd = boundary[ptr].xCoord() * 1.1;
-
-   ptr = 0;
-   while (boundary[ptr].yCoord() >= Point::INFTY)
-      ptr++;
-   double yEnd = boundary[ptr].yCoord() * 1.1;
-
-   stringstream ss;
-   switch (format)
-   {
-   case GNUPLOT: // gnuplot format
-      ss << filePrefix << "-" << count << fileSuffix;
-      count++;
-      
-      cout << "Writing gnuplot script to create file: "
-           << ss.str() << endl;           
-      GnuplotHeading(outs, ss.str());
-
-      outs << "set xtics" << endl;
-      outs << "set ytics" << endl;
-      outs << "set title \"boundary " << (count-1) << "\"" << endl;
-      outs << "plot [0:" << xEnd << "][0:" << yEnd << "] ";
-      outs << "\"-\" notitle with linesp lt 1 pt 3" << endl;
-      for (int i = 0; i < boundary.size(); i++)
-         outs << min(boundary[i].xCoord(), xEnd) << " "
-              << min(boundary[i].yCoord(), yEnd) << endl;
-      outs << "END" << endl;
-      break;
-   case CONSOLE:      
-      outs << "area: " << boundary.min_area() << endl;
-      for (int i = 0; i < boundary.size(); i++)
-         outs << boundary[i].xCoord() << " "
-              << boundary[i].yCoord() << endl;
-      break;
-   }
-}
-// --------------------------------------------------------
-void Debug::GnuplotHeading(ostream& outs,
-                           const string& filename)
-{
-   outs << "set noxtics" << endl;
-   outs << "set noytics" << endl;
-   outs << "set nox2tics" << endl;
-   outs << "set noy2tics" << endl;
-   outs << "set size ratio -1" << endl;
-   outs << "set terminal postscript landscape solid" << endl;
-   outs << "set output \"";
-   outs << filename;
-   outs << "\"" << endl;
-}
-// --------------------------------------------------------
-void Debug::ReadCurve(istream& ins,
-                      vector<Point>& curve)
-{
-   int numPts;
-   ins >> numPts;
-
-   curve.clear();
-   for (int j = 0; j < numPts; j++)
-   {
-      double x, y;
-      if (!ins.good())
-      {
-         cout << "ERROR: error before reading point["
-              << j << "]" << endl;
-         exit(1);
-      }
-      ins >> x >> y;
-
-      if (j == 0)
-         curve.push_back(Point(x, Point::INFTY));
-      curve.push_back(Point(x,y));
-      if (j == numPts-1)
-         curve.push_back(Point(Point::INFTY, y));
-   }
-}      
-// --------------------------------------------------------
-void Debug::PlotCurves(ostream& outs,
-                       const vector< vector<Point> >& curves)
-{
-   stringstream ss;
-   ss << filePrefix << "-" << count << fileSuffix;
-   count++;
-
-   GnuplotHeading(outs, ss.str());
-      
-   cout << "Writing gnuplot script to create file: "
-        << ss.str() << endl;           
-
-   outs << "set xtics" << endl;
-   outs << "set ytics" << endl;
-   outs << "set title \"" << ss.str() << "\"" << endl;
-
-   double xEnd = 0;
-   double yEnd = 0;
-
-   for (unsigned int i = 0; i < curves.size(); i++)
-      for (unsigned int j = 1; j < curves[i].size()-1; j++)
-      {
-         xEnd = max(xEnd, curves[i][j].xCoord());
-         yEnd = max(yEnd, curves[i][j].yCoord());
-      }
-
-   xEnd *= 1.1;
-   yEnd *= 1.1;
-   
-   outs << "plot [0:" << xEnd << "][0:" << yEnd << "] ";
-   for (unsigned int i = 0; i < curves.size(); i++)
-   {
-      outs << "\"-\" with linesp lw " << i << " pt 3";
-      if (i < curves.size()-1)
-         outs << ", ";
-   }
-   outs << endl;
-   
-   for (unsigned int i = 0; i < curves.size(); i++)
-   {
-      for (unsigned int j = 0; j < curves[i].size(); j++)
-         outs << min(curves[i][j].xCoord(), xEnd) << " "
-              << min(curves[i][j].yCoord(), yEnd) << endl;
-      outs << "END" << endl;
-   }
-}
-// --------------------------------------------------------
-void Debug::OutputNode(ostream& outs,
-                       const SoftNode& node)
-{
-   outs << "sign: ";
-   if (node.sign == BoundaryType::PLUS)
-      outs << "+" << endl;
-   else if (node.sign == BoundaryType::STAR)
-      outs << "*" << endl;
-   else
-      outs << node.sign << endl;
-
-   outs << "BLBlock: " << node.BLBlock << endl;
-   outs << "TRblblock: " << node.TRblblock << endl;
-   outs << "blkArea: " << node.blkArea << endl;
-   outs << "minArea: " << node.minArea << endl;
-   outs << "minDspc: " << node.minDeadspace << endl;
-}
-// --------------------------------------------------------
-void Debug::OutputSoftSTree(ostream& outs,
-                            const SoftSTree& st)
-{
-   cout.setf(ios::fixed);
-   cout.precision(2);
-   
-   cout << "balance: " << st.balance() << endl;
-   cout << "perSize: " << st.perSize() << endl;
-   cout << "d_Space: " << st.deadspace() << endl;
-   cout << "b__Area: " << st.total_area() - st.deadspace() << endl;
-   cout << "t__Area: " << st.total_area() << endl;
-
-   cout << "expression: ";
-   for (int i = 0; i < st.expression_size(); i++)
-      if (st.expression(i) == SoftSTree::PLUS)
-         cout << "+ ";
-      else if (st.expression(i) == SoftSTree::STAR)
-         cout << "* ";
-      else 
-         cout << st.expression(i) << " ";
-   cout << endl;
-
-   cout.precision(0);
-   cout << "-----buffer-----" << endl;
-   cout << " sign : ";
-   for (int i = 0; i < st.buffer_size(); i++)
-      if (st.buffer(i).sign == SoftSTree::PLUS)
-         cout << setw(5) << '+';
-      else if (st.buffer(i).sign == SoftSTree::STAR)
-         cout << setw(5) << '*';
-      else 
-         cout << setw(5) << st.buffer(i).sign;
-   cout << endl;
-   cout << " blblk: ";
-   for (int i = 0; i < st.buffer_size(); i++)
-      cout << setw(5) << st.buffer(i).BLBlock;
-   cout << endl;
-   cout << " trblb: ";
-   for (int i = 0; i < st.buffer_size(); i++)
-      cout << setw(5) << st.buffer(i).TRblblock;
-   cout << endl;
-   cout << " blk_a: ";
-   for (int i = 0; i < st.buffer_size(); i++)
-      cout << setw(5) << st.buffer(i).blkArea;
-   cout << endl;
-   cout << " min_a: ";
-   for (int i = 0; i < st.buffer_size(); i++)
-      cout << setw(5) << st.buffer(i).minArea;
-   cout << endl;
-   cout << " min_d: ";
-   for (int i = 0; i < st.buffer_size(); i++)
-      cout << setw(5) << st.buffer(i).minDeadspace;
-   cout << endl;
-
-   cout << endl;
-   cout << "-----storage-----" << endl;
-   cout << " sign : ";
-   for (int i = 0; i < st.storage_size(); i++)
-      if (st.storage(i).sign == SoftSTree::PLUS)
-         cout << setw(5) << '+';
-      else if (st.storage(i).sign == SoftSTree::STAR)
-         cout << setw(5) << '*';
-      else 
-         cout << setw(5) << st.storage(i).sign;
-   cout << endl;
-   cout << " blblk: ";
-   for (int i = 0; i < st.storage_size(); i++)
-      cout << setw(5) << st.storage(i).BLBlock;
-   cout << endl;
-   cout << " trblb: ";
-   for (int i = 0; i < st.storage_size(); i++)
-      cout << setw(5) << st.storage(i).TRblblock;
-   cout << endl;
-   cout << " blk_a: ";
-   for (int i = 0; i < st.storage_size(); i++)
-      cout << setw(5) << st.storage(i).blkArea;
-   cout << endl;
-   cout << " min_a: ";
-   for (int i = 0; i < st.storage_size(); i++)
-      cout << setw(5) << st.storage(i).minArea;
-   cout << endl;
-   cout << " min_d: ";
-   for (int i = 0; i < st.storage_size(); i++)
-      cout << setw(5) << st.storage(i).minDeadspace;
-   cout << endl;
-
-   cout << endl;
-   cout << "-----BLOCK_NODES-----" << endl;
-   cout << " sign : ";
-   for (unsigned int i = 0; i < st.BLOCK_NODES.size(); i++)
-      if (st.BLOCK_NODES[i].sign == SoftSTree::PLUS)
-         cout << setw(5) << '+';
-      else if (st.BLOCK_NODES[i].sign == SoftSTree::STAR)
-         cout << setw(5) << '*';
-      else 
-         cout << setw(5) << st.BLOCK_NODES[i].sign;
-   cout << endl;
-   cout << " blblk: ";
-   for (unsigned int i = 0; i < st.BLOCK_NODES.size(); i++)
-      cout << setw(5) << st.BLOCK_NODES[i].BLBlock;
-   cout << endl;
-   cout << " trblb: ";
-   for (unsigned int i = 0; i < st.BLOCK_NODES.size(); i++)
-      cout << setw(5) << st.BLOCK_NODES[i].TRblblock;
-   cout << endl;
-   cout << " blk_a: ";
-   for (unsigned int i = 0; i < st.BLOCK_NODES.size(); i++)
-      cout << setw(5) << st.BLOCK_NODES[i].blkArea;
-   cout << endl;
-   cout << " min_a: ";
-   for (unsigned int i = 0; i < st.BLOCK_NODES.size(); i++)
-      cout << setw(5) << st.BLOCK_NODES[i].minArea;
-   cout << endl;
-   cout << " min_d: ";
-   for (unsigned int i = 0; i < st.BLOCK_NODES.size(); i++)
-      cout << setw(5) << st.BLOCK_NODES[i].minDeadspace;
-   cout << endl;
-}
-// --------------------------------------------------------
-void Debug::OutputSoftSliceRecord(ostream& outs,
-                                  const SoftSliceRecord& ssr)
-{
-   cout << "sign: ";
-   for (unsigned int i = 0; i < ssr.expression.size(); i++)
-      if (ssr.expression[i] == SoftSTree::PLUS)
-         cout << setw(5) << '+';
-      else if (ssr.expression[i] == SoftSTree::STAR)
-         cout << setw(5) << '*';
-      else if (ssr.expression[i] == SoftSTree::BOTH)
-         cout << setw(5) << '-';
-      else
-         cout << setw(5) << ssr.expression[i];
-   cout << endl;
-   cout << "min_a: " << ssr.minArea << endl;
-   cout << "min_d: " << ssr.minDeadspace << endl;
-}
-// --------------------------------------------------------
-void Debug::CheckSTree(const SoftSTree& sst)
-{
-   for (int i = 0; i < sst.buffer_size(); i++)
-      if (sst.buffer(i).boundary.size() < 5)
-      {
-         cout << "boundary error starts here." << endl;
-         for (int j = 0; j < sst.expression_size(); j++)
-            if (sst.expression(j) == SoftSTree::PLUS)
-               cout << "+ ";
-            else if (sst.expression(j) == SoftSTree::STAR)
-               cout << "* ";
-            else
-               cout << sst.expression(j) << " ";         
-         cout << endl;
-         
-         cout << "pre-buffer: " << endl;
-         for (int j = 0; j < sst.buffer_size(); j++)
-         {
-            Debug::OutputNode(cout, sst.buffer(j));
-            cout << "size(): " << sst.buffer(j).boundary.size() << endl;
-            
-            cout << "x: ";
-            for (int k = 0; k < sst.buffer(j).boundary.size(); k++)
-               if (sst.buffer(j).boundary[k].xCoord() >= Point::INFTY)
-                  cout << setw(7) << "---";
-               else
-                  cout << setw(7) << sst.buffer(j).boundary[k].xCoord();
-            cout << endl;
-            cout << "y: ";
-            for (int k = 0; k < sst.buffer(j).boundary.size(); k++)
-               if (sst.buffer(j).boundary[k].yCoord() >= Point::INFTY)
-                  cout << setw(7) << "---";
-               else
-                  cout << setw(7) << sst.buffer(j).boundary[k].yCoord();
-            cout << endl << endl;
-            
-         }
-         cout << endl;
-         cout << "pre-storage: " << endl;
-         for (int j = 0; j < sst.storage_size(); j++)
-         {
-            Debug::OutputNode(cout, sst.storage(j));
-            cout << "size(): " << sst.storage(j).boundary.size() << endl;
-
-            cout << "x: ";
-            for (int k = 0; k < sst.storage(j).boundary.size(); k++)
-               if (sst.storage(j).boundary[k].xCoord() >= Point::INFTY)
-                  cout << setw(7) << "---";
-               else
-                  cout << setw(7) << sst.storage(j).boundary[k].xCoord();
-            cout << endl;
-            cout << "y: ";
-            for (int k = 0; k < sst.storage(j).boundary.size(); k++)
-               if (sst.storage(j).boundary[k].yCoord() >= Point::INFTY)
-                  cout << setw(7) << "---";
-               else
-                  cout << setw(7) << sst.storage(j).boundary[k].yCoord();
-            cout << endl << endl;
-         }         
-         exit(1);
-      }
-}  
-// --------------------------------------------------------
-
-// -----debugging program-----
-void DebugSTree(int argc, char *argv[]);
-void DebugEval(int argc, char *argv[]);
-void DebugBrute(int argc, char *argv[]);
-void DebugReadTxt(int argc, char *argv[]);
-void DebugPlus(int argc, char *argv[]);
-void DebugHier(int argc, char *argv[]);
-
-int main(int argc, char *argv[])
-{
-   vector< vector<Point> > curves;   
-
-   if (!strcmp(argv[2], "-i"))
-   {
-      int numPts, numCurves;
-
-      cout << "# curves ->";
-      cin >> numCurves;
-   
-      cout << "# points (excluding end points->";
-      cin >> numPts;
-
-      curves.resize(numCurves);
-      for (int i = 0; i < numCurves; i++)
-         for (int j = 0; j < numPts; j++)
-         {
-            double xCoord, yCoord;
-            cout << "point[" << i << "][" << j << "] ->";
-            cin >> xCoord >> yCoord;
-         
-            if (j == 0)
-               curves[i].push_back(Point(xCoord, Point::INFTY));
-         
-            curves[i].push_back(Point(xCoord, yCoord));
-            if (j == numPts-1)
-               curves[i].push_back(Point(Point::INFTY, yCoord));
-         }
-   }
-   else if (!strcmp(argv[2], "-f") ||
-            !strcmp(argv[2], "--interpolate"))
-   {
-      int numCurves;     
-      cout << "# curves ->";
-      cin >> numCurves;
-
-      curves.resize(numCurves);
-      for (int i = 0; i < numCurves; i++)
-      {
-         string filename;
-         cout << "filename[" << i << "]->";
-         cin >> filename;
-         
-         ifstream infile;
-         infile.open(filename.c_str());
-
-         int numPts;
-         infile >> numPts;
-
-         for (int j = 0; j < numPts; j++)
-         {
-            double x, y;
-            if (!infile.good())
-            {
-               cout << "ERROR: error before reading point " << j
-                    << " of curve " << i << endl;
-               exit(0);
-            }
-            infile >> x >> y;
-
-            if (j == 0)
-               curves[i].push_back(Point(x, Point::INFTY));
-            curves[i].push_back(Point(x, y));
-            if (j == numPts-1)
-               curves[i].push_back(Point(Point::INFTY, y));
-         }
-         infile.close();
-      }
-   }
-   if (!strcmp(argv[2], "--plus"))
-      DebugPlus(argc, argv);
-   
-  
-
-   if (!strcmp(argv[2], "-i") ||
-       !strcmp(argv[2], "-f"))
-   {
-      ofstream outfile;
-      outfile.open(Debug::TEMP_FILE_NAME.c_str());
-      Debug::initialize(argv[1]);
-      Debug::PlotCurves(outfile, curves);
-
-      cout << "Point::INFTY: " << Point::INFTY << endl;
-      cout << "min_area[" << 0 << "]: " << BoundaryType(curves[0]).min_area() << endl;
-      cout << "min_area[" << 1 << "]: " << BoundaryType(curves[1]).min_area() << endl;
-      cout << "min_area[" << 2 << "]: " << BoundaryType(curves[2]).min_area() << endl;
-      outfile.close();
-   }
-
-   if (!strcmp(argv[2], "--blockinfo"))
-   {
-      ifstream infile;
-
-      infile.open(argv[3]);
-      if (!infile.good())
-      {
-         cout << "ERROR: cannot open file: " << argv[3] << endl;
-         exit(1);
-      }
-      BlockInfoType blockinfo(BlockInfoType::SOFT, infile);
-
-      Debug::initialize(argv[1]);
-      int blocknum = blockinfo.BLOCK_NUM();
-      for (int i = 0; i < blocknum; i++)
-      {
-         ofstream outfile;
-         stringstream ss;
-
-         ss << "out" << i;
-         outfile.open(ss.str().c_str());
-         Debug::OutputBoundary(Debug::GNUPLOT, outfile, blockinfo[i]);
-         cout << "min_area_x: " << blockinfo[i].min_point().xCoord()
-              << " min_area_y: " << blockinfo[i].min_point().yCoord()
-              << " min_area: " << blockinfo[i].min_point().area() << endl;
-         outfile.close();
-      }
-      cout << "total_area: " << blockinfo.total_area() << endl;
-   }
-
-   if (!strcmp(argv[2], "--node"))
-   {
-      ifstream infile;
-
-      infile.open(argv[3]);
-      if (!infile.good())
-      {
-         cout << "ERROR: cannot open file: " << argv[3] << endl;
-         exit(1);      
-      }
-      BlockInfoType blockinfo(BlockInfoType::SOFT, 40, infile);
-
-      char ch = '\0';
-      vector<SoftNode> nodes;
-
-      for (int i = 0; i < blockinfo.BLOCK_NUM(); i++)
-         nodes.push_back(SoftNode(i, blockinfo[i]));
-
-      Debug::initialize(argv[1]);
-      while (ch != 'q' && cin.good())
-      {
-         cout << "action (s)tar and (p)lus->" << endl;
-         cin >> ch;
-
-         int a, b;
-         switch (ch)
-         {
-         case 's':
-            cout << "nodes 0-" << (nodes.size()-1) << "->";
-            cin >> a >> b;
-            nodes.push_back(SoftNode(BoundaryType::STAR, nodes[a], nodes[b]));
-            cout << nodes[a] << endl;
-            cout << nodes[b] << endl;
-            cout << nodes.back() << endl;
-            break;
-         case 'p':
-            cout << "nodes 0-" << (nodes.size()-1) << "->";
-            cin >> a >> b;
-            nodes.push_back(SoftNode(BoundaryType::PLUS, nodes[a], nodes[b]));
-            cout << nodes[a] << endl;
-            cout << nodes[b] << endl;
-            cout << nodes.back() << endl;
-            break;
-         }
-
-         ofstream outfile;
-         static int count = 0;
-         stringstream ss;
-         ss << "out" << count;
-         count++;
-         
-         outfile.open(ss.str().c_str());
-         if (!outfile.good())
-         {
-            cout << "cannot open: " << ss.str() << endl;
-            exit(1);
-         }
-         Debug::OutputBoundary(Debug::GNUPLOT, outfile, nodes.back().boundary);
-         outfile.close();
-
-         for (int i = 1; i < nodes.back().boundary.size()-1; i++)
-            if (nodes.back().boundary[i].xCoord() >= Point::INFTY ||
-                nodes.back().boundary[i].yCoord() >= Point::INFTY)
-            {
-               cout << "Duplicated infty[" << i << "]: x: "
-                    << nodes.back().boundary[i].xCoord()
-                    << " y: " << nodes.back().boundary[i].yCoord() << endl;               
-            }
-      }
-   }
-
-   if (!strcmp(argv[2], "--interpolate"))
-   {
-      BoundaryType bt(curves[0]);
-
-//      Debug::OutputBoundary(Debug::CONSOLE, cout, bt);
-      cout << "size:  " << bt.size() << endl;
-      cout << "minX: " << bt[0].xCoord() << " minY: "
-           << bt[bt.size()-1].yCoord() << endl;
-      while (cin.good())
-      {
-         double coord;
-         char ch;
-
-         cout << "provide x or y ->";
-         cin >> ch;
-
-         switch (ch)
-         {
-         case 'x':
-            cout << "xCoord ->";
-            cin >> coord;
-            cout << "y: " << bt.getY(coord) << endl;
-            break;
-         case 'y':
-            cout << "yCoord ->";
-            cin >> coord;
-            cout << "x: " << bt.getX(coord) << endl;
-            break;
-         }
-      }
-   }
-
-   if (!strcmp(argv[2], "--stree"))
-      DebugSTree(argc, argv);
-
-   if (!strcmp(argv[2], "--eval"))
-      DebugEval(argc, argv);
-
-   if (!strcmp(argv[2], "--brute") ||
-       !strcmp(argv[2], "--bound"))
-      DebugBrute(argc, argv);
-
-   if (!strcmp(argv[2], "--readtxt"))
-      DebugReadTxt(argc, argv);
-
-   if (!strcmp(argv[2], "--hier"))
-      DebugHier(argc, argv);
-   return 0;
-}
-// --------------------------------------------------------
-void DebugSTree(int argc, char *argv[])
-{
-   ifstream infile;
-
-   infile.open(argv[1]);
-   if (!infile.good())
-   {
-      cout << "ERROR: cannot open file: " << argv[1] << endl;
-      exit(1);
-   }
-
-   int format = -1;
-   if (!strcmp(argv[3], "--soft"))
-      format = BlockInfoType::SOFT;
-   else if (!strcmp(argv[3], "--txt"))
-      format = BlockInfoType::TXT;
-   
-   BlockInfoType blockinfo(format, infile);
-   SoftSTree st(blockinfo);
-   SoftSliceRecord *ptr = NULL;
-
-   Debug::OutputSoftSTree(cout, st);
-   while (cin.good())
-   {
-      char ch;
-      int sign;
-      char sign_ch;
-      
-      cout << "action: " << endl;
-      cout << " push operan(d), push operato(r), p(o)p operand, (p)op operator, (s)ave record->";
-      cin >> ch;
-
-      switch (ch)
-      {
-      case 'd':
-         cout << "block ->";
-         cin >> sign;
-         st.push_operand(sign);
-         break;
-
-      case 'r':
-         cout << "operator ->";
-         cin >> sign_ch;
-
-         switch (sign_ch)
-         {
-         case '+':
-            sign = SoftSTree::PLUS;
-            break;
-         case '*':
-            sign = SoftSTree::STAR;
-            break;
-         }
-         
-         if (st.can_push_operator(sign))
-         st.push_operator(sign);
-         else
-            cout << "Cannot push the chosn operator." << endl;
-         break;
-         
-      case 'o':
-         if ((st.expression_top() == SoftSTree::PLUS) ||
-             (st.expression_top() == SoftSTree::STAR))
-            cout << "the top of expression is operator." << endl;
-         else
-            st.pop_operand();
-         break;
-         
-      case 'p':
-         if ((st.expression_top() == SoftSTree::PLUS) ||
-             (st.expression_top() == SoftSTree::STAR))
-            st.pop_operator();
-         else
-            cout << "the top of expression is operand." << endl;
-         break;
-         
-      case 'q':
-         exit(0);
-         break;
-        
-      default:
-         cout << "invalid command: " << ch << endl;
-         break;
-      }
-      
-      if (ch == 's')
-      {
-         ptr = new SoftSliceRecord(st);
-         cout << "-----SoftSliceRecord-----" << endl;
-         Debug::OutputSoftSliceRecord(cout, *ptr);
-         cout << "ssr.size(): " << ptr->boundary.size() << endl;
-
-         ofstream outfile2;
-         outfile2.open("DEBUG/bdy");
-         Debug::OutputBoundary(Debug::GNUPLOT, cout, ptr->boundary);
-         Debug::OutputBoundary(Debug::GNUPLOT, outfile2, ptr->boundary);         
-         
-         SoftPacking spk(*ptr, blockinfo);   
-         cout << "after spk" << endl;
-         spk.output(cout);
-
-         ofstream outfile;
-         outfile.open("DEBUG/temp.bbb");
-         spk.output(outfile);
-         outfile.close();
-         delete ptr;
-      }
-         
-      Debug::OutputSoftSTree(cout, st);
-      for (int i = 0; i < st.buffer_size(); i++)
-         cout << "[" << i << "] numPts: " << st.buffer(i).boundary.size() << endl;
-      cout << endl;
-   }
-}
-// --------------------------------------------------------
-void DebugEval(int argc, char *argv[])
-{
-   ifstream infile;
-   ofstream outfile;
-
-   infile.open(argv[1]);
-   if (!infile.good())
-   {
-      cout << "Cannot open file: " << argv[1] << endl;
-      exit(1);
-   }
-
-   outfile.open(argv[3]);
-   if (!infile.good())
-   {
-      cout << "Cannot open file: " << argv[3] << endl;
-      exit(1);
-   }
-
-   int format = -1;
-   if (!strcmp(argv[4], "--txt"))
-      format = BlockInfoType::TXT;
-   else if (!strcmp(argv[4], "--soft"))
-      format = BlockInfoType::SOFT;
-   
-   BlockInfoType blockinfo(format, infile);
-   SoftSTree st(blockinfo);
-
-   int expr_size = 2 * blockinfo.BLOCK_NUM() - 1;
-   vector<int> expression(expr_size);
-
-   cout << "expr: ";
-   for (int i = 0; i < expr_size; i++)
-   {
-      int sign;
-      infile >> sign;
-
-      if (sign == blockinfo.BLOCK_NUM() ||
-          sign == SoftSTree::PLUS)
-      {
-         expression[i] = SoftSTree::PLUS;
-         cout << "+ ";
-      }
-      else if (sign == blockinfo.BLOCK_NUM()+1 ||
-               sign == SoftSTree::STAR)
-      {
-         expression[i] = SoftSTree::STAR;
-         cout << "* ";
-      }
-      else if (sign < blockinfo.BLOCK_NUM())
-      {
-         expression[i] = sign;
-         cout << sign << " ";
-      }
-      else
-      {
-         cout << "Invalid sign." << endl;
-         exit(1);
-      }      
-   }
-   cout << endl;
-
-   for (int i = 0; i < expr_size; i++)
-   {
-      int sign = expression[i];
-      switch (sign)
-      {
-      case SoftSTree::PLUS:
-      case SoftSTree::STAR:
-      case SoftSTree::BOTH:
-         if (!strcmp(argv[5], "--explicit"))
-            st.push_operator(sign);
-         else if (!strcmp(argv[5], "--implicit"))
-            st.push_operator(SoftSTree::BOTH);
-         else
-         {
-            cout << "invalid mode: " << argv[5] << endl;
-            exit(1);
-         }
-         break;
-      default:
-         st.push_operand(sign);
-         break;
-      }
-   }
-
-   Debug::initialize("bound.ps");
-   SoftSliceRecord ssr(st);
-   SoftPacking spk(ssr, blockinfo);
-   spk.output(outfile);
-}
-// --------------------------------------------------------
-void DebugBrute(int argc, char *argv[])
-{
-   ifstream infile;
-   ofstream outfile;
-
-   infile.open(argv[1]);
-   if (!infile.good())
-   {
-      cout << "ERROR: cannot open file: " << argv[1] << endl;
-      exit(1);
-   }
-
-   outfile.open(argv[3]);
-   if (!outfile.good())
-   {
-      cout << "ERROR: cannot open file: " << argv[3] << endl;
-      exit(1);
-   }
-
-   int format = -1;
-   if (!strcmp(argv[4], "--txt"))
-      format = BlockInfoType::TXT;
-   else if (!strcmp(argv[4], "--soft"))
-      format = BlockInfoType::SOFT;
-   
-   BlockInfoType blockinfo(format, infile);
-   SoftEngineType engine(blockinfo);
-
-   SoftSliceRecordList *ssr_ptr = NULL;
-
-   int mode = -1;
-   if (!strcmp(argv[5], "--explicit"))
-      mode = SoftEngineType::EXPLICIT;
-   else if (!strcmp(argv[5], "--implicit"))
-      mode = SoftEngineType::IMPLICIT;
-
-   int algo = -1;
-   if (!strcmp(argv[2], "--brute"))
-      algo = SoftEngineType::BRUTE;
-   else if (!strcmp(argv[2], "--bound"))
-      algo = SoftEngineType::B_BOUND;   
-       
-   if (!strcmp(argv[2], "--brute"))
-      ssr_ptr = engine(algo, mode);
-   else if (!strcmp(argv[2], "--bound"))
-      ssr_ptr = engine(algo, mode);
-
-   cout << "last records: " << endl;
-   SoftPacking(ssr_ptr->last(), blockinfo).output(outfile);
-   SoftPacking(ssr_ptr->last(), blockinfo).output(cout);
-
-   outfile.close();
-   
-//    outfile.open(argv[5]);
-//    if (!outfile.good())
-//    {
-//       cout << "ERROR: cannot open file: " << argv[5] << endl;
-//       exit(1);
-//    }
-   
-//    cout << "size: " << ssr_ptr->last().boundary.size() << endl;
-//    for (int i = 0; i < ssr_ptr->last().boundary.size(); i++)
-//       cout << "[" << i << "] x: " << ssr_ptr->last().boundary[i].xCoord()
-//            << "y: " << ssr_ptr->last().boundary[i].yCoord() << endl;
-//    cout << endl;
-//    Debug::OutputBoundary(Debug::GNUPLOT, outfile, ssr_ptr->last().boundary);
-   
-   delete ssr_ptr;
-}
-// --------------------------------------------------------
-void DebugReadTxt(int argc, char *argv[])
-{
-   ifstream infile;
-
-   infile.open(argv[1]);
-   if (!infile.good())
-   {
-      cout << "ERROR: cannot open file: " << argv[1] << endl;
-      exit(1);
-   }
-
-   BlockInfoType blockinfo(BlockInfoType::TXT, infile);
-
-   cout.setf(ios::fixed);
-   cout.precision(2);
-   for (int i = 0; i < blockinfo.size(); i++)
-      cout << "[" << i << "] x: " << blockinfo[i][1].xCoord() << " "
-           << "y: " << blockinfo[i][1].yCoord() << " "
-           << "a: " << blockinfo[i].min_area() << endl;
-   cout << endl;
-   cout << "total_area: " << blockinfo.block_area() << endl;
-   exit(0);
-}
-// --------------------------------------------------------
-void DebugPlus(int argc, char *argv[])
-{
-   vector< vector<Point> > curves;
-   curves.resize(4);
-   string filename(argv[3]);
-
-   ifstream infile;
-   infile.open(filename.c_str());
-   if (!infile.good())
-   {
-      cout << "ERROR: cannot open file: " << filename << endl;
-      exit(1);
-   }
-   Debug::ReadCurve(infile, curves[0]);
-   infile.close();
-
-   filename = argv[4];
-   infile.open(filename.c_str());
-   if (!infile.good())
-   {
-      cout << "ERROR: cannot open file: " << filename << endl;
-      exit(1);
-   }
-   Debug::ReadCurve(infile, curves[1]);
-   infile.close();
-
-   BoundaryType b0a(BoundaryType::PLUS, BoundaryType(curves[0]), BoundaryType(curves[1]));
-   BoundaryType b0b(BoundaryType::STAR, BoundaryType(curves[0]), BoundaryType(curves[1]));
-   BoundaryType b1(BoundaryType::BOTH, BoundaryType(curves[0]), BoundaryType(curves[1]));
-   BoundaryType b2(BoundaryType::BOTH, BoundaryType(curves[1]), BoundaryType(curves[0]));
-
-   vector<Point> block_A(curves[0]);
-   vector<Point> block_B(curves[1]);
-   curves[0] = b0a.curve();
-   curves[1] = b0b.curve();
-   curves[2] = b1.curve();
-   curves[3] = b2.curve();
-   
-   for (unsigned int j = 0; j < min(curves[2].size(), curves[3].size()); j++)
-      if (curves[2][j].xCoord() != curves[3][j].xCoord() ||
-          curves[2][j].yCoord() != curves[3][j].yCoord())
-      {
-         cout << "ERROR: the two curves disagree in point[" << j << "]: "
-              << "(" << curves[2][j].xCoord()
-              << "," << curves[2][j].yCoord() << ")"
-              << " vs (" << curves[4][j].xCoord()
-              << "," << curves[3][j].yCoord() << ")"
-              << endl;
-      }
-   
-   if (curves[2].size() != curves[3].size())
-      cout << "ERROR: the two curves disagree in size. " << endl;
-   
-   ofstream outfile;
-   Debug::initialize(argv[1]);
-
-   vector< vector<Point> > b1_curve(1, curves[0]);
-   vector< vector<Point> > b2_curve(1, curves[1]);
-   vector< vector<Point> > or_curve(1, curves[2]);
-
-   outfile.open("DEBUG/out0");
-   Debug::PlotCurves(outfile, b1_curve);
-//   Debug::PlotCurves(cout, b1_curve);   
-   outfile.close();
-
-   outfile.open("DEBUG/out1");
-   Debug::PlotCurves(outfile, b2_curve);
-//   Debug::PlotCurves(cout, b2_curve);
-   outfile.close();
-
-   outfile.open("DEBUG/out2");   
-   Debug::PlotCurves(outfile, or_curve);
-//   Debug::PlotCurves(cout, or_curve);
-   outfile.close();
-
-   cout << "Point::INFTY: " << Point::INFTY << endl;
-   cout << "min_area of block A: " << BoundaryType(block_A).min_area()
-        << " size: " << block_A.size() << endl;
-   cout << "min_area of block B: " << BoundaryType(block_B).min_area()
-        << " size: " << block_B.size() << endl;
-   cout << "min_area[" << 0 << "]: " << BoundaryType(curves[0]).min_area()
-        << " size: " << curves[0].size() << endl;
-   cout << "min_area[" << 1 << "]: " << BoundaryType(curves[1]).min_area()
-        << " size: " << curves[1].size() << endl;
-   cout << "min_area[" << 2 << "]: " << BoundaryType(curves[2]).min_area()
-        << " size: " << curves[2].size() << endl;
-   cout << "min_point[" << 2 << "]: x:" << BoundaryType(curves[2]).min_point().xCoord()
-        << " y:" << BoundaryType(curves[2]).min_point().yCoord() << endl;
-}
-// --------------------------------------------------------
-void DebugHier(int argc, char *argv[])
-{
-   
-   ifstream infile;
-   ofstream outfile;
-
-   infile.open(argv[1]);
-   if (!infile.good())
-   {
-      cout << "ERROR: cannot open file: " << argv[1] << endl;
-      exit(1);
-   }
-
-   outfile.open(argv[3]);
-   if (!outfile.good())
-   {
-      cout << "ERROR: cannot open file: " << argv[3] << endl;
-      exit(1);
-   }
-
-   int format = -1;
-   if (!strcmp(argv[4], "--txt"))
-      format = BlockInfoType::TXT;
-   else if (!strcmp(argv[4], "--soft"))
-      format = BlockInfoType::SOFT;
-
-   cout << "---HIER MODE---" << endl;
-   BlockInfoType blockinfo(format, infile);
-   SoftHierEngineType engine(blockinfo);
-
-   SoftSliceRecord *ssrPtr = engine();
-
-   cout << "last records: " << endl;
-   cout << "min_area: " << (ssrPtr->boundary).min_area() << endl;
-   SoftPacking(*ssrPtr, blockinfo).output(outfile);
-   
-   outfile.close();
-}
diff -druN BloBB_CompaSS_050315/CompaSS/debug.h blob_compass/CompaSS/debug.h
--- BloBB_CompaSS_050315/CompaSS/debug.h	2004-02-07 20:15:14.000000000 -0800
+++ blob_compass/CompaSS/debug.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,77 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef DEBUG_H
-#define DEBUG_H
-
-#include "datastrbacksoftst.h"
-#include "datastrfrontsoftst.h"
-
-#include <iostream>
-
-// --------------------------------------------------------
-class Debug
-{
-public:   
-   static void GnuplotHeading(ostream& outs,
-                              const string& filename);
-   static void OutputBoundary(int format,
-                              ostream& outs,
-                              const BoundaryType& boundary);
-   
-   static void ReadCurve(istream& ins,
-                         vector<Point>& curve);
-   static void PlotCurves(ostream& outs,
-                          const vector< vector<Point> >& curves);
-   static void initialize(const string& nName);
-
-   static void OutputNode(ostream& outs, const SoftNode& node);
-   static void OutputSoftSTree(ostream& outs, const SoftSTree& st);
-   static void OutputSoftSliceRecord(ostream& outs, const SoftSliceRecord& ssr);
-   static void CheckSTree(const SoftSTree& sst);
-   
-   enum FormatType {GNUPLOT = 0, CONSOLE};
-   static const string TEMP_FILE_NAME;
-
-private:
-   Debug();
-   static int count;
-   static string filePrefix;
-   static string fileSuffix;
-};
-// --------------------------------------------------------
-inline ostream& operator <<(ostream& outs, const SoftNode& node)
-{
-   Debug::OutputNode(outs, node);
-   return outs;
-}
-// --------------------------------------------------------
-#endif
diff -druN BloBB_CompaSS_050315/CompaSS/enginehiersoftst.cxx blob_compass/CompaSS/enginehiersoftst.cxx
--- BloBB_CompaSS_050315/CompaSS/enginehiersoftst.cxx	2005-03-13 22:00:29.000000000 -0800
+++ blob_compass/CompaSS/enginehiersoftst.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,609 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "enginehiersoftst.h"
-#include "datastrfrontsoftst.h"
-#include "datastrhiersoftst.h"
-#include "enginesoftst.h"
-#include "debug.h"
-
-#include <iostream>
-#include <sstream>
-#include <string>
-#include <vector>
-#include <set>
-#include <algorithm>
-using namespace std;
-
-// -----default parameters-----
-const double DEFAULT_HIER_INIT_DEADSPACE = 0.05;
-const double DEFAULT_HIER_DEADSPACE_INCRE = 1.5;
-const double DEFAULT_HIER_WIDTH_INCRE = 1.15;
-const double DEFAULT_HIER_HEIGHT_INCRE = 1.15;
-
-const int DEFAULT_HIER_CLUSTER_BASE = 8;
-const double DEFAULT_HIER_CLUSTER_AREA_DEV = 1.85;
-const double DEFAULT_HIER_AR = 1.2;
-const int DEFAULT_HIER_USE_AR_LEVEL = 2;
-const bool DEFAULT_HIER_USE_AR = false;
-
-const double DEFAULT_HIER_SIMILARITY_THRESHOLD = 1.9;
-
-// -----adjustable parameters-----
-double SoftHierEngineType::HIER_INIT_DEADSPACE = DEFAULT_HIER_INIT_DEADSPACE;
-double SoftHierEngineType::HIER_DEADSPACE_INCRE = DEFAULT_HIER_DEADSPACE_INCRE;
-double SoftHierEngineType::HIER_WIDTH_INCRE = DEFAULT_HIER_WIDTH_INCRE;
-double SoftHierEngineType::HIER_HEIGHT_INCRE = DEFAULT_HIER_HEIGHT_INCRE;
-
-int SoftHierEngineType::HIER_CLUSTER_BASE = DEFAULT_HIER_CLUSTER_BASE;
-double SoftHierEngineType::HIER_CLUSTER_AREA_DEV = DEFAULT_HIER_CLUSTER_AREA_DEV;
-double SoftHierEngineType::HIER_AR = DEFAULT_HIER_AR;
-int SoftHierEngineType::HIER_USE_AR_LEVEL = DEFAULT_HIER_USE_AR_LEVEL;
-bool SoftHierEngineType::HIER_USE_AR = false;
-
-double SoftHierEngineType::HIER_SIMILARITY_THRESHOLD
-    = DEFAULT_HIER_SIMILARITY_THRESHOLD;
-// --------------------------------------------------------
-BlockInfoType::BlockInfoType(const SoftClusterSet& clusterSet)
-{
-   int clusterNum = clusterSet.size();
-   in_total_area = 0;
-   for (int i = 0; i < clusterNum; i++)
-   {
-      blocks.push_back(clusterSet[i].boundary());
-      in_total_area +=
-         clusterSet[i].blkArea() + clusterSet[i].deadspace();
-   }
-}
-// --------------------------------------------------------
-SoftSliceRecord::SoftSliceRecord(const SoftCluster& cluster)
-   : minArea(cluster.blkArea()), minDeadspace(cluster.deadspace()),
-     expression(cluster.expression()),
-     boundary(cluster.boundary()) {}
-// --------------------------------------------------------
-SoftHierEngineType::SoftHierEngineType(int instanceType,
-                                       const BlockInfoType& blockinfo,
-                                       const set<string> *const userDefinedOptions)
-   : _instanceType(instanceType),
-     _blockinfo(blockinfo),
-     current_level(0),
-     _userDefinedOptions_cleaner((userDefinedOptions == NULL)
-                                 ? new set<string> : NULL),
-     _userDefinedOptions((userDefinedOptions == NULL)
-                         ? *_userDefinedOptions_cleaner // use the empty set
-                         : *userDefinedOptions)         // use the set spec. in the param.
-{
-   int blocknum = blockinfo.size();
-   for (int i = 0; i < blocknum; i++)
-      clusters.push_back(SoftCluster(i, blockinfo[i]));
-}
-// --------------------------------------------------------
-SoftHierEngineType::~SoftHierEngineType()
-{
-   if (_userDefinedOptions_cleaner != NULL)
-      delete _userDefinedOptions_cleaner;
-}
-// --------------------------------------------------------
-SoftSliceRecord* SoftHierEngineType::operator ()(int format)
-{
-   tuneAndPrintParameters();
-   while (clusters.size() > 1)
-   {
-      cout << "[" << current_level << "]===== Grouping "
-           << clusters.size() << " clusters... " << endl;
-      GroupClusterSets();
-
-      cout << "[" << current_level << "]===== Packing into "
-           << clusterSets.size() << " clusters... " << endl;
-      CoreEngine(format);
-      current_level++;
-      
-      int clusterNum = clusters.size();
-      double blkArea = 0;
-      double deadspace = 0;
-      for (int i = 0; i < clusterNum; i++)
-      {
-         blkArea += clusters[i].blkArea();
-         deadspace += clusters[i].deadspace();
-      }
-
-      cout.setf(ios::fixed);
-      cout.precision(2);
-      cout << endl;
-      cout << "blkArea: " << setw(11) << blkArea
-           << " deadspace: " << setw(11) << deadspace
-           << " (" << ((deadspace / blkArea) * 100)
-           << "%) time: " << getTotalTime() << endl;
-      cout << endl;
-   }
-
-   cout << "total area: " << setw(11)
-        << clusters[0].blkArea() + clusters[0].deadspace() << endl;
-   cout << "block area: " << setw(11)
-        << clusters[0].blkArea() << endl;
-   cout << "deadspace:  " << setw(11)
-        << clusters[0].deadspace() << endl;
-   SoftSliceRecord *ssr_ptr = new SoftSliceRecord(clusters[0]);
-
-//    for (unsigned int i = 0; i < ssr_ptr->expression.size(); i++)
-//       if (ssr_ptr->expression[i] == SoftSTree::BOTH)
-//          cout << " -";
-//       else
-//          cout << ssr_ptr->expression[i] << " ";
-   return ssr_ptr;   
-}      
-// --------------------------------------------------------   
-void SoftHierEngineType::CoreEngine(int format)
-{
-   int clusterSetNum = clusterSets.size();
-   BlockCompareType block_compare = NULL;
-   if (format == BlockInfoType::SOFT)
-      block_compare = trivial_compare;
-   else
-      block_compare = hard_blk_compare;
-   
-   clusters.clear();
-   for (int i = 0; i < clusterSetNum; i++)
-   {
-      BlockInfoType blockinfo(clusterSets[i]);
-      SoftEngineType engine(blockinfo, block_compare);
-
-      if (current_level <= HIER_USE_AR_LEVEL &&
-          clusterSetNum > HIER_CLUSTER_BASE * HIER_CLUSTER_BASE)
-      {
-         HIER_USE_AR = true;
-         if (i == 0)
-            cout << " * Aspect ratio bound used." << endl;
-      }
-      else
-      {
-         HIER_USE_AR = false;
-         if (i == 0)
-            cout << " * Aspect ratio bound not used." << endl;
-      }
-      SoftSliceRecordList *ssrListPtr = engine(SoftEngineType::HIER,
-                                               SoftEngineType::EXPLICIT);
-
-      if (clusterSetNum == HIER_CLUSTER_BASE)
-      {
-         if (i == 0)
-            cout << endl;
-         cout << "finished " << (i+1) << " / " << HIER_CLUSTER_BASE
-              << ". cluster size: " << clusterSets[i].size()
-              << " time: " << getTotalTime() << endl;
-      }
-
-      int instr = BoundaryType::FLIP_OR;
-      if (format == BlockInfoType::TXT_FIXED)
-         instr = BoundaryType::NOOP;
-      SoftCluster merged(instr,
-                         clusterSets[i], ssrListPtr->last());
-      clusters.push_back(merged);
-
-      delete ssrListPtr;
-   }
-}
-// --------------------------------------------------------
-void SoftHierEngineType::GroupClusterSets() 
-{
-   vector<DistanceInfo> distInfoVec;
-   BuildSortedVector(distInfoVec);
-
-   const int clusterNum = clusters.size();
-   int clusterSetNum = getClusterSetNum(clusterNum);   // <-- may be imposs   
-   const int maxClusterSize = HIER_CLUSTER_BASE + 1;
-   const double maxClusterArea = (clusterSetNum <= HIER_CLUSTER_BASE)?
-      DBL_MAX : getMaxArea();
-
-   // ----- initialize tools -----
-   vector<int> identifier;
-   vector<int> setSize;
-   vector<double> setArea;
-   for (int i = 0; i < clusterNum; i++)
-   {
-      double clusterArea = clusters[i].blkArea() + clusters[i].deadspace();
-      identifier.push_back(i);
-      setSize.push_back(1);
-      setArea.push_back(clusterArea);
-   }
-
-   // ----- assign sets -----
-   clusterSets.clear();
-   int clusterSetCount = clusterNum;
-   while ((clusterSetCount > clusterSetNum) &&
-          !distInfoVec.empty())
-   {
-      DistanceInfo closest(distInfoVec.back());
-      int block1 = closest.blkOne;
-      int block2 = closest.blkTwo;
-      int blockOneID = min(identifier[block1], identifier[block2]);
-      int blockTwoID = max(identifier[block1], identifier[block2]);
-      double setOneBLBlockArea = 
-         clusters[blockOneID].blkArea() + clusters[blockOneID].deadspace();
-
-      if ((blockOneID != blockTwoID) &&
-          (setSize[blockOneID] + setSize[blockTwoID] <= maxClusterSize) &&
-          (setArea[blockOneID] + setArea[blockTwoID] <= maxClusterArea))
-      {
-         for (int i = 0; i < clusterNum; i++)         
-            if (identifier[i] == blockTwoID)
-               identifier[i] = blockOneID;                                 
-               
-         setSize[blockOneID] += setSize[blockTwoID];
-         setArea[blockOneID] += setSize[blockTwoID] * setOneBLBlockArea;
-         clusterSetCount--;
-      }      
-      distInfoVec.pop_back();
-   }
-   clusterSetNum = clusterSetCount; // clusterSetNum >= intended
-
-   // ----- in case if clusterSetNum == clusterNum -----
-   if (clusterSetNum == clusterNum)
-   {
-      identifier[1] = 0;
-      setSize[0] = 2;
-      setArea[0] += setArea[1];
-      clusterSetNum--;
-   }
-
-   // ----- gather sets -----
-   for (int i = 0; i < clusterSetNum; i++)
-   {
-      int ptr = 0;
-      while (identifier[ptr] == -1)
-         ptr++;
-      
-      int setIndex = ptr;
-      SoftClusterSet temp;
-      clusterSets.push_back(temp);
-
-      for (int j = ptr; j < clusterNum; j++)
-         if (identifier[j] == setIndex)
-         {
-            identifier[j] = -1;
-            clusterSets[i].push_cluster(clusters[j]);
-         }     
-   }
-
-   // ----- empty clusters -----
-   clusters.clear();
-}
-// --------------------------------------------------------
-void SoftHierEngineType::BuildSortedVector(
-   vector<DistanceInfo>& distInfoVec) const
-{
-   int clusterNum = clusters.size();
-   for (int i = 1; i < clusterNum; i++)
-      for (int j = 0; j+i < clusterNum; j++)
-      {
-         if (distInfoVec.size() >= HIER_SORT_VEC_MAX_SIZE)
-            break;
-         
-         DistanceInfo dInfo;
-         dInfo.points = getPoints(clusters[j], clusters[j+i]);
-         dInfo.blkOne = j;
-         dInfo.blkTwo = j+i;
-
-         distInfoVec.push_back(dInfo);
-      }
-   sort(distInfoVec.begin(), distInfoVec.end());
-}
-// --------------------------------------------------------
-int SoftHierEngineType::getClusterSetNum(int clusterNum) const
-{
-   double cSetNum = clusterNum;
-   int index = 0;
-   while (cSetNum > HIER_CLUSTER_BASE)
-   {
-      index++;
-      cSetNum = cSetNum / HIER_CLUSTER_BASE;
-   }
-   return int(pow(double(HIER_CLUSTER_BASE), double(index)));
-}
-// --------------------------------------------------------
-double SoftHierEngineType::getPoints(const SoftCluster& c1,
-                                     const SoftCluster& c2) const
-{
-//    double x1 = c1.boundary().min_point().xCoord();
-//    double y1 = c1.boundary().min_point().yCoord();
-//    double x2 = c2.boundary().min_point().xCoord();
-//    double y2 = c2.boundary().min_point().yCoord();
-
-   double x1 = c1.boundary()[1].xCoord();
-   double y1 = c1.boundary()[1].yCoord();
-   double x2 = c2.boundary()[1].xCoord();
-   double y2 = c2.boundary()[1].yCoord();
-   
-   return (pow(min(x1, x2) / max(x1, x2), 10) +
-           pow(min(y1, y2) / max(y1, y2), 10));
-}
-// --------------------------------------------------------
-double SoftHierEngineType::getMaxArea() const
-{
-   double totalArea = 0;
-   int clusterNum = clusters.size();
-   for (int i = 0; i < clusterNum; i++)
-      totalArea += (clusters[i].blkArea() + clusters[i].deadspace());
-
-   return (totalArea / clusterNum) * HIER_CLUSTER_AREA_DEV;
-}
-// --------------------------------------------------------       
-void SoftEngineType::FindSoftSliceHierarchical(const double AR_LIMIT,
-                                               double width_limit,
-                                               double height_limit)
-{
-   int qSize = bCont.size();
-
-   if ((qSize == 0) && (sst.balance() == 1))
-   {
-      if (compare(sst, record_list_ptr->last()))
-      {
-         record_list_ptr->add_record(sst);
-         width_limit = sqrt(sst.total_area() * AR_LIMIT);
-         height_limit = sqrt(sst.total_area() * AR_LIMIT);
-      }
-      return;
-   }
-
-   for (int i = 0; i < qSize; i++)
-   {
-      int blk = bCont.front();
-      bCont.pop();
-
-      sst.push_operand(blk);
-
-      counter[sst.expression_size()][0]++;
-      counter[sst.expression_size()][1]++;
-      if (operandProceed(same, blkBefore, sst, record_list_ptr->last()))
-         FindSoftSliceHierarchical(AR_LIMIT, width_limit, height_limit);
-
-      sst.pop_operand();
-      bCont.push(blk);
-   }
-
-   for (int j = SoftSTree::PLUS; j >= SoftSTree::STAR; j--)
-      if (sst.can_push_operator(j))
-      {
-         sst.push_operator(j, width_limit, height_limit);
-
-         counter[sst.expression_size()][0]++;
-         counter[sst.expression_size()][4]++;
-         if (operatorProceed(sst, record_list_ptr->last()))
-            FindSoftSliceHierarchical(AR_LIMIT, width_limit, height_limit);
-
-         sst.pop_operator();
-      }         
-}
-// --------------------------------------------------------
-void SoftEngineType::HandleHierarchical(int mode)
-{
-   double init_totalArea = -1;
-   double init_deadspace = -1;
-   double init_ar = Point::INFTY;
-   double width_limit = Point::INFTY;
-   double height_limit = Point::INFTY;
-
-   for (int i = 1; i < blockinfo.BLOCK_NUM(); i++)
-      bCont.push(i);
-   
-   compare = BranchBoundCompare;
-   operandProceed = BranchBoundProceed;
-   
-   init_deadspace = sst.total_area() * SoftHierEngineType::HIER_INIT_DEADSPACE;
-   init_totalArea = sst.total_area() + init_deadspace;
-   record_list_ptr = new SoftSliceRecordList(init_totalArea, init_deadspace);
-   
-   if (SoftHierEngineType::HIER_USE_AR)
-   {
-      init_ar = SoftHierEngineType::HIER_AR;
-      width_limit = sqrt(init_totalArea * init_ar);
-      height_limit = sqrt(init_totalArea * init_ar);
-   }
-   else
-   {
-      width_limit = Point::INFTY;
-      height_limit = Point::INFTY;
-   }
-         
-
-   while (record_list_ptr->empty())
-   {
-      sst.push_operand(0);
-      if (mode == SoftEngineType::EXPLICIT)
-         operatorProceed = BranchBoundHierarchicalProceed;
-      else
-      {
-         cout << "Sorry: implicit mode is not supported with "
-              << "hierarchical packing." << endl;
-         exit(0);
-      }
-            
-      FindSoftSliceHierarchical(init_ar, width_limit, height_limit);
-
-      sst.pop_operand();
-      record_list_ptr->set_deadspace(
-         (*record_list_ptr)[0].minDeadspace
-         * SoftHierEngineType::HIER_DEADSPACE_INCRE);
-      init_totalArea = record_list_ptr->last().minArea;
-      width_limit *= SoftHierEngineType::HIER_WIDTH_INCRE;
-      height_limit *= SoftHierEngineType::HIER_HEIGHT_INCRE;
-   }
-}
-// --------------------------------------------------------
-void SoftHierEngineType::tuneAndPrintParameters() const
-{
-   // statistics about the blocks 
-   const int blockNum = _blockinfo.BLOCK_NUM();
-   const double blockArea = _blockinfo.block_area();
-
-   // statistics about the user specified instance
-   const double outline_area = Point::X_BOUND * Point::Y_BOUND;
-   const double outline_deadspace =
-      (outline_area >= Point::INFTY)
-      ? Point::INFTY : outline_area / blockArea - 1;
-   const double outline_AR =
-      (outline_area >= Point::INFTY)
-      ? Point::INFTY : sqrt(outline_area / blockArea);
-
-   // print the user specified instance
-   cout << "Instance Parameters: " << endl;
-   cout << "  - HIER_OUTLINE_AR: ";
-   if (outline_AR >= Point::INFTY)
-      cout << "inf (i.e. no aspect ratio constraint imposed.)" << endl;
-   else
-      cout << outline_AR << endl;
-   cout << "  - HIER_OUTLINE_DEADSPACE: ";
-   if (outline_deadspace >= Point::INFTY)
-      cout << "inf (i.e. no dead-space constraint imposed.)" << endl;
-   else
-      cout << (outline_deadspace * 100) << "%" << endl;
-   cout << endl;
-
-   // tune and print each tunable paramter
-   cout << "Performance Parameters: " << endl;   
-   if (!userSpecified("--HIER_CLUSTER_BASE"))
-   {
-      if (_instanceType == HARD_ONLY)
-      {
-         if (blockNum < 5000)
-            SoftHierEngineType::HIER_CLUSTER_BASE = 8;
-         else if (blockNum < 18000)
-            SoftHierEngineType::HIER_CLUSTER_BASE = 7;
-         else
-            SoftHierEngineType::HIER_CLUSTER_BASE = 6;
-      }
-      else
-      {
-         if (blockNum < 40)
-            SoftHierEngineType::HIER_CLUSTER_BASE = 6;
-         else if (blockNum < 90)
-            SoftHierEngineType::HIER_CLUSTER_BASE = 5;
-         else if (blockNum < 200)
-            SoftHierEngineType::HIER_CLUSTER_BASE = 4;
-         else
-            SoftHierEngineType::HIER_CLUSTER_BASE = 3;
-      }
-   }
-   printIntParameter("HIER_CLUSTER_BASE",
-                     SoftHierEngineType::HIER_CLUSTER_BASE);                    
-
-   if (!userSpecified("--HIER_CLUSTER_AREA_DEV"))
-   {
-      if (blockNum < 1000)
-         SoftHierEngineType::HIER_CLUSTER_AREA_DEV = 1.85;
-      else
-         SoftHierEngineType::HIER_CLUSTER_AREA_DEV = 1.95;
-   }  
-   printDoubleParameter("HIER_CLUSTER_AREA_DEV",
-                        SoftHierEngineType::HIER_CLUSTER_AREA_DEV);
-
-   printDoubleParameter("HIER_INIT_AR",
-                        SoftHierEngineType::HIER_AR);
-
-   if (!userSpecified("--HIER_USE_AR_LEVEL"))
-   {
-      if (blockNum < 5000)
-         SoftHierEngineType::HIER_USE_AR_LEVEL = 2;
-      else
-         SoftHierEngineType::HIER_USE_AR_LEVEL = -1;
-   }
-   if (SoftHierEngineType::HIER_USE_AR_LEVEL < 0)
-   {
-      printDoubleParameter("HIER_USE_AR_LEVEL",
-                           SoftHierEngineType::HIER_USE_AR_LEVEL,
-                           " (i.e. AR constraint not imposed at any level.)");
-   }
-   else
-   {
-      printDoubleParameter("HIER_USE_AR_LEVEL",
-                           SoftHierEngineType::HIER_USE_AR_LEVEL);
-   }
-  
-   printDoubleParameter("HIER_WIDTH_INCRE",
-                        SoftHierEngineType::HIER_WIDTH_INCRE);
-   
-   printDoubleParameter("HIER_HEIGHT_INCRE",
-                        SoftHierEngineType::HIER_HEIGHT_INCRE);
-   
-   printDoubleParameter("HIER_INIT_DEADSPACE",
-                        SoftHierEngineType::HIER_INIT_DEADSPACE);
-   
-   printDoubleParameter("HIER_DEADSPACE_INCRE",
-                        SoftHierEngineType::HIER_DEADSPACE_INCRE);
-   
-   printDoubleParameter("HIER_SIMILARITY_THRESHOLD",
-                        SoftHierEngineType::HIER_SIMILARITY_THRESHOLD);
-
-   cout << "  - compact? "
-        << (!userSpecified("--no_compact")? "Yes" : "No") << endl;
-   cout << endl;
-}   
-// --------------------------------------------------------
-void SoftHierEngineType::printIntParameter(string option,
-                                           int value,
-                                           string comments) const
-{
-   ostringstream sstream;
-   sstream << value;
-
-   printStringParameter(option, sstream.str(), comments);
-}
-
-void SoftHierEngineType::printDoubleParameter(string option,
-                                              double value,
-                                              string comments) const
-{
-   ostringstream sstream;
-
-   sstream.setf(ios::fixed);
-   sstream.precision(2);
-   sstream << value;
-
-   printStringParameter(option, sstream.str(), comments);
-}   
-
-void SoftHierEngineType::printStringParameter(string option,
-                                              string value,
-                                              string comments) const
-{
-   cout << "  - " << option << ": "
-        << value << " " << comments << " ";
-   if (!userSpecified("--" + option))
-   {
-      cout << " [tuned by CompaSS]" << endl;
-   }
-   else
-   {
-      cout << " [tuned by user] " << endl;
-   }
-}
-// --------------------------------------------------------
-
diff -druN BloBB_CompaSS_050315/CompaSS/enginehiersoftst.h blob_compass/CompaSS/enginehiersoftst.h
--- BloBB_CompaSS_050315/CompaSS/enginehiersoftst.h	2005-03-13 21:13:40.000000000 -0800
+++ blob_compass/CompaSS/enginehiersoftst.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,144 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef ENGINEHIERSOFTST_H
-#define ENGINEHIERSOFTST_H
-
-#include "datastrfrontsoftst.h"
-#include "datastrhiersoftst.h"
-
-#include <vector>
-#include <set>
-using namespace std;
-
-class SoftHierEngineType
-{
-public:
-   SoftHierEngineType(int instanceType,
-                      const BlockInfoType& blockinfo,
-                      const set<string> *const userDefinedOptions = NULL);
-
-   ~SoftHierEngineType();
-   
-   static int HIER_CLUSTER_BASE;
-   static double HIER_CLUSTER_AREA_DEV;
-   
-   static double HIER_AR;
-   static int HIER_USE_AR_LEVEL;
-   static bool HIER_USE_AR;
-   static double HIER_WIDTH_INCRE;
-   static double HIER_HEIGHT_INCRE;
-
-   static double HIER_INIT_DEADSPACE;
-   static double HIER_DEADSPACE_INCRE;
-
-   static double HIER_SIMILARITY_THRESHOLD;
-   
-   static const unsigned int HIER_SORT_VEC_MAX_SIZE = 300000;
-
-   enum {HARD_ONLY = 0, SOFT_ONLY, HARD_AND_SOFT};
-
-   SoftSliceRecord* operator ()(int format);
-
-private:
-   const int _instanceType;
-   
-   const BlockInfoType& _blockinfo;
-   vector<SoftCluster> clusters;
-   vector<SoftClusterSet> clusterSets;
-   int current_level;   
-
-   const set<string> *const _userDefinedOptions_cleaner;
-   const set<string>& _userDefinedOptions;
-   inline bool userSpecified(string option) const;
-   
-   class DistanceInfo;
-
-   void tuneAndPrintParameters() const;
-   void printIntParameter(string option,
-                          int value, string comments = "") const;
-   void printDoubleParameter(string option,
-                             double value, string comments = "") const;
-   void printStringParameter(string option,
-                             string value, string comments = "") const;
-   
-   void CoreEngine(int format);
-
-   void GroupClusterSets();
-   void BuildSortedVector(vector<DistanceInfo>& distInfoVec) const;
-   int getClusterSetNum(int clusterNum) const;
-   double getPoints(const SoftCluster& c1,
-                    const SoftCluster& c2) const;
-   double getMaxArea() const;   
-
-   class DistanceInfo
-   {
-   public:
-      DistanceInfo() {}
-
-      double points;
-      int blkOne;
-      int blkTwo;
-      inline bool operator <(const DistanceInfo& d2) const
-         {   return points < d2.points; }      
-   };
-};
-
-inline bool SoftHierEngineType::userSpecified(string option) const
-{
-   return (_userDefinedOptions.find(option)
-           != _userDefinedOptions.end());
-}
-// --------------------------------------------------------
-inline bool trivial_compare(const BoundaryType& b1,
-                            const BoundaryType& b2)
-{
-   return false;
-}
-// --------------------------------------------------------
-inline bool hard_blk_compare(const BoundaryType& b1,
-                             const BoundaryType& b2)
-{
-   double x1 = b1[1].xCoord();
-   double y1 = b1[1].yCoord();
-
-   double x2 = b2[1].xCoord();
-   double y2 = b2[1].yCoord();
-
-   return (pow((min(x1, x2) / max(x1, x2)), 2) +
-           pow((min(y1, y2) / max(y1, y2)), 2) >=
-           SoftHierEngineType::HIER_SIMILARITY_THRESHOLD);
-}
-// --------------------------------------------------------
-
-#endif
-   
-      
diff -druN BloBB_CompaSS_050315/CompaSS/enginesoftst.cxx blob_compass/CompaSS/enginesoftst.cxx
--- BloBB_CompaSS_050315/CompaSS/enginesoftst.cxx	2004-02-07 20:17:25.000000000 -0800
+++ blob_compass/CompaSS/enginesoftst.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,346 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "enginesoftst.h"
-#include "datastrbacksoftst.h"
-#include "datastrfrontsoftst.h"
-#include "boundsoftst.h"
-#include "debug.h"
-
-#include <queue>
-#include <float.h>
-#include <iomanip>
-#include <cmath>
-using namespace std;
-
-const double DEFAULT_OPT_INIT_DEADSPACE = 0.05;
-const double DEFAULT_OPT_DEADSPACE_INCRE = 1.1;
-
-double SoftEngineType::INIT_DEADSPACE = DEFAULT_OPT_INIT_DEADSPACE;
-double SoftEngineType::DEADSPACE_INCRE = DEFAULT_OPT_DEADSPACE_INCRE;
-// --------------------------------------------------------
-SoftEngineType::SoftEngineType(const BlockInfoType& new_blockinfo)
-   : sst(new_blockinfo),
-     blockinfo(new_blockinfo),
-     record_list_ptr(NULL),
-     compare(NULL),
-     operandProceed(NULL),
-     operatorProceed(NULL)
-{
-   int blocknum = new_blockinfo.BLOCK_NUM();
-
-   blkBefore.resize(blocknum);
-   same.resize(blocknum);
-   for (int i = 0; i < blocknum; i++)
-   {
-      blkBefore[i] = 0;
-      same[i].resize(blocknum);
-      for (int j = 0; j < i; j++)
-         if (blockinfo[j] == blockinfo[i])
-         {
-            same[i][j] = true;
-            same[j][i] = true;
-            blkBefore[i]++;
-         }
-         else
-         {
-            same[i][j] = false;
-            same[j][i] = false;
-         }
-      same[i][i] = true;
-   }
-   
-   cout << "simiarity table: " << endl;
-   for (int i = 0; i < blockinfo.BLOCK_NUM(); i++)
-   {
-      cout << setw(11) << ' ';
-      for (int j = 0; j < blockinfo.BLOCK_NUM(); j++)
-         cout << ((same[i][j])? "T " : "- ");
-      cout << endl;
-   }
-
-   cout << "blkBefore: ";
-   for (int i = 0; i < blockinfo.BLOCK_NUM(); i++)
-      cout << blkBefore[i] << " ";
-   cout << endl << endl;   
-}
-// --------------------------------------------------------
-SoftEngineType::SoftEngineType(const BlockInfoType& new_blockinfo,
-                               const BlockCompareType similar)
-   : sst(new_blockinfo),
-     blockinfo(new_blockinfo),
-     record_list_ptr(NULL),
-     compare(NULL),
-     operandProceed(NULL),
-     operatorProceed(NULL)
-{
-   int blocknum = new_blockinfo.BLOCK_NUM();
-
-   blkBefore.resize(blocknum);
-   same.resize(blocknum);
-   for (int i = 0; i < blocknum; i++)
-   {
-      blkBefore[i] = 0;
-      same[i].resize(blocknum);
-      for (int j = 0; j < i; j++)
-         if (similar(blockinfo[j], blockinfo[i]))
-         {
-            same[i][j] = true;
-            same[j][i] = true;
-            blkBefore[i]++;
-         }
-         else
-         {
-            same[i][j] = false;
-            same[j][i] = false;
-         }
-      same[i][i] = true;
-   }
-}
-// --------------------------------------------------------
-SoftSliceRecordList* SoftEngineType::operator ()(int algo,
-                                                 int mode)
-{
-   if (mode != SoftEngineType::EXPLICIT &&
-       mode != SoftEngineType::IMPLICIT)
-   {
-      cout << "ERROR: the requested mode is not available." << endl;
-      exit(0);
-   }
-   
-   switch (algo)
-   {
-   case BRUTE:
-      HandleBrute(mode);
-      break;
-
-   case B_BOUND:
-      HandleBranchBound(mode);
-      break;
-
-   case HIER:
-      HandleHierarchical(mode);
-      break;      
-
-   default:
-      cout << "ERROR: the requested algo is not available." << endl;
-      exit(0);
-      break;
-   }
-   
-   return record_list_ptr;
-}
-// --------------------------------------------------------
-void SoftEngineType::FindSoftSliceExplicit()
-{
-   int qSize = bCont.size();
-
-   if ((qSize == 0) && (sst.balance() == 1))
-   {
-      if (compare(sst, record_list_ptr->last()))
-      {
-         record_list_ptr->add_record(sst);
-
-         static int count = 0;
-         double area = record_list_ptr->last().minArea;
-         double deadspace = record_list_ptr->last().minDeadspace;
-         cout << "[" << count << "]: ";
-         for (int i = 0; i < sst.expression_size(); i++)
-            if (sst.expression(i) == SoftSTree::PLUS)
-               cout << "+ ";
-            else if (sst.expression(i) == SoftSTree::STAR)
-               cout << "* ";
-            else
-               cout << sst.expression(i) << " ";
-         cout.setf(ios::fixed);
-         cout.precision(2);
-         cout << " area: " << area;
-         cout << " (" << ((deadspace / (area-deadspace)) * 100) << "%)";
-         cout << " " << getTotalTime();
-         cout << " size: " << sst.buffer(0).boundary.size();
-         cout << endl;
-         count++;
-      }              
-      return;
-   }
-
-   for (int i = 0; i < qSize; i++)
-   {
-      int blk = bCont.front();
-      bCont.pop();
-
-      sst.push_operand(blk);
-
-      counter[sst.expression_size()][0]++;
-      counter[sst.expression_size()][1]++;
-      if (operandProceed(same, blkBefore, sst, record_list_ptr->last()))
-         FindSoftSliceExplicit();
-
-      sst.pop_operand();
-      bCont.push(blk);
-   }
-
-   for (int j = SoftSTree::PLUS; j >= SoftSTree::STAR; j--)
-      if (sst.can_push_operator(j))
-      {
-         sst.push_operator(j);
-
-         counter[sst.expression_size()][0]++;
-         counter[sst.expression_size()][3]++;
-         if (operatorProceed(sst, record_list_ptr->last()))
-            FindSoftSliceExplicit();
-
-         sst.pop_operator();
-      }         
-}
-// --------------------------------------------------------
-void SoftEngineType::FindSoftSliceImplicit()
-{
-   int qSize = bCont.size();
-   if ((qSize == 0) && (sst.balance() == 1))
-   {
-      if (compare(sst, record_list_ptr->last()))
-      {
-         record_list_ptr->add_record(sst);
-
-         static int count = 0;
-         double area = record_list_ptr->last().minArea;
-         double deadspace = record_list_ptr->last().minDeadspace;
-         cout << "[" << count << "]: ";
-         for (int i = 0; i < sst.expression_size(); i++)
-            if (sst.expression(i) == SoftSTree::PLUS)
-               cout << "+ ";
-            else if (sst.expression(i) == SoftSTree::STAR)
-               cout << "* ";
-            else if (sst.expression(i) == SoftSTree::BOTH)
-               cout << "- ";
-            else
-               cout << sst.expression(i) << " ";
-         cout.setf(ios::fixed);
-         cout.precision(2);
-         cout << " area: " << area;
-         cout << " (" << ((deadspace / (area-deadspace)) * 100) << "%)";
-         cout << " " << getTotalTime();
-         cout << " size: " << sst.buffer(0).boundary.size();
-         cout << endl;
-         count++;
-      }              
-      return;
-   }
-
-   for (int i = 0; i < qSize; i++)
-   {
-      int blk = bCont.front();
-      bCont.pop();
-
-      sst.push_operand(blk);
-
-      counter[sst.expression_size()][0]++;
-      counter[sst.expression_size()][1]++;
-      if (operandProceed(same, blkBefore, sst, record_list_ptr->last()))
-         FindSoftSliceImplicit();
-
-      sst.pop_operand();
-      bCont.push(blk);
-   }
-
-   if (sst.balance() > 1)
-   {
-      sst.push_operator(SoftSTree::BOTH);
-      
-      counter[sst.expression_size()][0]++;
-      counter[sst.expression_size()][4]++;
-      if (operatorProceed(sst, record_list_ptr->last()))
-         FindSoftSliceImplicit();
-
-      sst.pop_operator();
-   }
-}
-// --------------------------------------------------------
-void SoftEngineType::HandleBrute(int mode)
-{
-   for (int i = 1; i < blockinfo.BLOCK_NUM(); i++)
-         bCont.push(i);
-   
-   compare = BranchBoundCompare;
-   operandProceed = BruteProceed;
-   operatorProceed = BruteProceed;
-   record_list_ptr = new SoftSliceRecordList(DBL_MAX, DBL_MAX);
-
-   sst.push_operand(0);
-   if (mode == SoftEngineType::EXPLICIT)
-      FindSoftSliceExplicit();
-   else if (mode == SoftEngineType::IMPLICIT)
-      FindSoftSliceImplicit();        
-   sst.pop_operand();
-}      
-// --------------------------------------------------------
-void SoftEngineType::HandleBranchBound(int mode)
-{
-   double init_totalArea = -1;
-   double init_deadspace = -1;
-   
-   for (int i = 1; i < blockinfo.BLOCK_NUM(); i++)
-      bCont.push(i);
-      
-   compare = BranchBoundCompare;
-   operandProceed = BranchBoundProceed;
-
-   init_deadspace = sst.total_area() * INIT_DEADSPACE;
-   init_totalArea = sst.total_area() + init_deadspace;
-   record_list_ptr = new SoftSliceRecordList(init_totalArea, init_deadspace);
-
-   InitializeCounter();
-
-   while (record_list_ptr->empty())
-   {
-      cout << "Considering solutions with no more than "
-           << ((*record_list_ptr)[0].minDeadspace / sst.total_area()) * 100
-           << "% deadspace" << endl;
-      sst.push_operand(0);         
-      if (mode == SoftEngineType::EXPLICIT)
-      {
-         operatorProceed = BranchBoundExplicitProceed;
-         FindSoftSliceExplicit();
-      }
-      else if (mode == SoftEngineType::IMPLICIT)
-      {
-         operatorProceed = BranchBoundImplicitProceed;
-         FindSoftSliceImplicit();
-      }
-      sst.pop_operand();
-      record_list_ptr->set_deadspace((*record_list_ptr)[0].minDeadspace
-                                     * DEADSPACE_INCRE);
-   }
-
-   OutputCounter(cout, 5, 2*blockinfo.BLOCK_NUM());
-}
-// --------------------------------------------------------
diff -druN BloBB_CompaSS_050315/CompaSS/enginesoftst.h blob_compass/CompaSS/enginesoftst.h
--- BloBB_CompaSS_050315/CompaSS/enginesoftst.h	2004-02-07 20:15:18.000000000 -0800
+++ blob_compass/CompaSS/enginesoftst.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,92 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef ENGINESOFTST_H
-#define ENGINESOFTST_H
-
-#include "datastrbacksoftst.h"
-#include "datastrfrontsoftst.h"
-#include "boundsoftst.h"
-
-#include <queue>
-#include <vector>
-using namespace std;
-
-
-// --------------------------------------------------------
-typedef bool (*BlockCompareType)(const BoundaryType& b1,
-                                 const BoundaryType& b2);
-// --------------------------------------------------------
-class SoftEngineType
-{
-public:
-   SoftEngineType(const BlockInfoType& new_blockinfo);
-   SoftEngineType(const BlockInfoType& new_blockinfo,
-                  const BlockCompareType similar);
-
-   SoftSliceRecordList* operator ()(int algo, int mode);
-   enum AlgoType {B_BOUND, B_TRACK, ENUM, BRUTE, HIER};
-   enum ModeType {EXPLICIT, IMPLICIT};
-
-   static double INIT_DEADSPACE;
-   static double DEADSPACE_INCRE;
-   
-private:
-   SoftSTree sst;
-   queue<int> bCont;
-   BlockInfoType blockinfo;
-
-   vector< vector<bool> > same;
-   vector<int> blkBefore;
-   SoftSliceRecordList  *record_list_ptr;
-
-   SoftCompareType compare;
-   SoftOperandProceed operandProceed;
-   SoftOperatorProceed operatorProceed;
-
-   void FindSoftSliceExplicit();
-   void FindSoftSliceImplicit();
-   
-   void HandleBrute(int mode);
-   void HandleBranchBound(int mode);
-
-   // defined in enginehiersoftst.cpp 
-   void FindSoftSliceHierarchical(const double AR_LIMIT,
-                                  double width_limit,
-                                  double height_limit);
-   void HandleHierarchical(int mode); 
-
-   SoftEngineType(const SoftEngineType&);
-   void operator =(const SoftEngineType&);
-};
-// --------------------------------------------------------
-
-#endif
diff -druN BloBB_CompaSS_050315/CompaSS/expected_040510.out blob_compass/CompaSS/expected_040510.out
--- BloBB_CompaSS_050315/CompaSS/expected_040510.out	2004-07-04 22:52:33.000000000 -0700
+++ blob_compass/CompaSS/expected_040510.out	1969-12-31 16:00:00.000000000 -0800
@@ -1,557 +0,0 @@
------ Running source/TESTS/MCNCami33.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Parameters:
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-  - HIER_CLUSTER_BASE: 4
-  - HIER_CLUSTER_AREA_DEV: 1.85
-  - HIER_INIT_AR: 1.20
-  - HIER_USE_AR_LEVEL: 2
-  - HIER_WIDTH_INCRE: 1.15
-  - HIER_HEIGHT_INCRE: 1.15
-  - HIER_INIT_DEADSPACE: 0.05
-  - HIER_DEADSPACE_INCRE: 1.50
-  - HIER_SIMILARITY_THRESHOLD: 1.90
-  - compact? Yes
-
-[0]===== Grouping 33 clusters... 
-[0]===== Packing into 23 clusters... 
- * Aspect ratio bound used.
-
-blkArea:  1156449.00 deadspace:    24255.00 (2.10%) time: 0.01
-
-[1]===== Grouping 23 clusters... 
-[1]===== Packing into 16 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  1156449.00 deadspace:    28224.00 (2.44%) time: 0.01
-
-[2]===== Grouping 16 clusters... 
-[2]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 4 time: 0.01
-finished 2 / 4. cluster size: 2 time: 0.01
-finished 3 / 4. cluster size: 5 time: 0.01
-finished 4 / 4. cluster size: 5 time: 0.01
-
-blkArea:  1156449.00 deadspace:    80017.00 (6.92%) time: 0.01
-
-[3]===== Grouping 4 clusters... 
-[3]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  1156449.00 deadspace:   220402.00 (19.06%) time: 0.01
-
-total area:  1376851.00
-block area:  1156449.00
-deadspace:    220402.00
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea:  1156449.00 deadspace:   133231.00 (11.52%) time: 0.01
-
-width:  658.00
-height: 1960.00
-total area:  1289680.00
-block area:  1156449.00
-dead space:   133231.00 (11.52%)
-
-area usage   (wrt. total area): 89.67%
-dead space % (wrt. total area): 10.33%
----------------------------
-
-Compacting...
-converted to B*-Tree: 1289680.00 (11.52%) -> 1289680.00 (11.52%)
-round 0:      4 blks changed: 1289680.00 (11.52%) -> 1289680.00 (11.52%)
-round 1:      0 blks changed: 1289680.00 (11.52%) -> 1289680.00 (11.52%)
-
-After compaction, 
-blkArea:  1156449.00 deadspace:   133231.00 (11.52%)
-
-width:  658.00
-height: 1960.00
-total area:  1289680.00
-block area:  1156449.00
-dead space:   133231.00 (11.52%)
-
-area usage   (wrt. total area): 89.67%
-dead space % (wrt. total area): 10.33%
----------------------------
-
-Output successfully written to dummy_output
-
-===== Thanks for using CompaSS =====
------ Running source/TESTS/MCNCami49_10.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Parameters:
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-  - HIER_CLUSTER_BASE: 4
-  - HIER_CLUSTER_AREA_DEV: 1.85
-  - HIER_INIT_AR: 1.20
-  - HIER_USE_AR_LEVEL: 2
-  - HIER_WIDTH_INCRE: 1.15
-  - HIER_HEIGHT_INCRE: 1.15
-  - HIER_INIT_DEADSPACE: 0.05
-  - HIER_DEADSPACE_INCRE: 1.50
-  - HIER_SIMILARITY_THRESHOLD: 1.90
-  - compact? Yes
-
-[0]===== Grouping 490 clusters... 
-[0]===== Packing into 257 clusters... 
- * Aspect ratio bound used.
-
-blkArea:  3544542.40 deadspace:     4394.32 (0.12%) time: 0.10
-
-[1]===== Grouping 257 clusters... 
-[1]===== Packing into 256 clusters... 
- * Aspect ratio bound used.
-
-blkArea:  3544542.40 deadspace:     4394.32 (0.12%) time: 0.12
-
-[2]===== Grouping 256 clusters... 
-[2]===== Packing into 152 clusters... 
- * Aspect ratio bound used.
-
-blkArea:  3544542.40 deadspace:    16471.84 (0.46%) time: 0.15
-
-[3]===== Grouping 152 clusters... 
-[3]===== Packing into 104 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:    25213.44 (0.71%) time: 0.16
-
-[4]===== Grouping 104 clusters... 
-[4]===== Packing into 77 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:    39695.88 (1.12%) time: 0.16
-
-[5]===== Grouping 77 clusters... 
-[5]===== Packing into 64 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:    45446.52 (1.28%) time: 0.17
-
-[6]===== Grouping 64 clusters... 
-[6]===== Packing into 46 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:    68427.52 (1.93%) time: 0.17
-
-[7]===== Grouping 46 clusters... 
-[7]===== Packing into 35 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:    82447.40 (2.33%) time: 0.18
-
-[8]===== Grouping 35 clusters... 
-[8]===== Packing into 27 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:   109030.88 (3.08%) time: 0.18
-
-[9]===== Grouping 27 clusters... 
-[9]===== Packing into 19 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:   114236.64 (3.22%) time: 0.18
-
-[10]===== Grouping 19 clusters... 
-[10]===== Packing into 16 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:   127204.00 (3.59%) time: 0.18
-
-[11]===== Grouping 16 clusters... 
-[11]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 5 time: 0.23
-finished 2 / 4. cluster size: 5 time: 0.29
-finished 3 / 4. cluster size: 1 time: 0.29
-finished 4 / 4. cluster size: 5 time: 0.29
-
-blkArea:  3544542.40 deadspace:   204218.28 (5.76%) time: 0.29
-
-[12]===== Grouping 4 clusters... 
-[12]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:   261201.36 (7.37%) time: 0.31
-
-total area:  3805743.76
-block area:  3544542.40
-deadspace:    261201.36
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea:  3544542.40 deadspace:   187987.52 (5.30%) time: 0.33
-
-width:  1394.40
-height: 2676.80
-total area:  3732529.92
-block area:  3544542.40
-dead space:   187987.52 (5.30%)
-
-area usage   (wrt. total area): 94.96%
-dead space % (wrt. total area): 5.04%
----------------------------
-
-Compacting...
-converted to B*-Tree: 3732529.92 (5.30%) -> 3714960.48 (4.81%)
-round 0:    276 blks changed: 3714960.48 (4.81%) -> 3707500.72 (4.60%)
-round 1:     17 blks changed: 3707500.72 (4.60%) -> 3707500.72 (4.60%)
-round 2:      0 blks changed: 3707500.72 (4.60%) -> 3707500.72 (4.60%)
-
-After compaction, 
-blkArea:  3544542.40 deadspace:   162958.32 (4.60%)
-
-width:  1391.60
-height: 2664.20
-total area:  3707500.72
-block area:  3544542.40
-dead space:   162958.32 (4.60%)
-
-area usage   (wrt. total area): 95.60%
-dead space % (wrt. total area): 4.40%
----------------------------
-
-Output successfully written to dummy_output
-
-===== Thanks for using CompaSS =====
------ Running source/TESTS/MCNCami49.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Parameters:
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-  - HIER_CLUSTER_BASE: 4
-  - HIER_CLUSTER_AREA_DEV: 1.85
-  - HIER_INIT_AR: 1.20
-  - HIER_USE_AR_LEVEL: 2
-  - HIER_WIDTH_INCRE: 1.15
-  - HIER_HEIGHT_INCRE: 1.15
-  - HIER_INIT_DEADSPACE: 0.05
-  - HIER_DEADSPACE_INCRE: 1.50
-  - HIER_SIMILARITY_THRESHOLD: 1.90
-  - compact? Yes
-
-[0]===== Grouping 49 clusters... 
-[0]===== Packing into 22 clusters... 
- * Aspect ratio bound used.
-
-blkArea: 35445424.00 deadspace:   673260.00 (1.90%) time: 0.01
-
-[1]===== Grouping 22 clusters... 
-[1]===== Packing into 16 clusters... 
- * Aspect ratio bound not used.
-
-blkArea: 35445424.00 deadspace:   824376.00 (2.33%) time: 0.01
-
-[2]===== Grouping 16 clusters... 
-[2]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 5 time: 0.01
-finished 2 / 4. cluster size: 3 time: 0.01
-finished 3 / 4. cluster size: 4 time: 0.01
-finished 4 / 4. cluster size: 4 time: 0.01
-
-blkArea: 35445424.00 deadspace:  2954112.00 (8.33%) time: 0.01
-
-[3]===== Grouping 4 clusters... 
-[3]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea: 35445424.00 deadspace:  4002908.00 (11.29%) time: 0.02
-
-total area: 39448332.00
-block area: 35445424.00
-deadspace:   4002908.00
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea: 35445424.00 deadspace:  3365712.00 (9.50%) time: 0.02
-
-width:  3808.00
-height: 10192.00
-total area: 38811136.00
-block area: 35445424.00
-dead space:  3365712.00 (9.50%)
-
-area usage   (wrt. total area): 91.33%
-dead space % (wrt. total area): 8.67%
----------------------------
-
-Compacting...
-converted to B*-Tree: 38811136.00 (9.50%) -> 38704512.00 (9.19%)
-round 0:     10 blks changed: 38704512.00 (9.19%) -> 38704512.00 (9.19%)
-round 1:      0 blks changed: 38704512.00 (9.19%) -> 38704512.00 (9.19%)
-
-After compaction, 
-blkArea: 35445424.00 deadspace:  3259088.00 (9.19%)
-
-width:  3808.00
-height: 10164.00
-total area: 38704512.00
-block area: 35445424.00
-dead space:  3259088.00 (9.19%)
-
-area usage   (wrt. total area): 91.58%
-dead space % (wrt. total area): 8.42%
----------------------------
-
-Output successfully written to dummy_output
-
-===== Thanks for using CompaSS =====
------ Running source/TESTS/MCNCapte.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Parameters:
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-  - HIER_CLUSTER_BASE: 4
-  - HIER_CLUSTER_AREA_DEV: 1.85
-  - HIER_INIT_AR: 1.20
-  - HIER_USE_AR_LEVEL: 2
-  - HIER_WIDTH_INCRE: 1.15
-  - HIER_HEIGHT_INCRE: 1.15
-  - HIER_INIT_DEADSPACE: 0.05
-  - HIER_DEADSPACE_INCRE: 1.50
-  - HIER_SIMILARITY_THRESHOLD: 1.90
-  - compact? Yes
-
-[0]===== Grouping 9 clusters... 
-[0]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 1 time: 0.01
-finished 2 / 4. cluster size: 3 time: 0.01
-finished 3 / 4. cluster size: 1 time: 0.01
-finished 4 / 4. cluster size: 4 time: 0.01
-
-blkArea: 46561628.00 deadspace:        0.00 (0.00%) time: 0.01
-
-[1]===== Grouping 4 clusters... 
-[1]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea: 46561628.00 deadspace:  3178612.00 (6.83%) time: 0.01
-
-total area: 49740240.00
-block area: 46561628.00
-deadspace:   3178612.00
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea: 46561628.00 deadspace:   363220.00 (0.78%) time: 0.01
-
-width:  1832.00
-height: 25614.00
-total area: 46924848.00
-block area: 46561628.00
-dead space:   363220.00 (0.78%)
-
-area usage   (wrt. total area): 99.23%
-dead space % (wrt. total area): 0.77%
----------------------------
-
-Compacting...
-converted to B*-Tree: 46924848.00 (0.78%) -> 46924848.00 (0.78%)
-round 0:      0 blks changed: 46924848.00 (0.78%) -> 46924848.00 (0.78%)
-
-After compaction, 
-blkArea: 46561628.00 deadspace:   363220.00 (0.78%)
-
-width:  1832.00
-height: 25614.00
-total area: 46924848.00
-block area: 46561628.00
-dead space:   363220.00 (0.78%)
-
-area usage   (wrt. total area): 99.23%
-dead space % (wrt. total area): 0.77%
----------------------------
-
-Output successfully written to dummy_output
-
-===== Thanks for using CompaSS =====
------ Running source/TESTS/MCNChp.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Parameters:
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-  - HIER_CLUSTER_BASE: 4
-  - HIER_CLUSTER_AREA_DEV: 1.85
-  - HIER_INIT_AR: 1.20
-  - HIER_USE_AR_LEVEL: 2
-  - HIER_WIDTH_INCRE: 1.15
-  - HIER_HEIGHT_INCRE: 1.15
-  - HIER_INIT_DEADSPACE: 0.05
-  - HIER_DEADSPACE_INCRE: 1.50
-  - HIER_SIMILARITY_THRESHOLD: 1.90
-  - compact? Yes
-
-[0]===== Grouping 11 clusters... 
-[0]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 3 time: 0.00
-finished 2 / 4. cluster size: 1 time: 0.00
-finished 3 / 4. cluster size: 5 time: 0.00
-finished 4 / 4. cluster size: 2 time: 0.00
-
-blkArea:  8830584.00 deadspace:   321048.00 (3.64%) time: 0.00
-
-[1]===== Grouping 4 clusters... 
-[1]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  8830584.00 deadspace:   712656.00 (8.07%) time: 0.00
-
-total area:  9543240.00
-block area:  8830584.00
-deadspace:    712656.00
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea:  8830584.00 deadspace:   712656.00 (8.07%) time: 0.00
-
-width:  1260.00
-height: 7574.00
-total area:  9543240.00
-block area:  8830584.00
-dead space:   712656.00 (8.07%)
-
-area usage   (wrt. total area): 92.53%
-dead space % (wrt. total area): 7.47%
----------------------------
-
-Compacting...
-converted to B*-Tree: 9543240.00 (8.07%) -> 9543240.00 (8.07%)
-round 0:      2 blks changed: 9543240.00 (8.07%) -> 9543240.00 (8.07%)
-round 1:      0 blks changed: 9543240.00 (8.07%) -> 9543240.00 (8.07%)
-
-After compaction, 
-blkArea:  8830584.00 deadspace:   712656.00 (8.07%)
-
-width:  1260.00
-height: 7574.00
-total area:  9543240.00
-block area:  8830584.00
-dead space:   712656.00 (8.07%)
-
-area usage   (wrt. total area): 92.53%
-dead space % (wrt. total area): 7.47%
----------------------------
-
-Output successfully written to dummy_output
-
-===== Thanks for using CompaSS =====
------ Running source/TESTS/MCNCxerox.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Parameters:
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-  - HIER_CLUSTER_BASE: 4
-  - HIER_CLUSTER_AREA_DEV: 1.85
-  - HIER_INIT_AR: 1.20
-  - HIER_USE_AR_LEVEL: 2
-  - HIER_WIDTH_INCRE: 1.15
-  - HIER_HEIGHT_INCRE: 1.15
-  - HIER_INIT_DEADSPACE: 0.05
-  - HIER_DEADSPACE_INCRE: 1.50
-  - HIER_SIMILARITY_THRESHOLD: 1.90
-  - compact? Yes
-
-[0]===== Grouping 10 clusters... 
-[0]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 3 time: 0.00
-finished 2 / 4. cluster size: 1 time: 0.00
-finished 3 / 4. cluster size: 1 time: 0.00
-finished 4 / 4. cluster size: 5 time: 0.00
-
-blkArea: 19350296.00 deadspace:   281113.00 (1.45%) time: 0.00
-
-[1]===== Grouping 4 clusters... 
-[1]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea: 19350296.00 deadspace:  1035860.00 (5.35%) time: 0.01
-
-total area: 20386156.00
-block area: 19350296.00
-deadspace:   1035860.00
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea: 19350296.00 deadspace:  1035860.00 (5.35%) time: 0.01
-
-width:  1316.00
-height: 15491.00
-total area: 20386156.00
-block area: 19350296.00
-dead space:  1035860.00 (5.35%)
-
-area usage   (wrt. total area): 94.92%
-dead space % (wrt. total area): 5.08%
----------------------------
-
-Compacting...
-converted to B*-Tree: 20386156.00 (5.35%) -> 20386156.00 (5.35%)
-round 0:      0 blks changed: 20386156.00 (5.35%) -> 20386156.00 (5.35%)
-
-After compaction, 
-blkArea: 19350296.00 deadspace:  1035860.00 (5.35%)
-
-width:  1316.00
-height: 15491.00
-total area: 20386156.00
-block area: 19350296.00
-dead space:  1035860.00 (5.35%)
-
-area usage   (wrt. total area): 94.92%
-dead space % (wrt. total area): 5.08%
----------------------------
-
-Output successfully written to dummy_output
-
-===== Thanks for using CompaSS =====
diff -druN BloBB_CompaSS_050315/CompaSS/expected_050313.out blob_compass/CompaSS/expected_050313.out
--- BloBB_CompaSS_050315/CompaSS/expected_050313.out	2005-03-13 15:11:16.000000000 -0800
+++ blob_compass/CompaSS/expected_050313.out	1969-12-31 16:00:00.000000000 -0800
@@ -1,557 +0,0 @@
------ Running ../TESTS/MCNCami33.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Parameters:
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-  - HIER_CLUSTER_BASE: 4
-  - HIER_CLUSTER_AREA_DEV: 1.85
-  - HIER_INIT_AR: 1.20
-  - HIER_USE_AR_LEVEL: 2
-  - HIER_WIDTH_INCRE: 1.15
-  - HIER_HEIGHT_INCRE: 1.15
-  - HIER_INIT_DEADSPACE: 0.05
-  - HIER_DEADSPACE_INCRE: 1.50
-  - HIER_SIMILARITY_THRESHOLD: 1.90
-  - compact? Yes
-
-[0]===== Grouping 33 clusters... 
-[0]===== Packing into 23 clusters... 
- * Aspect ratio bound used.
-
-blkArea:  1156449.00 deadspace:    24255.00 (2.10%) time: 0.00
-
-[1]===== Grouping 23 clusters... 
-[1]===== Packing into 16 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  1156449.00 deadspace:    28224.00 (2.44%) time: 0.00
-
-[2]===== Grouping 16 clusters... 
-[2]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 4 time: 0.01
-finished 2 / 4. cluster size: 2 time: 0.01
-finished 3 / 4. cluster size: 5 time: 0.01
-finished 4 / 4. cluster size: 5 time: 0.01
-
-blkArea:  1156449.00 deadspace:    80017.00 (6.92%) time: 0.01
-
-[3]===== Grouping 4 clusters... 
-[3]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  1156449.00 deadspace:   220402.00 (19.06%) time: 0.01
-
-total area:  1376851.00
-block area:  1156449.00
-deadspace:    220402.00
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea:  1156449.00 deadspace:   133231.00 (11.52%) time: 0.01
-
-width:  658.00
-height: 1960.00
-total area:  1289680.00
-block area:  1156449.00
-dead space:   133231.00 (11.52%)
-
-area usage   (wrt. total area): 89.67%
-dead space % (wrt. total area): 10.33%
----------------------------
-
-Compacting...
-converted to B*-Tree: 1289680.00 (11.52%) -> 1289680.00 (11.52%)
-round 0:      4 blks changed: 1289680.00 (11.52%) -> 1289680.00 (11.52%)
-round 1:      0 blks changed: 1289680.00 (11.52%) -> 1289680.00 (11.52%)
-
-After compaction, 
-blkArea:  1156449.00 deadspace:   133231.00 (11.52%)
-
-width:  658.00
-height: 1960.00
-total area:  1289680.00
-block area:  1156449.00
-dead space:   133231.00 (11.52%)
-
-area usage   (wrt. total area): 89.67%
-dead space % (wrt. total area): 10.33%
----------------------------
-
-Output successfully written to dummy_output
-
-===== Thanks for using CompaSS =====
------ Running ../TESTS/MCNCami49_10.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Parameters:
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-  - HIER_CLUSTER_BASE: 4
-  - HIER_CLUSTER_AREA_DEV: 1.85
-  - HIER_INIT_AR: 1.20
-  - HIER_USE_AR_LEVEL: 2
-  - HIER_WIDTH_INCRE: 1.15
-  - HIER_HEIGHT_INCRE: 1.15
-  - HIER_INIT_DEADSPACE: 0.05
-  - HIER_DEADSPACE_INCRE: 1.50
-  - HIER_SIMILARITY_THRESHOLD: 1.90
-  - compact? Yes
-
-[0]===== Grouping 490 clusters... 
-[0]===== Packing into 257 clusters... 
- * Aspect ratio bound used.
-
-blkArea:  3544542.40 deadspace:     4394.32 (0.12%) time: 0.08
-
-[1]===== Grouping 257 clusters... 
-[1]===== Packing into 256 clusters... 
- * Aspect ratio bound used.
-
-blkArea:  3544542.40 deadspace:     4394.32 (0.12%) time: 0.10
-
-[2]===== Grouping 256 clusters... 
-[2]===== Packing into 152 clusters... 
- * Aspect ratio bound used.
-
-blkArea:  3544542.40 deadspace:    16471.84 (0.46%) time: 0.12
-
-[3]===== Grouping 152 clusters... 
-[3]===== Packing into 104 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:    25213.44 (0.71%) time: 0.13
-
-[4]===== Grouping 104 clusters... 
-[4]===== Packing into 77 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:    39695.88 (1.12%) time: 0.14
-
-[5]===== Grouping 77 clusters... 
-[5]===== Packing into 64 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:    45446.52 (1.28%) time: 0.14
-
-[6]===== Grouping 64 clusters... 
-[6]===== Packing into 46 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:    68427.52 (1.93%) time: 0.15
-
-[7]===== Grouping 46 clusters... 
-[7]===== Packing into 35 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:    82447.40 (2.33%) time: 0.15
-
-[8]===== Grouping 35 clusters... 
-[8]===== Packing into 27 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:   109030.88 (3.08%) time: 0.15
-
-[9]===== Grouping 27 clusters... 
-[9]===== Packing into 19 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:   114236.64 (3.22%) time: 0.15
-
-[10]===== Grouping 19 clusters... 
-[10]===== Packing into 16 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:   127204.00 (3.59%) time: 0.15
-
-[11]===== Grouping 16 clusters... 
-[11]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 5 time: 0.21
-finished 2 / 4. cluster size: 5 time: 0.30
-finished 3 / 4. cluster size: 1 time: 0.30
-finished 4 / 4. cluster size: 5 time: 0.30
-
-blkArea:  3544542.40 deadspace:   204218.28 (5.76%) time: 0.30
-
-[12]===== Grouping 4 clusters... 
-[12]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:   261201.36 (7.37%) time: 0.32
-
-total area:  3805743.76
-block area:  3544542.40
-deadspace:    261201.36
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea:  3544542.40 deadspace:   187987.52 (5.30%) time: 0.34
-
-width:  1394.40
-height: 2676.80
-total area:  3732529.92
-block area:  3544542.40
-dead space:   187987.52 (5.30%)
-
-area usage   (wrt. total area): 94.96%
-dead space % (wrt. total area): 5.04%
----------------------------
-
-Compacting...
-converted to B*-Tree: 3732529.92 (5.30%) -> 3714960.48 (4.81%)
-round 0:    276 blks changed: 3714960.48 (4.81%) -> 3707500.72 (4.60%)
-round 1:     17 blks changed: 3707500.72 (4.60%) -> 3707500.72 (4.60%)
-round 2:      0 blks changed: 3707500.72 (4.60%) -> 3707500.72 (4.60%)
-
-After compaction, 
-blkArea:  3544542.40 deadspace:   162958.32 (4.60%)
-
-width:  1391.60
-height: 2664.20
-total area:  3707500.72
-block area:  3544542.40
-dead space:   162958.32 (4.60%)
-
-area usage   (wrt. total area): 95.60%
-dead space % (wrt. total area): 4.40%
----------------------------
-
-Output successfully written to dummy_output
-
-===== Thanks for using CompaSS =====
------ Running ../TESTS/MCNCami49.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Parameters:
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-  - HIER_CLUSTER_BASE: 4
-  - HIER_CLUSTER_AREA_DEV: 1.85
-  - HIER_INIT_AR: 1.20
-  - HIER_USE_AR_LEVEL: 2
-  - HIER_WIDTH_INCRE: 1.15
-  - HIER_HEIGHT_INCRE: 1.15
-  - HIER_INIT_DEADSPACE: 0.05
-  - HIER_DEADSPACE_INCRE: 1.50
-  - HIER_SIMILARITY_THRESHOLD: 1.90
-  - compact? Yes
-
-[0]===== Grouping 49 clusters... 
-[0]===== Packing into 22 clusters... 
- * Aspect ratio bound used.
-
-blkArea: 35445424.00 deadspace:   673260.00 (1.90%) time: 0.01
-
-[1]===== Grouping 22 clusters... 
-[1]===== Packing into 16 clusters... 
- * Aspect ratio bound not used.
-
-blkArea: 35445424.00 deadspace:   824376.00 (2.33%) time: 0.01
-
-[2]===== Grouping 16 clusters... 
-[2]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 5 time: 0.02
-finished 2 / 4. cluster size: 3 time: 0.02
-finished 3 / 4. cluster size: 4 time: 0.02
-finished 4 / 4. cluster size: 4 time: 0.02
-
-blkArea: 35445424.00 deadspace:  2954112.00 (8.33%) time: 0.02
-
-[3]===== Grouping 4 clusters... 
-[3]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea: 35445424.00 deadspace:  4002908.00 (11.29%) time: 0.02
-
-total area: 39448332.00
-block area: 35445424.00
-deadspace:   4002908.00
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea: 35445424.00 deadspace:  3365712.00 (9.50%) time: 0.02
-
-width:  3808.00
-height: 10192.00
-total area: 38811136.00
-block area: 35445424.00
-dead space:  3365712.00 (9.50%)
-
-area usage   (wrt. total area): 91.33%
-dead space % (wrt. total area): 8.67%
----------------------------
-
-Compacting...
-converted to B*-Tree: 38811136.00 (9.50%) -> 38704512.00 (9.19%)
-round 0:     10 blks changed: 38704512.00 (9.19%) -> 38704512.00 (9.19%)
-round 1:      0 blks changed: 38704512.00 (9.19%) -> 38704512.00 (9.19%)
-
-After compaction, 
-blkArea: 35445424.00 deadspace:  3259088.00 (9.19%)
-
-width:  3808.00
-height: 10164.00
-total area: 38704512.00
-block area: 35445424.00
-dead space:  3259088.00 (9.19%)
-
-area usage   (wrt. total area): 91.58%
-dead space % (wrt. total area): 8.42%
----------------------------
-
-Output successfully written to dummy_output
-
-===== Thanks for using CompaSS =====
------ Running ../TESTS/MCNCapte.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Parameters:
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-  - HIER_CLUSTER_BASE: 4
-  - HIER_CLUSTER_AREA_DEV: 1.85
-  - HIER_INIT_AR: 1.20
-  - HIER_USE_AR_LEVEL: 2
-  - HIER_WIDTH_INCRE: 1.15
-  - HIER_HEIGHT_INCRE: 1.15
-  - HIER_INIT_DEADSPACE: 0.05
-  - HIER_DEADSPACE_INCRE: 1.50
-  - HIER_SIMILARITY_THRESHOLD: 1.90
-  - compact? Yes
-
-[0]===== Grouping 9 clusters... 
-[0]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 1 time: 0.00
-finished 2 / 4. cluster size: 3 time: 0.00
-finished 3 / 4. cluster size: 1 time: 0.00
-finished 4 / 4. cluster size: 4 time: 0.00
-
-blkArea: 46561628.00 deadspace:        0.00 (0.00%) time: 0.00
-
-[1]===== Grouping 4 clusters... 
-[1]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea: 46561628.00 deadspace:  3178612.00 (6.83%) time: 0.00
-
-total area: 49740240.00
-block area: 46561628.00
-deadspace:   3178612.00
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea: 46561628.00 deadspace:   363220.00 (0.78%) time: 0.01
-
-width:  1832.00
-height: 25614.00
-total area: 46924848.00
-block area: 46561628.00
-dead space:   363220.00 (0.78%)
-
-area usage   (wrt. total area): 99.23%
-dead space % (wrt. total area): 0.77%
----------------------------
-
-Compacting...
-converted to B*-Tree: 46924848.00 (0.78%) -> 46924848.00 (0.78%)
-round 0:      0 blks changed: 46924848.00 (0.78%) -> 46924848.00 (0.78%)
-
-After compaction, 
-blkArea: 46561628.00 deadspace:   363220.00 (0.78%)
-
-width:  1832.00
-height: 25614.00
-total area: 46924848.00
-block area: 46561628.00
-dead space:   363220.00 (0.78%)
-
-area usage   (wrt. total area): 99.23%
-dead space % (wrt. total area): 0.77%
----------------------------
-
-Output successfully written to dummy_output
-
-===== Thanks for using CompaSS =====
------ Running ../TESTS/MCNChp.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Parameters:
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-  - HIER_CLUSTER_BASE: 4
-  - HIER_CLUSTER_AREA_DEV: 1.85
-  - HIER_INIT_AR: 1.20
-  - HIER_USE_AR_LEVEL: 2
-  - HIER_WIDTH_INCRE: 1.15
-  - HIER_HEIGHT_INCRE: 1.15
-  - HIER_INIT_DEADSPACE: 0.05
-  - HIER_DEADSPACE_INCRE: 1.50
-  - HIER_SIMILARITY_THRESHOLD: 1.90
-  - compact? Yes
-
-[0]===== Grouping 11 clusters... 
-[0]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 3 time: 0.00
-finished 2 / 4. cluster size: 1 time: 0.00
-finished 3 / 4. cluster size: 5 time: 0.01
-finished 4 / 4. cluster size: 2 time: 0.01
-
-blkArea:  8830584.00 deadspace:   321048.00 (3.64%) time: 0.01
-
-[1]===== Grouping 4 clusters... 
-[1]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  8830584.00 deadspace:   712656.00 (8.07%) time: 0.01
-
-total area:  9543240.00
-block area:  8830584.00
-deadspace:    712656.00
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea:  8830584.00 deadspace:   712656.00 (8.07%) time: 0.01
-
-width:  1260.00
-height: 7574.00
-total area:  9543240.00
-block area:  8830584.00
-dead space:   712656.00 (8.07%)
-
-area usage   (wrt. total area): 92.53%
-dead space % (wrt. total area): 7.47%
----------------------------
-
-Compacting...
-converted to B*-Tree: 9543240.00 (8.07%) -> 9543240.00 (8.07%)
-round 0:      2 blks changed: 9543240.00 (8.07%) -> 9543240.00 (8.07%)
-round 1:      0 blks changed: 9543240.00 (8.07%) -> 9543240.00 (8.07%)
-
-After compaction, 
-blkArea:  8830584.00 deadspace:   712656.00 (8.07%)
-
-width:  1260.00
-height: 7574.00
-total area:  9543240.00
-block area:  8830584.00
-dead space:   712656.00 (8.07%)
-
-area usage   (wrt. total area): 92.53%
-dead space % (wrt. total area): 7.47%
----------------------------
-
-Output successfully written to dummy_output
-
-===== Thanks for using CompaSS =====
------ Running ../TESTS/MCNCxerox.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Parameters:
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-  - HIER_CLUSTER_BASE: 4
-  - HIER_CLUSTER_AREA_DEV: 1.85
-  - HIER_INIT_AR: 1.20
-  - HIER_USE_AR_LEVEL: 2
-  - HIER_WIDTH_INCRE: 1.15
-  - HIER_HEIGHT_INCRE: 1.15
-  - HIER_INIT_DEADSPACE: 0.05
-  - HIER_DEADSPACE_INCRE: 1.50
-  - HIER_SIMILARITY_THRESHOLD: 1.90
-  - compact? Yes
-
-[0]===== Grouping 10 clusters... 
-[0]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 3 time: 0.00
-finished 2 / 4. cluster size: 1 time: 0.00
-finished 3 / 4. cluster size: 1 time: 0.00
-finished 4 / 4. cluster size: 5 time: 0.00
-
-blkArea: 19350296.00 deadspace:   281113.00 (1.45%) time: 0.00
-
-[1]===== Grouping 4 clusters... 
-[1]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea: 19350296.00 deadspace:  1035860.00 (5.35%) time: 0.00
-
-total area: 20386156.00
-block area: 19350296.00
-deadspace:   1035860.00
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea: 19350296.00 deadspace:  1035860.00 (5.35%) time: 0.00
-
-width:  1316.00
-height: 15491.00
-total area: 20386156.00
-block area: 19350296.00
-dead space:  1035860.00 (5.35%)
-
-area usage   (wrt. total area): 94.92%
-dead space % (wrt. total area): 5.08%
----------------------------
-
-Compacting...
-converted to B*-Tree: 20386156.00 (5.35%) -> 20386156.00 (5.35%)
-round 0:      0 blks changed: 20386156.00 (5.35%) -> 20386156.00 (5.35%)
-
-After compaction, 
-blkArea: 19350296.00 deadspace:  1035860.00 (5.35%)
-
-width:  1316.00
-height: 15491.00
-total area: 20386156.00
-block area: 19350296.00
-dead space:  1035860.00 (5.35%)
-
-area usage   (wrt. total area): 94.92%
-dead space % (wrt. total area): 5.08%
----------------------------
-
-Output successfully written to dummy_output
-
-===== Thanks for using CompaSS =====
diff -druN BloBB_CompaSS_050315/CompaSS/expected_050315.out blob_compass/CompaSS/expected_050315.out
--- BloBB_CompaSS_050315/CompaSS/expected_050315.out	2005-03-14 22:24:33.000000000 -0800
+++ blob_compass/CompaSS/expected_050315.out	1969-12-31 16:00:00.000000000 -0800
@@ -1,575 +0,0 @@
------ Running ../TESTS/MCNCami33.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Instance Parameters: 
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-
-Performance Parameters: 
-  - HIER_CLUSTER_BASE: 4   [tuned by user] 
-  - HIER_CLUSTER_AREA_DEV: 1.85   [tuned by CompaSS]
-  - HIER_INIT_AR: 1.20   [tuned by CompaSS]
-  - HIER_USE_AR_LEVEL: 2.00   [tuned by CompaSS]
-  - HIER_WIDTH_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_HEIGHT_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_INIT_DEADSPACE: 0.05   [tuned by CompaSS]
-  - HIER_DEADSPACE_INCRE: 1.50   [tuned by CompaSS]
-  - HIER_SIMILARITY_THRESHOLD: 1.90   [tuned by CompaSS]
-  - compact? Yes
-
-[0]===== Grouping 33 clusters... 
-[0]===== Packing into 23 clusters... 
- * Aspect ratio bound used.
-
-blkArea:  1156449.00 deadspace:    24255.00 (2.10%) time: 0.00
-
-[1]===== Grouping 23 clusters... 
-[1]===== Packing into 16 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  1156449.00 deadspace:    28224.00 (2.44%) time: 0.00
-
-[2]===== Grouping 16 clusters... 
-[2]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 4 time: 0.00
-finished 2 / 4. cluster size: 2 time: 0.00
-finished 3 / 4. cluster size: 5 time: 0.01
-finished 4 / 4. cluster size: 5 time: 0.01
-
-blkArea:  1156449.00 deadspace:    80017.00 (6.92%) time: 0.01
-
-[3]===== Grouping 4 clusters... 
-[3]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  1156449.00 deadspace:   220402.00 (19.06%) time: 0.01
-
-total area:  1376851.00
-block area:  1156449.00
-deadspace:    220402.00
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea:  1156449.00 deadspace:   133231.00 (11.52%) time: 0.01
-
-width:  658.00
-height: 1960.00
-total area:  1289680.00
-block area:  1156449.00
-dead space:   133231.00 (11.52%)
-
-area usage   (wrt. total area): 89.67%
-dead space % (wrt. total area): 10.33%
----------------------------
-
-Compacting...
-converted to B*-Tree: 1289680.00 (11.52%) -> 1289680.00 (11.52%)
-round 0:      4 blks changed: 1289680.00 (11.52%) -> 1289680.00 (11.52%)
-round 1:      0 blks changed: 1289680.00 (11.52%) -> 1289680.00 (11.52%)
-
-After compaction, 
-blkArea:  1156449.00 deadspace:   133231.00 (11.52%)
-
-width:  658.00
-height: 1960.00
-total area:  1289680.00
-block area:  1156449.00
-dead space:   133231.00 (11.52%)
-
-area usage   (wrt. total area): 89.67%
-dead space % (wrt. total area): 10.33%
----------------------------
-
-Output successfully written to dummy_output
-
-CompaSS's runtime: 0.01s
-===== Thanks for using CompaSS =====
------ Running ../TESTS/MCNCami49_10.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Instance Parameters: 
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-
-Performance Parameters: 
-  - HIER_CLUSTER_BASE: 4   [tuned by user] 
-  - HIER_CLUSTER_AREA_DEV: 1.85   [tuned by CompaSS]
-  - HIER_INIT_AR: 1.20   [tuned by CompaSS]
-  - HIER_USE_AR_LEVEL: 2.00   [tuned by CompaSS]
-  - HIER_WIDTH_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_HEIGHT_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_INIT_DEADSPACE: 0.05   [tuned by CompaSS]
-  - HIER_DEADSPACE_INCRE: 1.50   [tuned by CompaSS]
-  - HIER_SIMILARITY_THRESHOLD: 1.90   [tuned by CompaSS]
-  - compact? Yes
-
-[0]===== Grouping 490 clusters... 
-[0]===== Packing into 257 clusters... 
- * Aspect ratio bound used.
-
-blkArea:  3544542.40 deadspace:     4394.32 (0.12%) time: 0.08
-
-[1]===== Grouping 257 clusters... 
-[1]===== Packing into 256 clusters... 
- * Aspect ratio bound used.
-
-blkArea:  3544542.40 deadspace:     4394.32 (0.12%) time: 0.10
-
-[2]===== Grouping 256 clusters... 
-[2]===== Packing into 152 clusters... 
- * Aspect ratio bound used.
-
-blkArea:  3544542.40 deadspace:    16471.84 (0.46%) time: 0.13
-
-[3]===== Grouping 152 clusters... 
-[3]===== Packing into 104 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:    25213.44 (0.71%) time: 0.13
-
-[4]===== Grouping 104 clusters... 
-[4]===== Packing into 77 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:    39695.88 (1.12%) time: 0.14
-
-[5]===== Grouping 77 clusters... 
-[5]===== Packing into 64 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:    45446.52 (1.28%) time: 0.14
-
-[6]===== Grouping 64 clusters... 
-[6]===== Packing into 46 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:    68427.52 (1.93%) time: 0.15
-
-[7]===== Grouping 46 clusters... 
-[7]===== Packing into 35 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:    82447.40 (2.33%) time: 0.15
-
-[8]===== Grouping 35 clusters... 
-[8]===== Packing into 27 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:   109030.88 (3.08%) time: 0.15
-
-[9]===== Grouping 27 clusters... 
-[9]===== Packing into 19 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:   114236.64 (3.22%) time: 0.15
-
-[10]===== Grouping 19 clusters... 
-[10]===== Packing into 16 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:   127204.00 (3.59%) time: 0.16
-
-[11]===== Grouping 16 clusters... 
-[11]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 5 time: 0.22
-finished 2 / 4. cluster size: 5 time: 0.30
-finished 3 / 4. cluster size: 1 time: 0.30
-finished 4 / 4. cluster size: 5 time: 0.30
-
-blkArea:  3544542.40 deadspace:   204218.28 (5.76%) time: 0.30
-
-[12]===== Grouping 4 clusters... 
-[12]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:   261201.36 (7.37%) time: 0.32
-
-total area:  3805743.76
-block area:  3544542.40
-deadspace:    261201.36
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea:  3544542.40 deadspace:   187987.52 (5.30%) time: 0.34
-
-width:  1394.40
-height: 2676.80
-total area:  3732529.92
-block area:  3544542.40
-dead space:   187987.52 (5.30%)
-
-area usage   (wrt. total area): 94.96%
-dead space % (wrt. total area): 5.04%
----------------------------
-
-Compacting...
-converted to B*-Tree: 3732529.92 (5.30%) -> 3714960.48 (4.81%)
-round 0:    276 blks changed: 3714960.48 (4.81%) -> 3707500.72 (4.60%)
-round 1:     17 blks changed: 3707500.72 (4.60%) -> 3707500.72 (4.60%)
-round 2:      0 blks changed: 3707500.72 (4.60%) -> 3707500.72 (4.60%)
-
-After compaction, 
-blkArea:  3544542.40 deadspace:   162958.32 (4.60%)
-
-width:  1391.60
-height: 2664.20
-total area:  3707500.72
-block area:  3544542.40
-dead space:   162958.32 (4.60%)
-
-area usage   (wrt. total area): 95.60%
-dead space % (wrt. total area): 4.40%
----------------------------
-
-Output successfully written to dummy_output
-
-CompaSS's runtime: 0.36s
-===== Thanks for using CompaSS =====
------ Running ../TESTS/MCNCami49.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Instance Parameters: 
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-
-Performance Parameters: 
-  - HIER_CLUSTER_BASE: 4   [tuned by user] 
-  - HIER_CLUSTER_AREA_DEV: 1.85   [tuned by CompaSS]
-  - HIER_INIT_AR: 1.20   [tuned by CompaSS]
-  - HIER_USE_AR_LEVEL: 2.00   [tuned by CompaSS]
-  - HIER_WIDTH_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_HEIGHT_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_INIT_DEADSPACE: 0.05   [tuned by CompaSS]
-  - HIER_DEADSPACE_INCRE: 1.50   [tuned by CompaSS]
-  - HIER_SIMILARITY_THRESHOLD: 1.90   [tuned by CompaSS]
-  - compact? Yes
-
-[0]===== Grouping 49 clusters... 
-[0]===== Packing into 22 clusters... 
- * Aspect ratio bound used.
-
-blkArea: 35445424.00 deadspace:   673260.00 (1.90%) time: 0.01
-
-[1]===== Grouping 22 clusters... 
-[1]===== Packing into 16 clusters... 
- * Aspect ratio bound not used.
-
-blkArea: 35445424.00 deadspace:   824376.00 (2.33%) time: 0.01
-
-[2]===== Grouping 16 clusters... 
-[2]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 5 time: 0.02
-finished 2 / 4. cluster size: 3 time: 0.02
-finished 3 / 4. cluster size: 4 time: 0.02
-finished 4 / 4. cluster size: 4 time: 0.02
-
-blkArea: 35445424.00 deadspace:  2954112.00 (8.33%) time: 0.02
-
-[3]===== Grouping 4 clusters... 
-[3]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea: 35445424.00 deadspace:  4002908.00 (11.29%) time: 0.02
-
-total area: 39448332.00
-block area: 35445424.00
-deadspace:   4002908.00
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea: 35445424.00 deadspace:  3365712.00 (9.50%) time: 0.02
-
-width:  3808.00
-height: 10192.00
-total area: 38811136.00
-block area: 35445424.00
-dead space:  3365712.00 (9.50%)
-
-area usage   (wrt. total area): 91.33%
-dead space % (wrt. total area): 8.67%
----------------------------
-
-Compacting...
-converted to B*-Tree: 38811136.00 (9.50%) -> 38704512.00 (9.19%)
-round 0:     10 blks changed: 38704512.00 (9.19%) -> 38704512.00 (9.19%)
-round 1:      0 blks changed: 38704512.00 (9.19%) -> 38704512.00 (9.19%)
-
-After compaction, 
-blkArea: 35445424.00 deadspace:  3259088.00 (9.19%)
-
-width:  3808.00
-height: 10164.00
-total area: 38704512.00
-block area: 35445424.00
-dead space:  3259088.00 (9.19%)
-
-area usage   (wrt. total area): 91.58%
-dead space % (wrt. total area): 8.42%
----------------------------
-
-Output successfully written to dummy_output
-
-CompaSS's runtime: 0.02s
-===== Thanks for using CompaSS =====
------ Running ../TESTS/MCNCapte.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Instance Parameters: 
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-
-Performance Parameters: 
-  - HIER_CLUSTER_BASE: 4   [tuned by user] 
-  - HIER_CLUSTER_AREA_DEV: 1.85   [tuned by CompaSS]
-  - HIER_INIT_AR: 1.20   [tuned by CompaSS]
-  - HIER_USE_AR_LEVEL: 2.00   [tuned by CompaSS]
-  - HIER_WIDTH_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_HEIGHT_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_INIT_DEADSPACE: 0.05   [tuned by CompaSS]
-  - HIER_DEADSPACE_INCRE: 1.50   [tuned by CompaSS]
-  - HIER_SIMILARITY_THRESHOLD: 1.90   [tuned by CompaSS]
-  - compact? Yes
-
-[0]===== Grouping 9 clusters... 
-[0]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 1 time: 0.00
-finished 2 / 4. cluster size: 3 time: 0.00
-finished 3 / 4. cluster size: 1 time: 0.00
-finished 4 / 4. cluster size: 4 time: 0.00
-
-blkArea: 46561628.00 deadspace:        0.00 (0.00%) time: 0.00
-
-[1]===== Grouping 4 clusters... 
-[1]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea: 46561628.00 deadspace:  3178612.00 (6.83%) time: 0.00
-
-total area: 49740240.00
-block area: 46561628.00
-deadspace:   3178612.00
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea: 46561628.00 deadspace:   363220.00 (0.78%) time: 0.00
-
-width:  1832.00
-height: 25614.00
-total area: 46924848.00
-block area: 46561628.00
-dead space:   363220.00 (0.78%)
-
-area usage   (wrt. total area): 99.23%
-dead space % (wrt. total area): 0.77%
----------------------------
-
-Compacting...
-converted to B*-Tree: 46924848.00 (0.78%) -> 46924848.00 (0.78%)
-round 0:      0 blks changed: 46924848.00 (0.78%) -> 46924848.00 (0.78%)
-
-After compaction, 
-blkArea: 46561628.00 deadspace:   363220.00 (0.78%)
-
-width:  1832.00
-height: 25614.00
-total area: 46924848.00
-block area: 46561628.00
-dead space:   363220.00 (0.78%)
-
-area usage   (wrt. total area): 99.23%
-dead space % (wrt. total area): 0.77%
----------------------------
-
-Output successfully written to dummy_output
-
-CompaSS's runtime: 0.01s
-===== Thanks for using CompaSS =====
------ Running ../TESTS/MCNChp.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Instance Parameters: 
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-
-Performance Parameters: 
-  - HIER_CLUSTER_BASE: 4   [tuned by user] 
-  - HIER_CLUSTER_AREA_DEV: 1.85   [tuned by CompaSS]
-  - HIER_INIT_AR: 1.20   [tuned by CompaSS]
-  - HIER_USE_AR_LEVEL: 2.00   [tuned by CompaSS]
-  - HIER_WIDTH_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_HEIGHT_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_INIT_DEADSPACE: 0.05   [tuned by CompaSS]
-  - HIER_DEADSPACE_INCRE: 1.50   [tuned by CompaSS]
-  - HIER_SIMILARITY_THRESHOLD: 1.90   [tuned by CompaSS]
-  - compact? Yes
-
-[0]===== Grouping 11 clusters... 
-[0]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 3 time: 0.00
-finished 2 / 4. cluster size: 1 time: 0.00
-finished 3 / 4. cluster size: 5 time: 0.00
-finished 4 / 4. cluster size: 2 time: 0.00
-
-blkArea:  8830584.00 deadspace:   321048.00 (3.64%) time: 0.00
-
-[1]===== Grouping 4 clusters... 
-[1]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  8830584.00 deadspace:   712656.00 (8.07%) time: 0.00
-
-total area:  9543240.00
-block area:  8830584.00
-deadspace:    712656.00
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea:  8830584.00 deadspace:   712656.00 (8.07%) time: 0.00
-
-width:  1260.00
-height: 7574.00
-total area:  9543240.00
-block area:  8830584.00
-dead space:   712656.00 (8.07%)
-
-area usage   (wrt. total area): 92.53%
-dead space % (wrt. total area): 7.47%
----------------------------
-
-Compacting...
-converted to B*-Tree: 9543240.00 (8.07%) -> 9543240.00 (8.07%)
-round 0:      2 blks changed: 9543240.00 (8.07%) -> 9543240.00 (8.07%)
-round 1:      0 blks changed: 9543240.00 (8.07%) -> 9543240.00 (8.07%)
-
-After compaction, 
-blkArea:  8830584.00 deadspace:   712656.00 (8.07%)
-
-width:  1260.00
-height: 7574.00
-total area:  9543240.00
-block area:  8830584.00
-dead space:   712656.00 (8.07%)
-
-area usage   (wrt. total area): 92.53%
-dead space % (wrt. total area): 7.47%
----------------------------
-
-Output successfully written to dummy_output
-
-CompaSS's runtime: 0.01s
-===== Thanks for using CompaSS =====
------ Running ../TESTS/MCNCxerox.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Instance Parameters: 
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-
-Performance Parameters: 
-  - HIER_CLUSTER_BASE: 4   [tuned by user] 
-  - HIER_CLUSTER_AREA_DEV: 1.85   [tuned by CompaSS]
-  - HIER_INIT_AR: 1.20   [tuned by CompaSS]
-  - HIER_USE_AR_LEVEL: 2.00   [tuned by CompaSS]
-  - HIER_WIDTH_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_HEIGHT_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_INIT_DEADSPACE: 0.05   [tuned by CompaSS]
-  - HIER_DEADSPACE_INCRE: 1.50   [tuned by CompaSS]
-  - HIER_SIMILARITY_THRESHOLD: 1.90   [tuned by CompaSS]
-  - compact? Yes
-
-[0]===== Grouping 10 clusters... 
-[0]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 3 time: 0.00
-finished 2 / 4. cluster size: 1 time: 0.00
-finished 3 / 4. cluster size: 1 time: 0.00
-finished 4 / 4. cluster size: 5 time: 0.00
-
-blkArea: 19350296.00 deadspace:   281113.00 (1.45%) time: 0.00
-
-[1]===== Grouping 4 clusters... 
-[1]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea: 19350296.00 deadspace:  1035860.00 (5.35%) time: 0.00
-
-total area: 20386156.00
-block area: 19350296.00
-deadspace:   1035860.00
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea: 19350296.00 deadspace:  1035860.00 (5.35%) time: 0.00
-
-width:  1316.00
-height: 15491.00
-total area: 20386156.00
-block area: 19350296.00
-dead space:  1035860.00 (5.35%)
-
-area usage   (wrt. total area): 94.92%
-dead space % (wrt. total area): 5.08%
----------------------------
-
-Compacting...
-converted to B*-Tree: 20386156.00 (5.35%) -> 20386156.00 (5.35%)
-round 0:      0 blks changed: 20386156.00 (5.35%) -> 20386156.00 (5.35%)
-
-After compaction, 
-blkArea: 19350296.00 deadspace:  1035860.00 (5.35%)
-
-width:  1316.00
-height: 15491.00
-total area: 20386156.00
-block area: 19350296.00
-dead space:  1035860.00 (5.35%)
-
-area usage   (wrt. total area): 94.92%
-dead space % (wrt. total area): 5.08%
----------------------------
-
-Output successfully written to dummy_output
-
-CompaSS's runtime: 0.00s
-===== Thanks for using CompaSS =====
diff -druN BloBB_CompaSS_050315/CompaSS/iosoftst.cxx blob_compass/CompaSS/iosoftst.cxx
--- BloBB_CompaSS_050315/CompaSS/iosoftst.cxx	2004-05-07 10:12:45.000000000 -0700
+++ blob_compass/CompaSS/iosoftst.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,225 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "datastrbacksoftst.h"
-#include "datastrfrontsoftst.h"
-
-#include <iostream>
-#include <fstream>
-#include <sstream>
-#include <iomanip>
-#include <algorithm>
-using namespace std;
-
-// ========================================================
-void BlockInfoType::ReadSoftFormat(int accuracy,
-                                   istream& ins)
-{
-   int blocknum;
-   ins >> blocknum;
-   ins.ignore(1000, '\n');
-   
-   for (int i = 0; i < blocknum; i++)
-   {
-      // read the information for blocks[j]
-      double area;
-      vector<double> minAR;
-      vector<double> maxAR;
-      string line;      
-      getline(ins, line);
-
-      stringstream ss;
-      ss << line << " ";
-      ss >> area;
-      while (ss.good())
-      {
-         double min_ar, max_ar;
-         ss >> min_ar >> max_ar;
-         if (ss.good())
-         {
-            minAR.push_back(min_ar);
-            maxAR.push_back(max_ar);
-         }
-      }
-
-      if (minAR.empty())
-      {
-         cout << "ERROR: error in reading block[" << i << "]" << endl;
-         exit(1);
-      }
-
-      // construct curve for blocks[j]
-      vector<Point> curve;
-      for (int j = minAR.size()-1; j >= 0; j--)
-      {
-         double widthStart = sqrt(area / maxAR[j]);
-         double widthEnd = sqrt(area / minAR[j]);
-         double interval = (widthEnd-widthStart) / accuracy;
-
-         if (j == int(minAR.size()-1))
-         {
-            // add the vertical infty part of the curve
-            curve.push_back(Point(widthStart, Point::INFTY));
-         }
-         else
-         {
-            // add the vertical corner before this part
-            double oldY = curve.back().yCoord();
-            double newX = widthStart;
-            curve.push_back(Point(newX, oldY));
-         }
-         
-         if (maxAR[j] == minAR[j]) // rigid at that aspect ratio
-         {
-            double width = widthStart;
-            double height = area / width;
-            curve.push_back(Point(width, height));
-         }
-         else if (maxAR[j] > minAR[j]) // soft block
-         {
-            for (double width = widthStart;
-                 abs(widthEnd-width) > 0.001; width += interval)
-            {
-               double height = area / width;
-               curve.push_back(Point(width, height));
-            }
-         }
-         else
-         {
-            cout << "ERROR: minAR (" << minAR[j] << ") greater than "
-                 << "maxAR (" << maxAR[j] << ")." << endl;
-            exit(1);
-         }
-
-         if (j == 0)
-            curve.push_back(Point(Point::INFTY, area / widthEnd));
-      }
-      blocks.push_back(BoundaryType(curve));
-      in_total_area += area;
-   }
-}
-// --------------------------------------------------------
-void BlockInfoType::ReadTxtFormat(istream& ins)
-{
-   int blocknum;
-   ins >> blocknum;
-   ins.ignore(1000, '\n');
-
-   for (int i = 0; i < blocknum; i++)
-   {
-      double width, height;
-      
-      ins >> width >> height;
-      if (!ins.good())
-      {
-         cout << "ERROR: error in reading block[" << i << "]." << endl;
-         exit(1);
-      }
-
-      double maxEdge = max(width, height);
-      double minEdge = min(width, height);
-      vector<Point> curve;
-
-      curve.push_back(Point(minEdge, Point::INFTY));
-      curve.push_back(Point(minEdge, maxEdge));
-      curve.push_back(Point(maxEdge, maxEdge));
-      curve.push_back(Point(maxEdge, minEdge));
-      curve.push_back(Point(Point::INFTY, minEdge));
-
-      blocks.push_back(curve);
-      in_total_area += width * height;
-   }
-}
-// --------------------------------------------------------
-void BlockInfoType::ReadTxtFixedFormat(istream& ins)
-{
-   int blocknum;
-   ins >> blocknum;
-   ins.ignore(1000, '\n');
-
-   for (int i = 0; i < blocknum; i++)
-   {
-      double width, height;
-      
-      ins >> width >> height;
-      if (!ins.good())
-      {
-         cout << "ERROR: error in reading block[" << i << "]." << endl;
-         exit(1);
-      }
-
-      vector<Point> curve;
-
-      curve.push_back(Point(width, Point::INFTY));
-      curve.push_back(Point(width, height));
-      curve.push_back(Point(Point::INFTY, height));
-
-      blocks.push_back(curve);
-      in_total_area += width * height;
-   }
-}     
-// ========================================================
-void SoftPacking::output(ostream& outs) const
-{
-   int blocknum = xloc.size();
-
-   outs.setf(ios::fixed);
-   outs.precision(3);
-   outs << totalWidth << endl;
-   outs << totalHeight << endl;
-   
-   outs << blocknum << endl;
-   for (int i = 0; i < blocknum; i++)
-      outs << width[i] << " " << height[i] << endl;
-   outs << endl;
-
-   for (int i = 0; i < blocknum; i++)
-      outs << xloc[i] << " " << yloc[i] << endl;
-   outs << endl;
-   
-   outs << endl << endl;
-   for (unsigned int i = 0; i < expression.size(); i++)
-   {
-      int sign = expression[i];
-      if (SoftSTree::isOperand(sign))
-         outs << sign << " ";
-      else if (sign == SoftSTree::STAR)
-         outs << "* ";
-      else if (sign == SoftSTree::PLUS)
-         outs << "+ ";
-      else if (sign == SoftSTree::BOTH)
-         outs << "- ";
-      else
-         outs << "? ";
-   }
-   outs << endl;
-}   
-// ========================================================
diff -druN BloBB_CompaSS_050315/CompaSS/main.cxx blob_compass/CompaSS/main.cxx
--- BloBB_CompaSS_050315/CompaSS/main.cxx	2005-03-13 17:48:13.000000000 -0800
+++ blob_compass/CompaSS/main.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,79 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "datastrbacksoftst.h"
-#include "datastrfrontsoftst.h"
-#include "datastrhiersoftst.h"
-#include "enginesoftst.h"
-#include "enginehiersoftst.h"
-
-#include "mainsoftst.h"
-#include "mainhiersoftst.h"
-
-#include "utilities.h"
-
-// --------------------------------------------------------
-int main(int argc, char *argv[])
-{
-   int algorithm = -1;
-
-   if (argc < 4)
-   {
-      cout << "USAGE: compass <input-file> <output-file> "
-           << "<input-format> [options] " << endl;
-      exit(0);
-   }
-   
-   cout << "===== CompaSS (Compacting Soft Slicing Packings) =====" << endl;
-   for (int i = argc-1; i >= 0; i--)
-      if (!strcmp(argv[i], "--optimal") ||
-          !strcmp(argv[i], "-o"))
-         algorithm = SoftEngineType::B_BOUND;
-      else if (!strcmp(argv[i], "--hierarchical") ||
-               !strcmp(argv[i], "-h"))
-         algorithm = SoftEngineType::HIER;
-
-   if (algorithm == -1)
-   {
-      cout << "WARNING: Algorithm not chosen, \"--hierarchical\" assumed."
-           << endl;
-      main_hier(argc, argv);
-   }
-   else if (algorithm == SoftEngineType::B_BOUND)
-      main_optimal(argc, argv);
-   else if (algorithm == SoftEngineType::HIER)
-      main_hier(argc, argv);
-
-   cout << "CompaSS's runtime: " << getTotalTime() << "s" << endl;
-   cout << "===== Thanks for using CompaSS =====" << endl;
-   return 0;
-}
-// --------------------------------------------------------
diff -druN BloBB_CompaSS_050315/CompaSS/mainhiersoftst.cxx blob_compass/CompaSS/mainhiersoftst.cxx
--- BloBB_CompaSS_050315/CompaSS/mainhiersoftst.cxx	2005-03-13 21:22:18.000000000 -0800
+++ blob_compass/CompaSS/mainhiersoftst.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,295 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "mainhiersoftst.h"
-#include "interfaceutil.h"
-
-#include "datastrbacksoftst.h"
-#include "datastrfrontsoftst.h"
-#include "datastrhiersoftst.h"
-#include "enginesoftst.h"
-#include "enginehiersoftst.h"
-
-#include "btreefromsstree.h"
-#include "btreecompactsstree.h"
-
-#include "parsers.h"
-
-#include <string>
-#include <set>
-#include <utility>
-using namespace std;
-
-// --------------------------------------------------------
-void main_hier(int argc, char *argv[])
-{   
-   ifstream infile;
-   ofstream outfile;
-
-   cout << "---< HIERARCHICAL Packing >---" << endl;
-   infile.open(argv[1]);
-   if (!infile.good())
-   {
-      cout << "ERROR: cannot open file: " << argv[1] << endl;
-      exit(1);
-   }
-
-   outfile.open(argv[2]);
-   if (!outfile.good())
-   {
-      cout << "ERROR: cannot open file: " << argv[3] << endl;
-      exit(1);
-   }
-
-   int format = -1;
-   if (!strcmp(argv[3], "--txt"))
-      format = BlockInfoType::TXT;
-   else if (!strcmp(argv[3], "--soft"))
-      format = BlockInfoType::SOFT;
-   else
-   {
-      cout << "ERROR: invalid input format \"" << argv[3]
-           << "\"." << endl;
-      exit(1);
-   }
-
-   // -----set default values-----
-   if (format == BlockInfoType::TXT)
-      HIER_ACCURACY = DEFAULT_HIER_TXT_ACCURACY;
-   else if (format == BlockInfoType::SOFT)
-      HIER_ACCURACY = DEFAULT_HIER_SOFT_ACCURACY;
-   
-   // -----parse optional options-----
-   set<string> userDefinedOptions; // to be excluded from parameter tuning
-   
-   bool option_compact = true;
-   double option_outline_ar = Point::INFTY;
-   double option_outline_deadspace = Point::INFTY;
-   for (int i = 4; i < argc; i++)
-   {
-      const int optionPosition = i;
-      bool validOption = true;
-      if (!strcmp(argv[i], "--fixed"))
-      {
-         if (format != BlockInfoType::TXT)
-         {
-            cout << "ERROR: \"--fixed\" must be used with \"--txt\"."
-                 << endl;
-            exit(1);
-         }
-         else
-            format = BlockInfoType::TXT_FIXED;
-      }
-      else if (!strcmp(argv[i], "--HIER_CLUSTER_BASE"))
-      {
-         i++;
-         SetInt(argc, argv, i,
-                SoftHierEngineType::HIER_CLUSTER_BASE);
-      }
-      else if (!strcmp(argv[i], "--HIER_CLUSTER_AREA_DEV"))
-      {
-         i++;
-         SetDouble(argc, argv, i,
-                   SoftHierEngineType::HIER_CLUSTER_AREA_DEV);
-      }
-      else if (!strcmp(argv[i], "--HIER_INIT_AR"))
-      {
-         i++;
-         SetDouble(argc, argv, i,
-                   SoftHierEngineType::HIER_AR);
-      }
-      else if (!strcmp(argv[i], "--HIER_WIDTH_INCRE"))
-      {
-         i++;
-         SetDouble(argc, argv, i,
-                   SoftHierEngineType::HIER_WIDTH_INCRE);
-      }
-      else if (!strcmp(argv[i], "--HIER_HEIGHT_INCRE"))
-      {
-         i++;
-         SetDouble(argc, argv, i,
-                   SoftHierEngineType::HIER_HEIGHT_INCRE);
-      }
-      else if (!strcmp(argv[i], "--HIER_USE_AR_LEVEL"))
-      {
-         i++;
-         SetInt(argc, argv, i, 
-                SoftHierEngineType::HIER_USE_AR_LEVEL);
-      }
-      else if (!strcmp(argv[i], "--HIER_INIT_DEADSPACE"))
-      {
-         i++;
-         SetDouble(argc, argv, i,
-                   SoftHierEngineType::HIER_INIT_DEADSPACE);
-         SoftHierEngineType::HIER_INIT_DEADSPACE /= 100;
-      }
-      else if (!strcmp(argv[i], "--HIER_DEADSPACE_INCRE"))
-      {
-         i++;
-         SetDouble(argc, argv, i,
-                   SoftHierEngineType::HIER_DEADSPACE_INCRE);
-      }
-      else if (!strcmp(argv[i], "--HIER_SIMILARITY_THRESHOLD"))
-      {
-         i++;
-         SetDouble(argc, argv, i,
-                   SoftHierEngineType::HIER_SIMILARITY_THRESHOLD);
-      }
-      else if (!strcmp(argv[i], "--HIER_OUTLINE_AR"))
-      {
-         i++;
-         SetDouble(argc, argv, i, option_outline_ar);
-      }
-      else if (!strcmp(argv[i], "--HIER_OUTLINE_DEADSPACE"))
-      {
-         i++;
-         SetDouble(argc, argv, i, option_outline_deadspace);
-         option_outline_deadspace /= 100;
-      }
-      else if (!strcmp(argv[i], "--AREA_ACCURACY"))
-      {
-         i++;
-         SetDouble(argc, argv, i, HIER_ACCURACY);
-         HIER_ACCURACY /= 100;
-         HIER_ACCURACY += 1;
-      }
-      else if (!strcmp(argv[i], "--CURVE_ACCURACY"))
-      {
-         i++;
-         SetInt(argc, argv, i, BlockInfoType::CURVE_ACCURACY);
-      }
-      else if (!strcmp(argv[i], "-h") ||
-               !strcmp(argv[i], "--hierarchical"))
-      {}
-      else if (!strcmp(argv[i], "--no_compact"))
-         option_compact = true;
-      else
-      {
-         validOption = false;
-         cout << "ERROR: Invalid option: " << argv[i] << endl;
-         exit(1);
-      }
-
-      if (validOption)
-      {
-         pair<set<string>::iterator, bool> 
-            status = userDefinedOptions.insert(argv[optionPosition]);
-         if (!status.second)
-         {
-            cout << "WARNING: duplicated option: " << argv[optionPosition] << endl;
-         }
-      }
-   } // end for each identier on the command-line
-
-   // -----output parameters-----
-   cout.setf(ios::fixed);
-   cout.precision(2);
-   cout << "Details: " << endl;
-   cout << "  - Block type: ";
-   if (format == BlockInfoType::TXT)
-      cout << "all hard, free orientations." << endl;
-   else if (format == BlockInfoType::TXT_FIXED)
-      cout << "all hard, fixed orientations." << endl;
-   else if (format == BlockInfoType::SOFT)
-   {
-      cout << "all soft ";
-      cout << "(Curve Accuracy = " << BlockInfoType::CURVE_ACCURACY
-           << ")." << endl;
-   }
-   cout << "  - Area accuracy: " << ((HIER_ACCURACY-1) * 100)
-        << "%." << endl;      
-
-   // -----Core program starts here-----
-   BlockInfoType blockinfo(format, infile);
-   const bool fixed_outline = ((option_outline_ar < Point::INFTY) &&
-                               (option_outline_deadspace < Point::INFTY));
-   const double side_bound = sqrt(blockinfo.block_area() * option_outline_deadspace *
-                                  option_outline_ar);
-   Point::X_BOUND = (!fixed_outline)? Point::INFTY : side_bound;
-   Point::Y_BOUND = (!fixed_outline)? Point::INFTY : side_bound;
-
-   // evoke the hierarchical block packing engine
-   SoftHierEngineType engine((format == BlockInfoType::SOFT)
-                             ? SoftHierEngineType::SOFT_ONLY 
-                             : SoftHierEngineType::HARD_ONLY,
-                             blockinfo, &userDefinedOptions);
-   SoftSliceRecord *ssrPtr = engine(format);
-
-   // -----Post processing: optimizing operators of PE-----
-   cout << endl << "Optimizing operators of the Polish expression";
-   if (option_outline_ar < Point::INFTY)
-   {
-      cout << " (aspect ratio ~" << option_outline_ar << ")..."
-           << endl;   
-      if (option_outline_deadspace >= Point::INFTY)
-      {
-         Point::X_BOUND = sqrt(ssrPtr->minArea * option_outline_ar);
-         Point::Y_BOUND = sqrt(ssrPtr->minArea * option_outline_ar);
-      }
-   }
-   else
-      cout << " (no aspect ratio constraints)..." << endl;
-      
-   SoftPacking final_packing(*ssrPtr, blockinfo);
-   double final_blkArea = final_packing.blockArea;
-   double final_deadspace = final_packing.deadspace;
-   cout << endl;
-   cout << "After operator optimization," << endl;
-   cout << "blkArea: " << setw(11) << final_blkArea
-        << " deadspace: " << setw(11) << final_deadspace
-        << " (" << ((final_deadspace / final_blkArea) * 100)
-        << "%) time: " << getTotalTime() << endl;
-   cout << endl;
-   PrintDimensions(final_packing.totalWidth,
-                   final_packing.totalHeight);
-   PrintAreas(final_deadspace, final_blkArea);
-   cout << endl;
-   PrintUtilization(final_deadspace, final_blkArea);
-   
-   // -----Post processing:  extended for compaction -----
-   if (option_compact)
-   {
-      cout << endl << "Compacting..." << endl;
-      BTreeCompactSlice(final_packing, argv[2]);
-   }
-   else
-   {
-      final_packing.output(outfile);      
-      if (outfile.good())
-         cout << "Output successfully written to " << argv[2] << endl;
-      else
-         cout << "Something wrong with the file " << argv[2] << endl;
-   }
-   cout << endl;
-   outfile.close();
-   delete ssrPtr;
-}
-// --------------------------------------------------------
diff -druN BloBB_CompaSS_050315/CompaSS/mainhiersoftst.h blob_compass/CompaSS/mainhiersoftst.h
--- BloBB_CompaSS_050315/CompaSS/mainhiersoftst.h	2004-02-07 20:15:22.000000000 -0800
+++ blob_compass/CompaSS/mainhiersoftst.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,43 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef MAINHIERSOFTST_H
-#define MAINHIERSOFTST_H
-
-#include "enginehiersoftst.h"
-
-#include <iostream>
-#include <fstream>
-using namespace std;
-
-void main_hier(int argc, char *argv[]);
-
-#endif
diff -druN BloBB_CompaSS_050315/CompaSS/mainsoftst.cxx blob_compass/CompaSS/mainsoftst.cxx
--- BloBB_CompaSS_050315/CompaSS/mainsoftst.cxx	2004-02-07 20:17:33.000000000 -0800
+++ blob_compass/CompaSS/mainsoftst.cxx	1969-12-31 16:00:00.000000000 -0800
@@ -1,174 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#include "mainsoftst.h"
-#include "interfaceutil.h"
-
-#include "datastrbacksoftst.h"
-#include "datastrfrontsoftst.h"
-#include "datastrhiersoftst.h"
-#include "enginesoftst.h"
-
-#include <iostream>
-#include <fstream>
-using namespace std;
-
-// --------------------------------------------------------
-void main_optimal(int argc, char *argv[])
-{
-   ifstream infile;
-   ofstream outfile;
-
-   cout << "---< OPTIMAL Packing >---" << endl;
-   infile.open(argv[1]);
-   if (!infile.good())
-   {
-      cout << "ERROR: cannot open file: " << argv[1] << endl;
-      exit(1);
-   }
-
-   outfile.open(argv[2]);
-   if (!outfile.good())
-   {
-      cout << "ERROR: cannot open file: " << argv[3] << endl;
-      exit(1);
-   }
-
-   int format = -1;
-   if (!strcmp(argv[3], "--txt"))
-      format = BlockInfoType::TXT;
-   else if (!strcmp(argv[3], "--soft"))
-      format = BlockInfoType::SOFT;
-   else
-   {
-      cout << "ERROR: unrecognized format: " << argv[3]
-           << " (--txt or --soft)." << endl;
-      exit(1);
-   }
-
-   // optional options
-   for (int i = 4; i < argc; i++)
-      if (!strcmp(argv[i], "--INIT_DEADSPACE"))
-      {
-         i++;
-         SetDouble(argc, argv, i, SoftEngineType::INIT_DEADSPACE);
-         SoftEngineType::INIT_DEADSPACE /= 100;
-      }
-      else if (!strcmp(argv[i], "--DEADSPACE_INCRE"))
-      {
-         i++;
-         SetDouble(argc, argv, i, SoftEngineType::DEADSPACE_INCRE);
-      }
-      else if (!strcmp(argv[i], "-o") ||
-               !strcmp(argv[i], "--optimal"))
-      {}
-      else if (!strcmp(argv[i], "--fixed"))
-      {
-         if (format != BlockInfoType::TXT)
-         {
-            cout << "ERROR: \"--fixed\" must be used with "
-                 << "\"--txt\"." << endl;
-            exit(1);
-         }
-         else
-            format = BlockInfoType::TXT_FIXED;
-      }
-      else if (!strcmp(argv[i], "--AREA_ACCURACY"))
-      {
-         i++;
-         SetDouble(argc, argv, i, OPTIMAL_ACCURACY);
-         OPTIMAL_ACCURACY /= 100;
-         OPTIMAL_ACCURACY += 1;
-      }
-      else if (!strcmp(argv[i], "--CURVE_ACCURACY"))
-      {
-         i++;
-         SetInt(argc, argv, i, BlockInfoType::CURVE_ACCURACY);
-      }
-      else
-      {
-         cout << "ERROR: unrecognized option: " << argv[i] << endl;
-         exit(1);
-      }
-
-   int mode = SoftEngineType::EXPLICIT;
-   int algo = SoftEngineType::B_BOUND;
-   cout << "Algorithm: ";
-   switch(algo)
-   {
-   case SoftEngineType::B_BOUND:
-      cout << "Branch-and-bound." << endl;
-      break;
-   }
-   cout.setf(ios::fixed);
-   cout.precision(2);
-   cout << "  - Block type: ";
-   if (format == BlockInfoType::TXT)
-      cout << "all hard, free orientations." << endl;
-   else if (format == BlockInfoType::TXT_FIXED)
-      cout << "all hard, fixed orientations." << endl;
-   else
-      cout << "all soft." << endl;
-   cout << "  - Area accuracy: " << (OPTIMAL_ACCURACY - 1) * 100
-        << "%." << endl;
-   if (format == BlockInfoType::SOFT)
-      cout << "  - Curve accuracy: " << BlockInfoType::CURVE_ACCURACY << endl;
-   
-   cout << "  - Initial deadspace: " << (SoftEngineType::INIT_DEADSPACE * 100)
-        << "%" << endl;
-   cout << "  - Deadspace increment: " << SoftEngineType::DEADSPACE_INCRE << endl;
-   cout << endl;
-
-   counterName[0] = "# nodes";
-   counterName[1] = "operand";
-   counterName[2] = "left";
-   counterName[3] = "operator";
-   counterName[4] = "left";
-
-   // -----core program starts here-----
-   BlockInfoType blockinfo(format, infile);
-   SoftEngineType engine(blockinfo);
-
-   SoftSliceRecordList *ssr_ptr = engine(algo, mode);
-
-   cout << "solution found: " << endl;
-   SoftPacking(ssr_ptr->last(), blockinfo).output(outfile);
-   SoftPacking(ssr_ptr->last(), blockinfo).output(cout);
-
-   if (outfile.good())
-      cout << "Output successfully written to " << argv[2] << endl;
-   else
-      cout << "Something wrong with the file " << argv[2] << endl;
-          
-   outfile.close();
-   delete ssr_ptr;
-}
-// --------------------------------------------------------
diff -druN BloBB_CompaSS_050315/CompaSS/mainsoftst.h blob_compass/CompaSS/mainsoftst.h
--- BloBB_CompaSS_050315/CompaSS/mainsoftst.h	2004-02-07 20:15:24.000000000 -0800
+++ blob_compass/CompaSS/mainsoftst.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,42 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
-#ifndef MAINSOFTST_H
-#define MAINSOFTST_H
-
-#include "datastrbacksoftst.h"
-#include "datastrfrontsoftst.h"
-#include "datastrhiersoftst.h"
-#include "enginesoftst.h"
-
-void main_optimal(int argc, char *argv[]);
-
-#endif
diff -druN BloBB_CompaSS_050315/CompaSS/Makefile blob_compass/CompaSS/Makefile
--- BloBB_CompaSS_050315/CompaSS/Makefile	2005-03-14 22:40:54.000000000 -0800
+++ blob_compass/CompaSS/Makefile	1969-12-31 16:00:00.000000000 -0800
@@ -1,79 +0,0 @@
-#/**************************************************************************
-#***    
-#*** Copyright (c) 2004 Regents of the University of Michigan,
-#***               Hayward H. Chan and Igor L. Markov
-#***
-#***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-#***  Original Affiliation:   EECS Department, 
-#***                          The University of Michigan,
-#***                          Ann Arbor, MI 48109-2122
-#***
-#***  Permission is hereby granted, free of charge, to any person obtaining 
-#***  a copy of this software and associated documentation files (the
-#***  "Software"), to deal in the Software without restriction, including
-#***  without limitation 
-#***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-#***  and/or sell copies of the Software, and to permit persons to whom the 
-#***  Software is furnished to do so, subject to the following conditions:
-#***
-#***  The above copyright notice and this permission notice shall be included
-#***  in all copies or substantial portions of the Software.
-#***
-#*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-#*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-#*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-#*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-#*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-#*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-#*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-#***
-#***
-#***************************************************************************/
-
-.SUFFIXES:        .o .cxx 
-
-CC = g++
-CCFLAGS = -Wall -O3 -ansi $(CCDIRS)
-PURIFY = purify -log-file=log.txt
-MOREOPT = -funroll-loops
-
-CCDIRS = -I../BloBB -I../CompaSS -I../common -I../BTree 
-LDDIRS = -L../BloBB -L../CompaSS -L../common -L../BTree
-
-AR = ar cr
-
-compass_OBJS = boundsoftst.o datastrbacksoftst.o datastrfrontsoftst.o datastrhiersoftst.o enginehiersoftst.o enginesoftst.o iosoftst.o main.o mainhiersoftst.o mainsoftst.o
-
-# bound.o boundfixed.o boundst.o btreefromblobb.o datastr.o datastrhierst.o datastrst.o enginehierst.o enginest.o interface.o main.o nonslice.o parameters.o slice.o slicehier.o utilities.o vectorize.o
-
-THISLIB = CompaSS
-LIBNAME = lib$(THISLIB).a
-
-LDFINAL = $(CC)
-LIBBASE = ../lib
-LIBS = -L$(LIBBASE) -L. -l$(THISLIB) -lBloBB -lBTree -lcommon -lCompaSS
-
-# main.o nonslice.o datastr.o bound.o boundfixed.o slice.o datastrst.o boundst.o enginest.o datastrhierst.o vectorize.o enginehierst.o slicehier.o utilities.o interface.o parameters.o basepacking.o btree.o btreefromsstree.o btreefromblobb.o btreecompact.o btreecompactsstree.o datastrbacksoftst.o datastrfrontsoftst.o iosoftst.o
-
-# -----linking all together-----
-lib : $(LIBNAME)
-
-$(LIBNAME) : $(compass_OBJS)
-	/bin/rm -f $(LIBNAME)
-	$(AR) $(LIBNAME) $(compass_OBJS) 
-	rm -f $(LIBBASE)/$(LIBNAME)
-	ln -s ../CompaSS/$(LIBNAME) $(LIBBASE)/$(LIBNAME) 
-
-
-compass : $(compass_OBJS)
-	/bin/rm -f compass
-	$(LDFINAL) -o compass -static $(LIBS)
-	/bin/rm -f ../bin/compass
-	ln -s ../CompaSS/compass ../bin/compass
-
-.cxx.o : 
-	$(CC) $(CCFLAGS) -c $*.cxx
-
-clean :
-	rm -f *.o *~ compass *.a
-
diff -druN BloBB_CompaSS_050315/CompaSS/new.out blob_compass/CompaSS/new.out
--- BloBB_CompaSS_050315/CompaSS/new.out	2005-03-14 22:31:59.000000000 -0800
+++ blob_compass/CompaSS/new.out	1969-12-31 16:00:00.000000000 -0800
@@ -1,575 +0,0 @@
------ Running ../TESTS/MCNCami33.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Instance Parameters: 
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-
-Performance Parameters: 
-  - HIER_CLUSTER_BASE: 4   [tuned by user] 
-  - HIER_CLUSTER_AREA_DEV: 1.85   [tuned by CompaSS]
-  - HIER_INIT_AR: 1.20   [tuned by CompaSS]
-  - HIER_USE_AR_LEVEL: 2.00   [tuned by CompaSS]
-  - HIER_WIDTH_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_HEIGHT_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_INIT_DEADSPACE: 0.05   [tuned by CompaSS]
-  - HIER_DEADSPACE_INCRE: 1.50   [tuned by CompaSS]
-  - HIER_SIMILARITY_THRESHOLD: 1.90   [tuned by CompaSS]
-  - compact? Yes
-
-[0]===== Grouping 33 clusters... 
-[0]===== Packing into 23 clusters... 
- * Aspect ratio bound used.
-
-blkArea:  1156449.00 deadspace:    24255.00 (2.10%) time: 0.00
-
-[1]===== Grouping 23 clusters... 
-[1]===== Packing into 16 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  1156449.00 deadspace:    28224.00 (2.44%) time: 0.00
-
-[2]===== Grouping 16 clusters... 
-[2]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 4 time: 0.00
-finished 2 / 4. cluster size: 2 time: 0.00
-finished 3 / 4. cluster size: 5 time: 0.01
-finished 4 / 4. cluster size: 5 time: 0.01
-
-blkArea:  1156449.00 deadspace:    80017.00 (6.92%) time: 0.01
-
-[3]===== Grouping 4 clusters... 
-[3]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  1156449.00 deadspace:   220402.00 (19.06%) time: 0.01
-
-total area:  1376851.00
-block area:  1156449.00
-deadspace:    220402.00
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea:  1156449.00 deadspace:   133231.00 (11.52%) time: 0.01
-
-width:  658.00
-height: 1960.00
-total area:  1289680.00
-block area:  1156449.00
-dead space:   133231.00 (11.52%)
-
-area usage   (wrt. total area): 89.67%
-dead space % (wrt. total area): 10.33%
----------------------------
-
-Compacting...
-converted to B*-Tree: 1289680.00 (11.52%) -> 1289680.00 (11.52%)
-round 0:      4 blks changed: 1289680.00 (11.52%) -> 1289680.00 (11.52%)
-round 1:      0 blks changed: 1289680.00 (11.52%) -> 1289680.00 (11.52%)
-
-After compaction, 
-blkArea:  1156449.00 deadspace:   133231.00 (11.52%)
-
-width:  658.00
-height: 1960.00
-total area:  1289680.00
-block area:  1156449.00
-dead space:   133231.00 (11.52%)
-
-area usage   (wrt. total area): 89.67%
-dead space % (wrt. total area): 10.33%
----------------------------
-
-Output successfully written to dummy_output
-
-CompaSS's runtime: 0.01s
-===== Thanks for using CompaSS =====
------ Running ../TESTS/MCNCami49_10.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Instance Parameters: 
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-
-Performance Parameters: 
-  - HIER_CLUSTER_BASE: 4   [tuned by user] 
-  - HIER_CLUSTER_AREA_DEV: 1.85   [tuned by CompaSS]
-  - HIER_INIT_AR: 1.20   [tuned by CompaSS]
-  - HIER_USE_AR_LEVEL: 2.00   [tuned by CompaSS]
-  - HIER_WIDTH_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_HEIGHT_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_INIT_DEADSPACE: 0.05   [tuned by CompaSS]
-  - HIER_DEADSPACE_INCRE: 1.50   [tuned by CompaSS]
-  - HIER_SIMILARITY_THRESHOLD: 1.90   [tuned by CompaSS]
-  - compact? Yes
-
-[0]===== Grouping 490 clusters... 
-[0]===== Packing into 257 clusters... 
- * Aspect ratio bound used.
-
-blkArea:  3544542.40 deadspace:     4394.32 (0.12%) time: 0.08
-
-[1]===== Grouping 257 clusters... 
-[1]===== Packing into 256 clusters... 
- * Aspect ratio bound used.
-
-blkArea:  3544542.40 deadspace:     4394.32 (0.12%) time: 0.10
-
-[2]===== Grouping 256 clusters... 
-[2]===== Packing into 152 clusters... 
- * Aspect ratio bound used.
-
-blkArea:  3544542.40 deadspace:    16471.84 (0.46%) time: 0.13
-
-[3]===== Grouping 152 clusters... 
-[3]===== Packing into 104 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:    25213.44 (0.71%) time: 0.14
-
-[4]===== Grouping 104 clusters... 
-[4]===== Packing into 77 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:    39695.88 (1.12%) time: 0.14
-
-[5]===== Grouping 77 clusters... 
-[5]===== Packing into 64 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:    45446.52 (1.28%) time: 0.15
-
-[6]===== Grouping 64 clusters... 
-[6]===== Packing into 46 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:    68427.52 (1.93%) time: 0.15
-
-[7]===== Grouping 46 clusters... 
-[7]===== Packing into 35 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:    82447.40 (2.33%) time: 0.15
-
-[8]===== Grouping 35 clusters... 
-[8]===== Packing into 27 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:   109030.88 (3.08%) time: 0.15
-
-[9]===== Grouping 27 clusters... 
-[9]===== Packing into 19 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:   114236.64 (3.22%) time: 0.16
-
-[10]===== Grouping 19 clusters... 
-[10]===== Packing into 16 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:   127204.00 (3.59%) time: 0.16
-
-[11]===== Grouping 16 clusters... 
-[11]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 5 time: 0.22
-finished 2 / 4. cluster size: 5 time: 0.30
-finished 3 / 4. cluster size: 1 time: 0.30
-finished 4 / 4. cluster size: 5 time: 0.30
-
-blkArea:  3544542.40 deadspace:   204218.28 (5.76%) time: 0.30
-
-[12]===== Grouping 4 clusters... 
-[12]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  3544542.40 deadspace:   261201.36 (7.37%) time: 0.33
-
-total area:  3805743.76
-block area:  3544542.40
-deadspace:    261201.36
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea:  3544542.40 deadspace:   187987.52 (5.30%) time: 0.35
-
-width:  1394.40
-height: 2676.80
-total area:  3732529.92
-block area:  3544542.40
-dead space:   187987.52 (5.30%)
-
-area usage   (wrt. total area): 94.96%
-dead space % (wrt. total area): 5.04%
----------------------------
-
-Compacting...
-converted to B*-Tree: 3732529.92 (5.30%) -> 3714960.48 (4.81%)
-round 0:    276 blks changed: 3714960.48 (4.81%) -> 3707500.72 (4.60%)
-round 1:     17 blks changed: 3707500.72 (4.60%) -> 3707500.72 (4.60%)
-round 2:      0 blks changed: 3707500.72 (4.60%) -> 3707500.72 (4.60%)
-
-After compaction, 
-blkArea:  3544542.40 deadspace:   162958.32 (4.60%)
-
-width:  1391.60
-height: 2664.20
-total area:  3707500.72
-block area:  3544542.40
-dead space:   162958.32 (4.60%)
-
-area usage   (wrt. total area): 95.60%
-dead space % (wrt. total area): 4.40%
----------------------------
-
-Output successfully written to dummy_output
-
-CompaSS's runtime: 0.37s
-===== Thanks for using CompaSS =====
------ Running ../TESTS/MCNCami49.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Instance Parameters: 
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-
-Performance Parameters: 
-  - HIER_CLUSTER_BASE: 4   [tuned by user] 
-  - HIER_CLUSTER_AREA_DEV: 1.85   [tuned by CompaSS]
-  - HIER_INIT_AR: 1.20   [tuned by CompaSS]
-  - HIER_USE_AR_LEVEL: 2.00   [tuned by CompaSS]
-  - HIER_WIDTH_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_HEIGHT_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_INIT_DEADSPACE: 0.05   [tuned by CompaSS]
-  - HIER_DEADSPACE_INCRE: 1.50   [tuned by CompaSS]
-  - HIER_SIMILARITY_THRESHOLD: 1.90   [tuned by CompaSS]
-  - compact? Yes
-
-[0]===== Grouping 49 clusters... 
-[0]===== Packing into 22 clusters... 
- * Aspect ratio bound used.
-
-blkArea: 35445424.00 deadspace:   673260.00 (1.90%) time: 0.01
-
-[1]===== Grouping 22 clusters... 
-[1]===== Packing into 16 clusters... 
- * Aspect ratio bound not used.
-
-blkArea: 35445424.00 deadspace:   824376.00 (2.33%) time: 0.01
-
-[2]===== Grouping 16 clusters... 
-[2]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 5 time: 0.02
-finished 2 / 4. cluster size: 3 time: 0.02
-finished 3 / 4. cluster size: 4 time: 0.02
-finished 4 / 4. cluster size: 4 time: 0.02
-
-blkArea: 35445424.00 deadspace:  2954112.00 (8.33%) time: 0.02
-
-[3]===== Grouping 4 clusters... 
-[3]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea: 35445424.00 deadspace:  4002908.00 (11.29%) time: 0.02
-
-total area: 39448332.00
-block area: 35445424.00
-deadspace:   4002908.00
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea: 35445424.00 deadspace:  3365712.00 (9.50%) time: 0.02
-
-width:  3808.00
-height: 10192.00
-total area: 38811136.00
-block area: 35445424.00
-dead space:  3365712.00 (9.50%)
-
-area usage   (wrt. total area): 91.33%
-dead space % (wrt. total area): 8.67%
----------------------------
-
-Compacting...
-converted to B*-Tree: 38811136.00 (9.50%) -> 38704512.00 (9.19%)
-round 0:     10 blks changed: 38704512.00 (9.19%) -> 38704512.00 (9.19%)
-round 1:      0 blks changed: 38704512.00 (9.19%) -> 38704512.00 (9.19%)
-
-After compaction, 
-blkArea: 35445424.00 deadspace:  3259088.00 (9.19%)
-
-width:  3808.00
-height: 10164.00
-total area: 38704512.00
-block area: 35445424.00
-dead space:  3259088.00 (9.19%)
-
-area usage   (wrt. total area): 91.58%
-dead space % (wrt. total area): 8.42%
----------------------------
-
-Output successfully written to dummy_output
-
-CompaSS's runtime: 0.02s
-===== Thanks for using CompaSS =====
------ Running ../TESTS/MCNCapte.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Instance Parameters: 
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-
-Performance Parameters: 
-  - HIER_CLUSTER_BASE: 4   [tuned by user] 
-  - HIER_CLUSTER_AREA_DEV: 1.85   [tuned by CompaSS]
-  - HIER_INIT_AR: 1.20   [tuned by CompaSS]
-  - HIER_USE_AR_LEVEL: 2.00   [tuned by CompaSS]
-  - HIER_WIDTH_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_HEIGHT_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_INIT_DEADSPACE: 0.05   [tuned by CompaSS]
-  - HIER_DEADSPACE_INCRE: 1.50   [tuned by CompaSS]
-  - HIER_SIMILARITY_THRESHOLD: 1.90   [tuned by CompaSS]
-  - compact? Yes
-
-[0]===== Grouping 9 clusters... 
-[0]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 1 time: 0.00
-finished 2 / 4. cluster size: 3 time: 0.00
-finished 3 / 4. cluster size: 1 time: 0.00
-finished 4 / 4. cluster size: 4 time: 0.00
-
-blkArea: 46561628.00 deadspace:        0.00 (0.00%) time: 0.00
-
-[1]===== Grouping 4 clusters... 
-[1]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea: 46561628.00 deadspace:  3178612.00 (6.83%) time: 0.00
-
-total area: 49740240.00
-block area: 46561628.00
-deadspace:   3178612.00
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea: 46561628.00 deadspace:   363220.00 (0.78%) time: 0.00
-
-width:  1832.00
-height: 25614.00
-total area: 46924848.00
-block area: 46561628.00
-dead space:   363220.00 (0.78%)
-
-area usage   (wrt. total area): 99.23%
-dead space % (wrt. total area): 0.77%
----------------------------
-
-Compacting...
-converted to B*-Tree: 46924848.00 (0.78%) -> 46924848.00 (0.78%)
-round 0:      0 blks changed: 46924848.00 (0.78%) -> 46924848.00 (0.78%)
-
-After compaction, 
-blkArea: 46561628.00 deadspace:   363220.00 (0.78%)
-
-width:  1832.00
-height: 25614.00
-total area: 46924848.00
-block area: 46561628.00
-dead space:   363220.00 (0.78%)
-
-area usage   (wrt. total area): 99.23%
-dead space % (wrt. total area): 0.77%
----------------------------
-
-Output successfully written to dummy_output
-
-CompaSS's runtime: 0.00s
-===== Thanks for using CompaSS =====
------ Running ../TESTS/MCNChp.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Instance Parameters: 
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-
-Performance Parameters: 
-  - HIER_CLUSTER_BASE: 4   [tuned by user] 
-  - HIER_CLUSTER_AREA_DEV: 1.85   [tuned by CompaSS]
-  - HIER_INIT_AR: 1.20   [tuned by CompaSS]
-  - HIER_USE_AR_LEVEL: 2.00   [tuned by CompaSS]
-  - HIER_WIDTH_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_HEIGHT_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_INIT_DEADSPACE: 0.05   [tuned by CompaSS]
-  - HIER_DEADSPACE_INCRE: 1.50   [tuned by CompaSS]
-  - HIER_SIMILARITY_THRESHOLD: 1.90   [tuned by CompaSS]
-  - compact? Yes
-
-[0]===== Grouping 11 clusters... 
-[0]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 3 time: 0.00
-finished 2 / 4. cluster size: 1 time: 0.00
-finished 3 / 4. cluster size: 5 time: 0.00
-finished 4 / 4. cluster size: 2 time: 0.00
-
-blkArea:  8830584.00 deadspace:   321048.00 (3.64%) time: 0.00
-
-[1]===== Grouping 4 clusters... 
-[1]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea:  8830584.00 deadspace:   712656.00 (8.07%) time: 0.00
-
-total area:  9543240.00
-block area:  8830584.00
-deadspace:    712656.00
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea:  8830584.00 deadspace:   712656.00 (8.07%) time: 0.00
-
-width:  1260.00
-height: 7574.00
-total area:  9543240.00
-block area:  8830584.00
-dead space:   712656.00 (8.07%)
-
-area usage   (wrt. total area): 92.53%
-dead space % (wrt. total area): 7.47%
----------------------------
-
-Compacting...
-converted to B*-Tree: 9543240.00 (8.07%) -> 9543240.00 (8.07%)
-round 0:      2 blks changed: 9543240.00 (8.07%) -> 9543240.00 (8.07%)
-round 1:      0 blks changed: 9543240.00 (8.07%) -> 9543240.00 (8.07%)
-
-After compaction, 
-blkArea:  8830584.00 deadspace:   712656.00 (8.07%)
-
-width:  1260.00
-height: 7574.00
-total area:  9543240.00
-block area:  8830584.00
-dead space:   712656.00 (8.07%)
-
-area usage   (wrt. total area): 92.53%
-dead space % (wrt. total area): 7.47%
----------------------------
-
-Output successfully written to dummy_output
-
-CompaSS's runtime: 0.01s
-===== Thanks for using CompaSS =====
------ Running ../TESTS/MCNCxerox.txt ...
-===== CompaSS (Compacting Soft Slicing Packings) =====
-WARNING: Algorithm not chosen, "--hierarchical" assumed.
----< HIERARCHICAL Packing >---
-Details: 
-  - Block type: all hard, free orientations.
-  - Area accuracy: 0.50%.
-Instance Parameters: 
-  - HIER_OUTLINE_AR: inf (i.e. no aspect ratio constraint imposed.)
-  - HIER_OUTLINE_DEADSPACE: inf (i.e. no dead-space constraint imposed.)
-
-Performance Parameters: 
-  - HIER_CLUSTER_BASE: 4   [tuned by user] 
-  - HIER_CLUSTER_AREA_DEV: 1.85   [tuned by CompaSS]
-  - HIER_INIT_AR: 1.20   [tuned by CompaSS]
-  - HIER_USE_AR_LEVEL: 2.00   [tuned by CompaSS]
-  - HIER_WIDTH_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_HEIGHT_INCRE: 1.15   [tuned by CompaSS]
-  - HIER_INIT_DEADSPACE: 0.05   [tuned by CompaSS]
-  - HIER_DEADSPACE_INCRE: 1.50   [tuned by CompaSS]
-  - HIER_SIMILARITY_THRESHOLD: 1.90   [tuned by CompaSS]
-  - compact? Yes
-
-[0]===== Grouping 10 clusters... 
-[0]===== Packing into 4 clusters... 
- * Aspect ratio bound not used.
-
-finished 1 / 4. cluster size: 3 time: 0.00
-finished 2 / 4. cluster size: 1 time: 0.00
-finished 3 / 4. cluster size: 1 time: 0.00
-finished 4 / 4. cluster size: 5 time: 0.00
-
-blkArea: 19350296.00 deadspace:   281113.00 (1.45%) time: 0.00
-
-[1]===== Grouping 4 clusters... 
-[1]===== Packing into 1 clusters... 
- * Aspect ratio bound not used.
-
-blkArea: 19350296.00 deadspace:  1035860.00 (5.35%) time: 0.00
-
-total area: 20386156.00
-block area: 19350296.00
-deadspace:   1035860.00
-
-Optimizing operators of the Polish expression (no aspect ratio constraints)...
-
-After operator optimization,
-blkArea: 19350296.00 deadspace:  1035860.00 (5.35%) time: 0.00
-
-width:  1316.00
-height: 15491.00
-total area: 20386156.00
-block area: 19350296.00
-dead space:  1035860.00 (5.35%)
-
-area usage   (wrt. total area): 94.92%
-dead space % (wrt. total area): 5.08%
----------------------------
-
-Compacting...
-converted to B*-Tree: 20386156.00 (5.35%) -> 20386156.00 (5.35%)
-round 0:      0 blks changed: 20386156.00 (5.35%) -> 20386156.00 (5.35%)
-
-After compaction, 
-blkArea: 19350296.00 deadspace:  1035860.00 (5.35%)
-
-width:  1316.00
-height: 15491.00
-total area: 20386156.00
-block area: 19350296.00
-dead space:  1035860.00 (5.35%)
-
-area usage   (wrt. total area): 94.92%
-dead space % (wrt. total area): 5.08%
----------------------------
-
-Output successfully written to dummy_output
-
-CompaSS's runtime: 0.00s
-===== Thanks for using CompaSS =====
diff -druN BloBB_CompaSS_050315/CompaSS/regression blob_compass/CompaSS/regression
--- BloBB_CompaSS_050315/CompaSS/regression	2005-03-14 22:24:50.000000000 -0800
+++ blob_compass/CompaSS/regression	1969-12-31 16:00:00.000000000 -0800
@@ -1,42 +0,0 @@
-#!/bin/sh 
-
-DIFF=/usr/bin/diff
-WC=/usr/bin/wc
-RM=/bin/rm
-RELEASE=050315
-PROG=compass
-BASELINE=expected_"$RELEASE".out
-INPUTS=../TESTS/*
-
-if [ -f new.out ]; then
-    echo "new.out found"
-    if [ -L new.out ]; then
-        echo "Warning: new.out is a link, removing it can be dangerous"
-        $RM -i new.out
-    else
-        $RM -f new.out
-    fi
-    echo "new.out removed"
-fi
-
-for fullname in $INPUTS; do
-    echo "----- Running $fullname ..." >> new.out
-    echo "----- Running $fullname ..."
-
-    $PROG $fullname dummy_output --txt --HIER_CLUSTER_BASE 4 >> new.out
-    echo "OK"
-done
-
-if [ -f dummy_output ]; then
-   $RM dummy_output
-fi
-
-sed 's/time:/\ntime:/' $BASELINE | egrep -i -v time: > $BASELINE.notime
-sed 's/time:/\ntime:/' new.out | egrep -i -v time: > new.out.notime
-
-$DIFF new.out.notime $BASELINE.notime > diffs.out
-echo "Differences from precomputed results" 
-echo "  lines:  words:  bytes:    error log:" 
-$WC diffs.out 
-
-$RM -f new.out.notime $BASELINE.notime
diff -druN BloBB_CompaSS_050315/COPYRIGHT blob_compass/COPYRIGHT
--- BloBB_CompaSS_050315/COPYRIGHT	2005-03-14 22:06:22.000000000 -0800
+++ blob_compass/COPYRIGHT	1969-12-31 16:00:00.000000000 -0800
@@ -1,31 +0,0 @@
-/**************************************************************************
-***    
-*** Copyright (c) 2004-2005 Regents of the University of Michigan,
-***               Hayward H. Chan and Igor L. Markov
-***
-***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-***  Original Affiliation:   EECS Department, 
-***                          The University of Michigan,
-***                          Ann Arbor, MI 48109-2122
-***
-***  Permission is hereby granted, free of charge, to any person obtaining 
-***  a copy of this software and associated documentation files (the
-***  "Software"), to deal in the Software without restriction, including
-***  without limitation 
-***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-***  and/or sell copies of the Software, and to permit persons to whom the 
-***  Software is furnished to do so, subject to the following conditions:
-***
-***  The above copyright notice and this permission notice shall be included
-***  in all copies or substantial portions of the Software.
-***
-*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-***
-***
-***************************************************************************/
diff -druN BloBB_CompaSS_050315/Makefile blob_compass/Makefile
--- BloBB_CompaSS_050315/Makefile	2005-03-14 22:30:33.000000000 -0800
+++ blob_compass/Makefile	1969-12-31 16:00:00.000000000 -0800
@@ -1,59 +0,0 @@
-#/**************************************************************************
-#***    
-#*** Copyright (c) 2005 Regents of the University of Michigan,
-#***               Hayward H. Chan and Igor L. Markov
-#***
-#***  Contact author(s): hhchan@umich.edu, imarkov@umich.edu
-#***  Original Affiliation:   EECS Department, 
-#***                          The University of Michigan,
-#***                          Ann Arbor, MI 48109-2122
-#***
-#***  Permission is hereby granted, free of charge, to any person obtaining 
-#***  a copy of this software and associated documentation files (the
-#***  "Software"), to deal in the Software without restriction, including
-#***  without limitation 
-#***  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
-#***  and/or sell copies of the Software, and to permit persons to whom the 
-#***  Software is furnished to do so, subject to the following conditions:
-#***
-#***  The above copyright notice and this permission notice shall be included
-#***  in all copies or substantial portions of the Software.
-#***
-#*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
-#*** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-#*** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
-#*** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-#*** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
-#*** OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
-#*** THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-#***
-#***
-#***************************************************************************/
-
-NPROC = 1
-MAKE = make -j $(NPROC)
-
-install : 
-	echo "cleaning files..."
-	$(MAKE) clean 
-	echo "building libraries..."
-	$(MAKE) libs
-	echo "building executables..."
-	$(MAKE) exec
-
-libs :
-	cd ./BloBB ; $(MAKE)
-	cd ./CompaSS ; $(MAKE)
-	cd ./BTree ; $(MAKE)
-	cd ./common ; $(MAKE)
-
-exec : 	
-	cd ./BloBB ; $(MAKE) blobb
-	cd ./CompaSS ; $(MAKE) compass
-
-clean : 
-	cd ./BloBB ; $(MAKE) clean
-	cd ./CompaSS ; $(MAKE) clean
-	cd ./BTree ; $(MAKE) clean
-	cd ./common ; $(MAKE) clean
-	cd ./bin ; rm -f *
diff -druN BloBB_CompaSS_050315/TESTS/MCNCami33.txt blob_compass/TESTS/MCNCami33.txt
--- BloBB_CompaSS_050315/TESTS/MCNCami33.txt	2004-07-04 21:19:35.000000000 -0700
+++ blob_compass/TESTS/MCNCami33.txt	1969-12-31 16:00:00.000000000 -0800
@@ -1,34 +0,0 @@
-33
-336.00 133.00
-378.00 119.00
-161.00 140.00
-119.00 49.00
-175.00 119.00
-140.00 406.00
-140.00 497.00
-196.00 119.00
-294.00 119.00
-161.00 119.00
-119.00 266.00
-119.00 336.00
-119.00 126.00
-371.00 182.00
-182.00 203.00
-182.00 203.00
-84.00 119.00
-133.00 294.00
-182.00 350.00
-315.00 140.00
-133.00 315.00
-560.00 133.00
-133.00 140.00
-175.00 133.00
-133.00 231.00
-133.00 315.00
-182.00 98.00
-210.00 210.00
-126.00 378.00
-182.00 119.00
-119.00 119.00
-357.00 119.00
-119.00 84.00
diff -druN BloBB_CompaSS_050315/TESTS/MCNCami49_10.txt blob_compass/TESTS/MCNCami49_10.txt
--- BloBB_CompaSS_050315/TESTS/MCNCami49_10.txt	2004-07-04 21:19:43.000000000 -0700
+++ blob_compass/TESTS/MCNCami49_10.txt	1969-12-31 16:00:00.000000000 -0800
@@ -1,491 +0,0 @@
-490
-170.80 323.40
-170.80 323.40
-170.80 323.40
-170.80 323.40
-170.80 323.40
-170.80 323.40
-170.80 323.40
-170.80 323.40
-170.80 323.40
-170.80 323.40
-67.20 155.40
-67.20 155.40
-67.20 155.40
-67.20 155.40
-67.20 155.40
-67.20 155.40
-67.20 155.40
-67.20 155.40
-67.20 155.40
-67.20 155.40
-218.40 100.80
-218.40 100.80
-218.40 100.80
-218.40 100.80
-218.40 100.80
-218.40 100.80
-218.40 100.80
-218.40 100.80
-218.40 100.80
-218.40 100.80
-308.00 161.00
-308.00 161.00
-308.00 161.00
-308.00 161.00
-308.00 161.00
-308.00 161.00
-308.00 161.00
-308.00 161.00
-308.00 161.00
-308.00 161.00
-53.20 138.60
-53.20 138.60
-53.20 138.60
-53.20 138.60
-53.20 138.60
-53.20 138.60
-53.20 138.60
-53.20 138.60
-53.20 138.60
-53.20 138.60
-186.20 88.20
-186.20 88.20
-186.20 88.20
-186.20 88.20
-186.20 88.20
-186.20 88.20
-186.20 88.20
-186.20 88.20
-186.20 88.20
-186.20 88.20
-35.00 86.80
-35.00 86.80
-35.00 86.80
-35.00 86.80
-35.00 86.80
-35.00 86.80
-35.00 86.80
-35.00 86.80
-35.00 86.80
-35.00 86.80
-64.40 124.60
-64.40 124.60
-64.40 124.60
-64.40 124.60
-64.40 124.60
-64.40 124.60
-64.40 124.60
-64.40 124.60
-64.40 124.60
-64.40 124.60
-98.00 46.20
-98.00 46.20
-98.00 46.20
-98.00 46.20
-98.00 46.20
-98.00 46.20
-98.00 46.20
-98.00 46.20
-98.00 46.20
-98.00 46.20
-29.40 61.60
-29.40 61.60
-29.40 61.60
-29.40 61.60
-29.40 61.60
-29.40 61.60
-29.40 61.60
-29.40 61.60
-29.40 61.60
-29.40 61.60
-82.60 37.80
-82.60 37.80
-82.60 37.80
-82.60 37.80
-82.60 37.80
-82.60 37.80
-82.60 37.80
-82.60 37.80
-82.60 37.80
-82.60 37.80
-79.80 40.60
-79.80 40.60
-79.80 40.60
-79.80 40.60
-79.80 40.60
-79.80 40.60
-79.80 40.60
-79.80 40.60
-79.80 40.60
-79.80 40.60
-26.60 67.20
-26.60 67.20
-26.60 67.20
-26.60 67.20
-26.60 67.20
-26.60 67.20
-26.60 67.20
-26.60 67.20
-26.60 67.20
-26.60 67.20
-40.60 92.40
-40.60 92.40
-40.60 92.40
-40.60 92.40
-40.60 92.40
-40.60 92.40
-40.60 92.40
-40.60 92.40
-40.60 92.40
-40.60 92.40
-40.60 84.00
-40.60 84.00
-40.60 84.00
-40.60 84.00
-40.60 84.00
-40.60 84.00
-40.60 84.00
-40.60 84.00
-40.60 84.00
-40.60 84.00
-32.20 79.80
-32.20 79.80
-32.20 79.80
-32.20 79.80
-32.20 79.80
-32.20 79.80
-32.20 79.80
-32.20 79.80
-32.20 79.80
-32.20 79.80
-39.20 75.60
-39.20 75.60
-39.20 75.60
-39.20 75.60
-39.20 75.60
-39.20 75.60
-39.20 75.60
-39.20 75.60
-39.20 75.60
-39.20 75.60
-107.80 39.20
-107.80 39.20
-107.80 39.20
-107.80 39.20
-107.80 39.20
-107.80 39.20
-107.80 39.20
-107.80 39.20
-107.80 39.20
-107.80 39.20
-39.20 82.60
-39.20 82.60
-39.20 82.60
-39.20 82.60
-39.20 82.60
-39.20 82.60
-39.20 82.60
-39.20 82.60
-39.20 82.60
-39.20 82.60
-79.80 25.20
-79.80 25.20
-79.80 25.20
-79.80 25.20
-79.80 25.20
-79.80 25.20
-79.80 25.20
-79.80 25.20
-79.80 25.20
-79.80 25.20
-39.20 82.60
-39.20 82.60
-39.20 82.60
-39.20 82.60
-39.20 82.60
-39.20 82.60
-39.20 82.60
-39.20 82.60
-39.20 82.60
-39.20 82.60
-95.20 36.40
-95.20 36.40
-95.20 36.40
-95.20 36.40
-95.20 36.40
-95.20 36.40
-95.20 36.40
-95.20 36.40
-95.20 36.40
-95.20 36.40
-113.40 49.00
-113.40 49.00
-113.40 49.00
-113.40 49.00
-113.40 49.00
-113.40 49.00
-113.40 49.00
-113.40 49.00
-113.40 49.00
-113.40 49.00
-79.80 26.60
-79.80 26.60
-79.80 26.60
-79.80 26.60
-79.80 26.60
-79.80 26.60
-79.80 26.60
-79.80 26.60
-79.80 26.60
-79.80 26.60
-78.40 32.20
-78.40 32.20
-78.40 32.20
-78.40 32.20
-78.40 32.20
-78.40 32.20
-78.40 32.20
-78.40 32.20
-78.40 32.20
-78.40 32.20
-35.00 72.80
-35.00 72.80
-35.00 72.80
-35.00 72.80
-35.00 72.80
-35.00 72.80
-35.00 72.80
-35.00 72.80
-35.00 72.80
-35.00 72.80
-36.40 84.00
-36.40 84.00
-36.40 84.00
-36.40 84.00
-36.40 84.00
-36.40 84.00
-36.40 84.00
-36.40 84.00
-36.40 84.00
-36.40 84.00
-51.80 106.40
-51.80 106.40
-51.80 106.40
-51.80 106.40
-51.80 106.40
-51.80 106.40
-51.80 106.40
-51.80 106.40
-51.80 106.40
-51.80 106.40
-49.00 99.40
-49.00 99.40
-49.00 99.40
-49.00 99.40
-49.00 99.40
-49.00 99.40
-49.00 99.40
-49.00 99.40
-49.00 99.40
-49.00 99.40
-130.20 72.80
-130.20 72.80
-130.20 72.80
-130.20 72.80
-130.20 72.80
-130.20 72.80
-130.20 72.80
-130.20 72.80
-130.20 72.80
-130.20 72.80
-39.20 105.00
-39.20 105.00
-39.20 105.00
-39.20 105.00
-39.20 105.00
-39.20 105.00
-39.20 105.00
-39.20 105.00
-39.20 105.00
-39.20 105.00
-78.40 37.80
-78.40 37.80
-78.40 37.80
-78.40 37.80
-78.40 37.80
-78.40 37.80
-78.40 37.80
-78.40 37.80
-78.40 37.80
-78.40 37.80
-189.00 95.20
-189.00 95.20
-189.00 95.20
-189.00 95.20
-189.00 95.20
-189.00 95.20
-189.00 95.20
-189.00 95.20
-189.00 95.20
-189.00 95.20
-56.00 114.80
-56.00 114.80
-56.00 114.80
-56.00 114.80
-56.00 114.80
-56.00 114.80
-56.00 114.80
-56.00 114.80
-56.00 114.80
-56.00 114.80
-85.40 39.20
-85.40 39.20
-85.40 39.20
-85.40 39.20
-85.40 39.20
-85.40 39.20
-85.40 39.20
-85.40 39.20
-85.40 39.20
-85.40 39.20
-99.40 44.80
-99.40 44.80
-99.40 44.80
-99.40 44.80
-99.40 44.80
-99.40 44.80
-99.40 44.80
-99.40 44.80
-99.40 44.80
-99.40 44.80
-121.80 56.00
-121.80 56.00
-121.80 56.00
-121.80 56.00
-121.80 56.00
-121.80 56.00
-121.80 56.00
-121.80 56.00
-121.80 56.00
-121.80 56.00
-44.80 96.60
-44.80 96.60
-44.80 96.60
-44.80 96.60
-44.80 96.60
-44.80 96.60
-44.80 96.60
-44.80 96.60
-44.80 96.60
-44.80 96.60
-36.40 78.40
-36.40 78.40
-36.40 78.40
-36.40 78.40
-36.40 78.40
-36.40 78.40
-36.40 78.40
-36.40 78.40
-36.40 78.40
-36.40 78.40
-39.20 86.80
-39.20 86.80
-39.20 86.80
-39.20 86.80
-39.20 86.80
-39.20 86.80
-39.20 86.80
-39.20 86.80
-39.20 86.80
-39.20 86.80
-36.40 85.40
-36.40 85.40
-36.40 85.40
-36.40 85.40
-36.40 85.40
-36.40 85.40
-36.40 85.40
-36.40 85.40
-36.40 85.40
-36.40 85.40
-16.80 37.80
-16.80 37.80
-16.80 37.80
-16.80 37.80
-16.80 37.80
-16.80 37.80
-16.80 37.80
-16.80 37.80
-16.80 37.80
-16.80 37.80
-91.00 53.20
-91.00 53.20
-91.00 53.20
-91.00 53.20
-91.00 53.20
-91.00 53.20
-91.00 53.20
-91.00 53.20
-91.00 53.20
-91.00 53.20
-63.00 130.20
-63.00 130.20
-63.00 130.20
-63.00 130.20
-63.00 130.20
-63.00 130.20
-63.00 130.20
-63.00 130.20
-63.00 130.20
-63.00 130.20
-67.20 116.20
-67.20 116.20
-67.20 116.20
-67.20 116.20
-67.20 116.20
-67.20 116.20
-67.20 116.20
-67.20 116.20
-67.20 116.20
-67.20 116.20
-120.40 50.40
-120.40 50.40
-120.40 50.40
-120.40 50.40
-120.40 50.40
-120.40 50.40
-120.40 50.40
-120.40 50.40
-120.40 50.40
-120.40 50.40
-43.40 81.20
-43.40 81.20
-43.40 81.20
-43.40 81.20
-43.40 81.20
-43.40 81.20
-43.40 81.20
-43.40 81.20
-43.40 81.20
-43.40 81.20
-130.20 72.80
-130.20 72.80
-130.20 72.80
-130.20 72.80
-130.20 72.80
-130.20 72.80
-130.20 72.80
-130.20 72.80
-130.20 72.80
-130.20 72.80
-39.20 74.20
-39.20 74.20
-39.20 74.20
-39.20 74.20
-39.20 74.20
-39.20 74.20
-39.20 74.20
-39.20 74.20
-39.20 74.20
-39.20 74.20
diff -druN BloBB_CompaSS_050315/TESTS/MCNCami49.txt blob_compass/TESTS/MCNCami49.txt
--- BloBB_CompaSS_050315/TESTS/MCNCami49.txt	2004-07-04 21:19:40.000000000 -0700
+++ blob_compass/TESTS/MCNCami49.txt	1969-12-31 16:00:00.000000000 -0800
@@ -1,50 +0,0 @@
-49
-1708.00 3234.00
-672.00 1554.00
-2184.00 1008.00
-3080.00 1610.00
-532.00 1386.00
-1862.00 882.00
-350.00 868.00
-644.00 1246.00
-980.00 462.00
-294.00 616.00
-826.00 378.00
-798.00 406.00
-266.00 672.00
-406.00 924.00
-406.00 840.00
-322.00 798.00
-392.00 756.00
-1078.00 392.00
-392.00 826.00
-798.00 252.00
-392.00 826.00
-952.00 364.00
-1134.00 490.00
-798.00 266.00
-784.00 322.00
-350.00 728.00
-364.00 840.00
-518.00 1064.00
-490.00 994.00
-1302.00 728.00
-392.00 1050.00
-784.00 378.00
-1890.00 952.00
-560.00 1148.00
-854.00 392.00
-994.00 448.00
-1218.00 560.00
-448.00 966.00
-364.00 784.00
-392.00 868.00
-364.00 854.00
-168.00 378.00
-910.00 532.00
-630.00 1302.00
-672.00 1162.00
-1204.00 504.00
-434.00 812.00
-1302.00 728.00
-392.00 742.00
diff -druN BloBB_CompaSS_050315/TESTS/MCNCapte.txt blob_compass/TESTS/MCNCapte.txt
--- BloBB_CompaSS_050315/TESTS/MCNCapte.txt	2004-07-04 21:19:25.000000000 -0700
+++ blob_compass/TESTS/MCNCapte.txt	1969-12-31 16:00:00.000000000 -0800
@@ -1,10 +0,0 @@
-9
-3146.00 1826.00
-3146.00 1826.00
-3146.00 1826.00
-3146.00 1826.00
-3186.00 1832.00
-3186.00 1832.00
-3186.00 1832.00
-3186.00 1832.00
-826.00 286.00
diff -druN BloBB_CompaSS_050315/TESTS/MCNChp.txt blob_compass/TESTS/MCNChp.txt
--- BloBB_CompaSS_050315/TESTS/MCNChp.txt	2004-07-04 21:19:31.000000000 -0700
+++ blob_compass/TESTS/MCNChp.txt	1969-12-31 16:00:00.000000000 -0800
@@ -1,12 +0,0 @@
-11
-1036.00 462.00
-378.00 700.00
-980.00 210.00
-980.00 210.00
-980.00 210.00
-3304.00 546.00
-3304.00 546.00
-2016.00 252.00
-3080.00 462.00
-2016.00 252.00
-3080.00 462.00
diff -druN BloBB_CompaSS_050315/TESTS/MCNCxerox.txt blob_compass/TESTS/MCNCxerox.txt
--- BloBB_CompaSS_050315/TESTS/MCNCxerox.txt	2004-07-04 21:19:28.000000000 -0700
+++ blob_compass/TESTS/MCNCxerox.txt	1969-12-31 16:00:00.000000000 -0800
@@ -1,11 +0,0 @@
-10
-1295.00 616.00
-1295.00 490.00
-1295.00 2534.00
-1295.00 2569.00
-756.00 840.00
-1162.00 1939.00
-1218.00 1652.00
-882.00 1316.00
-1295.00 2114.00
-1295.00 1939.00
