// inou.pyrope files:inou/pyrope/tests/semanticTest.prp |> pass.semantic
// ./bazel-bin/inou/pyrope/prp_lnast_test inou/pyrope/tests/semanticTest.prp

// Assign Statement
// val = 0d1023u10
// Warning: val
// ================================================

// Assign Simple Expression
// x = 1
// total := (x - 1) + 3 + 2
// Warning: total
// ================================================

// Binary Not Operation
// %out = ~$inp
// Warning: None
// ================================================

// Logical Not Operation
// %out = !$inp
// Warning: None
// ================================================

// And Operation
// a = 1;
// b = 1;
// c = 0;
// out = a & b & c
// Warning: out
// ================================================

// If Statement
// a = 4
// if a > 3 {
//   b = a + 1
// }
// Warning: b
// ================================================

// If Statement Full Case
// if a > 10 {
//  b = 3 
// } elif a < 1 {
//   b = 2
// } else {
//   b = 1
// }
// Warning: b
// ================================================

// Tuple Statement
// tup = (foo = 1, bar = cat + 2)
// Warning: tup, foo, bar
// ================================================

// Tuple Concate Statement
// tup = (foo = 1, bar = cat + 2) 
// tup = tup ++ (4, dog)
// Warning: foo, bar
// ================================================

// For Loop Statement
// for i in (0..3) {
//  tuple_foo[i] = tuple_bar[3-i]
// }
// Warning: ___range_begin, ___range_end
// ================================================

// While Loop Statement
// a = 10
// while (a > 0) {
//   b = a + 1
//   a = a - 1
// }
// Warning: b
// ================================================

// Basic Func Def
// func_xor = :($a, $b, %out):{
//   %out = param1 ^ param2
// }
// Warning: func_xor
// ================================================

// Cond Func Def (Doesn't work for some reason?)
// func_xor = :($a, $b, $valid, %out) when $valid:{
//   %out = $a ^ $b
// }
// Warning: func_xor
// ================================================

// Implicit Func Call
// func_xor = :($a, $b, %out):{
//   %out = $a ^ $b
// }

// my_xor = func_xor($foo, $bar)
// %out = my_xor.out
// Warning: None
// ================================================


// Explicit Func Call
// func_xor = :($a, $b, %out):{
//   %out = $a ^ $b
// }

// my_xor = func_xor(a = $foo, b = $bar)
// %out = my_xor.out
// Warning: a, b
// ================================================

// Attribute Statement
// foo.___bits = 3
// foo = 7

// bar as (___bits = 10)
// bar = 123
// Warning: bar
// ================================================

// Other Tests
// a = 10
// if (a < 0) {
//   b = -1 
// } elif (a == 0) {
//   b = 0
// } else {
//   b = 1
// }
// Warning: b
// ================================================

// Inefficient LNAST Tests
// a = 1
// b = a
// c = b + 1
// Warning: Inefficient LNAST for variable b, c

// tup = (foo = 1, bar = 2)
// temp_tup = tup
// temp_tup = temp_tup ++ (4, dog)
// Warning: Inefficient LNAST for variable temp_tup, foo + bar

// a = 1 + 4
// b = a
// b = b * 2
// Warning: Inefficient LNAST for variable b

// a = 1 + 4
// a = a * 3
// b = a
// a = a / 3
// Warning: None

// %foo = 4
// %out = %foo
// %out = %foo + 4
// %bar = (4 * 5) / 2
// %valid = %bar
// %valid = %valid + %out
// Warning: Inefficient LNASt for variable %out and %valid

// x = 3
// x = 3 * (x + 3)
// y = 4
// y = ((y + 3) * 7) / 7
// ================================================
